var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, {get: all[name2], enumerable: true});
};
var __exportStar = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module) => {
  return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
};

// node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS((exports, module) => {
  !function(e, t) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis != "undefined" ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
  }(exports, function() {
    "use strict";
    var e = {LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A"}, t = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^\s\d-_:/()]+/, o = {}, s = function(e2) {
      return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
    };
    var a = function(e2) {
      return function(t2) {
        this[e2] = +t2;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
      (this.zone || (this.zone = {})).offset = function(e3) {
        if (!e3)
          return 0;
        if (e3 === "Z")
          return 0;
        var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
        return n2 === 0 ? 0 : t2[0] === "+" ? -n2 : n2;
      }(e2);
    }], h = function(e2) {
      var t2 = o[e2];
      return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
    }, u = function(e2, t2) {
      var n2, r2 = o.meridiem;
      if (r2) {
        for (var i2 = 1; i2 <= 24; i2 += 1)
          if (e2.indexOf(r2(i2, 0, t2)) > -1) {
            n2 = i2 > 12;
            break;
          }
      } else
        n2 = e2 === (t2 ? "pm" : "PM");
      return n2;
    }, d = {A: [i, function(e2) {
      this.afternoon = u(e2, false);
    }], a: [i, function(e2) {
      this.afternoon = u(e2, true);
    }], S: [/\d/, function(e2) {
      this.milliseconds = 100 * +e2;
    }], SS: [n, function(e2) {
      this.milliseconds = 10 * +e2;
    }], SSS: [/\d{3}/, function(e2) {
      this.milliseconds = +e2;
    }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i, function(e2) {
      var t2 = o.ordinal, n2 = e2.match(/\d+/);
      if (this.day = n2[0], t2)
        for (var r2 = 1; r2 <= 31; r2 += 1)
          t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
    }], M: [r, a("month")], MM: [n, a("month")], MMM: [i, function(e2) {
      var t2 = h("months"), n2 = (h("monthsShort") || t2.map(function(e3) {
        return e3.slice(0, 3);
      })).indexOf(e2) + 1;
      if (n2 < 1)
        throw new Error();
      this.month = n2 % 12 || n2;
    }], MMMM: [i, function(e2) {
      var t2 = h("months").indexOf(e2) + 1;
      if (t2 < 1)
        throw new Error();
      this.month = t2 % 12 || t2;
    }], Y: [/[+-]?\d+/, a("year")], YY: [n, function(e2) {
      this.year = s(e2);
    }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f};
    function c(n2) {
      var r2, i2;
      r2 = n2, i2 = o && o.formats;
      for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
        var o2 = r3 && r3.toUpperCase();
        return n3 || i2[r3] || e[r3] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
          return t3 || n4.slice(1);
        });
      })).match(t), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
        var h2 = s2[f2], u2 = d[h2], c2 = u2 && u2[0], l = u2 && u2[1];
        s2[f2] = l ? {regex: c2, parser: l} : h2.replace(/^\[|\]$/g, "");
      }
      return function(e2) {
        for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
          var i3 = s2[n3];
          if (typeof i3 == "string")
            r3 += i3.length;
          else {
            var o2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = o2.exec(h3)[0];
            f3.call(t2, u3), e2 = e2.replace(u3, "");
          }
        }
        return function(e3) {
          var t3 = e3.afternoon;
          if (t3 !== void 0) {
            var n4 = e3.hours;
            t3 ? n4 < 12 && (e3.hours += 12) : n4 === 12 && (e3.hours = 0), delete e3.afternoon;
          }
        }(t2), t2;
      };
    }
    return function(e2, t2, n2) {
      n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s = e2.parseTwoDigitYear);
      var r2 = t2.prototype, i2 = r2.parse;
      r2.parse = function(e3) {
        var t3 = e3.date, r3 = e3.utc, s2 = e3.args;
        this.$u = r3;
        var a2 = s2[1];
        if (typeof a2 == "string") {
          var f2 = s2[2] === true, h2 = s2[3] === true, u2 = f2 || h2, d2 = s2[2];
          h2 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function(e4, t4, n3) {
            try {
              if (["x", "X"].indexOf(t4) > -1)
                return new Date((t4 === "X" ? 1e3 : 1) * e4);
              var r4 = c(t4)(e4), i3 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, h3 = r4.seconds, u3 = r4.milliseconds, d3 = r4.zone, l2 = new Date(), m2 = s3 || (i3 || o2 ? 1 : l2.getDate()), M3 = i3 || l2.getFullYear(), Y2 = 0;
              i3 && !o2 || (Y2 = o2 > 0 ? o2 - 1 : l2.getMonth());
              var p = a3 || 0, v = f3 || 0, D2 = h3 || 0, g = u3 || 0;
              return d3 ? new Date(Date.UTC(M3, Y2, m2, p, v, D2, g + 60 * d3.offset * 1e3)) : n3 ? new Date(Date.UTC(M3, Y2, m2, p, v, D2, g)) : new Date(M3, Y2, m2, p, v, D2, g);
            } catch (e5) {
              return new Date("");
            }
          }(t3, a2, r3), this.init(), d2 && d2 !== true && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = new Date("")), o = {};
        } else if (a2 instanceof Array)
          for (var l = a2.length, m = 1; m <= l; m += 1) {
            s2[1] = a2[m - 1];
            var M2 = n2.apply(this, s2);
            if (M2.isValid()) {
              this.$d = M2.$d, this.$L = M2.$L, this.init();
              break;
            }
            m === l && (this.$d = new Date(""));
          }
        else
          i2.call(this, e3);
      };
    };
  });
});

// node_modules/dayjs/plugin/localeData.js
var require_localeData = __commonJS((exports, module) => {
  !function(n, e) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (n = typeof globalThis != "undefined" ? globalThis : n || self).dayjs_plugin_localeData = e();
  }(exports, function() {
    "use strict";
    return function(n, e, t) {
      var r = e.prototype, o = function(n2) {
        return n2 && (n2.indexOf ? n2 : n2.s);
      }, u = function(n2, e2, t2, r2, u2) {
        var i2 = n2.name ? n2 : n2.$locale(), a2 = o(i2[e2]), s2 = o(i2[t2]), f = a2 || s2.map(function(n3) {
          return n3.slice(0, r2);
        });
        if (!u2)
          return f;
        var d = i2.weekStart;
        return f.map(function(n3, e3) {
          return f[(e3 + (d || 0)) % 7];
        });
      }, i = function() {
        return t.Ls[t.locale()];
      }, a = function(n2, e2) {
        return n2.formats[e2] || function(n3) {
          return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
            return e3 || t2.slice(1);
          });
        }(n2.formats[e2.toUpperCase()]);
      }, s = function() {
        var n2 = this;
        return {months: function(e2) {
          return e2 ? e2.format("MMMM") : u(n2, "months");
        }, monthsShort: function(e2) {
          return e2 ? e2.format("MMM") : u(n2, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return n2.$locale().weekStart || 0;
        }, weekdays: function(e2) {
          return e2 ? e2.format("dddd") : u(n2, "weekdays");
        }, weekdaysMin: function(e2) {
          return e2 ? e2.format("dd") : u(n2, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(e2) {
          return e2 ? e2.format("ddd") : u(n2, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(e2) {
          return a(n2.$locale(), e2);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal};
      };
      r.localeData = function() {
        return s.bind(this)();
      }, t.localeData = function() {
        var n2 = i();
        return {firstDayOfWeek: function() {
          return n2.weekStart || 0;
        }, weekdays: function() {
          return t.weekdays();
        }, weekdaysShort: function() {
          return t.weekdaysShort();
        }, weekdaysMin: function() {
          return t.weekdaysMin();
        }, months: function() {
          return t.months();
        }, monthsShort: function() {
          return t.monthsShort();
        }, longDateFormat: function(e2) {
          return a(n2, e2);
        }, meridiem: n2.meridiem, ordinal: n2.ordinal};
      }, t.months = function() {
        return u(i(), "months");
      }, t.monthsShort = function() {
        return u(i(), "monthsShort", "months", 3);
      }, t.weekdays = function(n2) {
        return u(i(), "weekdays", null, null, n2);
      }, t.weekdaysShort = function(n2) {
        return u(i(), "weekdaysShort", "weekdays", 3, n2);
      }, t.weekdaysMin = function(n2) {
        return u(i(), "weekdaysMin", "weekdays", 2, n2);
      };
    };
  });
});

// node_modules/dayjs/plugin/timezone.js
var require_timezone = __commonJS((exports, module) => {
  !function(t, e) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs_plugin_timezone = e();
  }(exports, function() {
    "use strict";
    var t = {year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5}, e = {};
    return function(n, i, o) {
      var r, a = function(t2, n2, i2) {
        i2 === void 0 && (i2 = {});
        var o2 = new Date(t2), r2 = function(t3, n3) {
          n3 === void 0 && (n3 = {});
          var i3 = n3.timeZoneName || "short", o3 = t3 + "|" + i3, r3 = e[o3];
          return r3 || (r3 = new Intl.DateTimeFormat("en-US", {hour12: false, timeZone: t3, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i3}), e[o3] = r3), r3;
        }(n2, i2);
        return r2.formatToParts(o2);
      }, u = function(e2, n2) {
        for (var i2 = a(e2, n2), r2 = [], u2 = 0; u2 < i2.length; u2 += 1) {
          var f2 = i2[u2], s2 = f2.type, m = f2.value, c = t[s2];
          c >= 0 && (r2[c] = parseInt(m, 10));
        }
        var d = r2[3], l = d === 24 ? 0 : d, v = r2[0] + "-" + r2[1] + "-" + r2[2] + " " + l + ":" + r2[4] + ":" + r2[5] + ":000", h = +e2;
        return (o.utc(v).valueOf() - (h -= h % 1e3)) / 6e4;
      }, f = i.prototype;
      f.tz = function(t2, e2) {
        t2 === void 0 && (t2 = r);
        var n2 = this.utcOffset(), i2 = this.toDate(), a2 = i2.toLocaleString("en-US", {timeZone: t2}), u2 = Math.round((i2 - new Date(a2)) / 1e3 / 60), f2 = o(a2).$set("millisecond", this.$ms).utcOffset(15 * -Math.round(i2.getTimezoneOffset() / 15) - u2, true);
        if (e2) {
          var s2 = f2.utcOffset();
          f2 = f2.add(n2 - s2, "minute");
        }
        return f2.$x.$timezone = t2, f2;
      }, f.offsetName = function(t2) {
        var e2 = this.$x.$timezone || o.tz.guess(), n2 = a(this.valueOf(), e2, {timeZoneName: t2}).find(function(t3) {
          return t3.type.toLowerCase() === "timezonename";
        });
        return n2 && n2.value;
      };
      var s = f.startOf;
      f.startOf = function(t2, e2) {
        if (!this.$x || !this.$x.$timezone)
          return s.call(this, t2, e2);
        var n2 = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"));
        return s.call(n2, t2, e2).tz(this.$x.$timezone, true);
      }, o.tz = function(t2, e2, n2) {
        var i2 = n2 && e2, a2 = n2 || e2 || r, f2 = u(+o(), a2);
        if (typeof t2 != "string")
          return o(t2).tz(a2);
        var s2 = function(t3, e3, n3) {
          var i3 = t3 - 60 * e3 * 1e3, o2 = u(i3, n3);
          if (e3 === o2)
            return [i3, e3];
          var r2 = u(i3 -= 60 * (o2 - e3) * 1e3, n3);
          return o2 === r2 ? [i3, o2] : [t3 - 60 * Math.min(o2, r2) * 1e3, Math.max(o2, r2)];
        }(o.utc(t2, i2).valueOf(), f2, a2), m = s2[0], c = s2[1], d = o(m).utcOffset(c);
        return d.$x.$timezone = a2, d;
      }, o.tz.guess = function() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      }, o.tz.setDefault = function(t2) {
        r = t2;
      };
    };
  });
});

// node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS((exports, module) => {
  !function(t, i) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = i() : typeof define == "function" && define.amd ? define(i) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs_plugin_utc = i();
  }(exports, function() {
    "use strict";
    var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
    return function(s, f, n) {
      var u = f.prototype;
      n.utc = function(t2) {
        var i2 = {date: t2, utc: true, args: arguments};
        return new f(i2);
      }, u.utc = function(i2) {
        var e2 = n(this.toDate(), {locale: this.$L, utc: true});
        return i2 ? e2.add(this.utcOffset(), t) : e2;
      }, u.local = function() {
        return n(this.toDate(), {locale: this.$L, utc: false});
      };
      var o = u.parse;
      u.parse = function(t2) {
        t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
      };
      var r = u.init;
      u.init = function() {
        if (this.$u) {
          var t2 = this.$d;
          this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
        } else
          r.call(this);
      };
      var a = u.utcOffset;
      u.utcOffset = function(s2, f2) {
        var n2 = this.$utils().u;
        if (n2(s2))
          return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
        if (typeof s2 == "string" && (s2 = function(t2) {
          t2 === void 0 && (t2 = "");
          var s3 = t2.match(i);
          if (!s3)
            return null;
          var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
          return u3 === 0 ? 0 : n3 === "+" ? u3 : -u3;
        }(s2), s2 === null))
          return this;
        var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
        if (f2)
          return o2.$offset = u2, o2.$u = s2 === 0, o2;
        if (s2 !== 0) {
          var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
        } else
          o2 = this.utc();
        return o2;
      };
      var h = u.format;
      u.format = function(t2) {
        var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return h.call(this, i2);
      }, u.valueOf = function() {
        var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * t2;
      }, u.isUTC = function() {
        return !!this.$u;
      }, u.toISOString = function() {
        return this.toDate().toISOString();
      }, u.toString = function() {
        return this.toDate().toUTCString();
      };
      var l = u.toDate;
      u.toDate = function(t2) {
        return t2 === "s" && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
      };
      var c = u.diff;
      u.diff = function(t2, i2, e2) {
        if (t2 && this.$u === t2.$u)
          return c.call(this, t2, i2, e2);
        var s2 = this.local(), f2 = n(t2).local();
        return c.call(s2, f2, i2, e2);
      };
    };
  });
});

// node_modules/codemirror/lib/codemirror.js
var require_codemirror = __commonJS((exports, module) => {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = global || self, global.CodeMirror = factory());
  })(exports, function() {
    "use strict";
    var userAgent2 = navigator.userAgent;
    var platform = navigator.platform;
    var gecko = /gecko\/\d/i.test(userAgent2);
    var ie_upto10 = /MSIE \d/.test(userAgent2);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent2);
    var edge = /Edge\/(\d+)/.exec(userAgent2);
    var ie = ie_upto10 || ie_11up || edge;
    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
    var webkit = !edge && /WebKit\//.test(userAgent2);
    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent2);
    var chrome2 = !edge && /Chrome\//.test(userAgent2);
    var presto = /Opera\//.test(userAgent2);
    var safari = /Apple Computer/.test(navigator.vendor);
    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent2);
    var phantom = /PhantomJS/.test(userAgent2);
    var ios = safari && (/Mobile\/\w+/.test(userAgent2) || navigator.maxTouchPoints > 2);
    var android = /Android/.test(userAgent2);
    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent2);
    var mac = ios || /Mac/.test(platform);
    var chromeOS = /\bCrOS\b/.test(userAgent2);
    var windows = /win/i.test(platform);
    var presto_version = presto && userAgent2.match(/Version\/(\d*\.\d*)/);
    if (presto_version) {
      presto_version = Number(presto_version[1]);
    }
    if (presto_version && presto_version >= 15) {
      presto = false;
      webkit = true;
    }
    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
    var captureRightClick = gecko || ie && ie_version >= 9;
    function classTest(cls) {
      return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
    }
    var rmClass = function(node, cls) {
      var current = node.className;
      var match = classTest(cls).exec(current);
      if (match) {
        var after = current.slice(match.index + match[0].length);
        node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
      }
    };
    function removeChildren(e) {
      for (var count = e.childNodes.length; count > 0; --count) {
        e.removeChild(e.firstChild);
      }
      return e;
    }
    function removeChildrenAndAdd(parent, e) {
      return removeChildren(parent).appendChild(e);
    }
    function elt(tag, content, className, style) {
      var e = document.createElement(tag);
      if (className) {
        e.className = className;
      }
      if (style) {
        e.style.cssText = style;
      }
      if (typeof content == "string") {
        e.appendChild(document.createTextNode(content));
      } else if (content) {
        for (var i2 = 0; i2 < content.length; ++i2) {
          e.appendChild(content[i2]);
        }
      }
      return e;
    }
    function eltP(tag, content, className, style) {
      var e = elt(tag, content, className, style);
      e.setAttribute("role", "presentation");
      return e;
    }
    var range;
    if (document.createRange) {
      range = function(node, start, end, endNode) {
        var r = document.createRange();
        r.setEnd(endNode || node, end);
        r.setStart(node, start);
        return r;
      };
    } else {
      range = function(node, start, end) {
        var r = document.body.createTextRange();
        try {
          r.moveToElementText(node.parentNode);
        } catch (e) {
          return r;
        }
        r.collapse(true);
        r.moveEnd("character", end);
        r.moveStart("character", start);
        return r;
      };
    }
    function contains(parent, child) {
      if (child.nodeType == 3) {
        child = child.parentNode;
      }
      if (parent.contains) {
        return parent.contains(child);
      }
      do {
        if (child.nodeType == 11) {
          child = child.host;
        }
        if (child == parent) {
          return true;
        }
      } while (child = child.parentNode);
    }
    function activeElt() {
      var activeElement;
      try {
        activeElement = document.activeElement;
      } catch (e) {
        activeElement = document.body || null;
      }
      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
        activeElement = activeElement.shadowRoot.activeElement;
      }
      return activeElement;
    }
    function addClass(node, cls) {
      var current = node.className;
      if (!classTest(cls).test(current)) {
        node.className += (current ? " " : "") + cls;
      }
    }
    function joinClasses(a, b) {
      var as = a.split(" ");
      for (var i2 = 0; i2 < as.length; i2++) {
        if (as[i2] && !classTest(as[i2]).test(b)) {
          b += " " + as[i2];
        }
      }
      return b;
    }
    var selectInput = function(node) {
      node.select();
    };
    if (ios) {
      selectInput = function(node) {
        node.selectionStart = 0;
        node.selectionEnd = node.value.length;
      };
    } else if (ie) {
      selectInput = function(node) {
        try {
          node.select();
        } catch (_e) {
        }
      };
    }
    function bind(f) {
      var args = Array.prototype.slice.call(arguments, 1);
      return function() {
        return f.apply(null, args);
      };
    }
    function copyObj(obj, target, overwrite) {
      if (!target) {
        target = {};
      }
      for (var prop2 in obj) {
        if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
          target[prop2] = obj[prop2];
        }
      }
      return target;
    }
    function countColumn(string, end, tabSize, startIndex, startValue) {
      if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1) {
          end = string.length;
        }
      }
      for (var i2 = startIndex || 0, n = startValue || 0; ; ) {
        var nextTab = string.indexOf("	", i2);
        if (nextTab < 0 || nextTab >= end) {
          return n + (end - i2);
        }
        n += nextTab - i2;
        n += tabSize - n % tabSize;
        i2 = nextTab + 1;
      }
    }
    var Delayed = function() {
      this.id = null;
      this.f = null;
      this.time = 0;
      this.handler = bind(this.onTimeout, this);
    };
    Delayed.prototype.onTimeout = function(self2) {
      self2.id = 0;
      if (self2.time <= +new Date()) {
        self2.f();
      } else {
        setTimeout(self2.handler, self2.time - +new Date());
      }
    };
    Delayed.prototype.set = function(ms, f) {
      this.f = f;
      var time = +new Date() + ms;
      if (!this.id || time < this.time) {
        clearTimeout(this.id);
        this.id = setTimeout(this.handler, ms);
        this.time = time;
      }
    };
    function indexOf(array, elt2) {
      for (var i2 = 0; i2 < array.length; ++i2) {
        if (array[i2] == elt2) {
          return i2;
        }
      }
      return -1;
    }
    var scrollerGap = 50;
    var Pass = {toString: function() {
      return "CodeMirror.Pass";
    }};
    var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};
    function findColumn(string, goal, tabSize) {
      for (var pos = 0, col = 0; ; ) {
        var nextTab = string.indexOf("	", pos);
        if (nextTab == -1) {
          nextTab = string.length;
        }
        var skipped = nextTab - pos;
        if (nextTab == string.length || col + skipped >= goal) {
          return pos + Math.min(skipped, goal - col);
        }
        col += nextTab - pos;
        col += tabSize - col % tabSize;
        pos = nextTab + 1;
        if (col >= goal) {
          return pos;
        }
      }
    }
    var spaceStrs = [""];
    function spaceStr(n) {
      while (spaceStrs.length <= n) {
        spaceStrs.push(lst(spaceStrs) + " ");
      }
      return spaceStrs[n];
    }
    function lst(arr) {
      return arr[arr.length - 1];
    }
    function map2(array, f) {
      var out = [];
      for (var i2 = 0; i2 < array.length; i2++) {
        out[i2] = f(array[i2], i2);
      }
      return out;
    }
    function insertSorted(array, value, score) {
      var pos = 0, priority = score(value);
      while (pos < array.length && score(array[pos]) <= priority) {
        pos++;
      }
      array.splice(pos, 0, value);
    }
    function nothing() {
    }
    function createObj(base, props) {
      var inst;
      if (Object.create) {
        inst = Object.create(base);
      } else {
        nothing.prototype = base;
        inst = new nothing();
      }
      if (props) {
        copyObj(props, inst);
      }
      return inst;
    }
    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    function isWordCharBasic(ch) {
      return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    }
    function isWordChar(ch, helper) {
      if (!helper) {
        return isWordCharBasic(ch);
      }
      if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
        return true;
      }
      return helper.test(ch);
    }
    function isEmpty2(obj) {
      for (var n in obj) {
        if (obj.hasOwnProperty(n) && obj[n]) {
          return false;
        }
      }
      return true;
    }
    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch) {
      return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    }
    function skipExtendingChars(str, pos, dir) {
      while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
        pos += dir;
      }
      return pos;
    }
    function findFirst(pred, from, to) {
      var dir = from > to ? -1 : 1;
      for (; ; ) {
        if (from == to) {
          return from;
        }
        var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
        if (mid == from) {
          return pred(mid) ? from : to;
        }
        if (pred(mid)) {
          to = mid;
        } else {
          from = mid + dir;
        }
      }
    }
    function iterateBidiSections(order, from, to, f) {
      if (!order) {
        return f(from, to, "ltr", 0);
      }
      var found = false;
      for (var i2 = 0; i2 < order.length; ++i2) {
        var part = order[i2];
        if (part.from < to && part.to > from || from == to && part.to == from) {
          f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
          found = true;
        }
      }
      if (!found) {
        f(from, to, "ltr");
      }
    }
    var bidiOther = null;
    function getBidiPartAt(order, ch, sticky) {
      var found;
      bidiOther = null;
      for (var i2 = 0; i2 < order.length; ++i2) {
        var cur = order[i2];
        if (cur.from < ch && cur.to > ch) {
          return i2;
        }
        if (cur.to == ch) {
          if (cur.from != cur.to && sticky == "before") {
            found = i2;
          } else {
            bidiOther = i2;
          }
        }
        if (cur.from == ch) {
          if (cur.from != cur.to && sticky != "before") {
            found = i2;
          } else {
            bidiOther = i2;
          }
        }
      }
      return found != null ? found : bidiOther;
    }
    var bidiOrdering = function() {
      var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
      var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
      function charType(code) {
        if (code <= 247) {
          return lowTypes.charAt(code);
        } else if (1424 <= code && code <= 1524) {
          return "R";
        } else if (1536 <= code && code <= 1785) {
          return arabicTypes.charAt(code - 1536);
        } else if (1774 <= code && code <= 2220) {
          return "r";
        } else if (8192 <= code && code <= 8203) {
          return "w";
        } else if (code == 8204) {
          return "b";
        } else {
          return "L";
        }
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      function BidiSpan(level, from, to) {
        this.level = level;
        this.from = from;
        this.to = to;
      }
      return function(str, direction) {
        var outerType = direction == "ltr" ? "L" : "R";
        if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
          return false;
        }
        var len = str.length, types = [];
        for (var i2 = 0; i2 < len; ++i2) {
          types.push(charType(str.charCodeAt(i2)));
        }
        for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {
          var type = types[i$12];
          if (type == "m") {
            types[i$12] = prev;
          } else {
            prev = type;
          }
        }
        for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
          var type$1 = types[i$22];
          if (type$1 == "1" && cur == "r") {
            types[i$22] = "n";
          } else if (isStrong.test(type$1)) {
            cur = type$1;
            if (type$1 == "r") {
              types[i$22] = "R";
            }
          }
        }
        for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
          var type$2 = types[i$3];
          if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
            types[i$3] = "1";
          } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
            types[i$3] = prev$1;
          }
          prev$1 = type$2;
        }
        for (var i$4 = 0; i$4 < len; ++i$4) {
          var type$3 = types[i$4];
          if (type$3 == ",") {
            types[i$4] = "N";
          } else if (type$3 == "%") {
            var end = void 0;
            for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {
            }
            var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
            for (var j = i$4; j < end; ++j) {
              types[j] = replace;
            }
            i$4 = end - 1;
          }
        }
        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
          var type$4 = types[i$5];
          if (cur$1 == "L" && type$4 == "1") {
            types[i$5] = "L";
          } else if (isStrong.test(type$4)) {
            cur$1 = type$4;
          }
        }
        for (var i$6 = 0; i$6 < len; ++i$6) {
          if (isNeutral.test(types[i$6])) {
            var end$1 = void 0;
            for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {
            }
            var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
            var after = (end$1 < len ? types[end$1] : outerType) == "L";
            var replace$1 = before == after ? before ? "L" : "R" : outerType;
            for (var j$1 = i$6; j$1 < end$1; ++j$1) {
              types[j$1] = replace$1;
            }
            i$6 = end$1 - 1;
          }
        }
        var order = [], m;
        for (var i$7 = 0; i$7 < len; ) {
          if (countsAsLeft.test(types[i$7])) {
            var start = i$7;
            for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {
            }
            order.push(new BidiSpan(0, start, i$7));
          } else {
            var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
            for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {
            }
            for (var j$2 = pos; j$2 < i$7; ) {
              if (countsAsNum.test(types[j$2])) {
                if (pos < j$2) {
                  order.splice(at, 0, new BidiSpan(1, pos, j$2));
                  at += isRTL;
                }
                var nstart = j$2;
                for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {
                }
                order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                at += isRTL;
                pos = j$2;
              } else {
                ++j$2;
              }
            }
            if (pos < i$7) {
              order.splice(at, 0, new BidiSpan(1, pos, i$7));
            }
          }
        }
        if (direction == "ltr") {
          if (order[0].level == 1 && (m = str.match(/^\s+/))) {
            order[0].from = m[0].length;
            order.unshift(new BidiSpan(0, 0, m[0].length));
          }
          if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
            lst(order).to -= m[0].length;
            order.push(new BidiSpan(0, len - m[0].length, len));
          }
        }
        return direction == "rtl" ? order.reverse() : order;
      };
    }();
    function getOrder(line, direction) {
      var order = line.order;
      if (order == null) {
        order = line.order = bidiOrdering(line.text, direction);
      }
      return order;
    }
    var noHandlers = [];
    var on3 = function(emitter, type, f) {
      if (emitter.addEventListener) {
        emitter.addEventListener(type, f, false);
      } else if (emitter.attachEvent) {
        emitter.attachEvent("on" + type, f);
      } else {
        var map3 = emitter._handlers || (emitter._handlers = {});
        map3[type] = (map3[type] || noHandlers).concat(f);
      }
    };
    function getHandlers(emitter, type) {
      return emitter._handlers && emitter._handlers[type] || noHandlers;
    }
    function off2(emitter, type, f) {
      if (emitter.removeEventListener) {
        emitter.removeEventListener(type, f, false);
      } else if (emitter.detachEvent) {
        emitter.detachEvent("on" + type, f);
      } else {
        var map3 = emitter._handlers, arr = map3 && map3[type];
        if (arr) {
          var index2 = indexOf(arr, f);
          if (index2 > -1) {
            map3[type] = arr.slice(0, index2).concat(arr.slice(index2 + 1));
          }
        }
      }
    }
    function signal(emitter, type) {
      var handlers = getHandlers(emitter, type);
      if (!handlers.length) {
        return;
      }
      var args = Array.prototype.slice.call(arguments, 2);
      for (var i2 = 0; i2 < handlers.length; ++i2) {
        handlers[i2].apply(null, args);
      }
    }
    function signalDOMEvent(cm, e, override) {
      if (typeof e == "string") {
        e = {type: e, preventDefault: function() {
          this.defaultPrevented = true;
        }};
      }
      signal(cm, override || e.type, cm, e);
      return e_defaultPrevented(e) || e.codemirrorIgnore;
    }
    function signalCursorActivity(cm) {
      var arr = cm._handlers && cm._handlers.cursorActivity;
      if (!arr) {
        return;
      }
      var set2 = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
      for (var i2 = 0; i2 < arr.length; ++i2) {
        if (indexOf(set2, arr[i2]) == -1) {
          set2.push(arr[i2]);
        }
      }
    }
    function hasHandler(emitter, type) {
      return getHandlers(emitter, type).length > 0;
    }
    function eventMixin(ctor) {
      ctor.prototype.on = function(type, f) {
        on3(this, type, f);
      };
      ctor.prototype.off = function(type, f) {
        off2(this, type, f);
      };
    }
    function e_preventDefault(e) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
    }
    function e_stopPropagation(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
    }
    function e_defaultPrevented(e) {
      return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
    }
    function e_stop(e) {
      e_preventDefault(e);
      e_stopPropagation(e);
    }
    function e_target(e) {
      return e.target || e.srcElement;
    }
    function e_button(e) {
      var b = e.which;
      if (b == null) {
        if (e.button & 1) {
          b = 1;
        } else if (e.button & 2) {
          b = 3;
        } else if (e.button & 4) {
          b = 2;
        }
      }
      if (mac && e.ctrlKey && b == 1) {
        b = 3;
      }
      return b;
    }
    var dragAndDrop = function() {
      if (ie && ie_version < 9) {
        return false;
      }
      var div = elt("div");
      return "draggable" in div || "dragDrop" in div;
    }();
    var zwspSupported;
    function zeroWidthElement(measure) {
      if (zwspSupported == null) {
        var test = elt("span", "\u200B");
        removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
        if (measure.firstChild.offsetHeight != 0) {
          zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
        }
      }
      var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
      node.setAttribute("cm-text", "");
      return node;
    }
    var badBidiRects;
    function hasBadBidiRects(measure) {
      if (badBidiRects != null) {
        return badBidiRects;
      }
      var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
      var r0 = range(txt, 0, 1).getBoundingClientRect();
      var r1 = range(txt, 1, 2).getBoundingClientRect();
      removeChildren(measure);
      if (!r0 || r0.left == r0.right) {
        return false;
      }
      return badBidiRects = r1.right - r0.right < 3;
    }
    var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string) {
      var pos = 0, result = [], l = string.length;
      while (pos <= l) {
        var nl = string.indexOf("\n", pos);
        if (nl == -1) {
          nl = string.length;
        }
        var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
        var rt = line.indexOf("\r");
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result;
    } : function(string) {
      return string.split(/\r\n?|\n/);
    };
    var hasSelection = window.getSelection ? function(te) {
      try {
        return te.selectionStart != te.selectionEnd;
      } catch (e) {
        return false;
      }
    } : function(te) {
      var range2;
      try {
        range2 = te.ownerDocument.selection.createRange();
      } catch (e) {
      }
      if (!range2 || range2.parentElement() != te) {
        return false;
      }
      return range2.compareEndPoints("StartToEnd", range2) != 0;
    };
    var hasCopyEvent = function() {
      var e = elt("div");
      if ("oncopy" in e) {
        return true;
      }
      e.setAttribute("oncopy", "return;");
      return typeof e.oncopy == "function";
    }();
    var badZoomedRects = null;
    function hasBadZoomedRects(measure) {
      if (badZoomedRects != null) {
        return badZoomedRects;
      }
      var node = removeChildrenAndAdd(measure, elt("span", "x"));
      var normal = node.getBoundingClientRect();
      var fromRange = range(node, 0, 1).getBoundingClientRect();
      return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
    }
    var modes = {}, mimeModes = {};
    function defineMode(name2, mode) {
      if (arguments.length > 2) {
        mode.dependencies = Array.prototype.slice.call(arguments, 2);
      }
      modes[name2] = mode;
    }
    function defineMIME(mime, spec) {
      mimeModes[mime] = spec;
    }
    function resolveMode(spec) {
      if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
        spec = mimeModes[spec];
      } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
        var found = mimeModes[spec.name];
        if (typeof found == "string") {
          found = {name: found};
        }
        spec = createObj(found, spec);
        spec.name = found.name;
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
        return resolveMode("application/xml");
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
        return resolveMode("application/json");
      }
      if (typeof spec == "string") {
        return {name: spec};
      } else {
        return spec || {name: "null"};
      }
    }
    function getMode(options, spec) {
      spec = resolveMode(spec);
      var mfactory = modes[spec.name];
      if (!mfactory) {
        return getMode(options, "text/plain");
      }
      var modeObj = mfactory(options, spec);
      if (modeExtensions.hasOwnProperty(spec.name)) {
        var exts = modeExtensions[spec.name];
        for (var prop2 in exts) {
          if (!exts.hasOwnProperty(prop2)) {
            continue;
          }
          if (modeObj.hasOwnProperty(prop2)) {
            modeObj["_" + prop2] = modeObj[prop2];
          }
          modeObj[prop2] = exts[prop2];
        }
      }
      modeObj.name = spec.name;
      if (spec.helperType) {
        modeObj.helperType = spec.helperType;
      }
      if (spec.modeProps) {
        for (var prop$1 in spec.modeProps) {
          modeObj[prop$1] = spec.modeProps[prop$1];
        }
      }
      return modeObj;
    }
    var modeExtensions = {};
    function extendMode(mode, properties) {
      var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
      copyObj(properties, exts);
    }
    function copyState(mode, state2) {
      if (state2 === true) {
        return state2;
      }
      if (mode.copyState) {
        return mode.copyState(state2);
      }
      var nstate = {};
      for (var n in state2) {
        var val = state2[n];
        if (val instanceof Array) {
          val = val.concat([]);
        }
        nstate[n] = val;
      }
      return nstate;
    }
    function innerMode(mode, state2) {
      var info;
      while (mode.innerMode) {
        info = mode.innerMode(state2);
        if (!info || info.mode == mode) {
          break;
        }
        state2 = info.state;
        mode = info.mode;
      }
      return info || {mode, state: state2};
    }
    function startState(mode, a1, a2) {
      return mode.startState ? mode.startState(a1, a2) : true;
    }
    var StringStream = function(string, tabSize, lineOracle) {
      this.pos = this.start = 0;
      this.string = string;
      this.tabSize = tabSize || 8;
      this.lastColumnPos = this.lastColumnValue = 0;
      this.lineStart = 0;
      this.lineOracle = lineOracle;
    };
    StringStream.prototype.eol = function() {
      return this.pos >= this.string.length;
    };
    StringStream.prototype.sol = function() {
      return this.pos == this.lineStart;
    };
    StringStream.prototype.peek = function() {
      return this.string.charAt(this.pos) || void 0;
    };
    StringStream.prototype.next = function() {
      if (this.pos < this.string.length) {
        return this.string.charAt(this.pos++);
      }
    };
    StringStream.prototype.eat = function(match) {
      var ch = this.string.charAt(this.pos);
      var ok;
      if (typeof match == "string") {
        ok = ch == match;
      } else {
        ok = ch && (match.test ? match.test(ch) : match(ch));
      }
      if (ok) {
        ++this.pos;
        return ch;
      }
    };
    StringStream.prototype.eatWhile = function(match) {
      var start = this.pos;
      while (this.eat(match)) {
      }
      return this.pos > start;
    };
    StringStream.prototype.eatSpace = function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
        ++this.pos;
      }
      return this.pos > start;
    };
    StringStream.prototype.skipToEnd = function() {
      this.pos = this.string.length;
    };
    StringStream.prototype.skipTo = function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    };
    StringStream.prototype.backUp = function(n) {
      this.pos -= n;
    };
    StringStream.prototype.column = function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream.prototype.indentation = function() {
      return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) {
            this.pos += pattern.length;
          }
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) {
          return null;
        }
        if (match && consume !== false) {
          this.pos += match[0].length;
        }
        return match;
      }
    };
    StringStream.prototype.current = function() {
      return this.string.slice(this.start, this.pos);
    };
    StringStream.prototype.hideFirstChars = function(n, inner) {
      this.lineStart += n;
      try {
        return inner();
      } finally {
        this.lineStart -= n;
      }
    };
    StringStream.prototype.lookAhead = function(n) {
      var oracle = this.lineOracle;
      return oracle && oracle.lookAhead(n);
    };
    StringStream.prototype.baseToken = function() {
      var oracle = this.lineOracle;
      return oracle && oracle.baseToken(this.pos);
    };
    function getLine(doc, n) {
      n -= doc.first;
      if (n < 0 || n >= doc.size) {
        throw new Error("There is no line " + (n + doc.first) + " in the document.");
      }
      var chunk = doc;
      while (!chunk.lines) {
        for (var i2 = 0; ; ++i2) {
          var child = chunk.children[i2], sz = child.chunkSize();
          if (n < sz) {
            chunk = child;
            break;
          }
          n -= sz;
        }
      }
      return chunk.lines[n];
    }
    function getBetween(doc, start, end) {
      var out = [], n = start.line;
      doc.iter(start.line, end.line + 1, function(line) {
        var text2 = line.text;
        if (n == end.line) {
          text2 = text2.slice(0, end.ch);
        }
        if (n == start.line) {
          text2 = text2.slice(start.ch);
        }
        out.push(text2);
        ++n;
      });
      return out;
    }
    function getLines(doc, from, to) {
      var out = [];
      doc.iter(from, to, function(line) {
        out.push(line.text);
      });
      return out;
    }
    function updateLineHeight(line, height) {
      var diff = height - line.height;
      if (diff) {
        for (var n = line; n; n = n.parent) {
          n.height += diff;
        }
      }
    }
    function lineNo(line) {
      if (line.parent == null) {
        return null;
      }
      var cur = line.parent, no = indexOf(cur.lines, line);
      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
        for (var i2 = 0; ; ++i2) {
          if (chunk.children[i2] == cur) {
            break;
          }
          no += chunk.children[i2].chunkSize();
        }
      }
      return no + cur.first;
    }
    function lineAtHeight(chunk, h) {
      var n = chunk.first;
      outer:
        do {
          for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
            var child = chunk.children[i$12], ch = child.height;
            if (h < ch) {
              chunk = child;
              continue outer;
            }
            h -= ch;
            n += child.chunkSize();
          }
          return n;
        } while (!chunk.lines);
      var i2 = 0;
      for (; i2 < chunk.lines.length; ++i2) {
        var line = chunk.lines[i2], lh = line.height;
        if (h < lh) {
          break;
        }
        h -= lh;
      }
      return n + i2;
    }
    function isLine(doc, l) {
      return l >= doc.first && l < doc.first + doc.size;
    }
    function lineNumberFor(options, i2) {
      return String(options.lineNumberFormatter(i2 + options.firstLineNumber));
    }
    function Pos(line, ch, sticky) {
      if (sticky === void 0)
        sticky = null;
      if (!(this instanceof Pos)) {
        return new Pos(line, ch, sticky);
      }
      this.line = line;
      this.ch = ch;
      this.sticky = sticky;
    }
    function cmp(a, b) {
      return a.line - b.line || a.ch - b.ch;
    }
    function equalCursorPos(a, b) {
      return a.sticky == b.sticky && cmp(a, b) == 0;
    }
    function copyPos(x) {
      return Pos(x.line, x.ch);
    }
    function maxPos(a, b) {
      return cmp(a, b) < 0 ? b : a;
    }
    function minPos(a, b) {
      return cmp(a, b) < 0 ? a : b;
    }
    function clipLine(doc, n) {
      return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
    }
    function clipPos(doc, pos) {
      if (pos.line < doc.first) {
        return Pos(doc.first, 0);
      }
      var last = doc.first + doc.size - 1;
      if (pos.line > last) {
        return Pos(last, getLine(doc, last).text.length);
      }
      return clipToLen(pos, getLine(doc, pos.line).text.length);
    }
    function clipToLen(pos, linelen) {
      var ch = pos.ch;
      if (ch == null || ch > linelen) {
        return Pos(pos.line, linelen);
      } else if (ch < 0) {
        return Pos(pos.line, 0);
      } else {
        return pos;
      }
    }
    function clipPosArray(doc, array) {
      var out = [];
      for (var i2 = 0; i2 < array.length; i2++) {
        out[i2] = clipPos(doc, array[i2]);
      }
      return out;
    }
    var SavedContext = function(state2, lookAhead) {
      this.state = state2;
      this.lookAhead = lookAhead;
    };
    var Context = function(doc, state2, line, lookAhead) {
      this.state = state2;
      this.doc = doc;
      this.line = line;
      this.maxLookAhead = lookAhead || 0;
      this.baseTokens = null;
      this.baseTokenPos = 1;
    };
    Context.prototype.lookAhead = function(n) {
      var line = this.doc.getLine(this.line + n);
      if (line != null && n > this.maxLookAhead) {
        this.maxLookAhead = n;
      }
      return line;
    };
    Context.prototype.baseToken = function(n) {
      if (!this.baseTokens) {
        return null;
      }
      while (this.baseTokens[this.baseTokenPos] <= n) {
        this.baseTokenPos += 2;
      }
      var type = this.baseTokens[this.baseTokenPos + 1];
      return {
        type: type && type.replace(/( |^)overlay .*/, ""),
        size: this.baseTokens[this.baseTokenPos] - n
      };
    };
    Context.prototype.nextLine = function() {
      this.line++;
      if (this.maxLookAhead > 0) {
        this.maxLookAhead--;
      }
    };
    Context.fromSaved = function(doc, saved, line) {
      if (saved instanceof SavedContext) {
        return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
      } else {
        return new Context(doc, copyState(doc.mode, saved), line);
      }
    };
    Context.prototype.save = function(copy) {
      var state2 = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
      return this.maxLookAhead > 0 ? new SavedContext(state2, this.maxLookAhead) : state2;
    };
    function highlightLine(cm, line, context, forceToEnd) {
      var st = [cm.state.modeGen], lineClasses = {};
      runMode(cm, line.text, cm.doc.mode, context, function(end, style) {
        return st.push(end, style);
      }, lineClasses, forceToEnd);
      var state2 = context.state;
      var loop = function(o2) {
        context.baseTokens = st;
        var overlay = cm.state.overlays[o2], i2 = 1, at = 0;
        context.state = true;
        runMode(cm, line.text, overlay.mode, context, function(end, style) {
          var start = i2;
          while (at < end) {
            var i_end = st[i2];
            if (i_end > end) {
              st.splice(i2, 1, end, st[i2 + 1], i_end);
            }
            i2 += 2;
            at = Math.min(end, i_end);
          }
          if (!style) {
            return;
          }
          if (overlay.opaque) {
            st.splice(start, i2 - start, end, "overlay " + style);
            i2 = start + 2;
          } else {
            for (; start < i2; start += 2) {
              var cur = st[start + 1];
              st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
            }
          }
        }, lineClasses);
        context.state = state2;
        context.baseTokens = null;
        context.baseTokenPos = 1;
      };
      for (var o = 0; o < cm.state.overlays.length; ++o)
        loop(o);
      return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
    }
    function getLineStyles(cm, line, updateFrontier) {
      if (!line.styles || line.styles[0] != cm.state.modeGen) {
        var context = getContextBefore(cm, lineNo(line));
        var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
        var result = highlightLine(cm, line, context);
        if (resetState) {
          context.state = resetState;
        }
        line.stateAfter = context.save(!resetState);
        line.styles = result.styles;
        if (result.classes) {
          line.styleClasses = result.classes;
        } else if (line.styleClasses) {
          line.styleClasses = null;
        }
        if (updateFrontier === cm.doc.highlightFrontier) {
          cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
        }
      }
      return line.styles;
    }
    function getContextBefore(cm, n, precise) {
      var doc = cm.doc, display = cm.display;
      if (!doc.mode.startState) {
        return new Context(doc, true, n);
      }
      var start = findStartLine(cm, n, precise);
      var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
      var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
      doc.iter(start, n, function(line) {
        processLine(cm, line.text, context);
        var pos = context.line;
        line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
        context.nextLine();
      });
      if (precise) {
        doc.modeFrontier = context.line;
      }
      return context;
    }
    function processLine(cm, text2, context, startAt) {
      var mode = cm.doc.mode;
      var stream = new StringStream(text2, cm.options.tabSize, context);
      stream.start = stream.pos = startAt || 0;
      if (text2 == "") {
        callBlankLine(mode, context.state);
      }
      while (!stream.eol()) {
        readToken(mode, stream, context.state);
        stream.start = stream.pos;
      }
    }
    function callBlankLine(mode, state2) {
      if (mode.blankLine) {
        return mode.blankLine(state2);
      }
      if (!mode.innerMode) {
        return;
      }
      var inner = innerMode(mode, state2);
      if (inner.mode.blankLine) {
        return inner.mode.blankLine(inner.state);
      }
    }
    function readToken(mode, stream, state2, inner) {
      for (var i2 = 0; i2 < 10; i2++) {
        if (inner) {
          inner[0] = innerMode(mode, state2).mode;
        }
        var style = mode.token(stream, state2);
        if (stream.pos > stream.start) {
          return style;
        }
      }
      throw new Error("Mode " + mode.name + " failed to advance stream.");
    }
    var Token = function(stream, type, state2) {
      this.start = stream.start;
      this.end = stream.pos;
      this.string = stream.current();
      this.type = type || null;
      this.state = state2;
    };
    function takeToken(cm, pos, precise, asArray) {
      var doc = cm.doc, mode = doc.mode, style;
      pos = clipPos(doc, pos);
      var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
      var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
      if (asArray) {
        tokens = [];
      }
      while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
        stream.start = stream.pos;
        style = readToken(mode, stream, context.state);
        if (asArray) {
          tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
        }
      }
      return asArray ? tokens : new Token(stream, style, context.state);
    }
    function extractLineClasses(type, output) {
      if (type) {
        for (; ; ) {
          var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
          if (!lineClass) {
            break;
          }
          type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
          var prop2 = lineClass[1] ? "bgClass" : "textClass";
          if (output[prop2] == null) {
            output[prop2] = lineClass[2];
          } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
            output[prop2] += " " + lineClass[2];
          }
        }
      }
      return type;
    }
    function runMode(cm, text2, mode, context, f, lineClasses, forceToEnd) {
      var flattenSpans = mode.flattenSpans;
      if (flattenSpans == null) {
        flattenSpans = cm.options.flattenSpans;
      }
      var curStart = 0, curStyle = null;
      var stream = new StringStream(text2, cm.options.tabSize, context), style;
      var inner = cm.options.addModeClass && [null];
      if (text2 == "") {
        extractLineClasses(callBlankLine(mode, context.state), lineClasses);
      }
      while (!stream.eol()) {
        if (stream.pos > cm.options.maxHighlightLength) {
          flattenSpans = false;
          if (forceToEnd) {
            processLine(cm, text2, context, stream.pos);
          }
          stream.pos = text2.length;
          style = null;
        } else {
          style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
        }
        if (inner) {
          var mName = inner[0].name;
          if (mName) {
            style = "m-" + (style ? mName + " " + style : mName);
          }
        }
        if (!flattenSpans || curStyle != style) {
          while (curStart < stream.start) {
            curStart = Math.min(stream.start, curStart + 5e3);
            f(curStart, curStyle);
          }
          curStyle = style;
        }
        stream.start = stream.pos;
      }
      while (curStart < stream.pos) {
        var pos = Math.min(stream.pos, curStart + 5e3);
        f(pos, curStyle);
        curStart = pos;
      }
    }
    function findStartLine(cm, n, precise) {
      var minindent, minline, doc = cm.doc;
      var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
      for (var search = n; search > lim; --search) {
        if (search <= doc.first) {
          return doc.first;
        }
        var line = getLine(doc, search - 1), after = line.stateAfter;
        if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
          return search;
        }
        var indented = countColumn(line.text, null, cm.options.tabSize);
        if (minline == null || minindent > indented) {
          minline = search - 1;
          minindent = indented;
        }
      }
      return minline;
    }
    function retreatFrontier(doc, n) {
      doc.modeFrontier = Math.min(doc.modeFrontier, n);
      if (doc.highlightFrontier < n - 10) {
        return;
      }
      var start = doc.first;
      for (var line = n - 1; line > start; line--) {
        var saved = getLine(doc, line).stateAfter;
        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
          start = line + 1;
          break;
        }
      }
      doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
    }
    var sawReadOnlySpans = false, sawCollapsedSpans = false;
    function seeReadOnlySpans() {
      sawReadOnlySpans = true;
    }
    function seeCollapsedSpans() {
      sawCollapsedSpans = true;
    }
    function MarkedSpan(marker, from, to) {
      this.marker = marker;
      this.from = from;
      this.to = to;
    }
    function getMarkedSpanFor(spans, marker) {
      if (spans) {
        for (var i2 = 0; i2 < spans.length; ++i2) {
          var span = spans[i2];
          if (span.marker == marker) {
            return span;
          }
        }
      }
    }
    function removeMarkedSpan(spans, span) {
      var r;
      for (var i2 = 0; i2 < spans.length; ++i2) {
        if (spans[i2] != span) {
          (r || (r = [])).push(spans[i2]);
        }
      }
      return r;
    }
    function addMarkedSpan(line, span, op) {
      var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet()));
      if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
        line.markedSpans.push(span);
      } else {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        if (inThisOp) {
          inThisOp.add(line.markedSpans);
        }
      }
      span.marker.attachLine(line);
    }
    function markedSpansBefore(old, startCh, isInsert) {
      var nw;
      if (old) {
        for (var i2 = 0; i2 < old.length; ++i2) {
          var span = old[i2], marker = span.marker;
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
          if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
            (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
          }
        }
      }
      return nw;
    }
    function markedSpansAfter(old, endCh, isInsert) {
      var nw;
      if (old) {
        for (var i2 = 0; i2 < old.length; ++i2) {
          var span = old[i2], marker = span.marker;
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
          if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
            (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
          }
        }
      }
      return nw;
    }
    function stretchSpansOverChange(doc, change) {
      if (change.full) {
        return null;
      }
      var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
      var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
      if (!oldFirst && !oldLast) {
        return null;
      }
      var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
      var first = markedSpansBefore(oldFirst, startCh, isInsert);
      var last = markedSpansAfter(oldLast, endCh, isInsert);
      var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
      if (first) {
        for (var i2 = 0; i2 < first.length; ++i2) {
          var span = first[i2];
          if (span.to == null) {
            var found = getMarkedSpanFor(last, span.marker);
            if (!found) {
              span.to = startCh;
            } else if (sameLine) {
              span.to = found.to == null ? null : found.to + offset;
            }
          }
        }
      }
      if (last) {
        for (var i$12 = 0; i$12 < last.length; ++i$12) {
          var span$1 = last[i$12];
          if (span$1.to != null) {
            span$1.to += offset;
          }
          if (span$1.from == null) {
            var found$1 = getMarkedSpanFor(first, span$1.marker);
            if (!found$1) {
              span$1.from = offset;
              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          } else {
            span$1.from += offset;
            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        }
      }
      if (first) {
        first = clearEmptySpans(first);
      }
      if (last && last != first) {
        last = clearEmptySpans(last);
      }
      var newMarkers = [first];
      if (!sameLine) {
        var gap = change.text.length - 2, gapMarkers;
        if (gap > 0 && first) {
          for (var i$22 = 0; i$22 < first.length; ++i$22) {
            if (first[i$22].to == null) {
              (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
            }
          }
        }
        for (var i$3 = 0; i$3 < gap; ++i$3) {
          newMarkers.push(gapMarkers);
        }
        newMarkers.push(last);
      }
      return newMarkers;
    }
    function clearEmptySpans(spans) {
      for (var i2 = 0; i2 < spans.length; ++i2) {
        var span = spans[i2];
        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
          spans.splice(i2--, 1);
        }
      }
      if (!spans.length) {
        return null;
      }
      return spans;
    }
    function removeReadOnlyRanges(doc, from, to) {
      var markers = null;
      doc.iter(from.line, to.line + 1, function(line) {
        if (line.markedSpans) {
          for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
            var mark = line.markedSpans[i3].marker;
            if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
              (markers || (markers = [])).push(mark);
            }
          }
        }
      });
      if (!markers) {
        return null;
      }
      var parts = [{from, to}];
      for (var i2 = 0; i2 < markers.length; ++i2) {
        var mk = markers[i2], m = mk.find(0);
        for (var j = 0; j < parts.length; ++j) {
          var p = parts[j];
          if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
            continue;
          }
          var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
          if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
            newParts.push({from: p.from, to: m.from});
          }
          if (dto > 0 || !mk.inclusiveRight && !dto) {
            newParts.push({from: m.to, to: p.to});
          }
          parts.splice.apply(parts, newParts);
          j += newParts.length - 3;
        }
      }
      return parts;
    }
    function detachMarkedSpans(line) {
      var spans = line.markedSpans;
      if (!spans) {
        return;
      }
      for (var i2 = 0; i2 < spans.length; ++i2) {
        spans[i2].marker.detachLine(line);
      }
      line.markedSpans = null;
    }
    function attachMarkedSpans(line, spans) {
      if (!spans) {
        return;
      }
      for (var i2 = 0; i2 < spans.length; ++i2) {
        spans[i2].marker.attachLine(line);
      }
      line.markedSpans = spans;
    }
    function extraLeft(marker) {
      return marker.inclusiveLeft ? -1 : 0;
    }
    function extraRight(marker) {
      return marker.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers(a, b) {
      var lenDiff = a.lines.length - b.lines.length;
      if (lenDiff != 0) {
        return lenDiff;
      }
      var aPos = a.find(), bPos = b.find();
      var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
      if (fromCmp) {
        return -fromCmp;
      }
      var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
      if (toCmp) {
        return toCmp;
      }
      return b.id - a.id;
    }
    function collapsedSpanAtSide(line, start) {
      var sps = sawCollapsedSpans && line.markedSpans, found;
      if (sps) {
        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
          sp = sps[i2];
          if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
            found = sp.marker;
          }
        }
      }
      return found;
    }
    function collapsedSpanAtStart(line) {
      return collapsedSpanAtSide(line, true);
    }
    function collapsedSpanAtEnd(line) {
      return collapsedSpanAtSide(line, false);
    }
    function collapsedSpanAround(line, ch) {
      var sps = sawCollapsedSpans && line.markedSpans, found;
      if (sps) {
        for (var i2 = 0; i2 < sps.length; ++i2) {
          var sp = sps[i2];
          if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
            found = sp.marker;
          }
        }
      }
      return found;
    }
    function conflictingCollapsedRange(doc, lineNo2, from, to, marker) {
      var line = getLine(doc, lineNo2);
      var sps = sawCollapsedSpans && line.markedSpans;
      if (sps) {
        for (var i2 = 0; i2 < sps.length; ++i2) {
          var sp = sps[i2];
          if (!sp.marker.collapsed) {
            continue;
          }
          var found = sp.marker.find(0);
          var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
          var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
          if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
            continue;
          }
          if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
            return true;
          }
        }
      }
    }
    function visualLine(line) {
      var merged;
      while (merged = collapsedSpanAtStart(line)) {
        line = merged.find(-1, true).line;
      }
      return line;
    }
    function visualLineEnd(line) {
      var merged;
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
      }
      return line;
    }
    function visualLineContinued(line) {
      var merged, lines;
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
        (lines || (lines = [])).push(line);
      }
      return lines;
    }
    function visualLineNo(doc, lineN) {
      var line = getLine(doc, lineN), vis = visualLine(line);
      if (line == vis) {
        return lineN;
      }
      return lineNo(vis);
    }
    function visualLineEndNo(doc, lineN) {
      if (lineN > doc.lastLine()) {
        return lineN;
      }
      var line = getLine(doc, lineN), merged;
      if (!lineIsHidden(doc, line)) {
        return lineN;
      }
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
      }
      return lineNo(line) + 1;
    }
    function lineIsHidden(doc, line) {
      var sps = sawCollapsedSpans && line.markedSpans;
      if (sps) {
        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
          sp = sps[i2];
          if (!sp.marker.collapsed) {
            continue;
          }
          if (sp.from == null) {
            return true;
          }
          if (sp.marker.widgetNode) {
            continue;
          }
          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
            return true;
          }
        }
      }
    }
    function lineIsHiddenInner(doc, line, span) {
      if (span.to == null) {
        var end = span.marker.find(1, true);
        return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
      }
      if (span.marker.inclusiveRight && span.to == line.text.length) {
        return true;
      }
      for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
        sp = line.markedSpans[i2];
        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
          return true;
        }
      }
    }
    function heightAtLine(lineObj) {
      lineObj = visualLine(lineObj);
      var h = 0, chunk = lineObj.parent;
      for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
        var line = chunk.lines[i2];
        if (line == lineObj) {
          break;
        } else {
          h += line.height;
        }
      }
      for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
        for (var i$12 = 0; i$12 < p.children.length; ++i$12) {
          var cur = p.children[i$12];
          if (cur == chunk) {
            break;
          } else {
            h += cur.height;
          }
        }
      }
      return h;
    }
    function lineLength(line) {
      if (line.height == 0) {
        return 0;
      }
      var len = line.text.length, merged, cur = line;
      while (merged = collapsedSpanAtStart(cur)) {
        var found = merged.find(0, true);
        cur = found.from.line;
        len += found.from.ch - found.to.ch;
      }
      cur = line;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found$1 = merged.find(0, true);
        len -= cur.text.length - found$1.from.ch;
        cur = found$1.to.line;
        len += cur.text.length - found$1.to.ch;
      }
      return len;
    }
    function findMaxLine(cm) {
      var d = cm.display, doc = cm.doc;
      d.maxLine = getLine(doc, doc.first);
      d.maxLineLength = lineLength(d.maxLine);
      d.maxLineChanged = true;
      doc.iter(function(line) {
        var len = lineLength(line);
        if (len > d.maxLineLength) {
          d.maxLineLength = len;
          d.maxLine = line;
        }
      });
    }
    var Line = function(text2, markedSpans, estimateHeight2) {
      this.text = text2;
      attachMarkedSpans(this, markedSpans);
      this.height = estimateHeight2 ? estimateHeight2(this) : 1;
    };
    Line.prototype.lineNo = function() {
      return lineNo(this);
    };
    eventMixin(Line);
    function updateLine3(line, text2, markedSpans, estimateHeight2) {
      line.text = text2;
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      if (line.styles) {
        line.styles = null;
      }
      if (line.order != null) {
        line.order = null;
      }
      detachMarkedSpans(line);
      attachMarkedSpans(line, markedSpans);
      var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    }
    function cleanUpLine(line) {
      line.parent = null;
      detachMarkedSpans(line);
    }
    var styleToClassCache = {}, styleToClassCacheWithMode = {};
    function interpretTokenStyle(style, options) {
      if (!style || /^\s*$/.test(style)) {
        return null;
      }
      var cache2 = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
      return cache2[style] || (cache2[style] = style.replace(/\S+/g, "cm-$&"));
    }
    function buildLineContent(cm, lineView) {
      var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
      var builder = {
        pre: eltP("pre", [content], "CodeMirror-line"),
        content,
        col: 0,
        pos: 0,
        cm,
        trailingSpace: false,
        splitSpaces: cm.getOption("lineWrapping")
      };
      lineView.measure = {};
      for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
        var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;
        builder.pos = 0;
        builder.addToken = buildToken;
        if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
          builder.addToken = buildTokenBadBidi(builder.addToken, order);
        }
        builder.map = [];
        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
        insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
        if (line.styleClasses) {
          if (line.styleClasses.bgClass) {
            builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
          }
          if (line.styleClasses.textClass) {
            builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
          }
        }
        if (builder.map.length == 0) {
          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
        }
        if (i2 == 0) {
          lineView.measure.map = builder.map;
          lineView.measure.cache = {};
        } else {
          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
          (lineView.measure.caches || (lineView.measure.caches = [])).push({});
        }
      }
      if (webkit) {
        var last = builder.content.lastChild;
        if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
          builder.content.className = "cm-tab-wrap-hack";
        }
      }
      signal(cm, "renderLine", cm, lineView.line, builder.pre);
      if (builder.pre.className) {
        builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
      }
      return builder;
    }
    function defaultSpecialCharPlaceholder(ch) {
      var token = elt("span", "\u2022", "cm-invalidchar");
      token.title = "\\u" + ch.charCodeAt(0).toString(16);
      token.setAttribute("aria-label", token.title);
      return token;
    }
    function buildToken(builder, text2, style, startStyle, endStyle, css2, attributes) {
      if (!text2) {
        return;
      }
      var displayText = builder.splitSpaces ? splitSpaces(text2, builder.trailingSpace) : text2;
      var special = builder.cm.state.specialChars, mustWrap = false;
      var content;
      if (!special.test(text2)) {
        builder.col += text2.length;
        content = document.createTextNode(displayText);
        builder.map.push(builder.pos, builder.pos + text2.length, content);
        if (ie && ie_version < 9) {
          mustWrap = true;
        }
        builder.pos += text2.length;
      } else {
        content = document.createDocumentFragment();
        var pos = 0;
        while (true) {
          special.lastIndex = pos;
          var m = special.exec(text2);
          var skipped = m ? m.index - pos : text2.length - pos;
          if (skipped) {
            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
            if (ie && ie_version < 9) {
              content.appendChild(elt("span", [txt]));
            } else {
              content.appendChild(txt);
            }
            builder.map.push(builder.pos, builder.pos + skipped, txt);
            builder.col += skipped;
            builder.pos += skipped;
          }
          if (!m) {
            break;
          }
          pos += skipped + 1;
          var txt$1 = void 0;
          if (m[0] == "	") {
            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
            txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
            txt$1.setAttribute("role", "presentation");
            txt$1.setAttribute("cm-text", "	");
            builder.col += tabWidth;
          } else if (m[0] == "\r" || m[0] == "\n") {
            txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
            txt$1.setAttribute("cm-text", m[0]);
            builder.col += 1;
          } else {
            txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
            txt$1.setAttribute("cm-text", m[0]);
            if (ie && ie_version < 9) {
              content.appendChild(elt("span", [txt$1]));
            } else {
              content.appendChild(txt$1);
            }
            builder.col += 1;
          }
          builder.map.push(builder.pos, builder.pos + 1, txt$1);
          builder.pos++;
        }
      }
      builder.trailingSpace = displayText.charCodeAt(text2.length - 1) == 32;
      if (style || startStyle || endStyle || mustWrap || css2 || attributes) {
        var fullStyle = style || "";
        if (startStyle) {
          fullStyle += startStyle;
        }
        if (endStyle) {
          fullStyle += endStyle;
        }
        var token = elt("span", [content], fullStyle, css2);
        if (attributes) {
          for (var attr2 in attributes) {
            if (attributes.hasOwnProperty(attr2) && attr2 != "style" && attr2 != "class") {
              token.setAttribute(attr2, attributes[attr2]);
            }
          }
        }
        return builder.content.appendChild(token);
      }
      builder.content.appendChild(content);
    }
    function splitSpaces(text2, trailingBefore) {
      if (text2.length > 1 && !/  /.test(text2)) {
        return text2;
      }
      var spaceBefore = trailingBefore, result = "";
      for (var i2 = 0; i2 < text2.length; i2++) {
        var ch = text2.charAt(i2);
        if (ch == " " && spaceBefore && (i2 == text2.length - 1 || text2.charCodeAt(i2 + 1) == 32)) {
          ch = "\xA0";
        }
        result += ch;
        spaceBefore = ch == " ";
      }
      return result;
    }
    function buildTokenBadBidi(inner, order) {
      return function(builder, text2, style, startStyle, endStyle, css2, attributes) {
        style = style ? style + " cm-force-border" : "cm-force-border";
        var start = builder.pos, end = start + text2.length;
        for (; ; ) {
          var part = void 0;
          for (var i2 = 0; i2 < order.length; i2++) {
            part = order[i2];
            if (part.to > start && part.from <= start) {
              break;
            }
          }
          if (part.to >= end) {
            return inner(builder, text2, style, startStyle, endStyle, css2, attributes);
          }
          inner(builder, text2.slice(0, part.to - start), style, startStyle, null, css2, attributes);
          startStyle = null;
          text2 = text2.slice(part.to - start);
          start = part.to;
        }
      };
    }
    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
      var widget = !ignoreWidget && marker.widgetNode;
      if (widget) {
        builder.map.push(builder.pos, builder.pos + size, widget);
      }
      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
        if (!widget) {
          widget = builder.content.appendChild(document.createElement("span"));
        }
        widget.setAttribute("cm-marker", marker.id);
      }
      if (widget) {
        builder.cm.display.input.setUneditable(widget);
        builder.content.appendChild(widget);
      }
      builder.pos += size;
      builder.trailingSpace = false;
    }
    function insertLineContent(line, builder, styles2) {
      var spans = line.markedSpans, allText = line.text, at = 0;
      if (!spans) {
        for (var i$12 = 1; i$12 < styles2.length; i$12 += 2) {
          builder.addToken(builder, allText.slice(at, at = styles2[i$12]), interpretTokenStyle(styles2[i$12 + 1], builder.cm.options));
        }
        return;
      }
      var len = allText.length, pos = 0, i2 = 1, text2 = "", style, css2;
      var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
      for (; ; ) {
        if (nextChange == pos) {
          spanStyle = spanEndStyle = spanStartStyle = css2 = "";
          attributes = null;
          collapsed = null;
          nextChange = Infinity;
          var foundBookmarks = [], endStyles = void 0;
          for (var j = 0; j < spans.length; ++j) {
            var sp = spans[j], m = sp.marker;
            if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
              foundBookmarks.push(m);
            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
              if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                nextChange = sp.to;
                spanEndStyle = "";
              }
              if (m.className) {
                spanStyle += " " + m.className;
              }
              if (m.css) {
                css2 = (css2 ? css2 + ";" : "") + m.css;
              }
              if (m.startStyle && sp.from == pos) {
                spanStartStyle += " " + m.startStyle;
              }
              if (m.endStyle && sp.to == nextChange) {
                (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
              }
              if (m.title) {
                (attributes || (attributes = {})).title = m.title;
              }
              if (m.attributes) {
                for (var attr2 in m.attributes) {
                  (attributes || (attributes = {}))[attr2] = m.attributes[attr2];
                }
              }
              if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
                collapsed = sp;
              }
            } else if (sp.from > pos && nextChange > sp.from) {
              nextChange = sp.from;
            }
          }
          if (endStyles) {
            for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
              if (endStyles[j$1 + 1] == nextChange) {
                spanEndStyle += " " + endStyles[j$1];
              }
            }
          }
          if (!collapsed || collapsed.from == pos) {
            for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
              buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
            }
          }
          if (collapsed && (collapsed.from || 0) == pos) {
            buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
            if (collapsed.to == null) {
              return;
            }
            if (collapsed.to == pos) {
              collapsed = false;
            }
          }
        }
        if (pos >= len) {
          break;
        }
        var upto = Math.min(len, nextChange);
        while (true) {
          if (text2) {
            var end = pos + text2.length;
            if (!collapsed) {
              var tokenText = end > upto ? text2.slice(0, upto - pos) : text2;
              builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css2, attributes);
            }
            if (end >= upto) {
              text2 = text2.slice(upto - pos);
              pos = upto;
              break;
            }
            pos = end;
            spanStartStyle = "";
          }
          text2 = allText.slice(at, at = styles2[i2++]);
          style = interpretTokenStyle(styles2[i2++], builder.cm.options);
        }
      }
    }
    function LineView(doc, line, lineN) {
      this.line = line;
      this.rest = visualLineContinued(line);
      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
      this.node = this.text = null;
      this.hidden = lineIsHidden(doc, line);
    }
    function buildViewArray(cm, from, to) {
      var array = [], nextPos;
      for (var pos = from; pos < to; pos = nextPos) {
        var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
        nextPos = pos + view.size;
        array.push(view);
      }
      return array;
    }
    var operationGroup = null;
    function pushOperation(op) {
      if (operationGroup) {
        operationGroup.ops.push(op);
      } else {
        op.ownsGroup = operationGroup = {
          ops: [op],
          delayedCallbacks: []
        };
      }
    }
    function fireCallbacksForOps(group) {
      var callbacks = group.delayedCallbacks, i2 = 0;
      do {
        for (; i2 < callbacks.length; i2++) {
          callbacks[i2].call(null);
        }
        for (var j = 0; j < group.ops.length; j++) {
          var op = group.ops[j];
          if (op.cursorActivityHandlers) {
            while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
              op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
            }
          }
        }
      } while (i2 < callbacks.length);
    }
    function finishOperation(op, endCb) {
      var group = op.ownsGroup;
      if (!group) {
        return;
      }
      try {
        fireCallbacksForOps(group);
      } finally {
        operationGroup = null;
        endCb(group);
      }
    }
    var orphanDelayedCallbacks = null;
    function signalLater(emitter, type) {
      var arr = getHandlers(emitter, type);
      if (!arr.length) {
        return;
      }
      var args = Array.prototype.slice.call(arguments, 2), list2;
      if (operationGroup) {
        list2 = operationGroup.delayedCallbacks;
      } else if (orphanDelayedCallbacks) {
        list2 = orphanDelayedCallbacks;
      } else {
        list2 = orphanDelayedCallbacks = [];
        setTimeout(fireOrphanDelayed, 0);
      }
      var loop = function(i3) {
        list2.push(function() {
          return arr[i3].apply(null, args);
        });
      };
      for (var i2 = 0; i2 < arr.length; ++i2)
        loop(i2);
    }
    function fireOrphanDelayed() {
      var delayed = orphanDelayedCallbacks;
      orphanDelayedCallbacks = null;
      for (var i2 = 0; i2 < delayed.length; ++i2) {
        delayed[i2]();
      }
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
      for (var j = 0; j < lineView.changes.length; j++) {
        var type = lineView.changes[j];
        if (type == "text") {
          updateLineText(cm, lineView);
        } else if (type == "gutter") {
          updateLineGutter(cm, lineView, lineN, dims);
        } else if (type == "class") {
          updateLineClasses(cm, lineView);
        } else if (type == "widget") {
          updateLineWidgets(cm, lineView, dims);
        }
      }
      lineView.changes = null;
    }
    function ensureLineWrapped(lineView) {
      if (lineView.node == lineView.text) {
        lineView.node = elt("div", null, null, "position: relative");
        if (lineView.text.parentNode) {
          lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
        }
        lineView.node.appendChild(lineView.text);
        if (ie && ie_version < 8) {
          lineView.node.style.zIndex = 2;
        }
      }
      return lineView.node;
    }
    function updateLineBackground(cm, lineView) {
      var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
      if (cls) {
        cls += " CodeMirror-linebackground";
      }
      if (lineView.background) {
        if (cls) {
          lineView.background.className = cls;
        } else {
          lineView.background.parentNode.removeChild(lineView.background);
          lineView.background = null;
        }
      } else if (cls) {
        var wrap2 = ensureLineWrapped(lineView);
        lineView.background = wrap2.insertBefore(elt("div", null, cls), wrap2.firstChild);
        cm.display.input.setUneditable(lineView.background);
      }
    }
    function getLineContent(cm, lineView) {
      var ext = cm.display.externalMeasured;
      if (ext && ext.line == lineView.line) {
        cm.display.externalMeasured = null;
        lineView.measure = ext.measure;
        return ext.built;
      }
      return buildLineContent(cm, lineView);
    }
    function updateLineText(cm, lineView) {
      var cls = lineView.text.className;
      var built = getLineContent(cm, lineView);
      if (lineView.text == lineView.node) {
        lineView.node = built.pre;
      }
      lineView.text.parentNode.replaceChild(built.pre, lineView.text);
      lineView.text = built.pre;
      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
        lineView.bgClass = built.bgClass;
        lineView.textClass = built.textClass;
        updateLineClasses(cm, lineView);
      } else if (cls) {
        lineView.text.className = cls;
      }
    }
    function updateLineClasses(cm, lineView) {
      updateLineBackground(cm, lineView);
      if (lineView.line.wrapClass) {
        ensureLineWrapped(lineView).className = lineView.line.wrapClass;
      } else if (lineView.node != lineView.text) {
        lineView.node.className = "";
      }
      var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
      lineView.text.className = textClass || "";
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
      if (lineView.gutter) {
        lineView.node.removeChild(lineView.gutter);
        lineView.gutter = null;
      }
      if (lineView.gutterBackground) {
        lineView.node.removeChild(lineView.gutterBackground);
        lineView.gutterBackground = null;
      }
      if (lineView.line.gutterClass) {
        var wrap2 = ensureLineWrapped(lineView);
        lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
        cm.display.input.setUneditable(lineView.gutterBackground);
        wrap2.insertBefore(lineView.gutterBackground, lineView.text);
      }
      var markers = lineView.line.gutterMarkers;
      if (cm.options.lineNumbers || markers) {
        var wrap$1 = ensureLineWrapped(lineView);
        var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
        gutterWrap.setAttribute("aria-hidden", "true");
        cm.display.input.setUneditable(gutterWrap);
        wrap$1.insertBefore(gutterWrap, lineView.text);
        if (lineView.line.gutterClass) {
          gutterWrap.className += " " + lineView.line.gutterClass;
        }
        if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
          lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
        }
        if (markers) {
          for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
            var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
            if (found) {
              gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
            }
          }
        }
      }
    }
    function updateLineWidgets(cm, lineView, dims) {
      if (lineView.alignable) {
        lineView.alignable = null;
      }
      var isWidget = classTest("CodeMirror-linewidget");
      for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
        next = node.nextSibling;
        if (isWidget.test(node.className)) {
          lineView.node.removeChild(node);
        }
      }
      insertLineWidgets(cm, lineView, dims);
    }
    function buildLineElement(cm, lineView, lineN, dims) {
      var built = getLineContent(cm, lineView);
      lineView.text = lineView.node = built.pre;
      if (built.bgClass) {
        lineView.bgClass = built.bgClass;
      }
      if (built.textClass) {
        lineView.textClass = built.textClass;
      }
      updateLineClasses(cm, lineView);
      updateLineGutter(cm, lineView, lineN, dims);
      insertLineWidgets(cm, lineView, dims);
      return lineView.node;
    }
    function insertLineWidgets(cm, lineView, dims) {
      insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
      if (lineView.rest) {
        for (var i2 = 0; i2 < lineView.rest.length; i2++) {
          insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
        }
      }
    }
    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
      if (!line.widgets) {
        return;
      }
      var wrap2 = ensureLineWrapped(lineView);
      for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
        var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
        if (!widget.handleMouseEvents) {
          node.setAttribute("cm-ignore-events", "true");
        }
        positionLineWidget(widget, node, lineView, dims);
        cm.display.input.setUneditable(node);
        if (allowAbove && widget.above) {
          wrap2.insertBefore(node, lineView.gutter || lineView.text);
        } else {
          wrap2.appendChild(node);
        }
        signalLater(widget, "redraw");
      }
    }
    function positionLineWidget(widget, node, lineView, dims) {
      if (widget.noHScroll) {
        (lineView.alignable || (lineView.alignable = [])).push(node);
        var width = dims.wrapperWidth;
        node.style.left = dims.fixedPos + "px";
        if (!widget.coverGutter) {
          width -= dims.gutterTotalWidth;
          node.style.paddingLeft = dims.gutterTotalWidth + "px";
        }
        node.style.width = width + "px";
      }
      if (widget.coverGutter) {
        node.style.zIndex = 5;
        node.style.position = "relative";
        if (!widget.noHScroll) {
          node.style.marginLeft = -dims.gutterTotalWidth + "px";
        }
      }
    }
    function widgetHeight(widget) {
      if (widget.height != null) {
        return widget.height;
      }
      var cm = widget.doc.cm;
      if (!cm) {
        return 0;
      }
      if (!contains(document.body, widget.node)) {
        var parentStyle = "position: relative;";
        if (widget.coverGutter) {
          parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
        }
        if (widget.noHScroll) {
          parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
        }
        removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
      }
      return widget.height = widget.node.parentNode.offsetHeight;
    }
    function eventInWidget(display, e) {
      for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
        if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
          return true;
        }
      }
    }
    function paddingTop(display) {
      return display.lineSpace.offsetTop;
    }
    function paddingVert(display) {
      return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH(display) {
      if (display.cachedPaddingH) {
        return display.cachedPaddingH;
      }
      var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
      var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
      var data3 = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
      if (!isNaN(data3.left) && !isNaN(data3.right)) {
        display.cachedPaddingH = data3;
      }
      return data3;
    }
    function scrollGap(cm) {
      return scrollerGap - cm.display.nativeBarWidth;
    }
    function displayWidth(cm) {
      return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
    }
    function displayHeight(cm) {
      return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
    }
    function ensureLineHeights(cm, lineView, rect) {
      var wrapping = cm.options.lineWrapping;
      var curWidth = wrapping && displayWidth(cm);
      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
        var heights = lineView.measure.heights = [];
        if (wrapping) {
          lineView.measure.width = curWidth;
          var rects = lineView.text.firstChild.getClientRects();
          for (var i2 = 0; i2 < rects.length - 1; i2++) {
            var cur = rects[i2], next = rects[i2 + 1];
            if (Math.abs(cur.bottom - next.bottom) > 2) {
              heights.push((cur.bottom + next.top) / 2 - rect.top);
            }
          }
        }
        heights.push(rect.bottom - rect.top);
      }
    }
    function mapFromLineView(lineView, line, lineN) {
      if (lineView.line == line) {
        return {map: lineView.measure.map, cache: lineView.measure.cache};
      }
      if (lineView.rest) {
        for (var i2 = 0; i2 < lineView.rest.length; i2++) {
          if (lineView.rest[i2] == line) {
            return {map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2]};
          }
        }
        for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
          if (lineNo(lineView.rest[i$12]) > lineN) {
            return {map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true};
          }
        }
      }
    }
    function updateExternalMeasurement(cm, line) {
      line = visualLine(line);
      var lineN = lineNo(line);
      var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
      view.lineN = lineN;
      var built = view.built = buildLineContent(cm, view);
      view.text = built.pre;
      removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
      return view;
    }
    function measureChar(cm, line, ch, bias) {
      return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
    }
    function findViewForLine(cm, lineN) {
      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
        return cm.display.view[findViewIndex(cm, lineN)];
      }
      var ext = cm.display.externalMeasured;
      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
        return ext;
      }
    }
    function prepareMeasureForLine(cm, line) {
      var lineN = lineNo(line);
      var view = findViewForLine(cm, lineN);
      if (view && !view.text) {
        view = null;
      } else if (view && view.changes) {
        updateLineForChanges(cm, view, lineN, getDimensions(cm));
        cm.curOp.forceUpdate = true;
      }
      if (!view) {
        view = updateExternalMeasurement(cm, line);
      }
      var info = mapFromLineView(view, line, lineN);
      return {
        line,
        view,
        rect: null,
        map: info.map,
        cache: info.cache,
        before: info.before,
        hasHeights: false
      };
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
      if (prepared.before) {
        ch = -1;
      }
      var key = ch + (bias || ""), found;
      if (prepared.cache.hasOwnProperty(key)) {
        found = prepared.cache[key];
      } else {
        if (!prepared.rect) {
          prepared.rect = prepared.view.text.getBoundingClientRect();
        }
        if (!prepared.hasHeights) {
          ensureLineHeights(cm, prepared.view, prepared.rect);
          prepared.hasHeights = true;
        }
        found = measureCharInner(cm, prepared, ch, bias);
        if (!found.bogus) {
          prepared.cache[key] = found;
        }
      }
      return {
        left: found.left,
        right: found.right,
        top: varHeight ? found.rtop : found.top,
        bottom: varHeight ? found.rbottom : found.bottom
      };
    }
    var nullRect = {left: 0, right: 0, top: 0, bottom: 0};
    function nodeAndOffsetInLineMap(map3, ch, bias) {
      var node, start, end, collapse, mStart, mEnd;
      for (var i2 = 0; i2 < map3.length; i2 += 3) {
        mStart = map3[i2];
        mEnd = map3[i2 + 1];
        if (ch < mStart) {
          start = 0;
          end = 1;
          collapse = "left";
        } else if (ch < mEnd) {
          start = ch - mStart;
          end = start + 1;
        } else if (i2 == map3.length - 3 || ch == mEnd && map3[i2 + 3] > ch) {
          end = mEnd - mStart;
          start = end - 1;
          if (ch >= mEnd) {
            collapse = "right";
          }
        }
        if (start != null) {
          node = map3[i2 + 2];
          if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
            collapse = bias;
          }
          if (bias == "left" && start == 0) {
            while (i2 && map3[i2 - 2] == map3[i2 - 3] && map3[i2 - 1].insertLeft) {
              node = map3[(i2 -= 3) + 2];
              collapse = "left";
            }
          }
          if (bias == "right" && start == mEnd - mStart) {
            while (i2 < map3.length - 3 && map3[i2 + 3] == map3[i2 + 4] && !map3[i2 + 5].insertLeft) {
              node = map3[(i2 += 3) + 2];
              collapse = "right";
            }
          }
          break;
        }
      }
      return {node, start, end, collapse, coverStart: mStart, coverEnd: mEnd};
    }
    function getUsefulRect(rects, bias) {
      var rect = nullRect;
      if (bias == "left") {
        for (var i2 = 0; i2 < rects.length; i2++) {
          if ((rect = rects[i2]).left != rect.right) {
            break;
          }
        }
      } else {
        for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
          if ((rect = rects[i$12]).left != rect.right) {
            break;
          }
        }
      }
      return rect;
    }
    function measureCharInner(cm, prepared, ch, bias) {
      var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
      var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
      var rect;
      if (node.nodeType == 3) {
        for (var i$12 = 0; i$12 < 4; i$12++) {
          while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
            --start;
          }
          while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
            ++end;
          }
          if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
            rect = node.parentNode.getBoundingClientRect();
          } else {
            rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
          }
          if (rect.left || rect.right || start == 0) {
            break;
          }
          end = start;
          start = start - 1;
          collapse = "right";
        }
        if (ie && ie_version < 11) {
          rect = maybeUpdateRectForZooming(cm.display.measure, rect);
        }
      } else {
        if (start > 0) {
          collapse = bias = "right";
        }
        var rects;
        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
          rect = rects[bias == "right" ? rects.length - 1 : 0];
        } else {
          rect = node.getBoundingClientRect();
        }
      }
      if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
        var rSpan = node.parentNode.getClientRects()[0];
        if (rSpan) {
          rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
        } else {
          rect = nullRect;
        }
      }
      var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
      var mid = (rtop + rbot) / 2;
      var heights = prepared.view.measure.heights;
      var i2 = 0;
      for (; i2 < heights.length - 1; i2++) {
        if (mid < heights[i2]) {
          break;
        }
      }
      var top = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
      var result = {
        left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
        right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
        top,
        bottom: bot
      };
      if (!rect.left && !rect.right) {
        result.bogus = true;
      }
      if (!cm.options.singleCursorHeightPerLine) {
        result.rtop = rtop;
        result.rbottom = rbot;
      }
      return result;
    }
    function maybeUpdateRectForZooming(measure, rect) {
      if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
        return rect;
      }
      var scaleX = screen.logicalXDPI / screen.deviceXDPI;
      var scaleY = screen.logicalYDPI / screen.deviceYDPI;
      return {
        left: rect.left * scaleX,
        right: rect.right * scaleX,
        top: rect.top * scaleY,
        bottom: rect.bottom * scaleY
      };
    }
    function clearLineMeasurementCacheFor(lineView) {
      if (lineView.measure) {
        lineView.measure.cache = {};
        lineView.measure.heights = null;
        if (lineView.rest) {
          for (var i2 = 0; i2 < lineView.rest.length; i2++) {
            lineView.measure.caches[i2] = {};
          }
        }
      }
    }
    function clearLineMeasurementCache(cm) {
      cm.display.externalMeasure = null;
      removeChildren(cm.display.lineMeasure);
      for (var i2 = 0; i2 < cm.display.view.length; i2++) {
        clearLineMeasurementCacheFor(cm.display.view[i2]);
      }
    }
    function clearCaches(cm) {
      clearLineMeasurementCache(cm);
      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
      if (!cm.options.lineWrapping) {
        cm.display.maxLineChanged = true;
      }
      cm.display.lineNumChars = null;
    }
    function pageScrollX() {
      if (chrome2 && android) {
        return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
      }
      return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY() {
      if (chrome2 && android) {
        return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
      }
      return window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function widgetTopHeight(lineObj) {
      var ref = visualLine(lineObj);
      var widgets = ref.widgets;
      var height = 0;
      if (widgets) {
        for (var i2 = 0; i2 < widgets.length; ++i2) {
          if (widgets[i2].above) {
            height += widgetHeight(widgets[i2]);
          }
        }
      }
      return height;
    }
    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
      if (!includeWidgets) {
        var height = widgetTopHeight(lineObj);
        rect.top += height;
        rect.bottom += height;
      }
      if (context == "line") {
        return rect;
      }
      if (!context) {
        context = "local";
      }
      var yOff = heightAtLine(lineObj);
      if (context == "local") {
        yOff += paddingTop(cm.display);
      } else {
        yOff -= cm.display.viewOffset;
      }
      if (context == "page" || context == "window") {
        var lOff = cm.display.lineSpace.getBoundingClientRect();
        yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
        var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
        rect.left += xOff;
        rect.right += xOff;
      }
      rect.top += yOff;
      rect.bottom += yOff;
      return rect;
    }
    function fromCoordSystem(cm, coords, context) {
      if (context == "div") {
        return coords;
      }
      var left = coords.left, top = coords.top;
      if (context == "page") {
        left -= pageScrollX();
        top -= pageScrollY();
      } else if (context == "local" || !context) {
        var localBox = cm.display.sizer.getBoundingClientRect();
        left += localBox.left;
        top += localBox.top;
      }
      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
      return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
    }
    function charCoords(cm, pos, context, lineObj, bias) {
      if (!lineObj) {
        lineObj = getLine(cm.doc, pos.line);
      }
      return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
      lineObj = lineObj || getLine(cm.doc, pos.line);
      if (!preparedMeasure) {
        preparedMeasure = prepareMeasureForLine(cm, lineObj);
      }
      function get(ch2, right) {
        var m = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);
        if (right) {
          m.left = m.right;
        } else {
          m.right = m.left;
        }
        return intoCoordSystem(cm, lineObj, m, context);
      }
      var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
      if (ch >= lineObj.text.length) {
        ch = lineObj.text.length;
        sticky = "before";
      } else if (ch <= 0) {
        ch = 0;
        sticky = "after";
      }
      if (!order) {
        return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
      }
      function getBidi(ch2, partPos2, invert) {
        var part = order[partPos2], right = part.level == 1;
        return get(invert ? ch2 - 1 : ch2, right != invert);
      }
      var partPos = getBidiPartAt(order, ch, sticky);
      var other = bidiOther;
      var val = getBidi(ch, partPos, sticky == "before");
      if (other != null) {
        val.other = getBidi(ch, other, sticky != "before");
      }
      return val;
    }
    function estimateCoords(cm, pos) {
      var left = 0;
      pos = clipPos(cm.doc, pos);
      if (!cm.options.lineWrapping) {
        left = charWidth(cm.display) * pos.ch;
      }
      var lineObj = getLine(cm.doc, pos.line);
      var top = heightAtLine(lineObj) + paddingTop(cm.display);
      return {left, right: left, top, bottom: top + lineObj.height};
    }
    function PosWithInfo(line, ch, sticky, outside, xRel) {
      var pos = Pos(line, ch, sticky);
      pos.xRel = xRel;
      if (outside) {
        pos.outside = outside;
      }
      return pos;
    }
    function coordsChar(cm, x, y) {
      var doc = cm.doc;
      y += cm.display.viewOffset;
      if (y < 0) {
        return PosWithInfo(doc.first, 0, null, -1, -1);
      }
      var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
      if (lineN > last) {
        return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
      }
      if (x < 0) {
        x = 0;
      }
      var lineObj = getLine(doc, lineN);
      for (; ; ) {
        var found = coordsCharInner(cm, lineObj, lineN, x, y);
        var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
        if (!collapsed) {
          return found;
        }
        var rangeEnd = collapsed.find(1);
        if (rangeEnd.line == lineN) {
          return rangeEnd;
        }
        lineObj = getLine(doc, lineN = rangeEnd.line);
      }
    }
    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
      y -= widgetTopHeight(lineObj);
      var end = lineObj.text.length;
      var begin = findFirst(function(ch) {
        return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
      }, end, 0);
      end = findFirst(function(ch) {
        return measureCharPrepared(cm, preparedMeasure, ch).top > y;
      }, begin, end);
      return {begin, end};
    }
    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
      if (!preparedMeasure) {
        preparedMeasure = prepareMeasureForLine(cm, lineObj);
      }
      var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
      return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
    }
    function boxIsAfter(box, x, y, left) {
      return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
    }
    function coordsCharInner(cm, lineObj, lineNo2, x, y) {
      y -= heightAtLine(lineObj);
      var preparedMeasure = prepareMeasureForLine(cm, lineObj);
      var widgetHeight2 = widgetTopHeight(lineObj);
      var begin = 0, end = lineObj.text.length, ltr = true;
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y);
        ltr = part.level != 1;
        begin = ltr ? part.from : part.to - 1;
        end = ltr ? part.to : part.from - 1;
      }
      var chAround = null, boxAround = null;
      var ch = findFirst(function(ch2) {
        var box = measureCharPrepared(cm, preparedMeasure, ch2);
        box.top += widgetHeight2;
        box.bottom += widgetHeight2;
        if (!boxIsAfter(box, x, y, false)) {
          return false;
        }
        if (box.top <= y && box.left <= x) {
          chAround = ch2;
          boxAround = box;
        }
        return true;
      }, begin, end);
      var baseX, sticky, outside = false;
      if (boxAround) {
        var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
        ch = chAround + (atStart ? 0 : 1);
        sticky = atStart ? "after" : "before";
        baseX = atLeft ? boxAround.left : boxAround.right;
      } else {
        if (!ltr && (ch == end || ch == begin)) {
          ch++;
        }
        sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
        var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
        baseX = coords.left;
        outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
      }
      ch = skipExtendingChars(lineObj.text, ch, 1);
      return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);
    }
    function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y) {
      var index2 = findFirst(function(i2) {
        var part2 = order[i2], ltr2 = part2.level != 1;
        return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
      }, 0, order.length - 1);
      var part = order[index2];
      if (index2 > 0) {
        var ltr = part.level != 1;
        var start = cursorCoords(cm, Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
        if (boxIsAfter(start, x, y, true) && start.top > y) {
          part = order[index2 - 1];
        }
      }
      return part;
    }
    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
      var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
      var begin = ref.begin;
      var end = ref.end;
      if (/\s/.test(lineObj.text.charAt(end - 1))) {
        end--;
      }
      var part = null, closestDist = null;
      for (var i2 = 0; i2 < order.length; i2++) {
        var p = order[i2];
        if (p.from >= end || p.to <= begin) {
          continue;
        }
        var ltr = p.level != 1;
        var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
        var dist = endX < x ? x - endX + 1e9 : endX - x;
        if (!part || closestDist > dist) {
          part = p;
          closestDist = dist;
        }
      }
      if (!part) {
        part = order[order.length - 1];
      }
      if (part.from < begin) {
        part = {from: begin, to: part.to, level: part.level};
      }
      if (part.to > end) {
        part = {from: part.from, to: end, level: part.level};
      }
      return part;
    }
    var measureText;
    function textHeight(display) {
      if (display.cachedTextHeight != null) {
        return display.cachedTextHeight;
      }
      if (measureText == null) {
        measureText = elt("pre", null, "CodeMirror-line-like");
        for (var i2 = 0; i2 < 49; ++i2) {
          measureText.appendChild(document.createTextNode("x"));
          measureText.appendChild(elt("br"));
        }
        measureText.appendChild(document.createTextNode("x"));
      }
      removeChildrenAndAdd(display.measure, measureText);
      var height = measureText.offsetHeight / 50;
      if (height > 3) {
        display.cachedTextHeight = height;
      }
      removeChildren(display.measure);
      return height || 1;
    }
    function charWidth(display) {
      if (display.cachedCharWidth != null) {
        return display.cachedCharWidth;
      }
      var anchor = elt("span", "xxxxxxxxxx");
      var pre = elt("pre", [anchor], "CodeMirror-line-like");
      removeChildrenAndAdd(display.measure, pre);
      var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
      if (width > 2) {
        display.cachedCharWidth = width;
      }
      return width || 10;
    }
    function getDimensions(cm) {
      var d = cm.display, left = {}, width = {};
      var gutterLeft = d.gutters.clientLeft;
      for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
        var id = cm.display.gutterSpecs[i2].className;
        left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
        width[id] = n.clientWidth;
      }
      return {
        fixedPos: compensateForHScroll(d),
        gutterTotalWidth: d.gutters.offsetWidth,
        gutterLeft: left,
        gutterWidth: width,
        wrapperWidth: d.wrapper.clientWidth
      };
    }
    function compensateForHScroll(display) {
      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function estimateHeight(cm) {
      var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
      return function(line) {
        if (lineIsHidden(cm.doc, line)) {
          return 0;
        }
        var widgetsHeight = 0;
        if (line.widgets) {
          for (var i2 = 0; i2 < line.widgets.length; i2++) {
            if (line.widgets[i2].height) {
              widgetsHeight += line.widgets[i2].height;
            }
          }
        }
        if (wrapping) {
          return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
        } else {
          return widgetsHeight + th;
        }
      };
    }
    function estimateLineHeights(cm) {
      var doc = cm.doc, est = estimateHeight(cm);
      doc.iter(function(line) {
        var estHeight = est(line);
        if (estHeight != line.height) {
          updateLineHeight(line, estHeight);
        }
      });
    }
    function posFromMouse(cm, e, liberal, forRect) {
      var display = cm.display;
      if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
        return null;
      }
      var x, y, space = display.lineSpace.getBoundingClientRect();
      try {
        x = e.clientX - space.left;
        y = e.clientY - space.top;
      } catch (e$1) {
        return null;
      }
      var coords = coordsChar(cm, x, y), line;
      if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
        var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
        coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
      }
      return coords;
    }
    function findViewIndex(cm, n) {
      if (n >= cm.display.viewTo) {
        return null;
      }
      n -= cm.display.viewFrom;
      if (n < 0) {
        return null;
      }
      var view = cm.display.view;
      for (var i2 = 0; i2 < view.length; i2++) {
        n -= view[i2].size;
        if (n < 0) {
          return i2;
        }
      }
    }
    function regChange(cm, from, to, lendiff) {
      if (from == null) {
        from = cm.doc.first;
      }
      if (to == null) {
        to = cm.doc.first + cm.doc.size;
      }
      if (!lendiff) {
        lendiff = 0;
      }
      var display = cm.display;
      if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
        display.updateLineNumbers = from;
      }
      cm.curOp.viewChanged = true;
      if (from >= display.viewTo) {
        if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
          resetView(cm);
        }
      } else if (to <= display.viewFrom) {
        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
          resetView(cm);
        } else {
          display.viewFrom += lendiff;
          display.viewTo += lendiff;
        }
      } else if (from <= display.viewFrom && to >= display.viewTo) {
        resetView(cm);
      } else if (from <= display.viewFrom) {
        var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
        if (cut) {
          display.view = display.view.slice(cut.index);
          display.viewFrom = cut.lineN;
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      } else if (to >= display.viewTo) {
        var cut$1 = viewCuttingPoint(cm, from, from, -1);
        if (cut$1) {
          display.view = display.view.slice(0, cut$1.index);
          display.viewTo = cut$1.lineN;
        } else {
          resetView(cm);
        }
      } else {
        var cutTop = viewCuttingPoint(cm, from, from, -1);
        var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
        if (cutTop && cutBot) {
          display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      }
      var ext = display.externalMeasured;
      if (ext) {
        if (to < ext.lineN) {
          ext.lineN += lendiff;
        } else if (from < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }
      }
    }
    function regLineChange(cm, line, type) {
      cm.curOp.viewChanged = true;
      var display = cm.display, ext = cm.display.externalMeasured;
      if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
      if (line < display.viewFrom || line >= display.viewTo) {
        return;
      }
      var lineView = display.view[findViewIndex(cm, line)];
      if (lineView.node == null) {
        return;
      }
      var arr = lineView.changes || (lineView.changes = []);
      if (indexOf(arr, type) == -1) {
        arr.push(type);
      }
    }
    function resetView(cm) {
      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
      cm.display.view = [];
      cm.display.viewOffset = 0;
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
      var index2 = findViewIndex(cm, oldN), diff, view = cm.display.view;
      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
        return {index: index2, lineN: newN};
      }
      var n = cm.display.viewFrom;
      for (var i2 = 0; i2 < index2; i2++) {
        n += view[i2].size;
      }
      if (n != oldN) {
        if (dir > 0) {
          if (index2 == view.length - 1) {
            return null;
          }
          diff = n + view[index2].size - oldN;
          index2++;
        } else {
          diff = n - oldN;
        }
        oldN += diff;
        newN += diff;
      }
      while (visualLineNo(cm.doc, newN) != newN) {
        if (index2 == (dir < 0 ? 0 : view.length - 1)) {
          return null;
        }
        newN += dir * view[index2 - (dir < 0 ? 1 : 0)].size;
        index2 += dir;
      }
      return {index: index2, lineN: newN};
    }
    function adjustView(cm, from, to) {
      var display = cm.display, view = display.view;
      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
        display.view = buildViewArray(cm, from, to);
        display.viewFrom = from;
      } else {
        if (display.viewFrom > from) {
          display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
        } else if (display.viewFrom < from) {
          display.view = display.view.slice(findViewIndex(cm, from));
        }
        display.viewFrom = from;
        if (display.viewTo < to) {
          display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
        } else if (display.viewTo > to) {
          display.view = display.view.slice(0, findViewIndex(cm, to));
        }
      }
      display.viewTo = to;
    }
    function countDirtyView(cm) {
      var view = cm.display.view, dirty = 0;
      for (var i2 = 0; i2 < view.length; i2++) {
        var lineView = view[i2];
        if (!lineView.hidden && (!lineView.node || lineView.changes)) {
          ++dirty;
        }
      }
      return dirty;
    }
    function updateSelection(cm) {
      cm.display.input.showSelection(cm.display.input.prepareSelection());
    }
    function prepareSelection(cm, primary) {
      if (primary === void 0)
        primary = true;
      var doc = cm.doc, result = {};
      var curFragment = result.cursors = document.createDocumentFragment();
      var selFragment = result.selection = document.createDocumentFragment();
      var customCursor = cm.options.$customCursor;
      if (customCursor) {
        primary = true;
      }
      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
        if (!primary && i2 == doc.sel.primIndex) {
          continue;
        }
        var range2 = doc.sel.ranges[i2];
        if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
          continue;
        }
        var collapsed = range2.empty();
        if (customCursor) {
          var head = customCursor(cm, range2);
          if (head) {
            drawSelectionCursor(cm, head, curFragment);
          }
        } else if (collapsed || cm.options.showCursorWhenSelecting) {
          drawSelectionCursor(cm, range2.head, curFragment);
        }
        if (!collapsed) {
          drawSelectionRange(cm, range2, selFragment);
        }
      }
      return result;
    }
    function drawSelectionCursor(cm, head, output) {
      var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
      var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
      cursor.style.left = pos.left + "px";
      cursor.style.top = pos.top + "px";
      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
      if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
        var charPos = charCoords(cm, head, "div", null, null);
        var width = charPos.right - charPos.left;
        cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
      }
      if (pos.other) {
        var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
        otherCursor.style.display = "";
        otherCursor.style.left = pos.other.left + "px";
        otherCursor.style.top = pos.other.top + "px";
        otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
      }
    }
    function cmpCoords(a, b) {
      return a.top - b.top || a.left - b.left;
    }
    function drawSelectionRange(cm, range2, output) {
      var display = cm.display, doc = cm.doc;
      var fragment = document.createDocumentFragment();
      var padding = paddingH(cm.display), leftSide = padding.left;
      var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
      var docLTR = doc.direction == "ltr";
      function add(left, top, width, bottom) {
        if (top < 0) {
          top = 0;
        }
        top = Math.round(top);
        bottom = Math.round(bottom);
        fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
      }
      function drawForLine(line, fromArg, toArg) {
        var lineObj = getLine(doc, line);
        var lineLen = lineObj.text.length;
        var start, end;
        function coords(ch, bias) {
          return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
        }
        function wrapX(pos, dir, side) {
          var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
          var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
          var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
          return coords(ch, prop2)[prop2];
        }
        var order = getOrder(lineObj, doc.direction);
        iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {
          var ltr = dir == "ltr";
          var fromPos = coords(from, ltr ? "left" : "right");
          var toPos = coords(to - 1, ltr ? "right" : "left");
          var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
          var first = i2 == 0, last = !order || i2 == order.length - 1;
          if (toPos.top - fromPos.top <= 3) {
            var openLeft = (docLTR ? openStart : openEnd) && first;
            var openRight = (docLTR ? openEnd : openStart) && last;
            var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
            var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
            add(left, fromPos.top, right - left, fromPos.bottom);
          } else {
            var topLeft, topRight, botLeft, botRight;
            if (ltr) {
              topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
              topRight = docLTR ? rightSide : wrapX(from, dir, "before");
              botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
              botRight = docLTR && openEnd && last ? rightSide : toPos.right;
            } else {
              topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
              topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
              botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
              botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
            }
            add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
            if (fromPos.bottom < toPos.top) {
              add(leftSide, fromPos.bottom, null, toPos.top);
            }
            add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
          }
          if (!start || cmpCoords(fromPos, start) < 0) {
            start = fromPos;
          }
          if (cmpCoords(toPos, start) < 0) {
            start = toPos;
          }
          if (!end || cmpCoords(fromPos, end) < 0) {
            end = fromPos;
          }
          if (cmpCoords(toPos, end) < 0) {
            end = toPos;
          }
        });
        return {start, end};
      }
      var sFrom = range2.from(), sTo = range2.to();
      if (sFrom.line == sTo.line) {
        drawForLine(sFrom.line, sFrom.ch, sTo.ch);
      } else {
        var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
        var singleVLine = visualLine(fromLine) == visualLine(toLine);
        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
        if (singleVLine) {
          if (leftEnd.top < rightStart.top - 2) {
            add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
          } else {
            add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
          }
        }
        if (leftEnd.bottom < rightStart.top) {
          add(leftSide, leftEnd.bottom, null, rightStart.top);
        }
      }
      output.appendChild(fragment);
    }
    function restartBlink(cm) {
      if (!cm.state.focused) {
        return;
      }
      var display = cm.display;
      clearInterval(display.blinker);
      var on4 = true;
      display.cursorDiv.style.visibility = "";
      if (cm.options.cursorBlinkRate > 0) {
        display.blinker = setInterval(function() {
          if (!cm.hasFocus()) {
            onBlur(cm);
          }
          display.cursorDiv.style.visibility = (on4 = !on4) ? "" : "hidden";
        }, cm.options.cursorBlinkRate);
      } else if (cm.options.cursorBlinkRate < 0) {
        display.cursorDiv.style.visibility = "hidden";
      }
    }
    function ensureFocus(cm) {
      if (!cm.hasFocus()) {
        cm.display.input.focus();
        if (!cm.state.focused) {
          onFocus(cm);
        }
      }
    }
    function delayBlurEvent(cm) {
      cm.state.delayingBlurEvent = true;
      setTimeout(function() {
        if (cm.state.delayingBlurEvent) {
          cm.state.delayingBlurEvent = false;
          if (cm.state.focused) {
            onBlur(cm);
          }
        }
      }, 100);
    }
    function onFocus(cm, e) {
      if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
        cm.state.delayingBlurEvent = false;
      }
      if (cm.options.readOnly == "nocursor") {
        return;
      }
      if (!cm.state.focused) {
        signal(cm, "focus", cm, e);
        cm.state.focused = true;
        addClass(cm.display.wrapper, "CodeMirror-focused");
        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
          cm.display.input.reset();
          if (webkit) {
            setTimeout(function() {
              return cm.display.input.reset(true);
            }, 20);
          }
        }
        cm.display.input.receivedFocus();
      }
      restartBlink(cm);
    }
    function onBlur(cm, e) {
      if (cm.state.delayingBlurEvent) {
        return;
      }
      if (cm.state.focused) {
        signal(cm, "blur", cm, e);
        cm.state.focused = false;
        rmClass(cm.display.wrapper, "CodeMirror-focused");
      }
      clearInterval(cm.display.blinker);
      setTimeout(function() {
        if (!cm.state.focused) {
          cm.display.shift = false;
        }
      }, 150);
    }
    function updateHeightsInViewport(cm) {
      var display = cm.display;
      var prevBottom = display.lineDiv.offsetTop;
      var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
      var oldHeight = display.lineDiv.getBoundingClientRect().top;
      var mustScroll = 0;
      for (var i2 = 0; i2 < display.view.length; i2++) {
        var cur = display.view[i2], wrapping = cm.options.lineWrapping;
        var height = void 0, width = 0;
        if (cur.hidden) {
          continue;
        }
        oldHeight += cur.line.height;
        if (ie && ie_version < 8) {
          var bot = cur.node.offsetTop + cur.node.offsetHeight;
          height = bot - prevBottom;
          prevBottom = bot;
        } else {
          var box = cur.node.getBoundingClientRect();
          height = box.bottom - box.top;
          if (!wrapping && cur.text.firstChild) {
            width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
          }
        }
        var diff = cur.line.height - height;
        if (diff > 5e-3 || diff < -5e-3) {
          if (oldHeight < viewTop) {
            mustScroll -= diff;
          }
          updateLineHeight(cur.line, height);
          updateWidgetHeight(cur.line);
          if (cur.rest) {
            for (var j = 0; j < cur.rest.length; j++) {
              updateWidgetHeight(cur.rest[j]);
            }
          }
        }
        if (width > cm.display.sizerWidth) {
          var chWidth = Math.ceil(width / charWidth(cm.display));
          if (chWidth > cm.display.maxLineLength) {
            cm.display.maxLineLength = chWidth;
            cm.display.maxLine = cur.line;
            cm.display.maxLineChanged = true;
          }
        }
      }
      if (Math.abs(mustScroll) > 2) {
        display.scroller.scrollTop += mustScroll;
      }
    }
    function updateWidgetHeight(line) {
      if (line.widgets) {
        for (var i2 = 0; i2 < line.widgets.length; ++i2) {
          var w = line.widgets[i2], parent = w.node.parentNode;
          if (parent) {
            w.height = parent.offsetHeight;
          }
        }
      }
    }
    function visibleLines(display, doc, viewport) {
      var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
      top = Math.floor(top - paddingTop(display));
      var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
      var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
      if (viewport && viewport.ensure) {
        var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
        if (ensureFrom < from) {
          from = ensureFrom;
          to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
        } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
          from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
          to = ensureTo;
        }
      }
      return {from, to: Math.max(to, from + 1)};
    }
    function maybeScrollWindow(cm, rect) {
      if (signalDOMEvent(cm, "scrollCursorIntoView")) {
        return;
      }
      var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
      if (rect.top + box.top < 0) {
        doScroll = true;
      } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
        doScroll = false;
      }
      if (doScroll != null && !phantom) {
        var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
        cm.display.lineSpace.appendChild(scrollNode);
        scrollNode.scrollIntoView(doScroll);
        cm.display.lineSpace.removeChild(scrollNode);
      }
    }
    function scrollPosIntoView(cm, pos, end, margin) {
      if (margin == null) {
        margin = 0;
      }
      var rect;
      if (!cm.options.lineWrapping && pos == end) {
        end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
        pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      }
      for (var limit2 = 0; limit2 < 5; limit2++) {
        var changed = false;
        var coords = cursorCoords(cm, pos);
        var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
        rect = {
          left: Math.min(coords.left, endCoords.left),
          top: Math.min(coords.top, endCoords.top) - margin,
          right: Math.max(coords.left, endCoords.left),
          bottom: Math.max(coords.bottom, endCoords.bottom) + margin
        };
        var scrollPos = calculateScrollPos(cm, rect);
        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
        if (scrollPos.scrollTop != null) {
          updateScrollTop(cm, scrollPos.scrollTop);
          if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
            changed = true;
          }
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
            changed = true;
          }
        }
        if (!changed) {
          break;
        }
      }
      return rect;
    }
    function scrollIntoView(cm, rect) {
      var scrollPos = calculateScrollPos(cm, rect);
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
      }
    }
    function calculateScrollPos(cm, rect) {
      var display = cm.display, snapMargin = textHeight(cm.display);
      if (rect.top < 0) {
        rect.top = 0;
      }
      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
      var screen2 = displayHeight(cm), result = {};
      if (rect.bottom - rect.top > screen2) {
        rect.bottom = rect.top + screen2;
      }
      var docBottom = cm.doc.height + paddingVert(display);
      var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
      if (rect.top < screentop) {
        result.scrollTop = atTop ? 0 : rect.top;
      } else if (rect.bottom > screentop + screen2) {
        var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
        if (newTop != screentop) {
          result.scrollTop = newTop;
        }
      }
      var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
      var screenw = displayWidth(cm) - display.gutters.offsetWidth;
      var tooWide = rect.right - rect.left > screenw;
      if (tooWide) {
        rect.right = rect.left + screenw;
      }
      if (rect.left < 10) {
        result.scrollLeft = 0;
      } else if (rect.left < screenleft) {
        result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
      } else if (rect.right > screenw + screenleft - 3) {
        result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
      }
      return result;
    }
    function addToScrollTop(cm, top) {
      if (top == null) {
        return;
      }
      resolveScrollToPos(cm);
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
    }
    function ensureCursorVisible(cm) {
      resolveScrollToPos(cm);
      var cur = cm.getCursor();
      cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
    }
    function scrollToCoords(cm, x, y) {
      if (x != null || y != null) {
        resolveScrollToPos(cm);
      }
      if (x != null) {
        cm.curOp.scrollLeft = x;
      }
      if (y != null) {
        cm.curOp.scrollTop = y;
      }
    }
    function scrollToRange(cm, range2) {
      resolveScrollToPos(cm);
      cm.curOp.scrollToPos = range2;
    }
    function resolveScrollToPos(cm) {
      var range2 = cm.curOp.scrollToPos;
      if (range2) {
        cm.curOp.scrollToPos = null;
        var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
        scrollToCoordsRange(cm, from, to, range2.margin);
      }
    }
    function scrollToCoordsRange(cm, from, to, margin) {
      var sPos = calculateScrollPos(cm, {
        left: Math.min(from.left, to.left),
        top: Math.min(from.top, to.top) - margin,
        right: Math.max(from.right, to.right),
        bottom: Math.max(from.bottom, to.bottom) + margin
      });
      scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
    }
    function updateScrollTop(cm, val) {
      if (Math.abs(cm.doc.scrollTop - val) < 2) {
        return;
      }
      if (!gecko) {
        updateDisplaySimple(cm, {top: val});
      }
      setScrollTop(cm, val, true);
      if (gecko) {
        updateDisplaySimple(cm);
      }
      startWorker(cm, 100);
    }
    function setScrollTop(cm, val, forceScroll) {
      val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
      if (cm.display.scroller.scrollTop == val && !forceScroll) {
        return;
      }
      cm.doc.scrollTop = val;
      cm.display.scrollbars.setScrollTop(val);
      if (cm.display.scroller.scrollTop != val) {
        cm.display.scroller.scrollTop = val;
      }
    }
    function setScrollLeft(cm, val, isScroller, forceScroll) {
      val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
      if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
        return;
      }
      cm.doc.scrollLeft = val;
      alignHorizontally(cm);
      if (cm.display.scroller.scrollLeft != val) {
        cm.display.scroller.scrollLeft = val;
      }
      cm.display.scrollbars.setScrollLeft(val);
    }
    function measureForScrollbars(cm) {
      var d = cm.display, gutterW = d.gutters.offsetWidth;
      var docH = Math.round(cm.doc.height + paddingVert(cm.display));
      return {
        clientHeight: d.scroller.clientHeight,
        viewHeight: d.wrapper.clientHeight,
        scrollWidth: d.scroller.scrollWidth,
        clientWidth: d.scroller.clientWidth,
        viewWidth: d.wrapper.clientWidth,
        barLeft: cm.options.fixedGutter ? gutterW : 0,
        docHeight: docH,
        scrollHeight: docH + scrollGap(cm) + d.barHeight,
        nativeBarWidth: d.nativeBarWidth,
        gutterWidth: gutterW
      };
    }
    var NativeScrollbars = function(place, scroll, cm) {
      this.cm = cm;
      var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
      var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
      vert.tabIndex = horiz.tabIndex = -1;
      place(vert);
      place(horiz);
      on3(vert, "scroll", function() {
        if (vert.clientHeight) {
          scroll(vert.scrollTop, "vertical");
        }
      });
      on3(horiz, "scroll", function() {
        if (horiz.clientWidth) {
          scroll(horiz.scrollLeft, "horizontal");
        }
      });
      this.checkedZeroWidth = false;
      if (ie && ie_version < 8) {
        this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
      }
    };
    NativeScrollbars.prototype.update = function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;
      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.scrollTop = 0;
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }
      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }
      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) {
          this.zeroWidthHack();
        }
        this.checkedZeroWidth = true;
      }
      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
    };
    NativeScrollbars.prototype.setScrollLeft = function(pos) {
      if (this.horiz.scrollLeft != pos) {
        this.horiz.scrollLeft = pos;
      }
      if (this.disableHoriz) {
        this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
      }
    };
    NativeScrollbars.prototype.setScrollTop = function(pos) {
      if (this.vert.scrollTop != pos) {
        this.vert.scrollTop = pos;
      }
      if (this.disableVert) {
        this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
      }
    };
    NativeScrollbars.prototype.zeroWidthHack = function() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed();
      this.disableVert = new Delayed();
    };
    NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        var box = bar.getBoundingClientRect();
        var elt2 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
        if (elt2 != bar) {
          bar.style.pointerEvents = "none";
        } else {
          delay.set(1e3, maybeDisable);
        }
      }
      delay.set(1e3, maybeDisable);
    };
    NativeScrollbars.prototype.clear = function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    };
    var NullScrollbars = function() {
    };
    NullScrollbars.prototype.update = function() {
      return {bottom: 0, right: 0};
    };
    NullScrollbars.prototype.setScrollLeft = function() {
    };
    NullScrollbars.prototype.setScrollTop = function() {
    };
    NullScrollbars.prototype.clear = function() {
    };
    function updateScrollbars(cm, measure) {
      if (!measure) {
        measure = measureForScrollbars(cm);
      }
      var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
      updateScrollbarsInner(cm, measure);
      for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
        if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
          updateHeightsInViewport(cm);
        }
        updateScrollbarsInner(cm, measureForScrollbars(cm));
        startWidth = cm.display.barWidth;
        startHeight = cm.display.barHeight;
      }
    }
    function updateScrollbarsInner(cm, measure) {
      var d = cm.display;
      var sizes = d.scrollbars.update(measure);
      d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
      d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
      d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
      if (sizes.right && sizes.bottom) {
        d.scrollbarFiller.style.display = "block";
        d.scrollbarFiller.style.height = sizes.bottom + "px";
        d.scrollbarFiller.style.width = sizes.right + "px";
      } else {
        d.scrollbarFiller.style.display = "";
      }
      if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
        d.gutterFiller.style.display = "block";
        d.gutterFiller.style.height = sizes.bottom + "px";
        d.gutterFiller.style.width = measure.gutterWidth + "px";
      } else {
        d.gutterFiller.style.display = "";
      }
    }
    var scrollbarModel = {native: NativeScrollbars, null: NullScrollbars};
    function initScrollbars(cm) {
      if (cm.display.scrollbars) {
        cm.display.scrollbars.clear();
        if (cm.display.scrollbars.addClass) {
          rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      }
      cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
        on3(node, "mousedown", function() {
          if (cm.state.focused) {
            setTimeout(function() {
              return cm.display.input.focus();
            }, 0);
          }
        });
        node.setAttribute("cm-not-content", "true");
      }, function(pos, axis) {
        if (axis == "horizontal") {
          setScrollLeft(cm, pos);
        } else {
          updateScrollTop(cm, pos);
        }
      }, cm);
      if (cm.display.scrollbars.addClass) {
        addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }
    var nextOpId = 0;
    function startOperation(cm) {
      cm.curOp = {
        cm,
        viewChanged: false,
        startHeight: cm.doc.height,
        forceUpdate: false,
        updateInput: 0,
        typing: false,
        changeObjs: null,
        cursorActivityHandlers: null,
        cursorActivityCalled: 0,
        selectionChanged: false,
        updateMaxLine: false,
        scrollLeft: null,
        scrollTop: null,
        scrollToPos: null,
        focus: false,
        id: ++nextOpId,
        markArrays: null
      };
      pushOperation(cm.curOp);
    }
    function endOperation(cm) {
      var op = cm.curOp;
      if (op) {
        finishOperation(op, function(group) {
          for (var i2 = 0; i2 < group.ops.length; i2++) {
            group.ops[i2].cm.curOp = null;
          }
          endOperations(group);
        });
      }
    }
    function endOperations(group) {
      var ops = group.ops;
      for (var i2 = 0; i2 < ops.length; i2++) {
        endOperation_R1(ops[i2]);
      }
      for (var i$12 = 0; i$12 < ops.length; i$12++) {
        endOperation_W1(ops[i$12]);
      }
      for (var i$22 = 0; i$22 < ops.length; i$22++) {
        endOperation_R2(ops[i$22]);
      }
      for (var i$3 = 0; i$3 < ops.length; i$3++) {
        endOperation_W2(ops[i$3]);
      }
      for (var i$4 = 0; i$4 < ops.length; i$4++) {
        endOperation_finish(ops[i$4]);
      }
    }
    function endOperation_R1(op) {
      var cm = op.cm, display = cm.display;
      maybeClipScrollbars(cm);
      if (op.updateMaxLine) {
        findMaxLine(cm);
      }
      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
      op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
    }
    function endOperation_W1(op) {
      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
    }
    function endOperation_R2(op) {
      var cm = op.cm, display = cm.display;
      if (op.updatedDisplay) {
        updateHeightsInViewport(cm);
      }
      op.barMeasure = measureForScrollbars(cm);
      if (display.maxLineChanged && !cm.options.lineWrapping) {
        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
        cm.display.sizerWidth = op.adjustWidthTo;
        op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
      }
      if (op.updatedDisplay || op.selectionChanged) {
        op.preparedSelection = display.input.prepareSelection();
      }
    }
    function endOperation_W2(op) {
      var cm = op.cm;
      if (op.adjustWidthTo != null) {
        cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
        if (op.maxScrollLeft < cm.doc.scrollLeft) {
          setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
        }
        cm.display.maxLineChanged = false;
      }
      var takeFocus = op.focus && op.focus == activeElt();
      if (op.preparedSelection) {
        cm.display.input.showSelection(op.preparedSelection, takeFocus);
      }
      if (op.updatedDisplay || op.startHeight != cm.doc.height) {
        updateScrollbars(cm, op.barMeasure);
      }
      if (op.updatedDisplay) {
        setDocumentHeight(cm, op.barMeasure);
      }
      if (op.selectionChanged) {
        restartBlink(cm);
      }
      if (cm.state.focused && op.updateInput) {
        cm.display.input.reset(op.typing);
      }
      if (takeFocus) {
        ensureFocus(op.cm);
      }
    }
    function endOperation_finish(op) {
      var cm = op.cm, display = cm.display, doc = cm.doc;
      if (op.updatedDisplay) {
        postUpdateDisplay(cm, op.update);
      }
      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
        display.wheelStartX = display.wheelStartY = null;
      }
      if (op.scrollTop != null) {
        setScrollTop(cm, op.scrollTop, op.forceScroll);
      }
      if (op.scrollLeft != null) {
        setScrollLeft(cm, op.scrollLeft, true, true);
      }
      if (op.scrollToPos) {
        var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
        maybeScrollWindow(cm, rect);
      }
      var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
      if (hidden) {
        for (var i2 = 0; i2 < hidden.length; ++i2) {
          if (!hidden[i2].lines.length) {
            signal(hidden[i2], "hide");
          }
        }
      }
      if (unhidden) {
        for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
          if (unhidden[i$12].lines.length) {
            signal(unhidden[i$12], "unhide");
          }
        }
      }
      if (display.wrapper.offsetHeight) {
        doc.scrollTop = cm.display.scroller.scrollTop;
      }
      if (op.changeObjs) {
        signal(cm, "changes", cm, op.changeObjs);
      }
      if (op.update) {
        op.update.finish();
      }
    }
    function runInOp(cm, f) {
      if (cm.curOp) {
        return f();
      }
      startOperation(cm);
      try {
        return f();
      } finally {
        endOperation(cm);
      }
    }
    function operation(cm, f) {
      return function() {
        if (cm.curOp) {
          return f.apply(cm, arguments);
        }
        startOperation(cm);
        try {
          return f.apply(cm, arguments);
        } finally {
          endOperation(cm);
        }
      };
    }
    function methodOp(f) {
      return function() {
        if (this.curOp) {
          return f.apply(this, arguments);
        }
        startOperation(this);
        try {
          return f.apply(this, arguments);
        } finally {
          endOperation(this);
        }
      };
    }
    function docMethodOp(f) {
      return function() {
        var cm = this.cm;
        if (!cm || cm.curOp) {
          return f.apply(this, arguments);
        }
        startOperation(cm);
        try {
          return f.apply(this, arguments);
        } finally {
          endOperation(cm);
        }
      };
    }
    function startWorker(cm, time) {
      if (cm.doc.highlightFrontier < cm.display.viewTo) {
        cm.state.highlight.set(time, bind(highlightWorker, cm));
      }
    }
    function highlightWorker(cm) {
      var doc = cm.doc;
      if (doc.highlightFrontier >= cm.display.viewTo) {
        return;
      }
      var end = +new Date() + cm.options.workTime;
      var context = getContextBefore(cm, doc.highlightFrontier);
      var changedLines = [];
      doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
        if (context.line >= cm.display.viewFrom) {
          var oldStyles = line.styles;
          var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
          var highlighted = highlightLine(cm, line, context, true);
          if (resetState) {
            context.state = resetState;
          }
          line.styles = highlighted.styles;
          var oldCls = line.styleClasses, newCls = highlighted.classes;
          if (newCls) {
            line.styleClasses = newCls;
          } else if (oldCls) {
            line.styleClasses = null;
          }
          var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
          for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
            ischange = oldStyles[i2] != line.styles[i2];
          }
          if (ischange) {
            changedLines.push(context.line);
          }
          line.stateAfter = context.save();
          context.nextLine();
        } else {
          if (line.text.length <= cm.options.maxHighlightLength) {
            processLine(cm, line.text, context);
          }
          line.stateAfter = context.line % 5 == 0 ? context.save() : null;
          context.nextLine();
        }
        if (+new Date() > end) {
          startWorker(cm, cm.options.workDelay);
          return true;
        }
      });
      doc.highlightFrontier = context.line;
      doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
      if (changedLines.length) {
        runInOp(cm, function() {
          for (var i2 = 0; i2 < changedLines.length; i2++) {
            regLineChange(cm, changedLines[i2], "text");
          }
        });
      }
    }
    var DisplayUpdate = function(cm, viewport, force) {
      var display = cm.display;
      this.viewport = viewport;
      this.visible = visibleLines(display, cm.doc, viewport);
      this.editorIsHidden = !display.wrapper.offsetWidth;
      this.wrapperHeight = display.wrapper.clientHeight;
      this.wrapperWidth = display.wrapper.clientWidth;
      this.oldDisplayWidth = displayWidth(cm);
      this.force = force;
      this.dims = getDimensions(cm);
      this.events = [];
    };
    DisplayUpdate.prototype.signal = function(emitter, type) {
      if (hasHandler(emitter, type)) {
        this.events.push(arguments);
      }
    };
    DisplayUpdate.prototype.finish = function() {
      for (var i2 = 0; i2 < this.events.length; i2++) {
        signal.apply(null, this.events[i2]);
      }
    };
    function maybeClipScrollbars(cm) {
      var display = cm.display;
      if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
        display.heightForcer.style.height = scrollGap(cm) + "px";
        display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
        display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
        display.scrollbarsClipped = true;
      }
    }
    function selectionSnapshot(cm) {
      if (cm.hasFocus()) {
        return null;
      }
      var active = activeElt();
      if (!active || !contains(cm.display.lineDiv, active)) {
        return null;
      }
      var result = {activeElt: active};
      if (window.getSelection) {
        var sel = window.getSelection();
        if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
          result.anchorNode = sel.anchorNode;
          result.anchorOffset = sel.anchorOffset;
          result.focusNode = sel.focusNode;
          result.focusOffset = sel.focusOffset;
        }
      }
      return result;
    }
    function restoreSelection(snapshot) {
      if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
        return;
      }
      snapshot.activeElt.focus();
      if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
        var sel = window.getSelection(), range2 = document.createRange();
        range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
        range2.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range2);
        sel.extend(snapshot.focusNode, snapshot.focusOffset);
      }
    }
    function updateDisplayIfNeeded(cm, update) {
      var display = cm.display, doc = cm.doc;
      if (update.editorIsHidden) {
        resetView(cm);
        return false;
      }
      if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
        return false;
      }
      if (maybeUpdateLineNumberWidth(cm)) {
        resetView(cm);
        update.dims = getDimensions(cm);
      }
      var end = doc.first + doc.size;
      var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
      var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
      if (display.viewFrom < from && from - display.viewFrom < 20) {
        from = Math.max(doc.first, display.viewFrom);
      }
      if (display.viewTo > to && display.viewTo - to < 20) {
        to = Math.min(end, display.viewTo);
      }
      if (sawCollapsedSpans) {
        from = visualLineNo(cm.doc, from);
        to = visualLineEndNo(cm.doc, to);
      }
      var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
      adjustView(cm, from, to);
      display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
      cm.display.mover.style.top = display.viewOffset + "px";
      var toUpdate = countDirtyView(cm);
      if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
        return false;
      }
      var selSnapshot = selectionSnapshot(cm);
      if (toUpdate > 4) {
        display.lineDiv.style.display = "none";
      }
      patchDisplay(cm, display.updateLineNumbers, update.dims);
      if (toUpdate > 4) {
        display.lineDiv.style.display = "";
      }
      display.renderedView = display.view;
      restoreSelection(selSnapshot);
      removeChildren(display.cursorDiv);
      removeChildren(display.selectionDiv);
      display.gutters.style.height = display.sizer.style.minHeight = 0;
      if (different) {
        display.lastWrapHeight = update.wrapperHeight;
        display.lastWrapWidth = update.wrapperWidth;
        startWorker(cm, 400);
      }
      display.updateLineNumbers = null;
      return true;
    }
    function postUpdateDisplay(cm, update) {
      var viewport = update.viewport;
      for (var first = true; ; first = false) {
        if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
          if (viewport && viewport.top != null) {
            viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
          }
          update.visible = visibleLines(cm.display, cm.doc, viewport);
          if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
            break;
          }
        } else if (first) {
          update.visible = visibleLines(cm.display, cm.doc, viewport);
        }
        if (!updateDisplayIfNeeded(cm, update)) {
          break;
        }
        updateHeightsInViewport(cm);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        updateScrollbars(cm, barMeasure);
        setDocumentHeight(cm, barMeasure);
        update.force = false;
      }
      update.signal(cm, "update", cm);
      if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
        update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
        cm.display.reportedViewFrom = cm.display.viewFrom;
        cm.display.reportedViewTo = cm.display.viewTo;
      }
    }
    function updateDisplaySimple(cm, viewport) {
      var update = new DisplayUpdate(cm, viewport);
      if (updateDisplayIfNeeded(cm, update)) {
        updateHeightsInViewport(cm);
        postUpdateDisplay(cm, update);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        updateScrollbars(cm, barMeasure);
        setDocumentHeight(cm, barMeasure);
        update.finish();
      }
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
      var display = cm.display, lineNumbers = cm.options.lineNumbers;
      var container = display.lineDiv, cur = container.firstChild;
      function rm(node2) {
        var next = node2.nextSibling;
        if (webkit && mac && cm.display.currentWheelTarget == node2) {
          node2.style.display = "none";
        } else {
          node2.parentNode.removeChild(node2);
        }
        return next;
      }
      var view = display.view, lineN = display.viewFrom;
      for (var i2 = 0; i2 < view.length; i2++) {
        var lineView = view[i2];
        if (lineView.hidden)
          ;
        else if (!lineView.node || lineView.node.parentNode != container) {
          var node = buildLineElement(cm, lineView, lineN, dims);
          container.insertBefore(node, cur);
        } else {
          while (cur != lineView.node) {
            cur = rm(cur);
          }
          var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
          if (lineView.changes) {
            if (indexOf(lineView.changes, "gutter") > -1) {
              updateNumber = false;
            }
            updateLineForChanges(cm, lineView, lineN, dims);
          }
          if (updateNumber) {
            removeChildren(lineView.lineNumber);
            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
          }
          cur = lineView.node.nextSibling;
        }
        lineN += lineView.size;
      }
      while (cur) {
        cur = rm(cur);
      }
    }
    function updateGutterSpace(display) {
      var width = display.gutters.offsetWidth;
      display.sizer.style.marginLeft = width + "px";
      signalLater(display, "gutterChanged", display);
    }
    function setDocumentHeight(cm, measure) {
      cm.display.sizer.style.minHeight = measure.docHeight + "px";
      cm.display.heightForcer.style.top = measure.docHeight + "px";
      cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
    }
    function alignHorizontally(cm) {
      var display = cm.display, view = display.view;
      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
        return;
      }
      var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
      var gutterW = display.gutters.offsetWidth, left = comp + "px";
      for (var i2 = 0; i2 < view.length; i2++) {
        if (!view[i2].hidden) {
          if (cm.options.fixedGutter) {
            if (view[i2].gutter) {
              view[i2].gutter.style.left = left;
            }
            if (view[i2].gutterBackground) {
              view[i2].gutterBackground.style.left = left;
            }
          }
          var align = view[i2].alignable;
          if (align) {
            for (var j = 0; j < align.length; j++) {
              align[j].style.left = left;
            }
          }
        }
      }
      if (cm.options.fixedGutter) {
        display.gutters.style.left = comp + gutterW + "px";
      }
    }
    function maybeUpdateLineNumberWidth(cm) {
      if (!cm.options.lineNumbers) {
        return false;
      }
      var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
      if (last.length != display.lineNumChars) {
        var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
        var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
        display.lineGutter.style.width = "";
        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
        display.lineNumWidth = display.lineNumInnerWidth + padding;
        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
        display.lineGutter.style.width = display.lineNumWidth + "px";
        updateGutterSpace(cm.display);
        return true;
      }
      return false;
    }
    function getGutters(gutters, lineNumbers) {
      var result = [], sawLineNumbers = false;
      for (var i2 = 0; i2 < gutters.length; i2++) {
        var name2 = gutters[i2], style = null;
        if (typeof name2 != "string") {
          style = name2.style;
          name2 = name2.className;
        }
        if (name2 == "CodeMirror-linenumbers") {
          if (!lineNumbers) {
            continue;
          } else {
            sawLineNumbers = true;
          }
        }
        result.push({className: name2, style});
      }
      if (lineNumbers && !sawLineNumbers) {
        result.push({className: "CodeMirror-linenumbers", style: null});
      }
      return result;
    }
    function renderGutters(display) {
      var gutters = display.gutters, specs = display.gutterSpecs;
      removeChildren(gutters);
      display.lineGutter = null;
      for (var i2 = 0; i2 < specs.length; ++i2) {
        var ref = specs[i2];
        var className = ref.className;
        var style = ref.style;
        var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
        if (style) {
          gElt.style.cssText = style;
        }
        if (className == "CodeMirror-linenumbers") {
          display.lineGutter = gElt;
          gElt.style.width = (display.lineNumWidth || 1) + "px";
        }
      }
      gutters.style.display = specs.length ? "" : "none";
      updateGutterSpace(display);
    }
    function updateGutters(cm) {
      renderGutters(cm.display);
      regChange(cm);
      alignHorizontally(cm);
    }
    function Display(place, doc, input, options) {
      var d = this;
      this.input = input;
      d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
      d.scrollbarFiller.setAttribute("cm-not-content", "true");
      d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
      d.gutterFiller.setAttribute("cm-not-content", "true");
      d.lineDiv = eltP("div", null, "CodeMirror-code");
      d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
      d.cursorDiv = elt("div", null, "CodeMirror-cursors");
      d.measure = elt("div", null, "CodeMirror-measure");
      d.lineMeasure = elt("div", null, "CodeMirror-measure");
      d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
      var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
      d.mover = elt("div", [lines], null, "position: relative");
      d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
      d.sizerWidth = null;
      d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
      d.gutters = elt("div", null, "CodeMirror-gutters");
      d.lineGutter = null;
      d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
      d.scroller.setAttribute("tabIndex", "-1");
      d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
      d.wrapper.setAttribute("translate", "no");
      if (ie && ie_version < 8) {
        d.gutters.style.zIndex = -1;
        d.scroller.style.paddingRight = 0;
      }
      if (!webkit && !(gecko && mobile)) {
        d.scroller.draggable = true;
      }
      if (place) {
        if (place.appendChild) {
          place.appendChild(d.wrapper);
        } else {
          place(d.wrapper);
        }
      }
      d.viewFrom = d.viewTo = doc.first;
      d.reportedViewFrom = d.reportedViewTo = doc.first;
      d.view = [];
      d.renderedView = null;
      d.externalMeasured = null;
      d.viewOffset = 0;
      d.lastWrapHeight = d.lastWrapWidth = 0;
      d.updateLineNumbers = null;
      d.nativeBarWidth = d.barHeight = d.barWidth = 0;
      d.scrollbarsClipped = false;
      d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
      d.alignWidgets = false;
      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
      d.maxLine = null;
      d.maxLineLength = 0;
      d.maxLineChanged = false;
      d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
      d.shift = false;
      d.selForContextMenu = null;
      d.activeTouch = null;
      d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
      renderGutters(d);
      input.init(d);
    }
    var wheelSamples = 0, wheelPixelsPerUnit = null;
    if (ie) {
      wheelPixelsPerUnit = -0.53;
    } else if (gecko) {
      wheelPixelsPerUnit = 15;
    } else if (chrome2) {
      wheelPixelsPerUnit = -0.7;
    } else if (safari) {
      wheelPixelsPerUnit = -1 / 3;
    }
    function wheelEventDelta(e) {
      var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
      if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
        dx = e.detail;
      }
      if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
        dy = e.detail;
      } else if (dy == null) {
        dy = e.wheelDelta;
      }
      return {x: dx, y: dy};
    }
    function wheelEventPixels(e) {
      var delta = wheelEventDelta(e);
      delta.x *= wheelPixelsPerUnit;
      delta.y *= wheelPixelsPerUnit;
      return delta;
    }
    function onScrollWheel(cm, e) {
      var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
      var pixelsPerUnit = wheelPixelsPerUnit;
      if (e.deltaMode === 0) {
        dx = e.deltaX;
        dy = e.deltaY;
        pixelsPerUnit = 1;
      }
      var display = cm.display, scroll = display.scroller;
      var canScrollX = scroll.scrollWidth > scroll.clientWidth;
      var canScrollY = scroll.scrollHeight > scroll.clientHeight;
      if (!(dx && canScrollX || dy && canScrollY)) {
        return;
      }
      if (dy && mac && webkit) {
        outer:
          for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i2 = 0; i2 < view.length; i2++) {
              if (view[i2].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
      }
      if (dx && !gecko && !presto && pixelsPerUnit != null) {
        if (dy && canScrollY) {
          updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
        }
        setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
        if (!dy || dy && canScrollY) {
          e_preventDefault(e);
        }
        display.wheelStartX = null;
        return;
      }
      if (dy && pixelsPerUnit != null) {
        var pixels = dy * pixelsPerUnit;
        var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
        if (pixels < 0) {
          top = Math.max(0, top + pixels - 50);
        } else {
          bot = Math.min(cm.doc.height, bot + pixels + 50);
        }
        updateDisplaySimple(cm, {top, bottom: bot});
      }
      if (wheelSamples < 20 && e.deltaMode !== 0) {
        if (display.wheelStartX == null) {
          display.wheelStartX = scroll.scrollLeft;
          display.wheelStartY = scroll.scrollTop;
          display.wheelDX = dx;
          display.wheelDY = dy;
          setTimeout(function() {
            if (display.wheelStartX == null) {
              return;
            }
            var movedX = scroll.scrollLeft - display.wheelStartX;
            var movedY = scroll.scrollTop - display.wheelStartY;
            var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
            display.wheelStartX = display.wheelStartY = null;
            if (!sample) {
              return;
            }
            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
            ++wheelSamples;
          }, 200);
        } else {
          display.wheelDX += dx;
          display.wheelDY += dy;
        }
      }
    }
    var Selection = function(ranges, primIndex) {
      this.ranges = ranges;
      this.primIndex = primIndex;
    };
    Selection.prototype.primary = function() {
      return this.ranges[this.primIndex];
    };
    Selection.prototype.equals = function(other) {
      if (other == this) {
        return true;
      }
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
        return false;
      }
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        var here = this.ranges[i2], there = other.ranges[i2];
        if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
          return false;
        }
      }
      return true;
    };
    Selection.prototype.deepCopy = function() {
      var out = [];
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        out[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
      }
      return new Selection(out, this.primIndex);
    };
    Selection.prototype.somethingSelected = function() {
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        if (!this.ranges[i2].empty()) {
          return true;
        }
      }
      return false;
    };
    Selection.prototype.contains = function(pos, end) {
      if (!end) {
        end = pos;
      }
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        var range2 = this.ranges[i2];
        if (cmp(end, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
          return i2;
        }
      }
      return -1;
    };
    var Range = function(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    };
    Range.prototype.from = function() {
      return minPos(this.anchor, this.head);
    };
    Range.prototype.to = function() {
      return maxPos(this.anchor, this.head);
    };
    Range.prototype.empty = function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    };
    function normalizeSelection(cm, ranges, primIndex) {
      var mayTouch = cm && cm.options.selectionsMayTouch;
      var prim = ranges[primIndex];
      ranges.sort(function(a, b) {
        return cmp(a.from(), b.from());
      });
      primIndex = indexOf(ranges, prim);
      for (var i2 = 1; i2 < ranges.length; i2++) {
        var cur = ranges[i2], prev = ranges[i2 - 1];
        var diff = cmp(prev.to(), cur.from());
        if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
          var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
          if (i2 <= primIndex) {
            --primIndex;
          }
          ranges.splice(--i2, 2, new Range(inv ? to : from, inv ? from : to));
        }
      }
      return new Selection(ranges, primIndex);
    }
    function simpleSelection(anchor, head) {
      return new Selection([new Range(anchor, head || anchor)], 0);
    }
    function changeEnd(change) {
      if (!change.text) {
        return change.to;
      }
      return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    }
    function adjustForChange(pos, change) {
      if (cmp(pos, change.from) < 0) {
        return pos;
      }
      if (cmp(pos, change.to) <= 0) {
        return changeEnd(change);
      }
      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line) {
        ch += changeEnd(change).ch - change.to.ch;
      }
      return Pos(line, ch);
    }
    function computeSelAfterChange(doc, change) {
      var out = [];
      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
        var range2 = doc.sel.ranges[i2];
        out.push(new Range(adjustForChange(range2.anchor, change), adjustForChange(range2.head, change)));
      }
      return normalizeSelection(doc.cm, out, doc.sel.primIndex);
    }
    function offsetPos(pos, old, nw) {
      if (pos.line == old.line) {
        return Pos(nw.line, pos.ch - old.ch + nw.ch);
      } else {
        return Pos(nw.line + (pos.line - old.line), pos.ch);
      }
    }
    function computeReplacedSel(doc, changes, hint) {
      var out = [];
      var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
      for (var i2 = 0; i2 < changes.length; i2++) {
        var change = changes[i2];
        var from = offsetPos(change.from, oldPrev, newPrev);
        var to = offsetPos(changeEnd(change), oldPrev, newPrev);
        oldPrev = change.to;
        newPrev = to;
        if (hint == "around") {
          var range2 = doc.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;
          out[i2] = new Range(inv ? to : from, inv ? from : to);
        } else {
          out[i2] = new Range(from, from);
        }
      }
      return new Selection(out, doc.sel.primIndex);
    }
    function loadMode(cm) {
      cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
      resetModeState(cm);
    }
    function resetModeState(cm) {
      cm.doc.iter(function(line) {
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        if (line.styles) {
          line.styles = null;
        }
      });
      cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
      startWorker(cm, 100);
      cm.state.modeGen++;
      if (cm.curOp) {
        regChange(cm);
      }
    }
    function isWholeLineUpdate(doc, change) {
      return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc(doc, change, markedSpans, estimateHeight2) {
      function spansFor(n) {
        return markedSpans ? markedSpans[n] : null;
      }
      function update(line, text3, spans) {
        updateLine3(line, text3, spans, estimateHeight2);
        signalLater(line, "change", line, change);
      }
      function linesFor(start, end) {
        var result = [];
        for (var i2 = start; i2 < end; ++i2) {
          result.push(new Line(text2[i2], spansFor(i2), estimateHeight2));
        }
        return result;
      }
      var from = change.from, to = change.to, text2 = change.text;
      var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
      var lastText = lst(text2), lastSpans = spansFor(text2.length - 1), nlines = to.line - from.line;
      if (change.full) {
        doc.insert(0, linesFor(0, text2.length));
        doc.remove(text2.length, doc.size - text2.length);
      } else if (isWholeLineUpdate(doc, change)) {
        var added = linesFor(0, text2.length - 1);
        update(lastLine, lastLine.text, lastSpans);
        if (nlines) {
          doc.remove(from.line, nlines);
        }
        if (added.length) {
          doc.insert(from.line, added);
        }
      } else if (firstLine == lastLine) {
        if (text2.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
        } else {
          var added$1 = linesFor(1, text2.length - 1);
          added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
          update(firstLine, firstLine.text.slice(0, from.ch) + text2[0], spansFor(0));
          doc.insert(from.line + 1, added$1);
        }
      } else if (text2.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + text2[0] + lastLine.text.slice(to.ch), spansFor(0));
        doc.remove(from.line + 1, nlines);
      } else {
        update(firstLine, firstLine.text.slice(0, from.ch) + text2[0], spansFor(0));
        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
        var added$2 = linesFor(1, text2.length - 1);
        if (nlines > 1) {
          doc.remove(from.line + 1, nlines - 1);
        }
        doc.insert(from.line + 1, added$2);
      }
      signalLater(doc, "change", doc, change);
    }
    function linkedDocs(doc, f, sharedHistOnly) {
      function propagate(doc2, skip, sharedHist) {
        if (doc2.linked) {
          for (var i2 = 0; i2 < doc2.linked.length; ++i2) {
            var rel = doc2.linked[i2];
            if (rel.doc == skip) {
              continue;
            }
            var shared = sharedHist && rel.sharedHist;
            if (sharedHistOnly && !shared) {
              continue;
            }
            f(rel.doc, shared);
            propagate(rel.doc, doc2, shared);
          }
        }
      }
      propagate(doc, null, true);
    }
    function attachDoc(cm, doc) {
      if (doc.cm) {
        throw new Error("This document is already in use.");
      }
      cm.doc = doc;
      doc.cm = cm;
      estimateLineHeights(cm);
      loadMode(cm);
      setDirectionClass(cm);
      cm.options.direction = doc.direction;
      if (!cm.options.lineWrapping) {
        findMaxLine(cm);
      }
      cm.options.mode = doc.modeOption;
      regChange(cm);
    }
    function setDirectionClass(cm) {
      (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
    }
    function directionChanged(cm) {
      runInOp(cm, function() {
        setDirectionClass(cm);
        regChange(cm);
      });
    }
    function History(prev) {
      this.done = [];
      this.undone = [];
      this.undoDepth = prev ? prev.undoDepth : Infinity;
      this.lastModTime = this.lastSelTime = 0;
      this.lastOp = this.lastSelOp = null;
      this.lastOrigin = this.lastSelOrigin = null;
      this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
    }
    function historyChangeFromChange(doc, change) {
      var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
      linkedDocs(doc, function(doc2) {
        return attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
      }, true);
      return histChange;
    }
    function clearSelectionEvents(array) {
      while (array.length) {
        var last = lst(array);
        if (last.ranges) {
          array.pop();
        } else {
          break;
        }
      }
    }
    function lastChangeEvent(hist, force) {
      if (force) {
        clearSelectionEvents(hist.done);
        return lst(hist.done);
      } else if (hist.done.length && !lst(hist.done).ranges) {
        return lst(hist.done);
      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
        hist.done.pop();
        return lst(hist.done);
      }
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
      var hist = doc.history;
      hist.undone.length = 0;
      var time = +new Date(), cur;
      var last;
      if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
        last = lst(cur.changes);
        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
          last.to = changeEnd(change);
        } else {
          cur.changes.push(historyChangeFromChange(doc, change));
        }
      } else {
        var before = lst(hist.done);
        if (!before || !before.ranges) {
          pushSelectionToHistory(doc.sel, hist.done);
        }
        cur = {
          changes: [historyChangeFromChange(doc, change)],
          generation: hist.generation
        };
        hist.done.push(cur);
        while (hist.done.length > hist.undoDepth) {
          hist.done.shift();
          if (!hist.done[0].ranges) {
            hist.done.shift();
          }
        }
      }
      hist.done.push(selAfter);
      hist.generation = ++hist.maxGeneration;
      hist.lastModTime = hist.lastSelTime = time;
      hist.lastOp = hist.lastSelOp = opId;
      hist.lastOrigin = hist.lastSelOrigin = change.origin;
      if (!last) {
        signal(doc, "historyAdded");
      }
    }
    function selectionEventCanBeMerged(doc, origin, prev, sel) {
      var ch = origin.charAt(0);
      return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
    }
    function addSelectionToHistory(doc, sel, opId, options) {
      var hist = doc.history, origin = options && options.origin;
      if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
        hist.done[hist.done.length - 1] = sel;
      } else {
        pushSelectionToHistory(sel, hist.done);
      }
      hist.lastSelTime = +new Date();
      hist.lastSelOrigin = origin;
      hist.lastSelOp = opId;
      if (options && options.clearRedo !== false) {
        clearSelectionEvents(hist.undone);
      }
    }
    function pushSelectionToHistory(sel, dest) {
      var top = lst(dest);
      if (!(top && top.ranges && top.equals(sel))) {
        dest.push(sel);
      }
    }
    function attachLocalSpans(doc, change, from, to) {
      var existing = change["spans_" + doc.id], n = 0;
      doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
        if (line.markedSpans) {
          (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
        }
        ++n;
      });
    }
    function removeClearedSpans(spans) {
      if (!spans) {
        return null;
      }
      var out;
      for (var i2 = 0; i2 < spans.length; ++i2) {
        if (spans[i2].marker.explicitlyCleared) {
          if (!out) {
            out = spans.slice(0, i2);
          }
        } else if (out) {
          out.push(spans[i2]);
        }
      }
      return !out ? spans : out.length ? out : null;
    }
    function getOldSpans(doc, change) {
      var found = change["spans_" + doc.id];
      if (!found) {
        return null;
      }
      var nw = [];
      for (var i2 = 0; i2 < change.text.length; ++i2) {
        nw.push(removeClearedSpans(found[i2]));
      }
      return nw;
    }
    function mergeOldSpans(doc, change) {
      var old = getOldSpans(doc, change);
      var stretched = stretchSpansOverChange(doc, change);
      if (!old) {
        return stretched;
      }
      if (!stretched) {
        return old;
      }
      for (var i2 = 0; i2 < old.length; ++i2) {
        var oldCur = old[i2], stretchCur = stretched[i2];
        if (oldCur && stretchCur) {
          spans:
            for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k) {
                if (oldCur[k].marker == span.marker) {
                  continue spans;
                }
              }
              oldCur.push(span);
            }
        } else if (stretchCur) {
          old[i2] = stretchCur;
        }
      }
      return old;
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
      var copy = [];
      for (var i2 = 0; i2 < events.length; ++i2) {
        var event = events[i2];
        if (event.ranges) {
          copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
          continue;
        }
        var changes = event.changes, newChanges = [];
        copy.push({changes: newChanges});
        for (var j = 0; j < changes.length; ++j) {
          var change = changes[j], m = void 0;
          newChanges.push({from: change.from, to: change.to, text: change.text});
          if (newGroup) {
            for (var prop2 in change) {
              if (m = prop2.match(/^spans_(\d+)$/)) {
                if (indexOf(newGroup, Number(m[1])) > -1) {
                  lst(newChanges)[prop2] = change[prop2];
                  delete change[prop2];
                }
              }
            }
          }
        }
      }
      return copy;
    }
    function extendRange(range2, head, other, extend2) {
      if (extend2) {
        var anchor = range2.anchor;
        if (other) {
          var posBefore = cmp(head, anchor) < 0;
          if (posBefore != cmp(other, anchor) < 0) {
            anchor = head;
            head = other;
          } else if (posBefore != cmp(head, other) < 0) {
            head = other;
          }
        }
        return new Range(anchor, head);
      } else {
        return new Range(other || head, head);
      }
    }
    function extendSelection(doc, head, other, options, extend2) {
      if (extend2 == null) {
        extend2 = doc.cm && (doc.cm.display.shift || doc.extend);
      }
      setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend2)], 0), options);
    }
    function extendSelections(doc, heads, options) {
      var out = [];
      var extend2 = doc.cm && (doc.cm.display.shift || doc.extend);
      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
        out[i2] = extendRange(doc.sel.ranges[i2], heads[i2], null, extend2);
      }
      var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
      setSelection(doc, newSel, options);
    }
    function replaceOneSelection(doc, i2, range2, options) {
      var ranges = doc.sel.ranges.slice(0);
      ranges[i2] = range2;
      setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
    }
    function setSimpleSelection(doc, anchor, head, options) {
      setSelection(doc, simpleSelection(anchor, head), options);
    }
    function filterSelectionChange(doc, sel, options) {
      var obj = {
        ranges: sel.ranges,
        update: function(ranges) {
          this.ranges = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            this.ranges[i2] = new Range(clipPos(doc, ranges[i2].anchor), clipPos(doc, ranges[i2].head));
          }
        },
        origin: options && options.origin
      };
      signal(doc, "beforeSelectionChange", doc, obj);
      if (doc.cm) {
        signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
      }
      if (obj.ranges != sel.ranges) {
        return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
      } else {
        return sel;
      }
    }
    function setSelectionReplaceHistory(doc, sel, options) {
      var done = doc.history.done, last = lst(done);
      if (last && last.ranges) {
        done[done.length - 1] = sel;
        setSelectionNoUndo(doc, sel, options);
      } else {
        setSelection(doc, sel, options);
      }
    }
    function setSelection(doc, sel, options) {
      setSelectionNoUndo(doc, sel, options);
      addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
    }
    function setSelectionNoUndo(doc, sel, options) {
      if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
        sel = filterSelectionChange(doc, sel, options);
      }
      var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
      setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
      if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {
        ensureCursorVisible(doc.cm);
      }
    }
    function setSelectionInner(doc, sel) {
      if (sel.equals(doc.sel)) {
        return;
      }
      doc.sel = sel;
      if (doc.cm) {
        doc.cm.curOp.updateInput = 1;
        doc.cm.curOp.selectionChanged = true;
        signalCursorActivity(doc.cm);
      }
      signalLater(doc, "cursorActivity", doc);
    }
    function reCheckSelection(doc) {
      setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
      var out;
      for (var i2 = 0; i2 < sel.ranges.length; i2++) {
        var range2 = sel.ranges[i2];
        var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i2];
        var newAnchor = skipAtomic(doc, range2.anchor, old && old.anchor, bias, mayClear);
        var newHead = skipAtomic(doc, range2.head, old && old.head, bias, mayClear);
        if (out || newAnchor != range2.anchor || newHead != range2.head) {
          if (!out) {
            out = sel.ranges.slice(0, i2);
          }
          out[i2] = new Range(newAnchor, newHead);
        }
      }
      return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
    }
    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
      var line = getLine(doc, pos.line);
      if (line.markedSpans) {
        for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
          var sp = line.markedSpans[i2], m = sp.marker;
          var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
          var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
          if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) {
                  break;
                } else {
                  --i2;
                  continue;
                }
              }
            }
            if (!m.atomic) {
              continue;
            }
            if (oldPos) {
              var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
              if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
              }
              if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                return skipAtomicInner(doc, near, pos, dir, mayClear);
              }
            }
            var far = m.find(dir < 0 ? -1 : 1);
            if (dir < 0 ? preventCursorLeft : preventCursorRight) {
              far = movePos(doc, far, dir, far.line == pos.line ? line : null);
            }
            return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
          }
        }
      }
      return pos;
    }
    function skipAtomic(doc, pos, oldPos, bias, mayClear) {
      var dir = bias || 1;
      var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
      if (!found) {
        doc.cantEdit = true;
        return Pos(doc.first, 0);
      }
      return found;
    }
    function movePos(doc, pos, dir, line) {
      if (dir < 0 && pos.ch == 0) {
        if (pos.line > doc.first) {
          return clipPos(doc, Pos(pos.line - 1));
        } else {
          return null;
        }
      } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
        if (pos.line < doc.first + doc.size - 1) {
          return Pos(pos.line + 1, 0);
        } else {
          return null;
        }
      } else {
        return new Pos(pos.line, pos.ch + dir);
      }
    }
    function selectAll(cm) {
      cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
    }
    function filterChange(doc, change, update) {
      var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        cancel: function() {
          return obj.canceled = true;
        }
      };
      if (update) {
        obj.update = function(from, to, text2, origin) {
          if (from) {
            obj.from = clipPos(doc, from);
          }
          if (to) {
            obj.to = clipPos(doc, to);
          }
          if (text2) {
            obj.text = text2;
          }
          if (origin !== void 0) {
            obj.origin = origin;
          }
        };
      }
      signal(doc, "beforeChange", doc, obj);
      if (doc.cm) {
        signal(doc.cm, "beforeChange", doc.cm, obj);
      }
      if (obj.canceled) {
        if (doc.cm) {
          doc.cm.curOp.updateInput = 2;
        }
        return null;
      }
      return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
    }
    function makeChange(doc, change, ignoreReadOnly) {
      if (doc.cm) {
        if (!doc.cm.curOp) {
          return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
        }
        if (doc.cm.state.suppressEdits) {
          return;
        }
      }
      if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
        change = filterChange(doc, change, true);
        if (!change) {
          return;
        }
      }
      var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
      if (split) {
        for (var i2 = split.length - 1; i2 >= 0; --i2) {
          makeChangeInner(doc, {from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin});
        }
      } else {
        makeChangeInner(doc, change);
      }
    }
    function makeChangeInner(doc, change) {
      if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
        return;
      }
      var selAfter = computeSelAfterChange(doc, change);
      addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
      makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
      var rebased = [];
      linkedDocs(doc, function(doc2, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
          rebaseHist(doc2.history, change);
          rebased.push(doc2.history);
        }
        makeChangeSingleDoc(doc2, change, null, stretchSpansOverChange(doc2, change));
      });
    }
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
      var suppress = doc.cm && doc.cm.state.suppressEdits;
      if (suppress && !allowSelectionOnly) {
        return;
      }
      var hist = doc.history, event, selAfter = doc.sel;
      var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
      var i2 = 0;
      for (; i2 < source.length; i2++) {
        event = source[i2];
        if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
          break;
        }
      }
      if (i2 == source.length) {
        return;
      }
      hist.lastOrigin = hist.lastSelOrigin = null;
      for (; ; ) {
        event = source.pop();
        if (event.ranges) {
          pushSelectionToHistory(event, dest);
          if (allowSelectionOnly && !event.equals(doc.sel)) {
            setSelection(doc, event, {clearRedo: false});
            return;
          }
          selAfter = event;
        } else if (suppress) {
          source.push(event);
          return;
        } else {
          break;
        }
      }
      var antiChanges = [];
      pushSelectionToHistory(selAfter, dest);
      dest.push({changes: antiChanges, generation: hist.generation});
      hist.generation = event.generation || ++hist.maxGeneration;
      var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
      var loop = function(i3) {
        var change = event.changes[i3];
        change.origin = type;
        if (filter && !filterChange(doc, change, false)) {
          source.length = 0;
          return {};
        }
        antiChanges.push(historyChangeFromChange(doc, change));
        var after = i3 ? computeSelAfterChange(doc, change) : lst(source);
        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
        if (!i3 && doc.cm) {
          doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
        }
        var rebased = [];
        linkedDocs(doc, function(doc2, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
            rebaseHist(doc2.history, change);
            rebased.push(doc2.history);
          }
          makeChangeSingleDoc(doc2, change, null, mergeOldSpans(doc2, change));
        });
      };
      for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {
        var returned = loop(i$12);
        if (returned)
          return returned.v;
      }
    }
    function shiftDoc(doc, distance) {
      if (distance == 0) {
        return;
      }
      doc.first += distance;
      doc.sel = new Selection(map2(doc.sel.ranges, function(range2) {
        return new Range(Pos(range2.anchor.line + distance, range2.anchor.ch), Pos(range2.head.line + distance, range2.head.ch));
      }), doc.sel.primIndex);
      if (doc.cm) {
        regChange(doc.cm, doc.first, doc.first - distance, distance);
        for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
          regLineChange(doc.cm, l, "gutter");
        }
      }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
      if (doc.cm && !doc.cm.curOp) {
        return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
      }
      if (change.to.line < doc.first) {
        shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
        return;
      }
      if (change.from.line > doc.lastLine()) {
        return;
      }
      if (change.from.line < doc.first) {
        var shift = change.text.length - 1 - (doc.first - change.from.line);
        shiftDoc(doc, shift);
        change = {
          from: Pos(doc.first, 0),
          to: Pos(change.to.line + shift, change.to.ch),
          text: [lst(change.text)],
          origin: change.origin
        };
      }
      var last = doc.lastLine();
      if (change.to.line > last) {
        change = {
          from: change.from,
          to: Pos(last, getLine(doc, last).text.length),
          text: [change.text[0]],
          origin: change.origin
        };
      }
      change.removed = getBetween(doc, change.from, change.to);
      if (!selAfter) {
        selAfter = computeSelAfterChange(doc, change);
      }
      if (doc.cm) {
        makeChangeSingleDocInEditor(doc.cm, change, spans);
      } else {
        updateDoc(doc, change, spans);
      }
      setSelectionNoUndo(doc, selAfter, sel_dontScroll);
      if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
        doc.cantEdit = false;
      }
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
      var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
      var recomputeMaxLength = false, checkWidthStart = from.line;
      if (!cm.options.lineWrapping) {
        checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
        doc.iter(checkWidthStart, to.line + 1, function(line) {
          if (line == display.maxLine) {
            recomputeMaxLength = true;
            return true;
          }
        });
      }
      if (doc.sel.contains(change.from, change.to) > -1) {
        signalCursorActivity(cm);
      }
      updateDoc(doc, change, spans, estimateHeight(cm));
      if (!cm.options.lineWrapping) {
        doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
          var len = lineLength(line);
          if (len > display.maxLineLength) {
            display.maxLine = line;
            display.maxLineLength = len;
            display.maxLineChanged = true;
            recomputeMaxLength = false;
          }
        });
        if (recomputeMaxLength) {
          cm.curOp.updateMaxLine = true;
        }
      }
      retreatFrontier(doc, from.line);
      startWorker(cm, 400);
      var lendiff = change.text.length - (to.line - from.line) - 1;
      if (change.full) {
        regChange(cm);
      } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
        regLineChange(cm, from.line, "text");
      } else {
        regChange(cm, from.line, to.line + 1, lendiff);
      }
      var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
      if (changeHandler || changesHandler) {
        var obj = {
          from,
          to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
        if (changeHandler) {
          signalLater(cm, "change", cm, obj);
        }
        if (changesHandler) {
          (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
      }
      cm.display.selForContextMenu = null;
    }
    function replaceRange(doc, code, from, to, origin) {
      var assign;
      if (!to) {
        to = from;
      }
      if (cmp(to, from) < 0) {
        assign = [to, from], from = assign[0], to = assign[1];
      }
      if (typeof code == "string") {
        code = doc.splitLines(code);
      }
      makeChange(doc, {from, to, text: code, origin});
    }
    function rebaseHistSelSingle(pos, from, to, diff) {
      if (to < pos.line) {
        pos.line += diff;
      } else if (from < pos.line) {
        pos.line = from;
        pos.ch = 0;
      }
    }
    function rebaseHistArray(array, from, to, diff) {
      for (var i2 = 0; i2 < array.length; ++i2) {
        var sub = array[i2], ok = true;
        if (sub.ranges) {
          if (!sub.copied) {
            sub = array[i2] = sub.deepCopy();
            sub.copied = true;
          }
          for (var j = 0; j < sub.ranges.length; j++) {
            rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
            rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
          }
          continue;
        }
        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
          var cur = sub.changes[j$1];
          if (to < cur.from.line) {
            cur.from = Pos(cur.from.line + diff, cur.from.ch);
            cur.to = Pos(cur.to.line + diff, cur.to.ch);
          } else if (from <= cur.to.line) {
            ok = false;
            break;
          }
        }
        if (!ok) {
          array.splice(0, i2 + 1);
          i2 = 0;
        }
      }
    }
    function rebaseHist(hist, change) {
      var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
      rebaseHistArray(hist.done, from, to, diff);
      rebaseHistArray(hist.undone, from, to, diff);
    }
    function changeLine(doc, handle, changeType, op) {
      var no = handle, line = handle;
      if (typeof handle == "number") {
        line = getLine(doc, clipLine(doc, handle));
      } else {
        no = lineNo(handle);
      }
      if (no == null) {
        return null;
      }
      if (op(line, no) && doc.cm) {
        regLineChange(doc.cm, no, changeType);
      }
      return line;
    }
    function LeafChunk(lines) {
      this.lines = lines;
      this.parent = null;
      var height = 0;
      for (var i2 = 0; i2 < lines.length; ++i2) {
        lines[i2].parent = this;
        height += lines[i2].height;
      }
      this.height = height;
    }
    LeafChunk.prototype = {
      chunkSize: function() {
        return this.lines.length;
      },
      removeInner: function(at, n) {
        for (var i2 = at, e = at + n; i2 < e; ++i2) {
          var line = this.lines[i2];
          this.height -= line.height;
          cleanUpLine(line);
          signalLater(line, "delete");
        }
        this.lines.splice(at, n);
      },
      collapse: function(lines) {
        lines.push.apply(lines, this.lines);
      },
      insertInner: function(at, lines, height) {
        this.height += height;
        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
        for (var i2 = 0; i2 < lines.length; ++i2) {
          lines[i2].parent = this;
        }
      },
      iterN: function(at, n, op) {
        for (var e = at + n; at < e; ++at) {
          if (op(this.lines[at])) {
            return true;
          }
        }
      }
    };
    function BranchChunk(children) {
      this.children = children;
      var size = 0, height = 0;
      for (var i2 = 0; i2 < children.length; ++i2) {
        var ch = children[i2];
        size += ch.chunkSize();
        height += ch.height;
        ch.parent = this;
      }
      this.size = size;
      this.height = height;
      this.parent = null;
    }
    BranchChunk.prototype = {
      chunkSize: function() {
        return this.size;
      },
      removeInner: function(at, n) {
        this.size -= n;
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          var child = this.children[i2], sz = child.chunkSize();
          if (at < sz) {
            var rm = Math.min(n, sz - at), oldHeight = child.height;
            child.removeInner(at, rm);
            this.height -= oldHeight - child.height;
            if (sz == rm) {
              this.children.splice(i2--, 1);
              child.parent = null;
            }
            if ((n -= rm) == 0) {
              break;
            }
            at = 0;
          } else {
            at -= sz;
          }
        }
        if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
          var lines = [];
          this.collapse(lines);
          this.children = [new LeafChunk(lines)];
          this.children[0].parent = this;
        }
      },
      collapse: function(lines) {
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          this.children[i2].collapse(lines);
        }
      },
      insertInner: function(at, lines, height) {
        this.size += lines.length;
        this.height += height;
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          var child = this.children[i2], sz = child.chunkSize();
          if (at <= sz) {
            child.insertInner(at, lines, height);
            if (child.lines && child.lines.length > 50) {
              var remaining = child.lines.length % 25 + 25;
              for (var pos = remaining; pos < child.lines.length; ) {
                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                child.height -= leaf.height;
                this.children.splice(++i2, 0, leaf);
                leaf.parent = this;
              }
              child.lines = child.lines.slice(0, remaining);
              this.maybeSpill();
            }
            break;
          }
          at -= sz;
        }
      },
      maybeSpill: function() {
        if (this.children.length <= 10) {
          return;
        }
        var me = this;
        do {
          var spilled = me.children.splice(me.children.length - 5, 5);
          var sibling = new BranchChunk(spilled);
          if (!me.parent) {
            var copy = new BranchChunk(me.children);
            copy.parent = me;
            me.children = [copy, sibling];
            me = copy;
          } else {
            me.size -= sibling.size;
            me.height -= sibling.height;
            var myIndex = indexOf(me.parent.children, me);
            me.parent.children.splice(myIndex + 1, 0, sibling);
          }
          sibling.parent = me.parent;
        } while (me.children.length > 10);
        me.parent.maybeSpill();
      },
      iterN: function(at, n, op) {
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          var child = this.children[i2], sz = child.chunkSize();
          if (at < sz) {
            var used = Math.min(n, sz - at);
            if (child.iterN(at, used, op)) {
              return true;
            }
            if ((n -= used) == 0) {
              break;
            }
            at = 0;
          } else {
            at -= sz;
          }
        }
      }
    };
    var LineWidget = function(doc, node, options) {
      if (options) {
        for (var opt in options) {
          if (options.hasOwnProperty(opt)) {
            this[opt] = options[opt];
          }
        }
      }
      this.doc = doc;
      this.node = node;
    };
    LineWidget.prototype.clear = function() {
      var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
      if (no == null || !ws) {
        return;
      }
      for (var i2 = 0; i2 < ws.length; ++i2) {
        if (ws[i2] == this) {
          ws.splice(i2--, 1);
        }
      }
      if (!ws.length) {
        line.widgets = null;
      }
      var height = widgetHeight(this);
      updateLineHeight(line, Math.max(0, line.height - height));
      if (cm) {
        runInOp(cm, function() {
          adjustScrollWhenAboveVisible(cm, line, -height);
          regLineChange(cm, no, "widget");
        });
        signalLater(cm, "lineWidgetCleared", cm, this, no);
      }
    };
    LineWidget.prototype.changed = function() {
      var this$1 = this;
      var oldH = this.height, cm = this.doc.cm, line = this.line;
      this.height = null;
      var diff = widgetHeight(this) - oldH;
      if (!diff) {
        return;
      }
      if (!lineIsHidden(this.doc, line)) {
        updateLineHeight(line, line.height + diff);
      }
      if (cm) {
        runInOp(cm, function() {
          cm.curOp.forceUpdate = true;
          adjustScrollWhenAboveVisible(cm, line, diff);
          signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
        });
      }
    };
    eventMixin(LineWidget);
    function adjustScrollWhenAboveVisible(cm, line, diff) {
      if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
        addToScrollTop(cm, diff);
      }
    }
    function addLineWidget(doc, handle, node, options) {
      var widget = new LineWidget(doc, node, options);
      var cm = doc.cm;
      if (cm && widget.noHScroll) {
        cm.display.alignWidgets = true;
      }
      changeLine(doc, handle, "widget", function(line) {
        var widgets = line.widgets || (line.widgets = []);
        if (widget.insertAt == null) {
          widgets.push(widget);
        } else {
          widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
        }
        widget.line = line;
        if (cm && !lineIsHidden(doc, line)) {
          var aboveVisible = heightAtLine(line) < doc.scrollTop;
          updateLineHeight(line, line.height + widgetHeight(widget));
          if (aboveVisible) {
            addToScrollTop(cm, widget.height);
          }
          cm.curOp.forceUpdate = true;
        }
        return true;
      });
      if (cm) {
        signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
      }
      return widget;
    }
    var nextMarkerId = 0;
    var TextMarker = function(doc, type) {
      this.lines = [];
      this.type = type;
      this.doc = doc;
      this.id = ++nextMarkerId;
    };
    TextMarker.prototype.clear = function() {
      if (this.explicitlyCleared) {
        return;
      }
      var cm = this.doc.cm, withOp = cm && !cm.curOp;
      if (withOp) {
        startOperation(cm);
      }
      if (hasHandler(this, "clear")) {
        var found = this.find();
        if (found) {
          signalLater(this, "clear", found.from, found.to);
        }
      }
      var min = null, max = null;
      for (var i2 = 0; i2 < this.lines.length; ++i2) {
        var line = this.lines[i2];
        var span = getMarkedSpanFor(line.markedSpans, this);
        if (cm && !this.collapsed) {
          regLineChange(cm, lineNo(line), "text");
        } else if (cm) {
          if (span.to != null) {
            max = lineNo(line);
          }
          if (span.from != null) {
            min = lineNo(line);
          }
        }
        line.markedSpans = removeMarkedSpan(line.markedSpans, span);
        if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
          updateLineHeight(line, textHeight(cm.display));
        }
      }
      if (cm && this.collapsed && !cm.options.lineWrapping) {
        for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
          var visual = visualLine(this.lines[i$12]), len = lineLength(visual);
          if (len > cm.display.maxLineLength) {
            cm.display.maxLine = visual;
            cm.display.maxLineLength = len;
            cm.display.maxLineChanged = true;
          }
        }
      }
      if (min != null && cm && this.collapsed) {
        regChange(cm, min, max + 1);
      }
      this.lines.length = 0;
      this.explicitlyCleared = true;
      if (this.atomic && this.doc.cantEdit) {
        this.doc.cantEdit = false;
        if (cm) {
          reCheckSelection(cm.doc);
        }
      }
      if (cm) {
        signalLater(cm, "markerCleared", cm, this, min, max);
      }
      if (withOp) {
        endOperation(cm);
      }
      if (this.parent) {
        this.parent.clear();
      }
    };
    TextMarker.prototype.find = function(side, lineObj) {
      if (side == null && this.type == "bookmark") {
        side = 1;
      }
      var from, to;
      for (var i2 = 0; i2 < this.lines.length; ++i2) {
        var line = this.lines[i2];
        var span = getMarkedSpanFor(line.markedSpans, this);
        if (span.from != null) {
          from = Pos(lineObj ? line : lineNo(line), span.from);
          if (side == -1) {
            return from;
          }
        }
        if (span.to != null) {
          to = Pos(lineObj ? line : lineNo(line), span.to);
          if (side == 1) {
            return to;
          }
        }
      }
      return from && {from, to};
    };
    TextMarker.prototype.changed = function() {
      var this$1 = this;
      var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
      if (!pos || !cm) {
        return;
      }
      runInOp(cm, function() {
        var line = pos.line, lineN = lineNo(pos.line);
        var view = findViewForLine(cm, lineN);
        if (view) {
          clearLineMeasurementCacheFor(view);
          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
        }
        cm.curOp.updateMaxLine = true;
        if (!lineIsHidden(widget.doc, line) && widget.height != null) {
          var oldHeight = widget.height;
          widget.height = null;
          var dHeight = widgetHeight(widget) - oldHeight;
          if (dHeight) {
            updateLineHeight(line, line.height + dHeight);
          }
        }
        signalLater(cm, "markerChanged", cm, this$1);
      });
    };
    TextMarker.prototype.attachLine = function(line) {
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
          (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
      }
      this.lines.push(line);
    };
    TextMarker.prototype.detachLine = function(line) {
      this.lines.splice(indexOf(this.lines, line), 1);
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
      }
    };
    eventMixin(TextMarker);
    function markText(doc, from, to, options, type) {
      if (options && options.shared) {
        return markTextShared(doc, from, to, options, type);
      }
      if (doc.cm && !doc.cm.curOp) {
        return operation(doc.cm, markText)(doc, from, to, options, type);
      }
      var marker = new TextMarker(doc, type), diff = cmp(from, to);
      if (options) {
        copyObj(options, marker, false);
      }
      if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
        return marker;
      }
      if (marker.replacedWith) {
        marker.collapsed = true;
        marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
        if (!options.handleMouseEvents) {
          marker.widgetNode.setAttribute("cm-ignore-events", "true");
        }
        if (options.insertLeft) {
          marker.widgetNode.insertLeft = true;
        }
      }
      if (marker.collapsed) {
        if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
          throw new Error("Inserting collapsed marker partially overlapping an existing one");
        }
        seeCollapsedSpans();
      }
      if (marker.addToHistory) {
        addChangeToHistory(doc, {from, to, origin: "markText"}, doc.sel, NaN);
      }
      var curLine = from.line, cm = doc.cm, updateMaxLine;
      doc.iter(curLine, to.line + 1, function(line) {
        if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
          updateMaxLine = true;
        }
        if (marker.collapsed && curLine != from.line) {
          updateLineHeight(line, 0);
        }
        addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
        ++curLine;
      });
      if (marker.collapsed) {
        doc.iter(from.line, to.line + 1, function(line) {
          if (lineIsHidden(doc, line)) {
            updateLineHeight(line, 0);
          }
        });
      }
      if (marker.clearOnEnter) {
        on3(marker, "beforeCursorEnter", function() {
          return marker.clear();
        });
      }
      if (marker.readOnly) {
        seeReadOnlySpans();
        if (doc.history.done.length || doc.history.undone.length) {
          doc.clearHistory();
        }
      }
      if (marker.collapsed) {
        marker.id = ++nextMarkerId;
        marker.atomic = true;
      }
      if (cm) {
        if (updateMaxLine) {
          cm.curOp.updateMaxLine = true;
        }
        if (marker.collapsed) {
          regChange(cm, from.line, to.line + 1);
        } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
          for (var i2 = from.line; i2 <= to.line; i2++) {
            regLineChange(cm, i2, "text");
          }
        }
        if (marker.atomic) {
          reCheckSelection(cm.doc);
        }
        signalLater(cm, "markerAdded", cm, marker);
      }
      return marker;
    }
    var SharedTextMarker = function(markers, primary) {
      this.markers = markers;
      this.primary = primary;
      for (var i2 = 0; i2 < markers.length; ++i2) {
        markers[i2].parent = this;
      }
    };
    SharedTextMarker.prototype.clear = function() {
      if (this.explicitlyCleared) {
        return;
      }
      this.explicitlyCleared = true;
      for (var i2 = 0; i2 < this.markers.length; ++i2) {
        this.markers[i2].clear();
      }
      signalLater(this, "clear");
    };
    SharedTextMarker.prototype.find = function(side, lineObj) {
      return this.primary.find(side, lineObj);
    };
    eventMixin(SharedTextMarker);
    function markTextShared(doc, from, to, options, type) {
      options = copyObj(options);
      options.shared = false;
      var markers = [markText(doc, from, to, options, type)], primary = markers[0];
      var widget = options.widgetNode;
      linkedDocs(doc, function(doc2) {
        if (widget) {
          options.widgetNode = widget.cloneNode(true);
        }
        markers.push(markText(doc2, clipPos(doc2, from), clipPos(doc2, to), options, type));
        for (var i2 = 0; i2 < doc2.linked.length; ++i2) {
          if (doc2.linked[i2].isParent) {
            return;
          }
        }
        primary = lst(markers);
      });
      return new SharedTextMarker(markers, primary);
    }
    function findSharedMarkers(doc) {
      return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
        return m.parent;
      });
    }
    function copySharedMarkers(doc, markers) {
      for (var i2 = 0; i2 < markers.length; i2++) {
        var marker = markers[i2], pos = marker.find();
        var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
        if (cmp(mFrom, mTo)) {
          var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
          marker.markers.push(subMark);
          subMark.parent = marker;
        }
      }
    }
    function detachSharedMarkers(markers) {
      var loop = function(i3) {
        var marker = markers[i3], linked = [marker.primary.doc];
        linkedDocs(marker.primary.doc, function(d) {
          return linked.push(d);
        });
        for (var j = 0; j < marker.markers.length; j++) {
          var subMarker = marker.markers[j];
          if (indexOf(linked, subMarker.doc) == -1) {
            subMarker.parent = null;
            marker.markers.splice(j--, 1);
          }
        }
      };
      for (var i2 = 0; i2 < markers.length; i2++)
        loop(i2);
    }
    var nextDocId = 0;
    var Doc = function(text2, mode, firstLine, lineSep, direction) {
      if (!(this instanceof Doc)) {
        return new Doc(text2, mode, firstLine, lineSep, direction);
      }
      if (firstLine == null) {
        firstLine = 0;
      }
      BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.cleanGeneration = 1;
      this.modeFrontier = this.highlightFrontier = firstLine;
      var start = Pos(firstLine, 0);
      this.sel = simpleSelection(start);
      this.history = new History(null);
      this.id = ++nextDocId;
      this.modeOption = mode;
      this.lineSep = lineSep;
      this.direction = direction == "rtl" ? "rtl" : "ltr";
      this.extend = false;
      if (typeof text2 == "string") {
        text2 = this.splitLines(text2);
      }
      updateDoc(this, {from: start, to: start, text: text2});
      setSelection(this, simpleSelection(start), sel_dontScroll);
    };
    Doc.prototype = createObj(BranchChunk.prototype, {
      constructor: Doc,
      iter: function(from, to, op) {
        if (op) {
          this.iterN(from - this.first, to - from, op);
        } else {
          this.iterN(this.first, this.first + this.size, from);
        }
      },
      insert: function(at, lines) {
        var height = 0;
        for (var i2 = 0; i2 < lines.length; ++i2) {
          height += lines[i2].height;
        }
        this.insertInner(at - this.first, lines, height);
      },
      remove: function(at, n) {
        this.removeInner(at - this.first, n);
      },
      getValue: function(lineSep) {
        var lines = getLines(this, this.first, this.first + this.size);
        if (lineSep === false) {
          return lines;
        }
        return lines.join(lineSep || this.lineSeparator());
      },
      setValue: docMethodOp(function(code) {
        var top = Pos(this.first, 0), last = this.first + this.size - 1;
        makeChange(this, {
          from: top,
          to: Pos(last, getLine(this, last).text.length),
          text: this.splitLines(code),
          origin: "setValue",
          full: true
        }, true);
        if (this.cm) {
          scrollToCoords(this.cm, 0, 0);
        }
        setSelection(this, simpleSelection(top), sel_dontScroll);
      }),
      replaceRange: function(code, from, to, origin) {
        from = clipPos(this, from);
        to = to ? clipPos(this, to) : from;
        replaceRange(this, code, from, to, origin);
      },
      getRange: function(from, to, lineSep) {
        var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
        if (lineSep === false) {
          return lines;
        }
        if (lineSep === "") {
          return lines.join("");
        }
        return lines.join(lineSep || this.lineSeparator());
      },
      getLine: function(line) {
        var l = this.getLineHandle(line);
        return l && l.text;
      },
      getLineHandle: function(line) {
        if (isLine(this, line)) {
          return getLine(this, line);
        }
      },
      getLineNumber: function(line) {
        return lineNo(line);
      },
      getLineHandleVisualStart: function(line) {
        if (typeof line == "number") {
          line = getLine(this, line);
        }
        return visualLine(line);
      },
      lineCount: function() {
        return this.size;
      },
      firstLine: function() {
        return this.first;
      },
      lastLine: function() {
        return this.first + this.size - 1;
      },
      clipPos: function(pos) {
        return clipPos(this, pos);
      },
      getCursor: function(start) {
        var range2 = this.sel.primary(), pos;
        if (start == null || start == "head") {
          pos = range2.head;
        } else if (start == "anchor") {
          pos = range2.anchor;
        } else if (start == "end" || start == "to" || start === false) {
          pos = range2.to();
        } else {
          pos = range2.from();
        }
        return pos;
      },
      listSelections: function() {
        return this.sel.ranges;
      },
      somethingSelected: function() {
        return this.sel.somethingSelected();
      },
      setCursor: docMethodOp(function(line, ch, options) {
        setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
      }),
      setSelection: docMethodOp(function(anchor, head, options) {
        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
      }),
      extendSelection: docMethodOp(function(head, other, options) {
        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
      }),
      extendSelections: docMethodOp(function(heads, options) {
        extendSelections(this, clipPosArray(this, heads), options);
      }),
      extendSelectionsBy: docMethodOp(function(f, options) {
        var heads = map2(this.sel.ranges, f);
        extendSelections(this, clipPosArray(this, heads), options);
      }),
      setSelections: docMethodOp(function(ranges, primary, options) {
        if (!ranges.length) {
          return;
        }
        var out = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          out[i2] = new Range(clipPos(this, ranges[i2].anchor), clipPos(this, ranges[i2].head || ranges[i2].anchor));
        }
        if (primary == null) {
          primary = Math.min(ranges.length - 1, this.sel.primIndex);
        }
        setSelection(this, normalizeSelection(this.cm, out, primary), options);
      }),
      addSelection: docMethodOp(function(anchor, head, options) {
        var ranges = this.sel.ranges.slice(0);
        ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
        setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
      }),
      getSelection: function(lineSep) {
        var ranges = this.sel.ranges, lines;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
          lines = lines ? lines.concat(sel) : sel;
        }
        if (lineSep === false) {
          return lines;
        } else {
          return lines.join(lineSep || this.lineSeparator());
        }
      },
      getSelections: function(lineSep) {
        var parts = [], ranges = this.sel.ranges;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
          if (lineSep !== false) {
            sel = sel.join(lineSep || this.lineSeparator());
          }
          parts[i2] = sel;
        }
        return parts;
      },
      replaceSelection: function(code, collapse, origin) {
        var dup = [];
        for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
          dup[i2] = code;
        }
        this.replaceSelections(dup, collapse, origin || "+input");
      },
      replaceSelections: docMethodOp(function(code, collapse, origin) {
        var changes = [], sel = this.sel;
        for (var i2 = 0; i2 < sel.ranges.length; i2++) {
          var range2 = sel.ranges[i2];
          changes[i2] = {from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin};
        }
        var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
        for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
          makeChange(this, changes[i$12]);
        }
        if (newSel) {
          setSelectionReplaceHistory(this, newSel);
        } else if (this.cm) {
          ensureCursorVisible(this.cm);
        }
      }),
      undo: docMethodOp(function() {
        makeChangeFromHistory(this, "undo");
      }),
      redo: docMethodOp(function() {
        makeChangeFromHistory(this, "redo");
      }),
      undoSelection: docMethodOp(function() {
        makeChangeFromHistory(this, "undo", true);
      }),
      redoSelection: docMethodOp(function() {
        makeChangeFromHistory(this, "redo", true);
      }),
      setExtending: function(val) {
        this.extend = val;
      },
      getExtending: function() {
        return this.extend;
      },
      historySize: function() {
        var hist = this.history, done = 0, undone = 0;
        for (var i2 = 0; i2 < hist.done.length; i2++) {
          if (!hist.done[i2].ranges) {
            ++done;
          }
        }
        for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
          if (!hist.undone[i$12].ranges) {
            ++undone;
          }
        }
        return {undo: done, redo: undone};
      },
      clearHistory: function() {
        var this$1 = this;
        this.history = new History(this.history);
        linkedDocs(this, function(doc) {
          return doc.history = this$1.history;
        }, true);
      },
      markClean: function() {
        this.cleanGeneration = this.changeGeneration(true);
      },
      changeGeneration: function(forceSplit) {
        if (forceSplit) {
          this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
        }
        return this.history.generation;
      },
      isClean: function(gen) {
        return this.history.generation == (gen || this.cleanGeneration);
      },
      getHistory: function() {
        return {
          done: copyHistoryArray(this.history.done),
          undone: copyHistoryArray(this.history.undone)
        };
      },
      setHistory: function(histData) {
        var hist = this.history = new History(this.history);
        hist.done = copyHistoryArray(histData.done.slice(0), null, true);
        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
      },
      setGutterMarker: docMethodOp(function(line, gutterID, value) {
        return changeLine(this, line, "gutter", function(line2) {
          var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
          markers[gutterID] = value;
          if (!value && isEmpty2(markers)) {
            line2.gutterMarkers = null;
          }
          return true;
        });
      }),
      clearGutter: docMethodOp(function(gutterID) {
        var this$1 = this;
        this.iter(function(line) {
          if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
            changeLine(this$1, line, "gutter", function() {
              line.gutterMarkers[gutterID] = null;
              if (isEmpty2(line.gutterMarkers)) {
                line.gutterMarkers = null;
              }
              return true;
            });
          }
        });
      }),
      lineInfo: function(line) {
        var n;
        if (typeof line == "number") {
          if (!isLine(this, line)) {
            return null;
          }
          n = line;
          line = getLine(this, line);
          if (!line) {
            return null;
          }
        } else {
          n = lineNo(line);
          if (n == null) {
            return null;
          }
        }
        return {
          line: n,
          handle: line,
          text: line.text,
          gutterMarkers: line.gutterMarkers,
          textClass: line.textClass,
          bgClass: line.bgClass,
          wrapClass: line.wrapClass,
          widgets: line.widgets
        };
      },
      addLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
          var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
          if (!line[prop2]) {
            line[prop2] = cls;
          } else if (classTest(cls).test(line[prop2])) {
            return false;
          } else {
            line[prop2] += " " + cls;
          }
          return true;
        });
      }),
      removeLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
          var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
          var cur = line[prop2];
          if (!cur) {
            return false;
          } else if (cls == null) {
            line[prop2] = null;
          } else {
            var found = cur.match(classTest(cls));
            if (!found) {
              return false;
            }
            var end = found.index + found[0].length;
            line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
          }
          return true;
        });
      }),
      addLineWidget: docMethodOp(function(handle, node, options) {
        return addLineWidget(this, handle, node, options);
      }),
      removeLineWidget: function(widget) {
        widget.clear();
      },
      markText: function(from, to, options) {
        return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
      },
      setBookmark: function(pos, options) {
        var realOpts = {
          replacedWith: options && (options.nodeType == null ? options.widget : options),
          insertLeft: options && options.insertLeft,
          clearWhenEmpty: false,
          shared: options && options.shared,
          handleMouseEvents: options && options.handleMouseEvents
        };
        pos = clipPos(this, pos);
        return markText(this, pos, pos, realOpts, "bookmark");
      },
      findMarksAt: function(pos) {
        pos = clipPos(this, pos);
        var markers = [], spans = getLine(this, pos.line).markedSpans;
        if (spans) {
          for (var i2 = 0; i2 < spans.length; ++i2) {
            var span = spans[i2];
            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
              markers.push(span.marker.parent || span.marker);
            }
          }
        }
        return markers;
      },
      findMarks: function(from, to, filter) {
        from = clipPos(this, from);
        to = clipPos(this, to);
        var found = [], lineNo2 = from.line;
        this.iter(from.line, to.line + 1, function(line) {
          var spans = line.markedSpans;
          if (spans) {
            for (var i2 = 0; i2 < spans.length; i2++) {
              var span = spans[i2];
              if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                found.push(span.marker.parent || span.marker);
              }
            }
          }
          ++lineNo2;
        });
        return found;
      },
      getAllMarks: function() {
        var markers = [];
        this.iter(function(line) {
          var sps = line.markedSpans;
          if (sps) {
            for (var i2 = 0; i2 < sps.length; ++i2) {
              if (sps[i2].from != null) {
                markers.push(sps[i2].marker);
              }
            }
          }
        });
        return markers;
      },
      posFromIndex: function(off3) {
        var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
        this.iter(function(line) {
          var sz = line.text.length + sepSize;
          if (sz > off3) {
            ch = off3;
            return true;
          }
          off3 -= sz;
          ++lineNo2;
        });
        return clipPos(this, Pos(lineNo2, ch));
      },
      indexFromPos: function(coords) {
        coords = clipPos(this, coords);
        var index2 = coords.ch;
        if (coords.line < this.first || coords.ch < 0) {
          return 0;
        }
        var sepSize = this.lineSeparator().length;
        this.iter(this.first, coords.line, function(line) {
          index2 += line.text.length + sepSize;
        });
        return index2;
      },
      copy: function(copyHistory) {
        var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
        doc.scrollTop = this.scrollTop;
        doc.scrollLeft = this.scrollLeft;
        doc.sel = this.sel;
        doc.extend = false;
        if (copyHistory) {
          doc.history.undoDepth = this.history.undoDepth;
          doc.setHistory(this.getHistory());
        }
        return doc;
      },
      linkedDoc: function(options) {
        if (!options) {
          options = {};
        }
        var from = this.first, to = this.first + this.size;
        if (options.from != null && options.from > from) {
          from = options.from;
        }
        if (options.to != null && options.to < to) {
          to = options.to;
        }
        var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
        if (options.sharedHist) {
          copy.history = this.history;
        }
        (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
        copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
        copySharedMarkers(copy, findSharedMarkers(this));
        return copy;
      },
      unlinkDoc: function(other) {
        if (other instanceof CodeMirror2) {
          other = other.doc;
        }
        if (this.linked) {
          for (var i2 = 0; i2 < this.linked.length; ++i2) {
            var link = this.linked[i2];
            if (link.doc != other) {
              continue;
            }
            this.linked.splice(i2, 1);
            other.unlinkDoc(this);
            detachSharedMarkers(findSharedMarkers(this));
            break;
          }
        }
        if (other.history == this.history) {
          var splitIds = [other.id];
          linkedDocs(other, function(doc) {
            return splitIds.push(doc.id);
          }, true);
          other.history = new History(null);
          other.history.done = copyHistoryArray(this.history.done, splitIds);
          other.history.undone = copyHistoryArray(this.history.undone, splitIds);
        }
      },
      iterLinkedDocs: function(f) {
        linkedDocs(this, f);
      },
      getMode: function() {
        return this.mode;
      },
      getEditor: function() {
        return this.cm;
      },
      splitLines: function(str) {
        if (this.lineSep) {
          return str.split(this.lineSep);
        }
        return splitLinesAuto(str);
      },
      lineSeparator: function() {
        return this.lineSep || "\n";
      },
      setDirection: docMethodOp(function(dir) {
        if (dir != "rtl") {
          dir = "ltr";
        }
        if (dir == this.direction) {
          return;
        }
        this.direction = dir;
        this.iter(function(line) {
          return line.order = null;
        });
        if (this.cm) {
          directionChanged(this.cm);
        }
      })
    });
    Doc.prototype.eachLine = Doc.prototype.iter;
    var lastDrop = 0;
    function onDrop(e) {
      var cm = this;
      clearDragCursor(cm);
      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
        return;
      }
      e_preventDefault(e);
      if (ie) {
        lastDrop = +new Date();
      }
      var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
      if (!pos || cm.isReadOnly()) {
        return;
      }
      if (files && files.length && window.FileReader && window.File) {
        var n = files.length, text2 = Array(n), read = 0;
        var markAsReadAndPasteIfAllFilesAreRead = function() {
          if (++read == n) {
            operation(cm, function() {
              pos = clipPos(cm.doc, pos);
              var change = {
                from: pos,
                to: pos,
                text: cm.doc.splitLines(text2.filter(function(t) {
                  return t != null;
                }).join(cm.doc.lineSeparator())),
                origin: "paste"
              };
              makeChange(cm.doc, change);
              setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
            })();
          }
        };
        var readTextFromFile = function(file2, i3) {
          if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file2.type) == -1) {
            markAsReadAndPasteIfAllFilesAreRead();
            return;
          }
          var reader = new FileReader();
          reader.onerror = function() {
            return markAsReadAndPasteIfAllFilesAreRead();
          };
          reader.onload = function() {
            var content = reader.result;
            if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
              markAsReadAndPasteIfAllFilesAreRead();
              return;
            }
            text2[i3] = content;
            markAsReadAndPasteIfAllFilesAreRead();
          };
          reader.readAsText(file2);
        };
        for (var i2 = 0; i2 < files.length; i2++) {
          readTextFromFile(files[i2], i2);
        }
      } else {
        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
          cm.state.draggingText(e);
          setTimeout(function() {
            return cm.display.input.focus();
          }, 20);
          return;
        }
        try {
          var text$12 = e.dataTransfer.getData("Text");
          if (text$12) {
            var selected;
            if (cm.state.draggingText && !cm.state.draggingText.copy) {
              selected = cm.listSelections();
            }
            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
            if (selected) {
              for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
              }
            }
            cm.replaceSelection(text$12, "around", "paste");
            cm.display.input.focus();
          }
        } catch (e$1) {
        }
      }
    }
    function onDragStart(cm, e) {
      if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
        e_stop(e);
        return;
      }
      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
        return;
      }
      e.dataTransfer.setData("Text", cm.getSelection());
      e.dataTransfer.effectAllowed = "copyMove";
      if (e.dataTransfer.setDragImage && !safari) {
        var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
        img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (presto) {
          img.width = img.height = 1;
          cm.display.wrapper.appendChild(img);
          img._top = img.offsetTop;
        }
        e.dataTransfer.setDragImage(img, 0, 0);
        if (presto) {
          img.parentNode.removeChild(img);
        }
      }
    }
    function onDragOver(cm, e) {
      var pos = posFromMouse(cm, e);
      if (!pos) {
        return;
      }
      var frag = document.createDocumentFragment();
      drawSelectionCursor(cm, pos, frag);
      if (!cm.display.dragCursor) {
        cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
      }
      removeChildrenAndAdd(cm.display.dragCursor, frag);
    }
    function clearDragCursor(cm) {
      if (cm.display.dragCursor) {
        cm.display.lineSpace.removeChild(cm.display.dragCursor);
        cm.display.dragCursor = null;
      }
    }
    function forEachCodeMirror(f) {
      if (!document.getElementsByClassName) {
        return;
      }
      var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
      for (var i2 = 0; i2 < byClass.length; i2++) {
        var cm = byClass[i2].CodeMirror;
        if (cm) {
          editors.push(cm);
        }
      }
      if (editors.length) {
        editors[0].operation(function() {
          for (var i3 = 0; i3 < editors.length; i3++) {
            f(editors[i3]);
          }
        });
      }
    }
    var globalsRegistered = false;
    function ensureGlobalHandlers() {
      if (globalsRegistered) {
        return;
      }
      registerGlobalHandlers();
      globalsRegistered = true;
    }
    function registerGlobalHandlers() {
      var resizeTimer;
      on3(window, "resize", function() {
        if (resizeTimer == null) {
          resizeTimer = setTimeout(function() {
            resizeTimer = null;
            forEachCodeMirror(onResize);
          }, 100);
        }
      });
      on3(window, "blur", function() {
        return forEachCodeMirror(onBlur);
      });
    }
    function onResize(cm) {
      var d = cm.display;
      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
      d.scrollbarsClipped = false;
      cm.setSize();
    }
    var keyNames = {
      3: "Pause",
      8: "Backspace",
      9: "Tab",
      13: "Enter",
      16: "Shift",
      17: "Ctrl",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Esc",
      32: "Space",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "Left",
      38: "Up",
      39: "Right",
      40: "Down",
      44: "PrintScrn",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Mod",
      92: "Mod",
      93: "Mod",
      106: "*",
      107: "=",
      109: "-",
      110: ".",
      111: "/",
      145: "ScrollLock",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'",
      224: "Mod",
      63232: "Up",
      63233: "Down",
      63234: "Left",
      63235: "Right",
      63272: "Delete",
      63273: "Home",
      63275: "End",
      63276: "PageUp",
      63277: "PageDown",
      63302: "Insert"
    };
    for (var i = 0; i < 10; i++) {
      keyNames[i + 48] = keyNames[i + 96] = String(i);
    }
    for (var i$1 = 65; i$1 <= 90; i$1++) {
      keyNames[i$1] = String.fromCharCode(i$1);
    }
    for (var i$2 = 1; i$2 <= 12; i$2++) {
      keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
    }
    var keyMap = {};
    keyMap.basic = {
      Left: "goCharLeft",
      Right: "goCharRight",
      Up: "goLineUp",
      Down: "goLineDown",
      End: "goLineEnd",
      Home: "goLineStartSmart",
      PageUp: "goPageUp",
      PageDown: "goPageDown",
      Delete: "delCharAfter",
      Backspace: "delCharBefore",
      "Shift-Backspace": "delCharBefore",
      Tab: "defaultTab",
      "Shift-Tab": "indentAuto",
      Enter: "newlineAndIndent",
      Insert: "toggleOverwrite",
      Esc: "singleSelection"
    };
    keyMap.pcDefault = {
      "Ctrl-A": "selectAll",
      "Ctrl-D": "deleteLine",
      "Ctrl-Z": "undo",
      "Shift-Ctrl-Z": "redo",
      "Ctrl-Y": "redo",
      "Ctrl-Home": "goDocStart",
      "Ctrl-End": "goDocEnd",
      "Ctrl-Up": "goLineUp",
      "Ctrl-Down": "goLineDown",
      "Ctrl-Left": "goGroupLeft",
      "Ctrl-Right": "goGroupRight",
      "Alt-Left": "goLineStart",
      "Alt-Right": "goLineEnd",
      "Ctrl-Backspace": "delGroupBefore",
      "Ctrl-Delete": "delGroupAfter",
      "Ctrl-S": "save",
      "Ctrl-F": "find",
      "Ctrl-G": "findNext",
      "Shift-Ctrl-G": "findPrev",
      "Shift-Ctrl-F": "replace",
      "Shift-Ctrl-R": "replaceAll",
      "Ctrl-[": "indentLess",
      "Ctrl-]": "indentMore",
      "Ctrl-U": "undoSelection",
      "Shift-Ctrl-U": "redoSelection",
      "Alt-U": "redoSelection",
      fallthrough: "basic"
    };
    keyMap.emacsy = {
      "Ctrl-F": "goCharRight",
      "Ctrl-B": "goCharLeft",
      "Ctrl-P": "goLineUp",
      "Ctrl-N": "goLineDown",
      "Ctrl-A": "goLineStart",
      "Ctrl-E": "goLineEnd",
      "Ctrl-V": "goPageDown",
      "Shift-Ctrl-V": "goPageUp",
      "Ctrl-D": "delCharAfter",
      "Ctrl-H": "delCharBefore",
      "Alt-Backspace": "delWordBefore",
      "Ctrl-K": "killLine",
      "Ctrl-T": "transposeChars",
      "Ctrl-O": "openLine"
    };
    keyMap.macDefault = {
      "Cmd-A": "selectAll",
      "Cmd-D": "deleteLine",
      "Cmd-Z": "undo",
      "Shift-Cmd-Z": "redo",
      "Cmd-Y": "redo",
      "Cmd-Home": "goDocStart",
      "Cmd-Up": "goDocStart",
      "Cmd-End": "goDocEnd",
      "Cmd-Down": "goDocEnd",
      "Alt-Left": "goGroupLeft",
      "Alt-Right": "goGroupRight",
      "Cmd-Left": "goLineLeft",
      "Cmd-Right": "goLineRight",
      "Alt-Backspace": "delGroupBefore",
      "Ctrl-Alt-Backspace": "delGroupAfter",
      "Alt-Delete": "delGroupAfter",
      "Cmd-S": "save",
      "Cmd-F": "find",
      "Cmd-G": "findNext",
      "Shift-Cmd-G": "findPrev",
      "Cmd-Alt-F": "replace",
      "Shift-Cmd-Alt-F": "replaceAll",
      "Cmd-[": "indentLess",
      "Cmd-]": "indentMore",
      "Cmd-Backspace": "delWrappedLineLeft",
      "Cmd-Delete": "delWrappedLineRight",
      "Cmd-U": "undoSelection",
      "Shift-Cmd-U": "redoSelection",
      "Ctrl-Up": "goDocStart",
      "Ctrl-Down": "goDocEnd",
      fallthrough: ["basic", "emacsy"]
    };
    keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
    function normalizeKeyName(name2) {
      var parts = name2.split(/-(?!$)/);
      name2 = parts[parts.length - 1];
      var alt, ctrl, shift, cmd;
      for (var i2 = 0; i2 < parts.length - 1; i2++) {
        var mod = parts[i2];
        if (/^(cmd|meta|m)$/i.test(mod)) {
          cmd = true;
        } else if (/^a(lt)?$/i.test(mod)) {
          alt = true;
        } else if (/^(c|ctrl|control)$/i.test(mod)) {
          ctrl = true;
        } else if (/^s(hift)?$/i.test(mod)) {
          shift = true;
        } else {
          throw new Error("Unrecognized modifier name: " + mod);
        }
      }
      if (alt) {
        name2 = "Alt-" + name2;
      }
      if (ctrl) {
        name2 = "Ctrl-" + name2;
      }
      if (cmd) {
        name2 = "Cmd-" + name2;
      }
      if (shift) {
        name2 = "Shift-" + name2;
      }
      return name2;
    }
    function normalizeKeyMap(keymap) {
      var copy = {};
      for (var keyname in keymap) {
        if (keymap.hasOwnProperty(keyname)) {
          var value = keymap[keyname];
          if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
            continue;
          }
          if (value == "...") {
            delete keymap[keyname];
            continue;
          }
          var keys = map2(keyname.split(" "), normalizeKeyName);
          for (var i2 = 0; i2 < keys.length; i2++) {
            var val = void 0, name2 = void 0;
            if (i2 == keys.length - 1) {
              name2 = keys.join(" ");
              val = value;
            } else {
              name2 = keys.slice(0, i2 + 1).join(" ");
              val = "...";
            }
            var prev = copy[name2];
            if (!prev) {
              copy[name2] = val;
            } else if (prev != val) {
              throw new Error("Inconsistent bindings for " + name2);
            }
          }
          delete keymap[keyname];
        }
      }
      for (var prop2 in copy) {
        keymap[prop2] = copy[prop2];
      }
      return keymap;
    }
    function lookupKey(key, map3, handle, context) {
      map3 = getKeyMap(map3);
      var found = map3.call ? map3.call(key, context) : map3[key];
      if (found === false) {
        return "nothing";
      }
      if (found === "...") {
        return "multi";
      }
      if (found != null && handle(found)) {
        return "handled";
      }
      if (map3.fallthrough) {
        if (Object.prototype.toString.call(map3.fallthrough) != "[object Array]") {
          return lookupKey(key, map3.fallthrough, handle, context);
        }
        for (var i2 = 0; i2 < map3.fallthrough.length; i2++) {
          var result = lookupKey(key, map3.fallthrough[i2], handle, context);
          if (result) {
            return result;
          }
        }
      }
    }
    function isModifierKey(value) {
      var name2 = typeof value == "string" ? value : keyNames[value.keyCode];
      return name2 == "Ctrl" || name2 == "Alt" || name2 == "Shift" || name2 == "Mod";
    }
    function addModifierNames(name2, event, noShift) {
      var base = name2;
      if (event.altKey && base != "Alt") {
        name2 = "Alt-" + name2;
      }
      if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
        name2 = "Ctrl-" + name2;
      }
      if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
        name2 = "Cmd-" + name2;
      }
      if (!noShift && event.shiftKey && base != "Shift") {
        name2 = "Shift-" + name2;
      }
      return name2;
    }
    function keyName(event, noShift) {
      if (presto && event.keyCode == 34 && event["char"]) {
        return false;
      }
      var name2 = keyNames[event.keyCode];
      if (name2 == null || event.altGraphKey) {
        return false;
      }
      if (event.keyCode == 3 && event.code) {
        name2 = event.code;
      }
      return addModifierNames(name2, event, noShift);
    }
    function getKeyMap(val) {
      return typeof val == "string" ? keyMap[val] : val;
    }
    function deleteNearSelection(cm, compute) {
      var ranges = cm.doc.sel.ranges, kill = [];
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var toKill = compute(ranges[i2]);
        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
          var replaced = kill.pop();
          if (cmp(replaced.from, toKill.from) < 0) {
            toKill.from = replaced.from;
            break;
          }
        }
        kill.push(toKill);
      }
      runInOp(cm, function() {
        for (var i3 = kill.length - 1; i3 >= 0; i3--) {
          replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");
        }
        ensureCursorVisible(cm);
      });
    }
    function moveCharLogically(line, ch, dir) {
      var target = skipExtendingChars(line.text, ch + dir, dir);
      return target < 0 || target > line.text.length ? null : target;
    }
    function moveLogically(line, start, dir) {
      var ch = moveCharLogically(line, start.ch, dir);
      return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
    }
    function endOfLine(visually, cm, lineObj, lineNo2, dir) {
      if (visually) {
        if (cm.doc.direction == "rtl") {
          dir = -dir;
        }
        var order = getOrder(lineObj, cm.doc.direction);
        if (order) {
          var part = dir < 0 ? lst(order) : order[0];
          var moveInStorageOrder = dir < 0 == (part.level == 1);
          var sticky = moveInStorageOrder ? "after" : "before";
          var ch;
          if (part.level > 0 || cm.doc.direction == "rtl") {
            var prep = prepareMeasureForLine(cm, lineObj);
            ch = dir < 0 ? lineObj.text.length - 1 : 0;
            var targetTop = measureCharPrepared(cm, prep, ch).top;
            ch = findFirst(function(ch2) {
              return measureCharPrepared(cm, prep, ch2).top == targetTop;
            }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
            if (sticky == "before") {
              ch = moveCharLogically(lineObj, ch, 1);
            }
          } else {
            ch = dir < 0 ? part.to : part.from;
          }
          return new Pos(lineNo2, ch, sticky);
        }
      }
      return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
    }
    function moveVisually(cm, line, start, dir) {
      var bidi = getOrder(line, cm.doc.direction);
      if (!bidi) {
        return moveLogically(line, start, dir);
      }
      if (start.ch >= line.text.length) {
        start.ch = line.text.length;
        start.sticky = "before";
      } else if (start.ch <= 0) {
        start.ch = 0;
        start.sticky = "after";
      }
      var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
      if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
        return moveLogically(line, start, dir);
      }
      var mv = function(pos, dir2) {
        return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
      };
      var prep;
      var getWrappedLineExtent = function(ch2) {
        if (!cm.options.lineWrapping) {
          return {begin: 0, end: line.text.length};
        }
        prep = prep || prepareMeasureForLine(cm, line);
        return wrappedLineExtentChar(cm, line, prep, ch2);
      };
      var wrappedLineExtent2 = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
      if (cm.doc.direction == "rtl" || part.level == 1) {
        var moveInStorageOrder = part.level == 1 == dir < 0;
        var ch = mv(start, moveInStorageOrder ? 1 : -1);
        if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
          var sticky = moveInStorageOrder ? "before" : "after";
          return new Pos(start.line, ch, sticky);
        }
      }
      var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
        var getRes = function(ch3, moveInStorageOrder3) {
          return moveInStorageOrder3 ? new Pos(start.line, mv(ch3, 1), "before") : new Pos(start.line, ch3, "after");
        };
        for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
          var part2 = bidi[partPos2];
          var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
          var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
          if (part2.from <= ch2 && ch2 < part2.to) {
            return getRes(ch2, moveInStorageOrder2);
          }
          ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
          if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
            return getRes(ch2, moveInStorageOrder2);
          }
        }
      };
      var res2 = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
      if (res2) {
        return res2;
      }
      var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
      if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
        res2 = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
        if (res2) {
          return res2;
        }
      }
      return null;
    }
    var commands = {
      selectAll,
      singleSelection: function(cm) {
        return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
      },
      killLine: function(cm) {
        return deleteNearSelection(cm, function(range2) {
          if (range2.empty()) {
            var len = getLine(cm.doc, range2.head.line).text.length;
            if (range2.head.ch == len && range2.head.line < cm.lastLine()) {
              return {from: range2.head, to: Pos(range2.head.line + 1, 0)};
            } else {
              return {from: range2.head, to: Pos(range2.head.line, len)};
            }
          } else {
            return {from: range2.from(), to: range2.to()};
          }
        });
      },
      deleteLine: function(cm) {
        return deleteNearSelection(cm, function(range2) {
          return {
            from: Pos(range2.from().line, 0),
            to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
          };
        });
      },
      delLineLeft: function(cm) {
        return deleteNearSelection(cm, function(range2) {
          return {
            from: Pos(range2.from().line, 0),
            to: range2.from()
          };
        });
      },
      delWrappedLineLeft: function(cm) {
        return deleteNearSelection(cm, function(range2) {
          var top = cm.charCoords(range2.head, "div").top + 5;
          var leftPos = cm.coordsChar({left: 0, top}, "div");
          return {from: leftPos, to: range2.from()};
        });
      },
      delWrappedLineRight: function(cm) {
        return deleteNearSelection(cm, function(range2) {
          var top = cm.charCoords(range2.head, "div").top + 5;
          var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top}, "div");
          return {from: range2.from(), to: rightPos};
        });
      },
      undo: function(cm) {
        return cm.undo();
      },
      redo: function(cm) {
        return cm.redo();
      },
      undoSelection: function(cm) {
        return cm.undoSelection();
      },
      redoSelection: function(cm) {
        return cm.redoSelection();
      },
      goDocStart: function(cm) {
        return cm.extendSelection(Pos(cm.firstLine(), 0));
      },
      goDocEnd: function(cm) {
        return cm.extendSelection(Pos(cm.lastLine()));
      },
      goLineStart: function(cm) {
        return cm.extendSelectionsBy(function(range2) {
          return lineStart(cm, range2.head.line);
        }, {origin: "+move", bias: 1});
      },
      goLineStartSmart: function(cm) {
        return cm.extendSelectionsBy(function(range2) {
          return lineStartSmart(cm, range2.head);
        }, {origin: "+move", bias: 1});
      },
      goLineEnd: function(cm) {
        return cm.extendSelectionsBy(function(range2) {
          return lineEnd(cm, range2.head.line);
        }, {origin: "+move", bias: -1});
      },
      goLineRight: function(cm) {
        return cm.extendSelectionsBy(function(range2) {
          var top = cm.cursorCoords(range2.head, "div").top + 5;
          return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top}, "div");
        }, sel_move);
      },
      goLineLeft: function(cm) {
        return cm.extendSelectionsBy(function(range2) {
          var top = cm.cursorCoords(range2.head, "div").top + 5;
          return cm.coordsChar({left: 0, top}, "div");
        }, sel_move);
      },
      goLineLeftSmart: function(cm) {
        return cm.extendSelectionsBy(function(range2) {
          var top = cm.cursorCoords(range2.head, "div").top + 5;
          var pos = cm.coordsChar({left: 0, top}, "div");
          if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
            return lineStartSmart(cm, range2.head);
          }
          return pos;
        }, sel_move);
      },
      goLineUp: function(cm) {
        return cm.moveV(-1, "line");
      },
      goLineDown: function(cm) {
        return cm.moveV(1, "line");
      },
      goPageUp: function(cm) {
        return cm.moveV(-1, "page");
      },
      goPageDown: function(cm) {
        return cm.moveV(1, "page");
      },
      goCharLeft: function(cm) {
        return cm.moveH(-1, "char");
      },
      goCharRight: function(cm) {
        return cm.moveH(1, "char");
      },
      goColumnLeft: function(cm) {
        return cm.moveH(-1, "column");
      },
      goColumnRight: function(cm) {
        return cm.moveH(1, "column");
      },
      goWordLeft: function(cm) {
        return cm.moveH(-1, "word");
      },
      goGroupRight: function(cm) {
        return cm.moveH(1, "group");
      },
      goGroupLeft: function(cm) {
        return cm.moveH(-1, "group");
      },
      goWordRight: function(cm) {
        return cm.moveH(1, "word");
      },
      delCharBefore: function(cm) {
        return cm.deleteH(-1, "codepoint");
      },
      delCharAfter: function(cm) {
        return cm.deleteH(1, "char");
      },
      delWordBefore: function(cm) {
        return cm.deleteH(-1, "word");
      },
      delWordAfter: function(cm) {
        return cm.deleteH(1, "word");
      },
      delGroupBefore: function(cm) {
        return cm.deleteH(-1, "group");
      },
      delGroupAfter: function(cm) {
        return cm.deleteH(1, "group");
      },
      indentAuto: function(cm) {
        return cm.indentSelection("smart");
      },
      indentMore: function(cm) {
        return cm.indentSelection("add");
      },
      indentLess: function(cm) {
        return cm.indentSelection("subtract");
      },
      insertTab: function(cm) {
        return cm.replaceSelection("	");
      },
      insertSoftTab: function(cm) {
        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var pos = ranges[i2].from();
          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
          spaces.push(spaceStr(tabSize - col % tabSize));
        }
        cm.replaceSelections(spaces);
      },
      defaultTab: function(cm) {
        if (cm.somethingSelected()) {
          cm.indentSelection("add");
        } else {
          cm.execCommand("insertTab");
        }
      },
      transposeChars: function(cm) {
        return runInOp(cm, function() {
          var ranges = cm.listSelections(), newSel = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            if (!ranges[i2].empty()) {
              continue;
            }
            var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
            if (line) {
              if (cur.ch == line.length) {
                cur = new Pos(cur.line, cur.ch - 1);
              }
              if (cur.ch > 0) {
                cur = new Pos(cur.line, cur.ch + 1);
                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
              } else if (cur.line > cm.doc.first) {
                var prev = getLine(cm.doc, cur.line - 1).text;
                if (prev) {
                  cur = new Pos(cur.line, 1);
                  cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                }
              }
            }
            newSel.push(new Range(cur, cur));
          }
          cm.setSelections(newSel);
        });
      },
      newlineAndIndent: function(cm) {
        return runInOp(cm, function() {
          var sels = cm.listSelections();
          for (var i2 = sels.length - 1; i2 >= 0; i2--) {
            cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
          }
          sels = cm.listSelections();
          for (var i$12 = 0; i$12 < sels.length; i$12++) {
            cm.indentLine(sels[i$12].from().line, null, true);
          }
          ensureCursorVisible(cm);
        });
      },
      openLine: function(cm) {
        return cm.replaceSelection("\n", "start");
      },
      toggleOverwrite: function(cm) {
        return cm.toggleOverwrite();
      }
    };
    function lineStart(cm, lineN) {
      var line = getLine(cm.doc, lineN);
      var visual = visualLine(line);
      if (visual != line) {
        lineN = lineNo(visual);
      }
      return endOfLine(true, cm, visual, lineN, 1);
    }
    function lineEnd(cm, lineN) {
      var line = getLine(cm.doc, lineN);
      var visual = visualLineEnd(line);
      if (visual != line) {
        lineN = lineNo(visual);
      }
      return endOfLine(true, cm, line, lineN, -1);
    }
    function lineStartSmart(cm, pos) {
      var start = lineStart(cm, pos.line);
      var line = getLine(cm.doc, start.line);
      var order = getOrder(line, cm.doc.direction);
      if (!order || order[0].level == 0) {
        var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
        var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
        return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
      }
      return start;
    }
    function doHandleBinding(cm, bound, dropShift) {
      if (typeof bound == "string") {
        bound = commands[bound];
        if (!bound) {
          return false;
        }
      }
      cm.display.input.ensurePolled();
      var prevShift = cm.display.shift, done = false;
      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }
        if (dropShift) {
          cm.display.shift = false;
        }
        done = bound(cm) != Pass;
      } finally {
        cm.display.shift = prevShift;
        cm.state.suppressEdits = false;
      }
      return done;
    }
    function lookupKeyForEditor(cm, name2, handle) {
      for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
        var result = lookupKey(name2, cm.state.keyMaps[i2], handle, cm);
        if (result) {
          return result;
        }
      }
      return cm.options.extraKeys && lookupKey(name2, cm.options.extraKeys, handle, cm) || lookupKey(name2, cm.options.keyMap, handle, cm);
    }
    var stopSeq = new Delayed();
    function dispatchKey(cm, name2, e, handle) {
      var seq = cm.state.keySeq;
      if (seq) {
        if (isModifierKey(name2)) {
          return "handled";
        }
        if (/\'$/.test(name2)) {
          cm.state.keySeq = null;
        } else {
          stopSeq.set(50, function() {
            if (cm.state.keySeq == seq) {
              cm.state.keySeq = null;
              cm.display.input.reset();
            }
          });
        }
        if (dispatchKeyInner(cm, seq + " " + name2, e, handle)) {
          return true;
        }
      }
      return dispatchKeyInner(cm, name2, e, handle);
    }
    function dispatchKeyInner(cm, name2, e, handle) {
      var result = lookupKeyForEditor(cm, name2, handle);
      if (result == "multi") {
        cm.state.keySeq = name2;
      }
      if (result == "handled") {
        signalLater(cm, "keyHandled", cm, name2, e);
      }
      if (result == "handled" || result == "multi") {
        e_preventDefault(e);
        restartBlink(cm);
      }
      return !!result;
    }
    function handleKeyBinding(cm, e) {
      var name2 = keyName(e, true);
      if (!name2) {
        return false;
      }
      if (e.shiftKey && !cm.state.keySeq) {
        return dispatchKey(cm, "Shift-" + name2, e, function(b) {
          return doHandleBinding(cm, b, true);
        }) || dispatchKey(cm, name2, e, function(b) {
          if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
            return doHandleBinding(cm, b);
          }
        });
      } else {
        return dispatchKey(cm, name2, e, function(b) {
          return doHandleBinding(cm, b);
        });
      }
    }
    function handleCharBinding(cm, e, ch) {
      return dispatchKey(cm, "'" + ch + "'", e, function(b) {
        return doHandleBinding(cm, b, true);
      });
    }
    var lastStoppedKey = null;
    function onKeyDown(e) {
      var cm = this;
      if (e.target && e.target != cm.display.input.getField()) {
        return;
      }
      cm.curOp.focus = activeElt();
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (ie && ie_version < 11 && e.keyCode == 27) {
        e.returnValue = false;
      }
      var code = e.keyCode;
      cm.display.shift = code == 16 || e.shiftKey;
      var handled = handleKeyBinding(cm, e);
      if (presto) {
        lastStoppedKey = handled ? code : null;
        if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
          cm.replaceSelection("", null, "cut");
        }
      }
      if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
        document.execCommand("cut");
      }
      if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
        showCrossHair(cm);
      }
    }
    function showCrossHair(cm) {
      var lineDiv = cm.display.lineDiv;
      addClass(lineDiv, "CodeMirror-crosshair");
      function up(e) {
        if (e.keyCode == 18 || !e.altKey) {
          rmClass(lineDiv, "CodeMirror-crosshair");
          off2(document, "keyup", up);
          off2(document, "mouseover", up);
        }
      }
      on3(document, "keyup", up);
      on3(document, "mouseover", up);
    }
    function onKeyUp(e) {
      if (e.keyCode == 16) {
        this.doc.sel.shift = false;
      }
      signalDOMEvent(this, e);
    }
    function onKeyPress(e) {
      var cm = this;
      if (e.target && e.target != cm.display.input.getField()) {
        return;
      }
      if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
        return;
      }
      var keyCode = e.keyCode, charCode = e.charCode;
      if (presto && keyCode == lastStoppedKey) {
        lastStoppedKey = null;
        e_preventDefault(e);
        return;
      }
      if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
        return;
      }
      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
      if (ch == "\b") {
        return;
      }
      if (handleCharBinding(cm, e, ch)) {
        return;
      }
      cm.display.input.onKeyPress(e);
    }
    var DOUBLECLICK_DELAY = 400;
    var PastClick = function(time, pos, button) {
      this.time = time;
      this.pos = pos;
      this.button = button;
    };
    PastClick.prototype.compare = function(time, pos, button) {
      return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
    };
    var lastClick, lastDoubleClick;
    function clickRepeat(pos, button) {
      var now = +new Date();
      if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
        lastClick = lastDoubleClick = null;
        return "triple";
      } else if (lastClick && lastClick.compare(now, pos, button)) {
        lastDoubleClick = new PastClick(now, pos, button);
        lastClick = null;
        return "double";
      } else {
        lastClick = new PastClick(now, pos, button);
        lastDoubleClick = null;
        return "single";
      }
    }
    function onMouseDown(e) {
      var cm = this, display = cm.display;
      if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
        return;
      }
      display.input.ensurePolled();
      display.shift = e.shiftKey;
      if (eventInWidget(display, e)) {
        if (!webkit) {
          display.scroller.draggable = false;
          setTimeout(function() {
            return display.scroller.draggable = true;
          }, 100);
        }
        return;
      }
      if (clickInGutter(cm, e)) {
        return;
      }
      var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
      window.focus();
      if (button == 1 && cm.state.selectingText) {
        cm.state.selectingText(e);
      }
      if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
        return;
      }
      if (button == 1) {
        if (pos) {
          leftButtonDown(cm, pos, repeat, e);
        } else if (e_target(e) == display.scroller) {
          e_preventDefault(e);
        }
      } else if (button == 2) {
        if (pos) {
          extendSelection(cm.doc, pos);
        }
        setTimeout(function() {
          return display.input.focus();
        }, 20);
      } else if (button == 3) {
        if (captureRightClick) {
          cm.display.input.onContextMenu(e);
        } else {
          delayBlurEvent(cm);
        }
      }
    }
    function handleMappedButton(cm, button, pos, repeat, event) {
      var name2 = "Click";
      if (repeat == "double") {
        name2 = "Double" + name2;
      } else if (repeat == "triple") {
        name2 = "Triple" + name2;
      }
      name2 = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name2;
      return dispatchKey(cm, addModifierNames(name2, event), event, function(bound) {
        if (typeof bound == "string") {
          bound = commands[bound];
        }
        if (!bound) {
          return false;
        }
        var done = false;
        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }
          done = bound(cm, pos) != Pass;
        } finally {
          cm.state.suppressEdits = false;
        }
        return done;
      });
    }
    function configureMouse(cm, repeat, event) {
      var option3 = cm.getOption("configureMouse");
      var value = option3 ? option3(cm, repeat, event) : {};
      if (value.unit == null) {
        var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
        value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
      }
      if (value.extend == null || cm.doc.extend) {
        value.extend = cm.doc.extend || event.shiftKey;
      }
      if (value.addNew == null) {
        value.addNew = mac ? event.metaKey : event.ctrlKey;
      }
      if (value.moveOnDrag == null) {
        value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
      }
      return value;
    }
    function leftButtonDown(cm, pos, repeat, event) {
      if (ie) {
        setTimeout(bind(ensureFocus, cm), 0);
      } else {
        cm.curOp.focus = activeElt();
      }
      var behavior = configureMouse(cm, repeat, event);
      var sel = cm.doc.sel, contained;
      if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
        leftButtonStartDrag(cm, event, pos, behavior);
      } else {
        leftButtonSelect(cm, event, pos, behavior);
      }
    }
    function leftButtonStartDrag(cm, event, pos, behavior) {
      var display = cm.display, moved2 = false;
      var dragEnd = operation(cm, function(e) {
        if (webkit) {
          display.scroller.draggable = false;
        }
        cm.state.draggingText = false;
        if (cm.state.delayingBlurEvent) {
          if (cm.hasFocus()) {
            cm.state.delayingBlurEvent = false;
          } else {
            delayBlurEvent(cm);
          }
        }
        off2(display.wrapper.ownerDocument, "mouseup", dragEnd);
        off2(display.wrapper.ownerDocument, "mousemove", mouseMove);
        off2(display.scroller, "dragstart", dragStart2);
        off2(display.scroller, "drop", dragEnd);
        if (!moved2) {
          e_preventDefault(e);
          if (!behavior.addNew) {
            extendSelection(cm.doc, pos, null, null, behavior.extend);
          }
          if (webkit && !safari || ie && ie_version == 9) {
            setTimeout(function() {
              display.wrapper.ownerDocument.body.focus({preventScroll: true});
              display.input.focus();
            }, 20);
          } else {
            display.input.focus();
          }
        }
      });
      var mouseMove = function(e2) {
        moved2 = moved2 || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
      };
      var dragStart2 = function() {
        return moved2 = true;
      };
      if (webkit) {
        display.scroller.draggable = true;
      }
      cm.state.draggingText = dragEnd;
      dragEnd.copy = !behavior.moveOnDrag;
      on3(display.wrapper.ownerDocument, "mouseup", dragEnd);
      on3(display.wrapper.ownerDocument, "mousemove", mouseMove);
      on3(display.scroller, "dragstart", dragStart2);
      on3(display.scroller, "drop", dragEnd);
      cm.state.delayingBlurEvent = true;
      setTimeout(function() {
        return display.input.focus();
      }, 20);
      if (display.scroller.dragDrop) {
        display.scroller.dragDrop();
      }
    }
    function rangeForUnit(cm, pos, unit) {
      if (unit == "char") {
        return new Range(pos, pos);
      }
      if (unit == "word") {
        return cm.findWordAt(pos);
      }
      if (unit == "line") {
        return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
      }
      var result = unit(cm, pos);
      return new Range(result.from, result.to);
    }
    function leftButtonSelect(cm, event, start, behavior) {
      if (ie) {
        delayBlurEvent(cm);
      }
      var display = cm.display, doc = cm.doc;
      e_preventDefault(event);
      var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
      if (behavior.addNew && !behavior.extend) {
        ourIndex = doc.sel.contains(start);
        if (ourIndex > -1) {
          ourRange = ranges[ourIndex];
        } else {
          ourRange = new Range(start, start);
        }
      } else {
        ourRange = doc.sel.primary();
        ourIndex = doc.sel.primIndex;
      }
      if (behavior.unit == "rectangle") {
        if (!behavior.addNew) {
          ourRange = new Range(start, start);
        }
        start = posFromMouse(cm, event, true, true);
        ourIndex = -1;
      } else {
        var range2 = rangeForUnit(cm, start, behavior.unit);
        if (behavior.extend) {
          ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
        } else {
          ourRange = range2;
        }
      }
      if (!behavior.addNew) {
        ourIndex = 0;
        setSelection(doc, new Selection([ourRange], 0), sel_mouse);
        startSel = doc.sel;
      } else if (ourIndex == -1) {
        ourIndex = ranges.length;
        setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), {scroll: false, origin: "*mouse"});
      } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
        setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {scroll: false, origin: "*mouse"});
        startSel = doc.sel;
      } else {
        replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
      }
      var lastPos = start;
      function extendTo(pos) {
        if (cmp(lastPos, pos) == 0) {
          return;
        }
        lastPos = pos;
        if (behavior.unit == "rectangle") {
          var ranges2 = [], tabSize = cm.options.tabSize;
          var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
          var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
          var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
          for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
            var text2 = getLine(doc, line).text, leftPos = findColumn(text2, left, tabSize);
            if (left == right) {
              ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
            } else if (text2.length > leftPos) {
              ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text2, right, tabSize))));
            }
          }
          if (!ranges2.length) {
            ranges2.push(new Range(start, start));
          }
          setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), {origin: "*mouse", scroll: false});
          cm.scrollIntoView(pos);
        } else {
          var oldRange = ourRange;
          var range3 = rangeForUnit(cm, pos, behavior.unit);
          var anchor = oldRange.anchor, head;
          if (cmp(range3.anchor, anchor) > 0) {
            head = range3.head;
            anchor = minPos(oldRange.from(), range3.anchor);
          } else {
            head = range3.anchor;
            anchor = maxPos(oldRange.to(), range3.head);
          }
          var ranges$1 = startSel.ranges.slice(0);
          ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
          setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
        }
      }
      var editorSize = display.wrapper.getBoundingClientRect();
      var counter = 0;
      function extend2(e) {
        var curCount = ++counter;
        var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
        if (!cur) {
          return;
        }
        if (cmp(cur, lastPos) != 0) {
          cm.curOp.focus = activeElt();
          extendTo(cur);
          var visible = visibleLines(display, doc);
          if (cur.line >= visible.to || cur.line < visible.from) {
            setTimeout(operation(cm, function() {
              if (counter == curCount) {
                extend2(e);
              }
            }), 150);
          }
        } else {
          var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
          if (outside) {
            setTimeout(operation(cm, function() {
              if (counter != curCount) {
                return;
              }
              display.scroller.scrollTop += outside;
              extend2(e);
            }), 50);
          }
        }
      }
      function done(e) {
        cm.state.selectingText = false;
        counter = Infinity;
        if (e) {
          e_preventDefault(e);
          display.input.focus();
        }
        off2(display.wrapper.ownerDocument, "mousemove", move);
        off2(display.wrapper.ownerDocument, "mouseup", up);
        doc.history.lastSelOrigin = null;
      }
      var move = operation(cm, function(e) {
        if (e.buttons === 0 || !e_button(e)) {
          done(e);
        } else {
          extend2(e);
        }
      });
      var up = operation(cm, done);
      cm.state.selectingText = up;
      on3(display.wrapper.ownerDocument, "mousemove", move);
      on3(display.wrapper.ownerDocument, "mouseup", up);
    }
    function bidiSimplify(cm, range2) {
      var anchor = range2.anchor;
      var head = range2.head;
      var anchorLine = getLine(cm.doc, anchor.line);
      if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
        return range2;
      }
      var order = getOrder(anchorLine);
      if (!order) {
        return range2;
      }
      var index2 = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index2];
      if (part.from != anchor.ch && part.to != anchor.ch) {
        return range2;
      }
      var boundary = index2 + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
      if (boundary == 0 || boundary == order.length) {
        return range2;
      }
      var leftSide;
      if (head.line != anchor.line) {
        leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
      } else {
        var headIndex = getBidiPartAt(order, head.ch, head.sticky);
        var dir = headIndex - index2 || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
        if (headIndex == boundary - 1 || headIndex == boundary) {
          leftSide = dir < 0;
        } else {
          leftSide = dir > 0;
        }
      }
      var usePart = order[boundary + (leftSide ? -1 : 0)];
      var from = leftSide == (usePart.level == 1);
      var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
      return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
    }
    function gutterEvent(cm, e, type, prevent2) {
      var mX, mY;
      if (e.touches) {
        mX = e.touches[0].clientX;
        mY = e.touches[0].clientY;
      } else {
        try {
          mX = e.clientX;
          mY = e.clientY;
        } catch (e$1) {
          return false;
        }
      }
      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
        return false;
      }
      if (prevent2) {
        e_preventDefault(e);
      }
      var display = cm.display;
      var lineBox = display.lineDiv.getBoundingClientRect();
      if (mY > lineBox.bottom || !hasHandler(cm, type)) {
        return e_defaultPrevented(e);
      }
      mY -= lineBox.top - display.viewOffset;
      for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
        var g = display.gutters.childNodes[i2];
        if (g && g.getBoundingClientRect().right >= mX) {
          var line = lineAtHeight(cm.doc, mY);
          var gutter = cm.display.gutterSpecs[i2];
          signal(cm, type, cm, line, gutter.className, e);
          return e_defaultPrevented(e);
        }
      }
    }
    function clickInGutter(cm, e) {
      return gutterEvent(cm, e, "gutterClick", true);
    }
    function onContextMenu(cm, e) {
      if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
        return;
      }
      if (signalDOMEvent(cm, e, "contextmenu")) {
        return;
      }
      if (!captureRightClick) {
        cm.display.input.onContextMenu(e);
      }
    }
    function contextMenuInGutter(cm, e) {
      if (!hasHandler(cm, "gutterContextMenu")) {
        return false;
      }
      return gutterEvent(cm, e, "gutterContextMenu", false);
    }
    function themeChanged(cm) {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
      clearCaches(cm);
    }
    var Init = {toString: function() {
      return "CodeMirror.Init";
    }};
    var defaults3 = {};
    var optionHandlers = {};
    function defineOptions(CodeMirror3) {
      var optionHandlers2 = CodeMirror3.optionHandlers;
      function option3(name2, deflt, handle, notOnInit) {
        CodeMirror3.defaults[name2] = deflt;
        if (handle) {
          optionHandlers2[name2] = notOnInit ? function(cm, val, old) {
            if (old != Init) {
              handle(cm, val, old);
            }
          } : handle;
        }
      }
      CodeMirror3.defineOption = option3;
      CodeMirror3.Init = Init;
      option3("value", "", function(cm, val) {
        return cm.setValue(val);
      }, true);
      option3("mode", null, function(cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
      }, true);
      option3("indentUnit", 2, loadMode, true);
      option3("indentWithTabs", false);
      option3("smartIndent", true);
      option3("tabSize", 4, function(cm) {
        resetModeState(cm);
        clearCaches(cm);
        regChange(cm);
      }, true);
      option3("lineSeparator", null, function(cm, val) {
        cm.doc.lineSep = val;
        if (!val) {
          return;
        }
        var newBreaks = [], lineNo2 = cm.doc.first;
        cm.doc.iter(function(line) {
          for (var pos = 0; ; ) {
            var found = line.text.indexOf(val, pos);
            if (found == -1) {
              break;
            }
            pos = found + val.length;
            newBreaks.push(Pos(lineNo2, found));
          }
          lineNo2++;
        });
        for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
          replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
        }
      });
      option3("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
        cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
        if (old != Init) {
          cm.refresh();
        }
      });
      option3("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
        return cm.refresh();
      }, true);
      option3("electricChars", true);
      option3("inputStyle", mobile ? "contenteditable" : "textarea", function() {
        throw new Error("inputStyle can not (yet) be changed in a running editor");
      }, true);
      option3("spellcheck", false, function(cm, val) {
        return cm.getInputField().spellcheck = val;
      }, true);
      option3("autocorrect", false, function(cm, val) {
        return cm.getInputField().autocorrect = val;
      }, true);
      option3("autocapitalize", false, function(cm, val) {
        return cm.getInputField().autocapitalize = val;
      }, true);
      option3("rtlMoveVisually", !windows);
      option3("wholeLineUpdateBefore", true);
      option3("theme", "default", function(cm) {
        themeChanged(cm);
        updateGutters(cm);
      }, true);
      option3("keyMap", "default", function(cm, val, old) {
        var next = getKeyMap(val);
        var prev = old != Init && getKeyMap(old);
        if (prev && prev.detach) {
          prev.detach(cm, next);
        }
        if (next.attach) {
          next.attach(cm, prev || null);
        }
      });
      option3("extraKeys", null);
      option3("configureMouse", null);
      option3("lineWrapping", false, wrappingChanged, true);
      option3("gutters", [], function(cm, val) {
        cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
        updateGutters(cm);
      }, true);
      option3("fixedGutter", true, function(cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
        cm.refresh();
      }, true);
      option3("coverGutterNextToScrollbar", false, function(cm) {
        return updateScrollbars(cm);
      }, true);
      option3("scrollbarStyle", "native", function(cm) {
        initScrollbars(cm);
        updateScrollbars(cm);
        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
      }, true);
      option3("lineNumbers", false, function(cm, val) {
        cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
        updateGutters(cm);
      }, true);
      option3("firstLineNumber", 1, updateGutters, true);
      option3("lineNumberFormatter", function(integer) {
        return integer;
      }, updateGutters, true);
      option3("showCursorWhenSelecting", false, updateSelection, true);
      option3("resetSelectionOnContextMenu", true);
      option3("lineWiseCopyCut", true);
      option3("pasteLinesPerSelection", true);
      option3("selectionsMayTouch", false);
      option3("readOnly", false, function(cm, val) {
        if (val == "nocursor") {
          onBlur(cm);
          cm.display.input.blur();
        }
        cm.display.input.readOnlyChanged(val);
      });
      option3("screenReaderLabel", null, function(cm, val) {
        val = val === "" ? null : val;
        cm.display.input.screenReaderLabelChanged(val);
      });
      option3("disableInput", false, function(cm, val) {
        if (!val) {
          cm.display.input.reset();
        }
      }, true);
      option3("dragDrop", true, dragDropChanged);
      option3("allowDropFileTypes", null);
      option3("cursorBlinkRate", 530);
      option3("cursorScrollMargin", 0);
      option3("cursorHeight", 1, updateSelection, true);
      option3("singleCursorHeightPerLine", true, updateSelection, true);
      option3("workTime", 100);
      option3("workDelay", 100);
      option3("flattenSpans", true, resetModeState, true);
      option3("addModeClass", false, resetModeState, true);
      option3("pollInterval", 100);
      option3("undoDepth", 200, function(cm, val) {
        return cm.doc.history.undoDepth = val;
      });
      option3("historyEventDelay", 1250);
      option3("viewportMargin", 10, function(cm) {
        return cm.refresh();
      }, true);
      option3("maxHighlightLength", 1e4, resetModeState, true);
      option3("moveInputWithCursor", true, function(cm, val) {
        if (!val) {
          cm.display.input.resetPosition();
        }
      });
      option3("tabindex", null, function(cm, val) {
        return cm.display.input.getField().tabIndex = val || "";
      });
      option3("autofocus", null);
      option3("direction", "ltr", function(cm, val) {
        return cm.doc.setDirection(val);
      }, true);
      option3("phrases", null);
    }
    function dragDropChanged(cm, value, old) {
      var wasOn = old && old != Init;
      if (!value != !wasOn) {
        var funcs = cm.display.dragFunctions;
        var toggle = value ? on3 : off2;
        toggle(cm.display.scroller, "dragstart", funcs.start);
        toggle(cm.display.scroller, "dragenter", funcs.enter);
        toggle(cm.display.scroller, "dragover", funcs.over);
        toggle(cm.display.scroller, "dragleave", funcs.leave);
        toggle(cm.display.scroller, "drop", funcs.drop);
      }
    }
    function wrappingChanged(cm) {
      if (cm.options.lineWrapping) {
        addClass(cm.display.wrapper, "CodeMirror-wrap");
        cm.display.sizer.style.minWidth = "";
        cm.display.sizerWidth = null;
      } else {
        rmClass(cm.display.wrapper, "CodeMirror-wrap");
        findMaxLine(cm);
      }
      estimateLineHeights(cm);
      regChange(cm);
      clearCaches(cm);
      setTimeout(function() {
        return updateScrollbars(cm);
      }, 100);
    }
    function CodeMirror2(place, options) {
      var this$1 = this;
      if (!(this instanceof CodeMirror2)) {
        return new CodeMirror2(place, options);
      }
      this.options = options = options ? copyObj(options) : {};
      copyObj(defaults3, options, false);
      var doc = options.value;
      if (typeof doc == "string") {
        doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
      } else if (options.mode) {
        doc.modeOption = options.mode;
      }
      this.doc = doc;
      var input = new CodeMirror2.inputStyles[options.inputStyle](this);
      var display = this.display = new Display(place, doc, input, options);
      display.wrapper.CodeMirror = this;
      themeChanged(this);
      if (options.lineWrapping) {
        this.display.wrapper.className += " CodeMirror-wrap";
      }
      initScrollbars(this);
      this.state = {
        keyMaps: [],
        overlays: [],
        modeGen: 0,
        overwrite: false,
        delayingBlurEvent: false,
        focused: false,
        suppressEdits: false,
        pasteIncoming: -1,
        cutIncoming: -1,
        selectingText: false,
        draggingText: false,
        highlight: new Delayed(),
        keySeq: null,
        specialChars: null
      };
      if (options.autofocus && !mobile) {
        display.input.focus();
      }
      if (ie && ie_version < 11) {
        setTimeout(function() {
          return this$1.display.input.reset(true);
        }, 20);
      }
      registerEventHandlers(this);
      ensureGlobalHandlers();
      startOperation(this);
      this.curOp.forceUpdate = true;
      attachDoc(this, doc);
      if (options.autofocus && !mobile || this.hasFocus()) {
        setTimeout(function() {
          if (this$1.hasFocus() && !this$1.state.focused) {
            onFocus(this$1);
          }
        }, 20);
      } else {
        onBlur(this);
      }
      for (var opt in optionHandlers) {
        if (optionHandlers.hasOwnProperty(opt)) {
          optionHandlers[opt](this, options[opt], Init);
        }
      }
      maybeUpdateLineNumberWidth(this);
      if (options.finishInit) {
        options.finishInit(this);
      }
      for (var i2 = 0; i2 < initHooks.length; ++i2) {
        initHooks[i2](this);
      }
      endOperation(this);
      if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
        display.lineDiv.style.textRendering = "auto";
      }
    }
    CodeMirror2.defaults = defaults3;
    CodeMirror2.optionHandlers = optionHandlers;
    function registerEventHandlers(cm) {
      var d = cm.display;
      on3(d.scroller, "mousedown", operation(cm, onMouseDown));
      if (ie && ie_version < 11) {
        on3(d.scroller, "dblclick", operation(cm, function(e) {
          if (signalDOMEvent(cm, e)) {
            return;
          }
          var pos = posFromMouse(cm, e);
          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
            return;
          }
          e_preventDefault(e);
          var word = cm.findWordAt(pos);
          extendSelection(cm.doc, word.anchor, word.head);
        }));
      } else {
        on3(d.scroller, "dblclick", function(e) {
          return signalDOMEvent(cm, e) || e_preventDefault(e);
        });
      }
      on3(d.scroller, "contextmenu", function(e) {
        return onContextMenu(cm, e);
      });
      on3(d.input.getField(), "contextmenu", function(e) {
        if (!d.scroller.contains(e.target)) {
          onContextMenu(cm, e);
        }
      });
      var touchFinished, prevTouch = {end: 0};
      function finishTouch() {
        if (d.activeTouch) {
          touchFinished = setTimeout(function() {
            return d.activeTouch = null;
          }, 1e3);
          prevTouch = d.activeTouch;
          prevTouch.end = +new Date();
        }
      }
      function isMouseLikeTouchEvent(e) {
        if (e.touches.length != 1) {
          return false;
        }
        var touch = e.touches[0];
        return touch.radiusX <= 1 && touch.radiusY <= 1;
      }
      function farAway(touch, other) {
        if (other.left == null) {
          return true;
        }
        var dx = other.left - touch.left, dy = other.top - touch.top;
        return dx * dx + dy * dy > 20 * 20;
      }
      on3(d.scroller, "touchstart", function(e) {
        if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
          d.input.ensurePolled();
          clearTimeout(touchFinished);
          var now = +new Date();
          d.activeTouch = {
            start: now,
            moved: false,
            prev: now - prevTouch.end <= 300 ? prevTouch : null
          };
          if (e.touches.length == 1) {
            d.activeTouch.left = e.touches[0].pageX;
            d.activeTouch.top = e.touches[0].pageY;
          }
        }
      });
      on3(d.scroller, "touchmove", function() {
        if (d.activeTouch) {
          d.activeTouch.moved = true;
        }
      });
      on3(d.scroller, "touchend", function(e) {
        var touch = d.activeTouch;
        if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
          var pos = cm.coordsChar(d.activeTouch, "page"), range2;
          if (!touch.prev || farAway(touch, touch.prev)) {
            range2 = new Range(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
            range2 = cm.findWordAt(pos);
          } else {
            range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
          cm.setSelection(range2.anchor, range2.head);
          cm.focus();
          e_preventDefault(e);
        }
        finishTouch();
      });
      on3(d.scroller, "touchcancel", finishTouch);
      on3(d.scroller, "scroll", function() {
        if (d.scroller.clientHeight) {
          updateScrollTop(cm, d.scroller.scrollTop);
          setScrollLeft(cm, d.scroller.scrollLeft, true);
          signal(cm, "scroll", cm);
        }
      });
      on3(d.scroller, "mousewheel", function(e) {
        return onScrollWheel(cm, e);
      });
      on3(d.scroller, "DOMMouseScroll", function(e) {
        return onScrollWheel(cm, e);
      });
      on3(d.wrapper, "scroll", function() {
        return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
      });
      d.dragFunctions = {
        enter: function(e) {
          if (!signalDOMEvent(cm, e)) {
            e_stop(e);
          }
        },
        over: function(e) {
          if (!signalDOMEvent(cm, e)) {
            onDragOver(cm, e);
            e_stop(e);
          }
        },
        start: function(e) {
          return onDragStart(cm, e);
        },
        drop: operation(cm, onDrop),
        leave: function(e) {
          if (!signalDOMEvent(cm, e)) {
            clearDragCursor(cm);
          }
        }
      };
      var inp = d.input.getField();
      on3(inp, "keyup", function(e) {
        return onKeyUp.call(cm, e);
      });
      on3(inp, "keydown", operation(cm, onKeyDown));
      on3(inp, "keypress", operation(cm, onKeyPress));
      on3(inp, "focus", function(e) {
        return onFocus(cm, e);
      });
      on3(inp, "blur", function(e) {
        return onBlur(cm, e);
      });
    }
    var initHooks = [];
    CodeMirror2.defineInitHook = function(f) {
      return initHooks.push(f);
    };
    function indentLine(cm, n, how, aggressive) {
      var doc = cm.doc, state2;
      if (how == null) {
        how = "add";
      }
      if (how == "smart") {
        if (!doc.mode.indent) {
          how = "prev";
        } else {
          state2 = getContextBefore(cm, n).state;
        }
      }
      var tabSize = cm.options.tabSize;
      var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      var curSpaceString = line.text.match(/^\s*/)[0], indentation;
      if (!aggressive && !/\S/.test(line.text)) {
        indentation = 0;
        how = "not";
      } else if (how == "smart") {
        indentation = doc.mode.indent(state2, line.text.slice(curSpaceString.length), line.text);
        if (indentation == Pass || indentation > 150) {
          if (!aggressive) {
            return;
          }
          how = "prev";
        }
      }
      if (how == "prev") {
        if (n > doc.first) {
          indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
        } else {
          indentation = 0;
        }
      } else if (how == "add") {
        indentation = curSpace + cm.options.indentUnit;
      } else if (how == "subtract") {
        indentation = curSpace - cm.options.indentUnit;
      } else if (typeof how == "number") {
        indentation = curSpace + how;
      }
      indentation = Math.max(0, indentation);
      var indentString = "", pos = 0;
      if (cm.options.indentWithTabs) {
        for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
          pos += tabSize;
          indentString += "	";
        }
      }
      if (pos < indentation) {
        indentString += spaceStr(indentation - pos);
      }
      if (indentString != curSpaceString) {
        replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
        line.stateAfter = null;
        return true;
      } else {
        for (var i$12 = 0; i$12 < doc.sel.ranges.length; i$12++) {
          var range2 = doc.sel.ranges[i$12];
          if (range2.head.line == n && range2.head.ch < curSpaceString.length) {
            var pos$1 = Pos(n, curSpaceString.length);
            replaceOneSelection(doc, i$12, new Range(pos$1, pos$1));
            break;
          }
        }
      }
    }
    var lastCopied = null;
    function setLastCopied(newLastCopied) {
      lastCopied = newLastCopied;
    }
    function applyTextInput(cm, inserted, deleted, sel, origin) {
      var doc = cm.doc;
      cm.display.shift = false;
      if (!sel) {
        sel = doc.sel;
      }
      var recent = +new Date() - 200;
      var paste = origin == "paste" || cm.state.pasteIncoming > recent;
      var textLines = splitLinesAuto(inserted), multiPaste = null;
      if (paste && sel.ranges.length > 1) {
        if (lastCopied && lastCopied.text.join("\n") == inserted) {
          if (sel.ranges.length % lastCopied.text.length == 0) {
            multiPaste = [];
            for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
              multiPaste.push(doc.splitLines(lastCopied.text[i2]));
            }
          }
        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
          multiPaste = map2(textLines, function(l) {
            return [l];
          });
        }
      }
      var updateInput = cm.curOp.updateInput;
      for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
        var range2 = sel.ranges[i$12];
        var from = range2.from(), to = range2.to();
        if (range2.empty()) {
          if (deleted && deleted > 0) {
            from = Pos(from.line, from.ch - deleted);
          } else if (cm.state.overwrite && !paste) {
            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
            from = to = Pos(from.line, 0);
          }
        }
        var changeEvent = {
          from,
          to,
          text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
          origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
        };
        makeChange(cm.doc, changeEvent);
        signalLater(cm, "inputRead", cm, changeEvent);
      }
      if (inserted && !paste) {
        triggerElectric(cm, inserted);
      }
      ensureCursorVisible(cm);
      if (cm.curOp.updateInput < 2) {
        cm.curOp.updateInput = updateInput;
      }
      cm.curOp.typing = true;
      cm.state.pasteIncoming = cm.state.cutIncoming = -1;
    }
    function handlePaste2(e, cm) {
      var pasted = e.clipboardData && e.clipboardData.getData("Text");
      if (pasted) {
        e.preventDefault();
        if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {
          runInOp(cm, function() {
            return applyTextInput(cm, pasted, 0, null, "paste");
          });
        }
        return true;
      }
    }
    function triggerElectric(cm, inserted) {
      if (!cm.options.electricChars || !cm.options.smartIndent) {
        return;
      }
      var sel = cm.doc.sel;
      for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
        var range2 = sel.ranges[i2];
        if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {
          continue;
        }
        var mode = cm.getModeAt(range2.head);
        var indented = false;
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++) {
            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indented = indentLine(cm, range2.head.line, "smart");
              break;
            }
          }
        } else if (mode.electricInput) {
          if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
            indented = indentLine(cm, range2.head.line, "smart");
          }
        }
        if (indented) {
          signalLater(cm, "electricInput", cm, range2.head.line);
        }
      }
    }
    function copyableRanges(cm) {
      var text2 = [], ranges = [];
      for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
        var line = cm.doc.sel.ranges[i2].head.line;
        var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
        ranges.push(lineRange);
        text2.push(cm.getRange(lineRange.anchor, lineRange.head));
      }
      return {text: text2, ranges};
    }
    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
      field.setAttribute("autocorrect", autocorrect ? "" : "off");
      field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
      field.setAttribute("spellcheck", !!spellcheck);
    }
    function hiddenTextarea() {
      var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
      var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
      if (webkit) {
        te.style.width = "1000px";
      } else {
        te.setAttribute("wrap", "off");
      }
      if (ios) {
        te.style.border = "1px solid black";
      }
      disableBrowserMagic(te);
      return div;
    }
    function addEditorMethods(CodeMirror3) {
      var optionHandlers2 = CodeMirror3.optionHandlers;
      var helpers = CodeMirror3.helpers = {};
      CodeMirror3.prototype = {
        constructor: CodeMirror3,
        focus: function() {
          window.focus();
          this.display.input.focus();
        },
        setOption: function(option3, value) {
          var options = this.options, old = options[option3];
          if (options[option3] == value && option3 != "mode") {
            return;
          }
          options[option3] = value;
          if (optionHandlers2.hasOwnProperty(option3)) {
            operation(this, optionHandlers2[option3])(this, value, old);
          }
          signal(this, "optionChange", this, option3);
        },
        getOption: function(option3) {
          return this.options[option3];
        },
        getDoc: function() {
          return this.doc;
        },
        addKeyMap: function(map3, bottom) {
          this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map3));
        },
        removeKeyMap: function(map3) {
          var maps = this.state.keyMaps;
          for (var i2 = 0; i2 < maps.length; ++i2) {
            if (maps[i2] == map3 || maps[i2].name == map3) {
              maps.splice(i2, 1);
              return true;
            }
          }
        },
        addOverlay: methodOp(function(spec, options) {
          var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
          if (mode.startState) {
            throw new Error("Overlays may not be stateful.");
          }
          insertSorted(this.state.overlays, {
            mode,
            modeSpec: spec,
            opaque: options && options.opaque,
            priority: options && options.priority || 0
          }, function(overlay) {
            return overlay.priority;
          });
          this.state.modeGen++;
          regChange(this);
        }),
        removeOverlay: methodOp(function(spec) {
          var overlays = this.state.overlays;
          for (var i2 = 0; i2 < overlays.length; ++i2) {
            var cur = overlays[i2].modeSpec;
            if (cur == spec || typeof spec == "string" && cur.name == spec) {
              overlays.splice(i2, 1);
              this.state.modeGen++;
              regChange(this);
              return;
            }
          }
        }),
        indentLine: methodOp(function(n, dir, aggressive) {
          if (typeof dir != "string" && typeof dir != "number") {
            if (dir == null) {
              dir = this.options.smartIndent ? "smart" : "prev";
            } else {
              dir = dir ? "add" : "subtract";
            }
          }
          if (isLine(this.doc, n)) {
            indentLine(this, n, dir, aggressive);
          }
        }),
        indentSelection: methodOp(function(how) {
          var ranges = this.doc.sel.ranges, end = -1;
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var range2 = ranges[i2];
            if (!range2.empty()) {
              var from = range2.from(), to = range2.to();
              var start = Math.max(end, from.line);
              end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
              for (var j = start; j < end; ++j) {
                indentLine(this, j, how);
              }
              var newRanges = this.doc.sel.ranges;
              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
                replaceOneSelection(this.doc, i2, new Range(from, newRanges[i2].to()), sel_dontScroll);
              }
            } else if (range2.head.line > end) {
              indentLine(this, range2.head.line, how, true);
              end = range2.head.line;
              if (i2 == this.doc.sel.primIndex) {
                ensureCursorVisible(this);
              }
            }
          }
        }),
        getTokenAt: function(pos, precise) {
          return takeToken(this, pos, precise);
        },
        getLineTokens: function(line, precise) {
          return takeToken(this, Pos(line), precise, true);
        },
        getTokenTypeAt: function(pos) {
          pos = clipPos(this.doc, pos);
          var styles2 = getLineStyles(this, getLine(this.doc, pos.line));
          var before = 0, after = (styles2.length - 1) / 2, ch = pos.ch;
          var type;
          if (ch == 0) {
            type = styles2[2];
          } else {
            for (; ; ) {
              var mid = before + after >> 1;
              if ((mid ? styles2[mid * 2 - 1] : 0) >= ch) {
                after = mid;
              } else if (styles2[mid * 2 + 1] < ch) {
                before = mid + 1;
              } else {
                type = styles2[mid * 2 + 2];
                break;
              }
            }
          }
          var cut = type ? type.indexOf("overlay ") : -1;
          return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
        },
        getModeAt: function(pos) {
          var mode = this.doc.mode;
          if (!mode.innerMode) {
            return mode;
          }
          return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
        },
        getHelper: function(pos, type) {
          return this.getHelpers(pos, type)[0];
        },
        getHelpers: function(pos, type) {
          var found = [];
          if (!helpers.hasOwnProperty(type)) {
            return found;
          }
          var help = helpers[type], mode = this.getModeAt(pos);
          if (typeof mode[type] == "string") {
            if (help[mode[type]]) {
              found.push(help[mode[type]]);
            }
          } else if (mode[type]) {
            for (var i2 = 0; i2 < mode[type].length; i2++) {
              var val = help[mode[type][i2]];
              if (val) {
                found.push(val);
              }
            }
          } else if (mode.helperType && help[mode.helperType]) {
            found.push(help[mode.helperType]);
          } else if (help[mode.name]) {
            found.push(help[mode.name]);
          }
          for (var i$12 = 0; i$12 < help._global.length; i$12++) {
            var cur = help._global[i$12];
            if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
              found.push(cur.val);
            }
          }
          return found;
        },
        getStateAfter: function(line, precise) {
          var doc = this.doc;
          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
          return getContextBefore(this, line + 1, precise).state;
        },
        cursorCoords: function(start, mode) {
          var pos, range2 = this.doc.sel.primary();
          if (start == null) {
            pos = range2.head;
          } else if (typeof start == "object") {
            pos = clipPos(this.doc, start);
          } else {
            pos = start ? range2.from() : range2.to();
          }
          return cursorCoords(this, pos, mode || "page");
        },
        charCoords: function(pos, mode) {
          return charCoords(this, clipPos(this.doc, pos), mode || "page");
        },
        coordsChar: function(coords, mode) {
          coords = fromCoordSystem(this, coords, mode || "page");
          return coordsChar(this, coords.left, coords.top);
        },
        lineAtHeight: function(height, mode) {
          height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
          return lineAtHeight(this.doc, height + this.display.viewOffset);
        },
        heightAtLine: function(line, mode, includeWidgets) {
          var end = false, lineObj;
          if (typeof line == "number") {
            var last = this.doc.first + this.doc.size - 1;
            if (line < this.doc.first) {
              line = this.doc.first;
            } else if (line > last) {
              line = last;
              end = true;
            }
            lineObj = getLine(this.doc, line);
          } else {
            lineObj = line;
          }
          return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
        },
        defaultTextHeight: function() {
          return textHeight(this.display);
        },
        defaultCharWidth: function() {
          return charWidth(this.display);
        },
        getViewport: function() {
          return {from: this.display.viewFrom, to: this.display.viewTo};
        },
        addWidget: function(pos, node, scroll, vert, horiz) {
          var display = this.display;
          pos = cursorCoords(this, clipPos(this.doc, pos));
          var top = pos.bottom, left = pos.left;
          node.style.position = "absolute";
          node.setAttribute("cm-ignore-events", "true");
          this.display.input.setUneditable(node);
          display.sizer.appendChild(node);
          if (vert == "over") {
            top = pos.top;
          } else if (vert == "above" || vert == "near") {
            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
            if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
              top = pos.top - node.offsetHeight;
            } else if (pos.bottom + node.offsetHeight <= vspace) {
              top = pos.bottom;
            }
            if (left + node.offsetWidth > hspace) {
              left = hspace - node.offsetWidth;
            }
          }
          node.style.top = top + "px";
          node.style.left = node.style.right = "";
          if (horiz == "right") {
            left = display.sizer.clientWidth - node.offsetWidth;
            node.style.right = "0px";
          } else {
            if (horiz == "left") {
              left = 0;
            } else if (horiz == "middle") {
              left = (display.sizer.clientWidth - node.offsetWidth) / 2;
            }
            node.style.left = left + "px";
          }
          if (scroll) {
            scrollIntoView(this, {left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight});
          }
        },
        triggerOnKeyDown: methodOp(onKeyDown),
        triggerOnKeyPress: methodOp(onKeyPress),
        triggerOnKeyUp: onKeyUp,
        triggerOnMouseDown: methodOp(onMouseDown),
        execCommand: function(cmd) {
          if (commands.hasOwnProperty(cmd)) {
            return commands[cmd].call(null, this);
          }
        },
        triggerElectric: methodOp(function(text2) {
          triggerElectric(this, text2);
        }),
        findPosH: function(from, amount, unit, visually) {
          var dir = 1;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          var cur = clipPos(this.doc, from);
          for (var i2 = 0; i2 < amount; ++i2) {
            cur = findPosH(this.doc, cur, dir, unit, visually);
            if (cur.hitSide) {
              break;
            }
          }
          return cur;
        },
        moveH: methodOp(function(dir, unit) {
          var this$1 = this;
          this.extendSelectionsBy(function(range2) {
            if (this$1.display.shift || this$1.doc.extend || range2.empty()) {
              return findPosH(this$1.doc, range2.head, dir, unit, this$1.options.rtlMoveVisually);
            } else {
              return dir < 0 ? range2.from() : range2.to();
            }
          }, sel_move);
        }),
        deleteH: methodOp(function(dir, unit) {
          var sel = this.doc.sel, doc = this.doc;
          if (sel.somethingSelected()) {
            doc.replaceSelection("", null, "+delete");
          } else {
            deleteNearSelection(this, function(range2) {
              var other = findPosH(doc, range2.head, dir, unit, false);
              return dir < 0 ? {from: other, to: range2.head} : {from: range2.head, to: other};
            });
          }
        }),
        findPosV: function(from, amount, unit, goalColumn) {
          var dir = 1, x = goalColumn;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          var cur = clipPos(this.doc, from);
          for (var i2 = 0; i2 < amount; ++i2) {
            var coords = cursorCoords(this, cur, "div");
            if (x == null) {
              x = coords.left;
            } else {
              coords.left = x;
            }
            cur = findPosV(this, coords, dir, unit);
            if (cur.hitSide) {
              break;
            }
          }
          return cur;
        },
        moveV: methodOp(function(dir, unit) {
          var this$1 = this;
          var doc = this.doc, goals = [];
          var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
          doc.extendSelectionsBy(function(range2) {
            if (collapse) {
              return dir < 0 ? range2.from() : range2.to();
            }
            var headPos = cursorCoords(this$1, range2.head, "div");
            if (range2.goalColumn != null) {
              headPos.left = range2.goalColumn;
            }
            goals.push(headPos.left);
            var pos = findPosV(this$1, headPos, dir, unit);
            if (unit == "page" && range2 == doc.sel.primary()) {
              addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
            }
            return pos;
          }, sel_move);
          if (goals.length) {
            for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
              doc.sel.ranges[i2].goalColumn = goals[i2];
            }
          }
        }),
        findWordAt: function(pos) {
          var doc = this.doc, line = getLine(doc, pos.line).text;
          var start = pos.ch, end = pos.ch;
          if (line) {
            var helper = this.getHelper(pos, "wordChars");
            if ((pos.sticky == "before" || end == line.length) && start) {
              --start;
            } else {
              ++end;
            }
            var startChar = line.charAt(start);
            var check = isWordChar(startChar, helper) ? function(ch) {
              return isWordChar(ch, helper);
            } : /\s/.test(startChar) ? function(ch) {
              return /\s/.test(ch);
            } : function(ch) {
              return !/\s/.test(ch) && !isWordChar(ch);
            };
            while (start > 0 && check(line.charAt(start - 1))) {
              --start;
            }
            while (end < line.length && check(line.charAt(end))) {
              ++end;
            }
          }
          return new Range(Pos(pos.line, start), Pos(pos.line, end));
        },
        toggleOverwrite: function(value) {
          if (value != null && value == this.state.overwrite) {
            return;
          }
          if (this.state.overwrite = !this.state.overwrite) {
            addClass(this.display.cursorDiv, "CodeMirror-overwrite");
          } else {
            rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
          }
          signal(this, "overwriteToggle", this, this.state.overwrite);
        },
        hasFocus: function() {
          return this.display.input.getField() == activeElt();
        },
        isReadOnly: function() {
          return !!(this.options.readOnly || this.doc.cantEdit);
        },
        scrollTo: methodOp(function(x, y) {
          scrollToCoords(this, x, y);
        }),
        getScrollInfo: function() {
          var scroller = this.display.scroller;
          return {
            left: scroller.scrollLeft,
            top: scroller.scrollTop,
            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
            clientHeight: displayHeight(this),
            clientWidth: displayWidth(this)
          };
        },
        scrollIntoView: methodOp(function(range2, margin) {
          if (range2 == null) {
            range2 = {from: this.doc.sel.primary().head, to: null};
            if (margin == null) {
              margin = this.options.cursorScrollMargin;
            }
          } else if (typeof range2 == "number") {
            range2 = {from: Pos(range2, 0), to: null};
          } else if (range2.from == null) {
            range2 = {from: range2, to: null};
          }
          if (!range2.to) {
            range2.to = range2.from;
          }
          range2.margin = margin || 0;
          if (range2.from.line != null) {
            scrollToRange(this, range2);
          } else {
            scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
          }
        }),
        setSize: methodOp(function(width, height) {
          var this$1 = this;
          var interpret = function(val) {
            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
          };
          if (width != null) {
            this.display.wrapper.style.width = interpret(width);
          }
          if (height != null) {
            this.display.wrapper.style.height = interpret(height);
          }
          if (this.options.lineWrapping) {
            clearLineMeasurementCache(this);
          }
          var lineNo2 = this.display.viewFrom;
          this.doc.iter(lineNo2, this.display.viewTo, function(line) {
            if (line.widgets) {
              for (var i2 = 0; i2 < line.widgets.length; i2++) {
                if (line.widgets[i2].noHScroll) {
                  regLineChange(this$1, lineNo2, "widget");
                  break;
                }
              }
            }
            ++lineNo2;
          });
          this.curOp.forceUpdate = true;
          signal(this, "refresh", this);
        }),
        operation: function(f) {
          return runInOp(this, f);
        },
        startOperation: function() {
          return startOperation(this);
        },
        endOperation: function() {
          return endOperation(this);
        },
        refresh: methodOp(function() {
          var oldHeight = this.display.cachedTextHeight;
          regChange(this);
          this.curOp.forceUpdate = true;
          clearCaches(this);
          scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
          updateGutterSpace(this.display);
          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
            estimateLineHeights(this);
          }
          signal(this, "refresh", this);
        }),
        swapDoc: methodOp(function(doc) {
          var old = this.doc;
          old.cm = null;
          if (this.state.selectingText) {
            this.state.selectingText();
          }
          attachDoc(this, doc);
          clearCaches(this);
          this.display.input.reset();
          scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
          this.curOp.forceScroll = true;
          signalLater(this, "swapDoc", this, old);
          return old;
        }),
        phrase: function(phraseText) {
          var phrases = this.options.phrases;
          return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
        },
        getInputField: function() {
          return this.display.input.getField();
        },
        getWrapperElement: function() {
          return this.display.wrapper;
        },
        getScrollerElement: function() {
          return this.display.scroller;
        },
        getGutterElement: function() {
          return this.display.gutters;
        }
      };
      eventMixin(CodeMirror3);
      CodeMirror3.registerHelper = function(type, name2, value) {
        if (!helpers.hasOwnProperty(type)) {
          helpers[type] = CodeMirror3[type] = {_global: []};
        }
        helpers[type][name2] = value;
      };
      CodeMirror3.registerGlobalHelper = function(type, name2, predicate, value) {
        CodeMirror3.registerHelper(type, name2, value);
        helpers[type]._global.push({pred: predicate, val: value});
      };
    }
    function findPosH(doc, pos, dir, unit, visually) {
      var oldPos = pos;
      var origDir = dir;
      var lineObj = getLine(doc, pos.line);
      var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
      function findNextLine() {
        var l = pos.line + lineDir;
        if (l < doc.first || l >= doc.first + doc.size) {
          return false;
        }
        pos = new Pos(l, pos.ch, pos.sticky);
        return lineObj = getLine(doc, l);
      }
      function moveOnce(boundToLine) {
        var next;
        if (unit == "codepoint") {
          var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
          if (isNaN(ch)) {
            next = null;
          } else {
            var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
            next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
          }
        } else if (visually) {
          next = moveVisually(doc.cm, lineObj, pos, dir);
        } else {
          next = moveLogically(lineObj, pos, dir);
        }
        if (next == null) {
          if (!boundToLine && findNextLine()) {
            pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
          } else {
            return false;
          }
        } else {
          pos = next;
        }
        return true;
      }
      if (unit == "char" || unit == "codepoint") {
        moveOnce();
      } else if (unit == "column") {
        moveOnce(true);
      } else if (unit == "word" || unit == "group") {
        var sawType = null, group = unit == "group";
        var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
        for (var first = true; ; first = false) {
          if (dir < 0 && !moveOnce(!first)) {
            break;
          }
          var cur = lineObj.text.charAt(pos.ch) || "\n";
          var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
          if (group && !first && !type) {
            type = "s";
          }
          if (sawType && sawType != type) {
            if (dir < 0) {
              dir = 1;
              moveOnce();
              pos.sticky = "after";
            }
            break;
          }
          if (type) {
            sawType = type;
          }
          if (dir > 0 && !moveOnce(!first)) {
            break;
          }
        }
      }
      var result = skipAtomic(doc, pos, oldPos, origDir, true);
      if (equalCursorPos(oldPos, result)) {
        result.hitSide = true;
      }
      return result;
    }
    function findPosV(cm, pos, dir, unit) {
      var doc = cm.doc, x = pos.left, y;
      if (unit == "page") {
        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
        var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
        y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
      } else if (unit == "line") {
        y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
      }
      var target;
      for (; ; ) {
        target = coordsChar(cm, x, y);
        if (!target.outside) {
          break;
        }
        if (dir < 0 ? y <= 0 : y >= doc.height) {
          target.hitSide = true;
          break;
        }
        y += dir * 5;
      }
      return target;
    }
    var ContentEditableInput = function(cm) {
      this.cm = cm;
      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
      this.polling = new Delayed();
      this.composing = null;
      this.gracePeriod = false;
      this.readDOMTimeout = null;
    };
    ContentEditableInput.prototype.init = function(display) {
      var this$1 = this;
      var input = this, cm = input.cm;
      var div = input.div = display.lineDiv;
      div.contentEditable = true;
      disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
      function belongsToInput(e) {
        for (var t = e.target; t; t = t.parentNode) {
          if (t == div) {
            return true;
          }
          if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
            break;
          }
        }
        return false;
      }
      on3(div, "paste", function(e) {
        if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste2(e, cm)) {
          return;
        }
        if (ie_version <= 11) {
          setTimeout(operation(cm, function() {
            return this$1.updateFromDOM();
          }), 20);
        }
      });
      on3(div, "compositionstart", function(e) {
        this$1.composing = {data: e.data, done: false};
      });
      on3(div, "compositionupdate", function(e) {
        if (!this$1.composing) {
          this$1.composing = {data: e.data, done: false};
        }
      });
      on3(div, "compositionend", function(e) {
        if (this$1.composing) {
          if (e.data != this$1.composing.data) {
            this$1.readFromDOMSoon();
          }
          this$1.composing.done = true;
        }
      });
      on3(div, "touchstart", function() {
        return input.forceCompositionEnd();
      });
      on3(div, "input", function() {
        if (!this$1.composing) {
          this$1.readFromDOMSoon();
        }
      });
      function onCopyCut(e) {
        if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied({lineWise: false, text: cm.getSelections()});
          if (e.type == "cut") {
            cm.replaceSelection("", null, "cut");
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({lineWise: true, text: ranges.text});
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        if (e.clipboardData) {
          e.clipboardData.clearData();
          var content = lastCopied.text.join("\n");
          e.clipboardData.setData("Text", content);
          if (e.clipboardData.getData("Text") == content) {
            e.preventDefault();
            return;
          }
        }
        var kludge = hiddenTextarea(), te = kludge.firstChild;
        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
        te.value = lastCopied.text.join("\n");
        var hadFocus = activeElt();
        selectInput(te);
        setTimeout(function() {
          cm.display.lineSpace.removeChild(kludge);
          hadFocus.focus();
          if (hadFocus == div) {
            input.showPrimarySelection();
          }
        }, 50);
      }
      on3(div, "copy", onCopyCut);
      on3(div, "cut", onCopyCut);
    };
    ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
      if (label) {
        this.div.setAttribute("aria-label", label);
      } else {
        this.div.removeAttribute("aria-label");
      }
    };
    ContentEditableInput.prototype.prepareSelection = function() {
      var result = prepareSelection(this.cm, false);
      result.focus = activeElt() == this.div;
      return result;
    };
    ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
      if (!info || !this.cm.display.view.length) {
        return;
      }
      if (info.focus || takeFocus) {
        this.showPrimarySelection();
      }
      this.showMultipleSelections(info);
    };
    ContentEditableInput.prototype.getSelection = function() {
      return this.cm.display.wrapper.ownerDocument.getSelection();
    };
    ContentEditableInput.prototype.showPrimarySelection = function() {
      var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
      var from = prim.from(), to = prim.to();
      if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
        sel.removeAllRanges();
        return;
      }
      var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
        return;
      }
      var view = cm.display.view;
      var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {node: view[0].measure.map[2], offset: 0};
      var end = to.line < cm.display.viewTo && posToDOM(cm, to);
      if (!end) {
        var measure = view[view.length - 1].measure;
        var map3 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = {node: map3[map3.length - 1], offset: map3[map3.length - 2] - map3[map3.length - 3]};
      }
      if (!start || !end) {
        sel.removeAllRanges();
        return;
      }
      var old = sel.rangeCount && sel.getRangeAt(0), rng;
      try {
        rng = range(start.node, start.offset, end.offset, end.node);
      } catch (e) {
      }
      if (rng) {
        if (!gecko && cm.state.focused) {
          sel.collapse(start.node, start.offset);
          if (!rng.collapsed) {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        if (old && sel.anchorNode == null) {
          sel.addRange(old);
        } else if (gecko) {
          this.startGracePeriod();
        }
      }
      this.rememberSelection();
    };
    ContentEditableInput.prototype.startGracePeriod = function() {
      var this$1 = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        this$1.gracePeriod = false;
        if (this$1.selectionChanged()) {
          this$1.cm.operation(function() {
            return this$1.cm.curOp.selectionChanged = true;
          });
        }
      }, 20);
    };
    ContentEditableInput.prototype.showMultipleSelections = function(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    };
    ContentEditableInput.prototype.rememberSelection = function() {
      var sel = this.getSelection();
      this.lastAnchorNode = sel.anchorNode;
      this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode;
      this.lastFocusOffset = sel.focusOffset;
    };
    ContentEditableInput.prototype.selectionInEditor = function() {
      var sel = this.getSelection();
      if (!sel.rangeCount) {
        return false;
      }
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node);
    };
    ContentEditableInput.prototype.focus = function() {
      if (this.cm.options.readOnly != "nocursor") {
        if (!this.selectionInEditor() || activeElt() != this.div) {
          this.showSelection(this.prepareSelection(), true);
        }
        this.div.focus();
      }
    };
    ContentEditableInput.prototype.blur = function() {
      this.div.blur();
    };
    ContentEditableInput.prototype.getField = function() {
      return this.div;
    };
    ContentEditableInput.prototype.supportsTouch = function() {
      return true;
    };
    ContentEditableInput.prototype.receivedFocus = function() {
      var this$1 = this;
      var input = this;
      if (this.selectionInEditor()) {
        setTimeout(function() {
          return this$1.pollSelection();
        }, 20);
      } else {
        runInOp(this.cm, function() {
          return input.cm.curOp.selectionChanged = true;
        });
      }
      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    };
    ContentEditableInput.prototype.selectionChanged = function() {
      var sel = this.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    };
    ContentEditableInput.prototype.pollSelection = function() {
      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
        return;
      }
      var sel = this.getSelection(), cm = this.cm;
      if (android && chrome2 && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
        this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
        this.blur();
        this.focus();
        return;
      }
      if (this.composing) {
        return;
      }
      this.rememberSelection();
      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var head = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (anchor && head) {
        runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) {
            cm.curOp.selectionChanged = true;
          }
        });
      }
    };
    ContentEditableInput.prototype.pollContent = function() {
      if (this.readDOMTimeout != null) {
        clearTimeout(this.readDOMTimeout);
        this.readDOMTimeout = null;
      }
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.ch == 0 && from.line > cm.firstLine()) {
        from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
      }
      if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
        to = Pos(to.line + 1, 0);
      }
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
        return false;
      }
      var fromIndex, fromLine, fromNode;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        fromLine = lineNo(display.view[0].line);
        fromNode = display.view[0].node;
      } else {
        fromLine = lineNo(display.view[fromIndex].line);
        fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      var toLine, toNode;
      if (toIndex == display.view.length - 1) {
        toLine = display.viewTo - 1;
        toNode = display.lineDiv.lastChild;
      } else {
        toLine = lineNo(display.view[toIndex + 1].line) - 1;
        toNode = display.view[toIndex + 1].node.previousSibling;
      }
      if (!fromNode) {
        return false;
      }
      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) {
          newText.pop();
          oldText.pop();
          toLine--;
        } else if (newText[0] == oldText[0]) {
          newText.shift();
          oldText.shift();
          fromLine++;
        } else {
          break;
        }
      }
      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
        ++cutFront;
      }
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        ++cutEnd;
      }
      if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
        while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          cutFront--;
          cutEnd++;
        }
      }
      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
      newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    };
    ContentEditableInput.prototype.ensurePolled = function() {
      this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.reset = function() {
      this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.forceCompositionEnd = function() {
      if (!this.composing) {
        return;
      }
      clearTimeout(this.readDOMTimeout);
      this.composing = null;
      this.updateFromDOM();
      this.div.blur();
      this.div.focus();
    };
    ContentEditableInput.prototype.readFromDOMSoon = function() {
      var this$1 = this;
      if (this.readDOMTimeout != null) {
        return;
      }
      this.readDOMTimeout = setTimeout(function() {
        this$1.readDOMTimeout = null;
        if (this$1.composing) {
          if (this$1.composing.done) {
            this$1.composing = null;
          } else {
            return;
          }
        }
        this$1.updateFromDOM();
      }, 80);
    };
    ContentEditableInput.prototype.updateFromDOM = function() {
      var this$1 = this;
      if (this.cm.isReadOnly() || !this.pollContent()) {
        runInOp(this.cm, function() {
          return regChange(this$1.cm);
        });
      }
    };
    ContentEditableInput.prototype.setUneditable = function(node) {
      node.contentEditable = "false";
    };
    ContentEditableInput.prototype.onKeyPress = function(e) {
      if (e.charCode == 0 || this.composing) {
        return;
      }
      e.preventDefault();
      if (!this.cm.isReadOnly()) {
        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
      }
    };
    ContentEditableInput.prototype.readOnlyChanged = function(val) {
      this.div.contentEditable = String(val != "nocursor");
    };
    ContentEditableInput.prototype.onContextMenu = function() {
    };
    ContentEditableInput.prototype.resetPosition = function() {
    };
    ContentEditableInput.prototype.needsContentAttribute = true;
    function posToDOM(cm, pos) {
      var view = findViewForLine(cm, pos.line);
      if (!view || view.hidden) {
        return null;
      }
      var line = getLine(cm.doc, pos.line);
      var info = mapFromLineView(view, line, pos.line);
      var order = getOrder(line, cm.doc.direction), side = "left";
      if (order) {
        var partPos = getBidiPartAt(order, pos.ch);
        side = partPos % 2 ? "right" : "left";
      }
      var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
      result.offset = result.collapse == "right" ? result.end : result.start;
      return result;
    }
    function isInGutter(node) {
      for (var scan = node; scan; scan = scan.parentNode) {
        if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
          return true;
        }
      }
      return false;
    }
    function badPos(pos, bad) {
      if (bad) {
        pos.bad = true;
      }
      return pos;
    }
    function domTextBetween(cm, from, to, fromLine, toLine) {
      var text2 = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
      function recognizeMarker(id) {
        return function(marker) {
          return marker.id == id;
        };
      }
      function close() {
        if (closing) {
          text2 += lineSep;
          if (extraLinebreak) {
            text2 += lineSep;
          }
          closing = extraLinebreak = false;
        }
      }
      function addText(str) {
        if (str) {
          close();
          text2 += str;
        }
      }
      function walk(node) {
        if (node.nodeType == 1) {
          var cmText = node.getAttribute("cm-text");
          if (cmText) {
            addText(cmText);
            return;
          }
          var markerID = node.getAttribute("cm-marker"), range2;
          if (markerID) {
            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
            if (found.length && (range2 = found[0].find(0))) {
              addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
            }
            return;
          }
          if (node.getAttribute("contenteditable") == "false") {
            return;
          }
          var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
          if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
            return;
          }
          if (isBlock) {
            close();
          }
          for (var i2 = 0; i2 < node.childNodes.length; i2++) {
            walk(node.childNodes[i2]);
          }
          if (/^(pre|p)$/i.test(node.nodeName)) {
            extraLinebreak = true;
          }
          if (isBlock) {
            closing = true;
          }
        } else if (node.nodeType == 3) {
          addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
        }
      }
      for (; ; ) {
        walk(from);
        if (from == to) {
          break;
        }
        from = from.nextSibling;
        extraLinebreak = false;
      }
      return text2;
    }
    function domToPos(cm, node, offset) {
      var lineNode;
      if (node == cm.display.lineDiv) {
        lineNode = cm.display.lineDiv.childNodes[offset];
        if (!lineNode) {
          return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
        }
        node = null;
        offset = 0;
      } else {
        for (lineNode = node; ; lineNode = lineNode.parentNode) {
          if (!lineNode || lineNode == cm.display.lineDiv) {
            return null;
          }
          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
            break;
          }
        }
      }
      for (var i2 = 0; i2 < cm.display.view.length; i2++) {
        var lineView = cm.display.view[i2];
        if (lineView.node == lineNode) {
          return locateNodeInLineView(lineView, node, offset);
        }
      }
    }
    function locateNodeInLineView(lineView, node, offset) {
      var wrapper3 = lineView.text.firstChild, bad = false;
      if (!node || !contains(wrapper3, node)) {
        return badPos(Pos(lineNo(lineView.line), 0), true);
      }
      if (node == wrapper3) {
        bad = true;
        node = wrapper3.childNodes[offset];
        offset = 0;
        if (!node) {
          var line = lineView.rest ? lst(lineView.rest) : lineView.line;
          return badPos(Pos(lineNo(line), line.text.length), bad);
        }
      }
      var textNode = node.nodeType == 3 ? node : null, topNode = node;
      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
        textNode = node.firstChild;
        if (offset) {
          offset = textNode.nodeValue.length;
        }
      }
      while (topNode.parentNode != wrapper3) {
        topNode = topNode.parentNode;
      }
      var measure = lineView.measure, maps = measure.maps;
      function find3(textNode2, topNode2, offset2) {
        for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
          var map3 = i2 < 0 ? measure.map : maps[i2];
          for (var j = 0; j < map3.length; j += 3) {
            var curNode = map3[j + 2];
            if (curNode == textNode2 || curNode == topNode2) {
              var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
              var ch = map3[j] + offset2;
              if (offset2 < 0 || curNode != textNode2) {
                ch = map3[j + (offset2 ? 1 : 0)];
              }
              return Pos(line2, ch);
            }
          }
        }
      }
      var found = find3(textNode, topNode, offset);
      if (found) {
        return badPos(found, bad);
      }
      for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
        found = find3(after, after.firstChild, 0);
        if (found) {
          return badPos(Pos(found.line, found.ch - dist), bad);
        } else {
          dist += after.textContent.length;
        }
      }
      for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
        found = find3(before, before.firstChild, -1);
        if (found) {
          return badPos(Pos(found.line, found.ch + dist$1), bad);
        } else {
          dist$1 += before.textContent.length;
        }
      }
    }
    var TextareaInput = function(cm) {
      this.cm = cm;
      this.prevInput = "";
      this.pollingFast = false;
      this.polling = new Delayed();
      this.hasSelection = false;
      this.composing = null;
    };
    TextareaInput.prototype.init = function(display) {
      var this$1 = this;
      var input = this, cm = this.cm;
      this.createField(display);
      var te = this.textarea;
      display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
      if (ios) {
        te.style.width = "0px";
      }
      on3(te, "input", function() {
        if (ie && ie_version >= 9 && this$1.hasSelection) {
          this$1.hasSelection = null;
        }
        input.poll();
      });
      on3(te, "paste", function(e) {
        if (signalDOMEvent(cm, e) || handlePaste2(e, cm)) {
          return;
        }
        cm.state.pasteIncoming = +new Date();
        input.fastPoll();
      });
      function prepareCopyCut(e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied({lineWise: false, text: cm.getSelections()});
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({lineWise: true, text: ranges.text});
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") {
          cm.state.cutIncoming = +new Date();
        }
      }
      on3(te, "cut", prepareCopyCut);
      on3(te, "copy", prepareCopyCut);
      on3(display.scroller, "paste", function(e) {
        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
          return;
        }
        if (!te.dispatchEvent) {
          cm.state.pasteIncoming = +new Date();
          input.focus();
          return;
        }
        var event = new Event("paste");
        event.clipboardData = e.clipboardData;
        te.dispatchEvent(event);
      });
      on3(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(display, e)) {
          e_preventDefault(e);
        }
      });
      on3(te, "compositionstart", function() {
        var start = cm.getCursor("from");
        if (input.composing) {
          input.composing.range.clear();
        }
        input.composing = {
          start,
          range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
        };
      });
      on3(te, "compositionend", function() {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    };
    TextareaInput.prototype.createField = function(_display) {
      this.wrapper = hiddenTextarea();
      this.textarea = this.wrapper.firstChild;
    };
    TextareaInput.prototype.screenReaderLabelChanged = function(label) {
      if (label) {
        this.textarea.setAttribute("aria-label", label);
      } else {
        this.textarea.removeAttribute("aria-label");
      }
    };
    TextareaInput.prototype.prepareSelection = function() {
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection(cm);
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
      }
      return result;
    };
    TextareaInput.prototype.showSelection = function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    };
    TextareaInput.prototype.reset = function(typing) {
      if (this.contextMenuPending || this.composing) {
        return;
      }
      var cm = this.cm;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var content = cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) {
          selectInput(this.textarea);
        }
        if (ie && ie_version >= 9) {
          this.hasSelection = content;
        }
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) {
          this.hasSelection = null;
        }
      }
    };
    TextareaInput.prototype.getField = function() {
      return this.textarea;
    };
    TextareaInput.prototype.supportsTouch = function() {
      return false;
    };
    TextareaInput.prototype.focus = function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try {
          this.textarea.focus();
        } catch (e) {
        }
      }
    };
    TextareaInput.prototype.blur = function() {
      this.textarea.blur();
    };
    TextareaInput.prototype.resetPosition = function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    };
    TextareaInput.prototype.receivedFocus = function() {
      this.slowPoll();
    };
    TextareaInput.prototype.slowPoll = function() {
      var this$1 = this;
      if (this.pollingFast) {
        return;
      }
      this.polling.set(this.cm.options.pollInterval, function() {
        this$1.poll();
        if (this$1.cm.state.focused) {
          this$1.slowPoll();
        }
      });
    };
    TextareaInput.prototype.fastPoll = function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p() {
        var changed = input.poll();
        if (!changed && !missed) {
          missed = true;
          input.polling.set(60, p);
        } else {
          input.pollingFast = false;
          input.slowPoll();
        }
      }
      input.polling.set(20, p);
    };
    TextareaInput.prototype.poll = function() {
      var this$1 = this;
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
        return false;
      }
      var text2 = input.value;
      if (text2 == prevInput && !cm.somethingSelected()) {
        return false;
      }
      if (ie && ie_version >= 9 && this.hasSelection === text2 || mac && /[\uf700-\uf7ff]/.test(text2)) {
        cm.display.input.reset();
        return false;
      }
      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text2.charCodeAt(0);
        if (first == 8203 && !prevInput) {
          prevInput = "\u200B";
        }
        if (first == 8666) {
          this.reset();
          return this.cm.execCommand("undo");
        }
      }
      var same = 0, l = Math.min(prevInput.length, text2.length);
      while (same < l && prevInput.charCodeAt(same) == text2.charCodeAt(same)) {
        ++same;
      }
      runInOp(cm, function() {
        applyTextInput(cm, text2.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);
        if (text2.length > 1e3 || text2.indexOf("\n") > -1) {
          input.value = this$1.prevInput = "";
        } else {
          this$1.prevInput = text2;
        }
        if (this$1.composing) {
          this$1.composing.range.clear();
          this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {className: "CodeMirror-composing"});
        }
      });
      return true;
    };
    TextareaInput.prototype.ensurePolled = function() {
      if (this.pollingFast && this.poll()) {
        this.pollingFast = false;
      }
    };
    TextareaInput.prototype.onKeyPress = function() {
      if (ie && ie_version >= 9) {
        this.hasSelection = null;
      }
      this.fastPoll();
    };
    TextareaInput.prototype.onContextMenu = function(e) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      if (input.contextMenuPending) {
        input.contextMenuPending();
      }
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) {
        return;
      }
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1) {
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
      }
      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
      var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
      input.wrapper.style.cssText = "position: static";
      te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      var oldScrollY;
      if (webkit) {
        oldScrollY = window.scrollY;
      }
      display.input.focus();
      if (webkit) {
        window.scrollTo(null, oldScrollY);
      }
      display.input.reset();
      if (!cm.somethingSelected()) {
        te.value = input.prevInput = " ";
      }
      input.contextMenuPending = rehide;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200B" + (selected ? te.value : "");
          te.value = "\u21DA";
          te.value = extval;
          input.prevInput = selected ? "" : "\u200B";
          te.selectionStart = 1;
          te.selectionEnd = extval.length;
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        if (input.contextMenuPending != rehide) {
          return;
        }
        input.contextMenuPending = false;
        input.wrapper.style.cssText = oldWrapperCSS;
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) {
          display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
        }
        if (te.selectionStart != null) {
          if (!ie || ie && ie_version < 9) {
            prepareSelectAllHack();
          }
          var i2 = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
              operation(cm, selectAll)(cm);
            } else if (i2++ < 10) {
              display.detectingSelectAll = setTimeout(poll, 500);
            } else {
              display.selForContextMenu = null;
              display.input.reset();
            }
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }
      if (ie && ie_version >= 9) {
        prepareSelectAllHack();
      }
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off2(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on3(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    };
    TextareaInput.prototype.readOnlyChanged = function(val) {
      if (!val) {
        this.reset();
      }
      this.textarea.disabled = val == "nocursor";
      this.textarea.readOnly = !!val;
    };
    TextareaInput.prototype.setUneditable = function() {
    };
    TextareaInput.prototype.needsContentAttribute = false;
    function fromTextArea(textarea, options) {
      options = options ? copyObj(options) : {};
      options.value = textarea.value;
      if (!options.tabindex && textarea.tabIndex) {
        options.tabindex = textarea.tabIndex;
      }
      if (!options.placeholder && textarea.placeholder) {
        options.placeholder = textarea.placeholder;
      }
      if (options.autofocus == null) {
        var hasFocus = activeElt();
        options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
      }
      function save2() {
        textarea.value = cm.getValue();
      }
      var realSubmit;
      if (textarea.form) {
        on3(textarea.form, "submit", save2);
        if (!options.leaveSubmitMethodAlone) {
          var form = textarea.form;
          realSubmit = form.submit;
          try {
            var wrappedSubmit = form.submit = function() {
              save2();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
          } catch (e) {
          }
        }
      }
      options.finishInit = function(cm2) {
        cm2.save = save2;
        cm2.getTextArea = function() {
          return textarea;
        };
        cm2.toTextArea = function() {
          cm2.toTextArea = isNaN;
          save2();
          textarea.parentNode.removeChild(cm2.getWrapperElement());
          textarea.style.display = "";
          if (textarea.form) {
            off2(textarea.form, "submit", save2);
            if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
              textarea.form.submit = realSubmit;
            }
          }
        };
      };
      textarea.style.display = "none";
      var cm = CodeMirror2(function(node) {
        return textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options);
      return cm;
    }
    function addLegacyProps(CodeMirror3) {
      CodeMirror3.off = off2;
      CodeMirror3.on = on3;
      CodeMirror3.wheelEventPixels = wheelEventPixels;
      CodeMirror3.Doc = Doc;
      CodeMirror3.splitLines = splitLinesAuto;
      CodeMirror3.countColumn = countColumn;
      CodeMirror3.findColumn = findColumn;
      CodeMirror3.isWordChar = isWordCharBasic;
      CodeMirror3.Pass = Pass;
      CodeMirror3.signal = signal;
      CodeMirror3.Line = Line;
      CodeMirror3.changeEnd = changeEnd;
      CodeMirror3.scrollbarModel = scrollbarModel;
      CodeMirror3.Pos = Pos;
      CodeMirror3.cmpPos = cmp;
      CodeMirror3.modes = modes;
      CodeMirror3.mimeModes = mimeModes;
      CodeMirror3.resolveMode = resolveMode;
      CodeMirror3.getMode = getMode;
      CodeMirror3.modeExtensions = modeExtensions;
      CodeMirror3.extendMode = extendMode;
      CodeMirror3.copyState = copyState;
      CodeMirror3.startState = startState;
      CodeMirror3.innerMode = innerMode;
      CodeMirror3.commands = commands;
      CodeMirror3.keyMap = keyMap;
      CodeMirror3.keyName = keyName;
      CodeMirror3.isModifierKey = isModifierKey;
      CodeMirror3.lookupKey = lookupKey;
      CodeMirror3.normalizeKeyMap = normalizeKeyMap;
      CodeMirror3.StringStream = StringStream;
      CodeMirror3.SharedTextMarker = SharedTextMarker;
      CodeMirror3.TextMarker = TextMarker;
      CodeMirror3.LineWidget = LineWidget;
      CodeMirror3.e_preventDefault = e_preventDefault;
      CodeMirror3.e_stopPropagation = e_stopPropagation;
      CodeMirror3.e_stop = e_stop;
      CodeMirror3.addClass = addClass;
      CodeMirror3.contains = contains;
      CodeMirror3.rmClass = rmClass;
      CodeMirror3.keyNames = keyNames;
    }
    defineOptions(CodeMirror2);
    addEditorMethods(CodeMirror2);
    var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
    for (var prop in Doc.prototype) {
      if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
        CodeMirror2.prototype[prop] = function(method) {
          return function() {
            return method.apply(this.doc, arguments);
          };
        }(Doc.prototype[prop]);
      }
    }
    eventMixin(Doc);
    CodeMirror2.inputStyles = {textarea: TextareaInput, contenteditable: ContentEditableInput};
    CodeMirror2.defineMode = function(name2) {
      if (!CodeMirror2.defaults.mode && name2 != "null") {
        CodeMirror2.defaults.mode = name2;
      }
      defineMode.apply(this, arguments);
    };
    CodeMirror2.defineMIME = defineMIME;
    CodeMirror2.defineMode("null", function() {
      return {token: function(stream) {
        return stream.skipToEnd();
      }};
    });
    CodeMirror2.defineMIME("text/plain", "null");
    CodeMirror2.defineExtension = function(name2, func) {
      CodeMirror2.prototype[name2] = func;
    };
    CodeMirror2.defineDocExtension = function(name2, func) {
      Doc.prototype[name2] = func;
    };
    CodeMirror2.fromTextArea = fromTextArea;
    addLegacyProps(CodeMirror2);
    CodeMirror2.version = "5.65.4";
    return CodeMirror2;
  });
});

// node_modules/codemirror/addon/edit/continuelist.js
var require_continuelist = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror());
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    "use strict";
    var listRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]\s|[*+-]\s|(\d+)([.)]))(\s*)/, emptyListRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]|[*+-]|(\d+)[.)])(\s*)$/, unorderedListRE = /[*+-]\s/;
    CodeMirror2.commands.newlineAndIndentContinueMarkdownList = function(cm) {
      if (cm.getOption("disableInput"))
        return CodeMirror2.Pass;
      var ranges = cm.listSelections(), replacements = [];
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].head;
        var eolState = cm.getStateAfter(pos.line);
        var inner = CodeMirror2.innerMode(cm.getMode(), eolState);
        if (inner.mode.name !== "markdown" && inner.mode.helperType !== "markdown") {
          cm.execCommand("newlineAndIndent");
          return;
        } else {
          eolState = inner.state;
        }
        var inList = eolState.list !== false;
        var inQuote = eolState.quote !== 0;
        var line = cm.getLine(pos.line), match = listRE.exec(line);
        var cursorBeforeBullet = /^\s*$/.test(line.slice(0, pos.ch));
        if (!ranges[i].empty() || !inList && !inQuote || !match || cursorBeforeBullet) {
          cm.execCommand("newlineAndIndent");
          return;
        }
        if (emptyListRE.test(line)) {
          var endOfQuote = inQuote && />\s*$/.test(line);
          var endOfList = !/>\s*$/.test(line);
          if (endOfQuote || endOfList)
            cm.replaceRange("", {
              line: pos.line,
              ch: 0
            }, {
              line: pos.line,
              ch: pos.ch + 1
            });
          replacements[i] = "\n";
        } else {
          var indent = match[1], after = match[5];
          var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf(">") >= 0);
          var bullet = numbered ? parseInt(match[3], 10) + 1 + match[4] : match[2].replace("x", " ");
          replacements[i] = "\n" + indent + bullet + after;
          if (numbered)
            incrementRemainingMarkdownListNumbers(cm, pos);
        }
      }
      cm.replaceSelections(replacements);
    };
    function incrementRemainingMarkdownListNumbers(cm, pos) {
      var startLine = pos.line, lookAhead = 0, skipCount = 0;
      var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];
      do {
        lookAhead += 1;
        var nextLineNumber = startLine + lookAhead;
        var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);
        if (nextItem) {
          var nextIndent = nextItem[1];
          var newNumber = parseInt(startItem[3], 10) + lookAhead - skipCount;
          var nextNumber = parseInt(nextItem[3], 10), itemNumber = nextNumber;
          if (startIndent === nextIndent && !isNaN(nextNumber)) {
            if (newNumber === nextNumber)
              itemNumber = nextNumber + 1;
            if (newNumber > nextNumber)
              itemNumber = newNumber + 1;
            cm.replaceRange(nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]), {
              line: nextLineNumber,
              ch: 0
            }, {
              line: nextLineNumber,
              ch: nextLine.length
            });
          } else {
            if (startIndent.length > nextIndent.length)
              return;
            if (startIndent.length < nextIndent.length && lookAhead === 1)
              return;
            skipCount += 1;
          }
        }
      } while (nextItem);
    }
  });
});

// node_modules/easymde/src/js/codemirror/tablist.js
var require_tablist = __commonJS(() => {
  var CodeMirror2 = require_codemirror();
  CodeMirror2.commands.tabAndIndentMarkdownList = function(cm) {
    var ranges = cm.listSelections();
    var pos = ranges[0].head;
    var eolState = cm.getStateAfter(pos.line);
    var inList = eolState.list !== false;
    if (inList) {
      cm.execCommand("indentMore");
      return;
    }
    if (cm.options.indentWithTabs) {
      cm.execCommand("insertTab");
    } else {
      var spaces = Array(cm.options.tabSize + 1).join(" ");
      cm.replaceSelection(spaces);
    }
  };
  CodeMirror2.commands.shiftTabAndUnindentMarkdownList = function(cm) {
    var ranges = cm.listSelections();
    var pos = ranges[0].head;
    var eolState = cm.getStateAfter(pos.line);
    var inList = eolState.list !== false;
    if (inList) {
      cm.execCommand("indentLess");
      return;
    }
    if (cm.options.indentWithTabs) {
      cm.execCommand("insertTab");
    } else {
      var spaces = Array(cm.options.tabSize + 1).join(" ");
      cm.replaceSelection(spaces);
    }
  };
});

// node_modules/codemirror/addon/display/fullscreen.js
var require_fullscreen = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror());
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    "use strict";
    CodeMirror2.defineOption("fullScreen", false, function(cm, val, old) {
      if (old == CodeMirror2.Init)
        old = false;
      if (!old == !val)
        return;
      if (val)
        setFullscreen(cm);
      else
        setNormal(cm);
    });
    function setFullscreen(cm) {
      var wrap2 = cm.getWrapperElement();
      cm.state.fullScreenRestore = {
        scrollTop: window.pageYOffset,
        scrollLeft: window.pageXOffset,
        width: wrap2.style.width,
        height: wrap2.style.height
      };
      wrap2.style.width = "";
      wrap2.style.height = "auto";
      wrap2.className += " CodeMirror-fullscreen";
      document.documentElement.style.overflow = "hidden";
      cm.refresh();
    }
    function setNormal(cm) {
      var wrap2 = cm.getWrapperElement();
      wrap2.className = wrap2.className.replace(/\s*CodeMirror-fullscreen\b/, "");
      document.documentElement.style.overflow = "";
      var info = cm.state.fullScreenRestore;
      wrap2.style.width = info.width;
      wrap2.style.height = info.height;
      window.scrollTo(info.scrollLeft, info.scrollTop);
      cm.refresh();
    }
  });
});

// node_modules/codemirror/mode/xml/xml.js
var require_xml = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror());
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    "use strict";
    var htmlConfig = {
      autoSelfClosers: {
        area: true,
        base: true,
        br: true,
        col: true,
        command: true,
        embed: true,
        frame: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true,
        menuitem: true
      },
      implicitlyClosed: {
        dd: true,
        li: true,
        optgroup: true,
        option: true,
        p: true,
        rp: true,
        rt: true,
        tbody: true,
        td: true,
        tfoot: true,
        th: true,
        tr: true
      },
      contextGrabbers: {
        dd: {dd: true, dt: true},
        dt: {dd: true, dt: true},
        li: {li: true},
        option: {option: true, optgroup: true},
        optgroup: {optgroup: true},
        p: {
          address: true,
          article: true,
          aside: true,
          blockquote: true,
          dir: true,
          div: true,
          dl: true,
          fieldset: true,
          footer: true,
          form: true,
          h1: true,
          h2: true,
          h3: true,
          h4: true,
          h5: true,
          h6: true,
          header: true,
          hgroup: true,
          hr: true,
          menu: true,
          nav: true,
          ol: true,
          p: true,
          pre: true,
          section: true,
          table: true,
          ul: true
        },
        rp: {rp: true, rt: true},
        rt: {rp: true, rt: true},
        tbody: {tbody: true, tfoot: true},
        td: {td: true, th: true},
        tfoot: {tbody: true},
        th: {td: true, th: true},
        thead: {tbody: true, tfoot: true},
        tr: {tr: true}
      },
      doNotIndent: {pre: true},
      allowUnquoted: true,
      allowMissing: true,
      caseFold: true
    };
    var xmlConfig = {
      autoSelfClosers: {},
      implicitlyClosed: {},
      contextGrabbers: {},
      doNotIndent: {},
      allowUnquoted: false,
      allowMissing: false,
      allowMissingTagName: false,
      caseFold: false
    };
    CodeMirror2.defineMode("xml", function(editorConf, config_) {
      var indentUnit = editorConf.indentUnit;
      var config = {};
      var defaults3 = config_.htmlMode ? htmlConfig : xmlConfig;
      for (var prop in defaults3)
        config[prop] = defaults3[prop];
      for (var prop in config_)
        config[prop] = config_[prop];
      var type, setStyle;
      function inText(stream, state2) {
        function chain2(parser) {
          state2.tokenize = parser;
          return parser(stream, state2);
        }
        var ch = stream.next();
        if (ch == "<") {
          if (stream.eat("!")) {
            if (stream.eat("[")) {
              if (stream.match("CDATA["))
                return chain2(inBlock("atom", "]]>"));
              else
                return null;
            } else if (stream.match("--")) {
              return chain2(inBlock("comment", "-->"));
            } else if (stream.match("DOCTYPE", true, true)) {
              stream.eatWhile(/[\w\._\-]/);
              return chain2(doctype(1));
            } else {
              return null;
            }
          } else if (stream.eat("?")) {
            stream.eatWhile(/[\w\._\-]/);
            state2.tokenize = inBlock("meta", "?>");
            return "meta";
          } else {
            type = stream.eat("/") ? "closeTag" : "openTag";
            state2.tokenize = inTag;
            return "tag bracket";
          }
        } else if (ch == "&") {
          var ok;
          if (stream.eat("#")) {
            if (stream.eat("x")) {
              ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
            } else {
              ok = stream.eatWhile(/[\d]/) && stream.eat(";");
            }
          } else {
            ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
          }
          return ok ? "atom" : "error";
        } else {
          stream.eatWhile(/[^&<]/);
          return null;
        }
      }
      inText.isInText = true;
      function inTag(stream, state2) {
        var ch = stream.next();
        if (ch == ">" || ch == "/" && stream.eat(">")) {
          state2.tokenize = inText;
          type = ch == ">" ? "endTag" : "selfcloseTag";
          return "tag bracket";
        } else if (ch == "=") {
          type = "equals";
          return null;
        } else if (ch == "<") {
          state2.tokenize = inText;
          state2.state = baseState;
          state2.tagName = state2.tagStart = null;
          var next = state2.tokenize(stream, state2);
          return next ? next + " tag error" : "tag error";
        } else if (/[\'\"]/.test(ch)) {
          state2.tokenize = inAttribute(ch);
          state2.stringStartCol = stream.column();
          return state2.tokenize(stream, state2);
        } else {
          stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
          return "word";
        }
      }
      function inAttribute(quote) {
        var closure = function(stream, state2) {
          while (!stream.eol()) {
            if (stream.next() == quote) {
              state2.tokenize = inTag;
              break;
            }
          }
          return "string";
        };
        closure.isInAttribute = true;
        return closure;
      }
      function inBlock(style, terminator) {
        return function(stream, state2) {
          while (!stream.eol()) {
            if (stream.match(terminator)) {
              state2.tokenize = inText;
              break;
            }
            stream.next();
          }
          return style;
        };
      }
      function doctype(depth) {
        return function(stream, state2) {
          var ch;
          while ((ch = stream.next()) != null) {
            if (ch == "<") {
              state2.tokenize = doctype(depth + 1);
              return state2.tokenize(stream, state2);
            } else if (ch == ">") {
              if (depth == 1) {
                state2.tokenize = inText;
                break;
              } else {
                state2.tokenize = doctype(depth - 1);
                return state2.tokenize(stream, state2);
              }
            }
          }
          return "meta";
        };
      }
      function lower(tagName) {
        return tagName && tagName.toLowerCase();
      }
      function Context(state2, tagName, startOfLine) {
        this.prev = state2.context;
        this.tagName = tagName || "";
        this.indent = state2.indented;
        this.startOfLine = startOfLine;
        if (config.doNotIndent.hasOwnProperty(tagName) || state2.context && state2.context.noIndent)
          this.noIndent = true;
      }
      function popContext(state2) {
        if (state2.context)
          state2.context = state2.context.prev;
      }
      function maybePopContext(state2, nextTagName) {
        var parentTagName;
        while (true) {
          if (!state2.context) {
            return;
          }
          parentTagName = state2.context.tagName;
          if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) || !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {
            return;
          }
          popContext(state2);
        }
      }
      function baseState(type2, stream, state2) {
        if (type2 == "openTag") {
          state2.tagStart = stream.column();
          return tagNameState;
        } else if (type2 == "closeTag") {
          return closeTagNameState;
        } else {
          return baseState;
        }
      }
      function tagNameState(type2, stream, state2) {
        if (type2 == "word") {
          state2.tagName = stream.current();
          setStyle = "tag";
          return attrState;
        } else if (config.allowMissingTagName && type2 == "endTag") {
          setStyle = "tag bracket";
          return attrState(type2, stream, state2);
        } else {
          setStyle = "error";
          return tagNameState;
        }
      }
      function closeTagNameState(type2, stream, state2) {
        if (type2 == "word") {
          var tagName = stream.current();
          if (state2.context && state2.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(lower(state2.context.tagName)))
            popContext(state2);
          if (state2.context && state2.context.tagName == tagName || config.matchClosing === false) {
            setStyle = "tag";
            return closeState;
          } else {
            setStyle = "tag error";
            return closeStateErr;
          }
        } else if (config.allowMissingTagName && type2 == "endTag") {
          setStyle = "tag bracket";
          return closeState(type2, stream, state2);
        } else {
          setStyle = "error";
          return closeStateErr;
        }
      }
      function closeState(type2, _stream, state2) {
        if (type2 != "endTag") {
          setStyle = "error";
          return closeState;
        }
        popContext(state2);
        return baseState;
      }
      function closeStateErr(type2, stream, state2) {
        setStyle = "error";
        return closeState(type2, stream, state2);
      }
      function attrState(type2, _stream, state2) {
        if (type2 == "word") {
          setStyle = "attribute";
          return attrEqState;
        } else if (type2 == "endTag" || type2 == "selfcloseTag") {
          var tagName = state2.tagName, tagStart = state2.tagStart;
          state2.tagName = state2.tagStart = null;
          if (type2 == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(lower(tagName))) {
            maybePopContext(state2, tagName);
          } else {
            maybePopContext(state2, tagName);
            state2.context = new Context(state2, tagName, tagStart == state2.indented);
          }
          return baseState;
        }
        setStyle = "error";
        return attrState;
      }
      function attrEqState(type2, stream, state2) {
        if (type2 == "equals")
          return attrValueState;
        if (!config.allowMissing)
          setStyle = "error";
        return attrState(type2, stream, state2);
      }
      function attrValueState(type2, stream, state2) {
        if (type2 == "string")
          return attrContinuedState;
        if (type2 == "word" && config.allowUnquoted) {
          setStyle = "string";
          return attrState;
        }
        setStyle = "error";
        return attrState(type2, stream, state2);
      }
      function attrContinuedState(type2, stream, state2) {
        if (type2 == "string")
          return attrContinuedState;
        return attrState(type2, stream, state2);
      }
      return {
        startState: function(baseIndent) {
          var state2 = {
            tokenize: inText,
            state: baseState,
            indented: baseIndent || 0,
            tagName: null,
            tagStart: null,
            context: null
          };
          if (baseIndent != null)
            state2.baseIndent = baseIndent;
          return state2;
        },
        token: function(stream, state2) {
          if (!state2.tagName && stream.sol())
            state2.indented = stream.indentation();
          if (stream.eatSpace())
            return null;
          type = null;
          var style = state2.tokenize(stream, state2);
          if ((style || type) && style != "comment") {
            setStyle = null;
            state2.state = state2.state(type || style, stream, state2);
            if (setStyle)
              style = setStyle == "error" ? style + " error" : setStyle;
          }
          return style;
        },
        indent: function(state2, textAfter, fullLine) {
          var context = state2.context;
          if (state2.tokenize.isInAttribute) {
            if (state2.tagStart == state2.indented)
              return state2.stringStartCol + 1;
            else
              return state2.indented + indentUnit;
          }
          if (context && context.noIndent)
            return CodeMirror2.Pass;
          if (state2.tokenize != inTag && state2.tokenize != inText)
            return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
          if (state2.tagName) {
            if (config.multilineTagIndentPastTag !== false)
              return state2.tagStart + state2.tagName.length + 2;
            else
              return state2.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
          }
          if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter))
            return 0;
          var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
          if (tagAfter && tagAfter[1]) {
            while (context) {
              if (context.tagName == tagAfter[2]) {
                context = context.prev;
                break;
              } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {
                context = context.prev;
              } else {
                break;
              }
            }
          } else if (tagAfter) {
            while (context) {
              var grabbers = config.contextGrabbers[lower(context.tagName)];
              if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))
                context = context.prev;
              else
                break;
            }
          }
          while (context && context.prev && !context.startOfLine)
            context = context.prev;
          if (context)
            return context.indent + indentUnit;
          else
            return state2.baseIndent || 0;
        },
        electricInput: /<\/[\s\w:]+>$/,
        blockCommentStart: "<!--",
        blockCommentEnd: "-->",
        configuration: config.htmlMode ? "html" : "xml",
        helperType: config.htmlMode ? "html" : "xml",
        skipAttribute: function(state2) {
          if (state2.state == attrValueState)
            state2.state = attrState;
        },
        xmlCurrentTag: function(state2) {
          return state2.tagName ? {name: state2.tagName, close: state2.type == "closeTag"} : null;
        },
        xmlCurrentContext: function(state2) {
          var context = [];
          for (var cx = state2.context; cx; cx = cx.prev)
            context.push(cx.tagName);
          return context.reverse();
        }
      };
    });
    CodeMirror2.defineMIME("text/xml", "xml");
    CodeMirror2.defineMIME("application/xml", "xml");
    if (!CodeMirror2.mimeModes.hasOwnProperty("text/html"))
      CodeMirror2.defineMIME("text/html", {name: "xml", htmlMode: true});
  });
});

// node_modules/codemirror/mode/meta.js
var require_meta = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror());
    else if (typeof define == "function" && define.amd)
      define(["../lib/codemirror"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    "use strict";
    CodeMirror2.modeInfo = [
      {name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]},
      {name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"]},
      {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]},
      {name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i},
      {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]},
      {name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"]},
      {name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"]},
      {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy", "cbl"]},
      {name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"]},
      {name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"]},
      {name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"]},
      {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]},
      {name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists\.txt$/},
      {name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"]},
      {name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"]},
      {name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"]},
      {name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"]},
      {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]},
      {name: "CSS", mime: "text/css", mode: "css", ext: ["css"]},
      {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]},
      {name: "D", mime: "text/x-d", mode: "d", ext: ["d"]},
      {name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"]},
      {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]},
      {name: "Django", mime: "text/x-django", mode: "django"},
      {name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/},
      {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]},
      {name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"]},
      {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"},
      {name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"]},
      {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]},
      {name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"]},
      {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]},
      {name: "Embedded JavaScript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"]},
      {name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"]},
      {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]},
      {name: "Esper", mime: "text/x-esper", mode: "sql"},
      {name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"]},
      {name: "FCL", mime: "text/x-fcl", mode: "fcl"},
      {name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"]},
      {name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"]},
      {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]},
      {name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"]},
      {name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"]},
      {name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history)\.md$/i},
      {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]},
      {name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/},
      {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]},
      {name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"]},
      {name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"]},
      {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]},
      {name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"]},
      {name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"]},
      {name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"]},
      {name: "HTTP", mime: "message/http", mode: "http"},
      {name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"]},
      {name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"]},
      {name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"]},
      {name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"]},
      {
        name: "JavaScript",
        mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
        mode: "javascript",
        ext: ["js"],
        alias: ["ecmascript", "js", "node"]
      },
      {name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"]},
      {name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"]},
      {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]},
      {name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"]},
      {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"], alias: ["jl"]},
      {name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"]},
      {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]},
      {name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"]},
      {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]},
      {name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"]},
      {name: "mIRC", mime: "text/mirc", mode: "mirc"},
      {name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql"},
      {name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb", "wl", "wls"]},
      {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]},
      {name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"]},
      {name: "MS SQL", mime: "text/x-mssql", mode: "sql"},
      {name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"]},
      {name: "MySQL", mime: "text/x-mysql", mode: "sql"},
      {name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i},
      {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]},
      {
        name: "NTriples",
        mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
        mode: "ntriples",
        ext: ["nt", "nq"]
      },
      {name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m"], alias: ["objective-c", "objc"]},
      {name: "Objective-C++", mime: "text/x-objectivec++", mode: "clike", ext: ["mm"], alias: ["objective-c++", "objc++"]},
      {name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"]},
      {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]},
      {name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"]},
      {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]},
      {name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"]},
      {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]},
      {name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"]},
      {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]},
      {name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"]},
      {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]},
      {name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql"},
      {name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"]},
      {name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"]},
      {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]},
      {name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/},
      {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]},
      {name: "Q", mime: "text/x-q", mode: "q", ext: ["q"]},
      {name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"]},
      {name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"]},
      {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"},
      {name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"]},
      {name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"]},
      {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]},
      {name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"]},
      {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]},
      {name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"]},
      {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]},
      {name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"]},
      {name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/},
      {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]},
      {name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"]},
      {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]},
      {name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"]},
      {name: "Solr", mime: "text/x-solr", mode: "solr"},
      {name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"]},
      {name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"]},
      {name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"]},
      {name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"]},
      {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]},
      {name: "SQLite", mime: "text/x-sqlite", mode: "sql"},
      {name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"]},
      {name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"]},
      {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]},
      {name: "sTeX", mime: "text/x-stex", mode: "stex"},
      {name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"]},
      {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"]},
      {name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"]},
      {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]},
      {name: "TiddlyWiki", mime: "text/x-tiddlywiki", mode: "tiddlywiki"},
      {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"},
      {name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"]},
      {name: "Tornado", mime: "text/x-tornado", mode: "tornado"},
      {name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]},
      {name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"]},
      {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]},
      {name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"]},
      {name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"]},
      {name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"]},
      {name: "Twig", mime: "text/x-twig", mode: "twig"},
      {name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"]},
      {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]},
      {name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"]},
      {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]},
      {name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"]},
      {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]},
      {name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"]},
      {name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"]},
      {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]},
      {name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"]},
      {name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"]},
      {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]},
      {name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"]},
      {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]},
      {name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"]},
      {name: "WebAssembly", mime: "text/webassembly", mode: "wast", ext: ["wat", "wast"]}
    ];
    for (var i = 0; i < CodeMirror2.modeInfo.length; i++) {
      var info = CodeMirror2.modeInfo[i];
      if (info.mimes)
        info.mime = info.mimes[0];
    }
    CodeMirror2.findModeByMIME = function(mime) {
      mime = mime.toLowerCase();
      for (var i2 = 0; i2 < CodeMirror2.modeInfo.length; i2++) {
        var info2 = CodeMirror2.modeInfo[i2];
        if (info2.mime == mime)
          return info2;
        if (info2.mimes) {
          for (var j = 0; j < info2.mimes.length; j++)
            if (info2.mimes[j] == mime)
              return info2;
        }
      }
      if (/\+xml$/.test(mime))
        return CodeMirror2.findModeByMIME("application/xml");
      if (/\+json$/.test(mime))
        return CodeMirror2.findModeByMIME("application/json");
    };
    CodeMirror2.findModeByExtension = function(ext) {
      ext = ext.toLowerCase();
      for (var i2 = 0; i2 < CodeMirror2.modeInfo.length; i2++) {
        var info2 = CodeMirror2.modeInfo[i2];
        if (info2.ext) {
          for (var j = 0; j < info2.ext.length; j++)
            if (info2.ext[j] == ext)
              return info2;
        }
      }
    };
    CodeMirror2.findModeByFileName = function(filename) {
      for (var i2 = 0; i2 < CodeMirror2.modeInfo.length; i2++) {
        var info2 = CodeMirror2.modeInfo[i2];
        if (info2.file && info2.file.test(filename))
          return info2;
      }
      var dot = filename.lastIndexOf(".");
      var ext = dot > -1 && filename.substring(dot + 1, filename.length);
      if (ext)
        return CodeMirror2.findModeByExtension(ext);
    };
    CodeMirror2.findModeByName = function(name2) {
      name2 = name2.toLowerCase();
      for (var i2 = 0; i2 < CodeMirror2.modeInfo.length; i2++) {
        var info2 = CodeMirror2.modeInfo[i2];
        if (info2.name.toLowerCase() == name2)
          return info2;
        if (info2.alias) {
          for (var j = 0; j < info2.alias.length; j++)
            if (info2.alias[j].toLowerCase() == name2)
              return info2;
        }
      }
    };
  });
});

// node_modules/codemirror/mode/markdown/markdown.js
var require_markdown = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror(), require_xml(), require_meta());
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror", "../xml/xml", "../meta"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    "use strict";
    CodeMirror2.defineMode("markdown", function(cmCfg, modeCfg) {
      var htmlMode = CodeMirror2.getMode(cmCfg, "text/html");
      var htmlModeMissing = htmlMode.name == "null";
      function getMode(name2) {
        if (CodeMirror2.findModeByName) {
          var found = CodeMirror2.findModeByName(name2);
          if (found)
            name2 = found.mime || found.mimes[0];
        }
        var mode2 = CodeMirror2.getMode(cmCfg, name2);
        return mode2.name == "null" ? null : mode2;
      }
      if (modeCfg.highlightFormatting === void 0)
        modeCfg.highlightFormatting = false;
      if (modeCfg.maxBlockquoteDepth === void 0)
        modeCfg.maxBlockquoteDepth = 0;
      if (modeCfg.taskLists === void 0)
        modeCfg.taskLists = false;
      if (modeCfg.strikethrough === void 0)
        modeCfg.strikethrough = false;
      if (modeCfg.emoji === void 0)
        modeCfg.emoji = false;
      if (modeCfg.fencedCodeBlockHighlighting === void 0)
        modeCfg.fencedCodeBlockHighlighting = true;
      if (modeCfg.fencedCodeBlockDefaultMode === void 0)
        modeCfg.fencedCodeBlockDefaultMode = "text/plain";
      if (modeCfg.xml === void 0)
        modeCfg.xml = true;
      if (modeCfg.tokenTypeOverrides === void 0)
        modeCfg.tokenTypeOverrides = {};
      var tokenTypes = {
        header: "header",
        code: "comment",
        quote: "quote",
        list1: "variable-2",
        list2: "variable-3",
        list3: "keyword",
        hr: "hr",
        image: "image",
        imageAltText: "image-alt-text",
        imageMarker: "image-marker",
        formatting: "formatting",
        linkInline: "link",
        linkEmail: "link",
        linkText: "link",
        linkHref: "string",
        em: "em",
        strong: "strong",
        strikethrough: "strikethrough",
        emoji: "builtin"
      };
      for (var tokenType in tokenTypes) {
        if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
          tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
        }
      }
      var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/, listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/, taskListRE = /^\[(x| )\](?=\s)/i, atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/, setextHeaderRE = /^ {0,3}(?:\={1,}|-{2,})\s*$/, textRE = /^[^#!\[\]*_\\<>` "'(~:]+/, fencedCodeRE = /^(~~~+|```+)[ \t]*([\w\/+#-]*)[^\n`]*$/, linkDefRE = /^\s*\[[^\]]+?\]:.*$/, punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/, expandedTab = "    ";
      function switchInline(stream, state2, f) {
        state2.f = state2.inline = f;
        return f(stream, state2);
      }
      function switchBlock(stream, state2, f) {
        state2.f = state2.block = f;
        return f(stream, state2);
      }
      function lineIsEmpty(line) {
        return !line || !/\S/.test(line.string);
      }
      function blankLine(state2) {
        state2.linkTitle = false;
        state2.linkHref = false;
        state2.linkText = false;
        state2.em = false;
        state2.strong = false;
        state2.strikethrough = false;
        state2.quote = 0;
        state2.indentedCode = false;
        if (state2.f == htmlBlock) {
          var exit = htmlModeMissing;
          if (!exit) {
            var inner = CodeMirror2.innerMode(htmlMode, state2.htmlState);
            exit = inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText);
          }
          if (exit) {
            state2.f = inlineNormal;
            state2.block = blockNormal;
            state2.htmlState = null;
          }
        }
        state2.trailingSpace = 0;
        state2.trailingSpaceNewLine = false;
        state2.prevLine = state2.thisLine;
        state2.thisLine = {stream: null};
        return null;
      }
      function blockNormal(stream, state2) {
        var firstTokenOnLine = stream.column() === state2.indentation;
        var prevLineLineIsEmpty = lineIsEmpty(state2.prevLine.stream);
        var prevLineIsIndentedCode = state2.indentedCode;
        var prevLineIsHr = state2.prevLine.hr;
        var prevLineIsList = state2.list !== false;
        var maxNonCodeIndentation = (state2.listStack[state2.listStack.length - 1] || 0) + 3;
        state2.indentedCode = false;
        var lineIndentation = state2.indentation;
        if (state2.indentationDiff === null) {
          state2.indentationDiff = state2.indentation;
          if (prevLineIsList) {
            state2.list = null;
            while (lineIndentation < state2.listStack[state2.listStack.length - 1]) {
              state2.listStack.pop();
              if (state2.listStack.length) {
                state2.indentation = state2.listStack[state2.listStack.length - 1];
              } else {
                state2.list = false;
              }
            }
            if (state2.list !== false) {
              state2.indentationDiff = lineIndentation - state2.listStack[state2.listStack.length - 1];
            }
          }
        }
        var allowsInlineContinuation = !prevLineLineIsEmpty && !prevLineIsHr && !state2.prevLine.header && (!prevLineIsList || !prevLineIsIndentedCode) && !state2.prevLine.fencedCodeEnd;
        var isHr = (state2.list === false || prevLineIsHr || prevLineLineIsEmpty) && state2.indentation <= maxNonCodeIndentation && stream.match(hrRE);
        var match = null;
        if (state2.indentationDiff >= 4 && (prevLineIsIndentedCode || state2.prevLine.fencedCodeEnd || state2.prevLine.header || prevLineLineIsEmpty)) {
          stream.skipToEnd();
          state2.indentedCode = true;
          return tokenTypes.code;
        } else if (stream.eatSpace()) {
          return null;
        } else if (firstTokenOnLine && state2.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
          state2.quote = 0;
          state2.header = match[1].length;
          state2.thisLine.header = true;
          if (modeCfg.highlightFormatting)
            state2.formatting = "header";
          state2.f = state2.inline;
          return getType2(state2);
        } else if (state2.indentation <= maxNonCodeIndentation && stream.eat(">")) {
          state2.quote = firstTokenOnLine ? 1 : state2.quote + 1;
          if (modeCfg.highlightFormatting)
            state2.formatting = "quote";
          stream.eatSpace();
          return getType2(state2);
        } else if (!isHr && !state2.setext && firstTokenOnLine && state2.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
          var listType = match[1] ? "ol" : "ul";
          state2.indentation = lineIndentation + stream.current().length;
          state2.list = true;
          state2.quote = 0;
          state2.listStack.push(state2.indentation);
          state2.em = false;
          state2.strong = false;
          state2.code = false;
          state2.strikethrough = false;
          if (modeCfg.taskLists && stream.match(taskListRE, false)) {
            state2.taskList = true;
          }
          state2.f = state2.inline;
          if (modeCfg.highlightFormatting)
            state2.formatting = ["list", "list-" + listType];
          return getType2(state2);
        } else if (firstTokenOnLine && state2.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {
          state2.quote = 0;
          state2.fencedEndRE = new RegExp(match[1] + "+ *$");
          state2.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2] || modeCfg.fencedCodeBlockDefaultMode);
          if (state2.localMode)
            state2.localState = CodeMirror2.startState(state2.localMode);
          state2.f = state2.block = local;
          if (modeCfg.highlightFormatting)
            state2.formatting = "code-block";
          state2.code = -1;
          return getType2(state2);
        } else if (state2.setext || (!allowsInlineContinuation || !prevLineIsList) && !state2.quote && state2.list === false && !state2.code && !isHr && !linkDefRE.test(stream.string) && (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))) {
          if (!state2.setext) {
            state2.header = match[0].charAt(0) == "=" ? 1 : 2;
            state2.setext = state2.header;
          } else {
            state2.header = state2.setext;
            state2.setext = 0;
            stream.skipToEnd();
            if (modeCfg.highlightFormatting)
              state2.formatting = "header";
          }
          state2.thisLine.header = true;
          state2.f = state2.inline;
          return getType2(state2);
        } else if (isHr) {
          stream.skipToEnd();
          state2.hr = true;
          state2.thisLine.hr = true;
          return tokenTypes.hr;
        } else if (stream.peek() === "[") {
          return switchInline(stream, state2, footnoteLink);
        }
        return switchInline(stream, state2, state2.inline);
      }
      function htmlBlock(stream, state2) {
        var style = htmlMode.token(stream, state2.htmlState);
        if (!htmlModeMissing) {
          var inner = CodeMirror2.innerMode(htmlMode, state2.htmlState);
          if (inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText) || state2.md_inside && stream.current().indexOf(">") > -1) {
            state2.f = inlineNormal;
            state2.block = blockNormal;
            state2.htmlState = null;
          }
        }
        return style;
      }
      function local(stream, state2) {
        var currListInd = state2.listStack[state2.listStack.length - 1] || 0;
        var hasExitedList = state2.indentation < currListInd;
        var maxFencedEndInd = currListInd + 3;
        if (state2.fencedEndRE && state2.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state2.fencedEndRE))) {
          if (modeCfg.highlightFormatting)
            state2.formatting = "code-block";
          var returnType;
          if (!hasExitedList)
            returnType = getType2(state2);
          state2.localMode = state2.localState = null;
          state2.block = blockNormal;
          state2.f = inlineNormal;
          state2.fencedEndRE = null;
          state2.code = 0;
          state2.thisLine.fencedCodeEnd = true;
          if (hasExitedList)
            return switchBlock(stream, state2, state2.block);
          return returnType;
        } else if (state2.localMode) {
          return state2.localMode.token(stream, state2.localState);
        } else {
          stream.skipToEnd();
          return tokenTypes.code;
        }
      }
      function getType2(state2) {
        var styles2 = [];
        if (state2.formatting) {
          styles2.push(tokenTypes.formatting);
          if (typeof state2.formatting === "string")
            state2.formatting = [state2.formatting];
          for (var i = 0; i < state2.formatting.length; i++) {
            styles2.push(tokenTypes.formatting + "-" + state2.formatting[i]);
            if (state2.formatting[i] === "header") {
              styles2.push(tokenTypes.formatting + "-" + state2.formatting[i] + "-" + state2.header);
            }
            if (state2.formatting[i] === "quote") {
              if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state2.quote) {
                styles2.push(tokenTypes.formatting + "-" + state2.formatting[i] + "-" + state2.quote);
              } else {
                styles2.push("error");
              }
            }
          }
        }
        if (state2.taskOpen) {
          styles2.push("meta");
          return styles2.length ? styles2.join(" ") : null;
        }
        if (state2.taskClosed) {
          styles2.push("property");
          return styles2.length ? styles2.join(" ") : null;
        }
        if (state2.linkHref) {
          styles2.push(tokenTypes.linkHref, "url");
        } else {
          if (state2.strong) {
            styles2.push(tokenTypes.strong);
          }
          if (state2.em) {
            styles2.push(tokenTypes.em);
          }
          if (state2.strikethrough) {
            styles2.push(tokenTypes.strikethrough);
          }
          if (state2.emoji) {
            styles2.push(tokenTypes.emoji);
          }
          if (state2.linkText) {
            styles2.push(tokenTypes.linkText);
          }
          if (state2.code) {
            styles2.push(tokenTypes.code);
          }
          if (state2.image) {
            styles2.push(tokenTypes.image);
          }
          if (state2.imageAltText) {
            styles2.push(tokenTypes.imageAltText, "link");
          }
          if (state2.imageMarker) {
            styles2.push(tokenTypes.imageMarker);
          }
        }
        if (state2.header) {
          styles2.push(tokenTypes.header, tokenTypes.header + "-" + state2.header);
        }
        if (state2.quote) {
          styles2.push(tokenTypes.quote);
          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state2.quote) {
            styles2.push(tokenTypes.quote + "-" + state2.quote);
          } else {
            styles2.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
          }
        }
        if (state2.list !== false) {
          var listMod = (state2.listStack.length - 1) % 3;
          if (!listMod) {
            styles2.push(tokenTypes.list1);
          } else if (listMod === 1) {
            styles2.push(tokenTypes.list2);
          } else {
            styles2.push(tokenTypes.list3);
          }
        }
        if (state2.trailingSpaceNewLine) {
          styles2.push("trailing-space-new-line");
        } else if (state2.trailingSpace) {
          styles2.push("trailing-space-" + (state2.trailingSpace % 2 ? "a" : "b"));
        }
        return styles2.length ? styles2.join(" ") : null;
      }
      function handleText(stream, state2) {
        if (stream.match(textRE, true)) {
          return getType2(state2);
        }
        return void 0;
      }
      function inlineNormal(stream, state2) {
        var style = state2.text(stream, state2);
        if (typeof style !== "undefined")
          return style;
        if (state2.list) {
          state2.list = null;
          return getType2(state2);
        }
        if (state2.taskList) {
          var taskOpen = stream.match(taskListRE, true)[1] === " ";
          if (taskOpen)
            state2.taskOpen = true;
          else
            state2.taskClosed = true;
          if (modeCfg.highlightFormatting)
            state2.formatting = "task";
          state2.taskList = false;
          return getType2(state2);
        }
        state2.taskOpen = false;
        state2.taskClosed = false;
        if (state2.header && stream.match(/^#+$/, true)) {
          if (modeCfg.highlightFormatting)
            state2.formatting = "header";
          return getType2(state2);
        }
        var ch = stream.next();
        if (state2.linkTitle) {
          state2.linkTitle = false;
          var matchCh = ch;
          if (ch === "(") {
            matchCh = ")";
          }
          matchCh = (matchCh + "").replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
          var regex = "^\\s*(?:[^" + matchCh + "\\\\]+|\\\\\\\\|\\\\.)" + matchCh;
          if (stream.match(new RegExp(regex), true)) {
            return tokenTypes.linkHref;
          }
        }
        if (ch === "`") {
          var previousFormatting = state2.formatting;
          if (modeCfg.highlightFormatting)
            state2.formatting = "code";
          stream.eatWhile("`");
          var count = stream.current().length;
          if (state2.code == 0 && (!state2.quote || count == 1)) {
            state2.code = count;
            return getType2(state2);
          } else if (count == state2.code) {
            var t = getType2(state2);
            state2.code = 0;
            return t;
          } else {
            state2.formatting = previousFormatting;
            return getType2(state2);
          }
        } else if (state2.code) {
          return getType2(state2);
        }
        if (ch === "\\") {
          stream.next();
          if (modeCfg.highlightFormatting) {
            var type = getType2(state2);
            var formattingEscape = tokenTypes.formatting + "-escape";
            return type ? type + " " + formattingEscape : formattingEscape;
          }
        }
        if (ch === "!" && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
          state2.imageMarker = true;
          state2.image = true;
          if (modeCfg.highlightFormatting)
            state2.formatting = "image";
          return getType2(state2);
        }
        if (ch === "[" && state2.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
          state2.imageMarker = false;
          state2.imageAltText = true;
          if (modeCfg.highlightFormatting)
            state2.formatting = "image";
          return getType2(state2);
        }
        if (ch === "]" && state2.imageAltText) {
          if (modeCfg.highlightFormatting)
            state2.formatting = "image";
          var type = getType2(state2);
          state2.imageAltText = false;
          state2.image = false;
          state2.inline = state2.f = linkHref;
          return type;
        }
        if (ch === "[" && !state2.image) {
          if (state2.linkText && stream.match(/^.*?\]/))
            return getType2(state2);
          state2.linkText = true;
          if (modeCfg.highlightFormatting)
            state2.formatting = "link";
          return getType2(state2);
        }
        if (ch === "]" && state2.linkText) {
          if (modeCfg.highlightFormatting)
            state2.formatting = "link";
          var type = getType2(state2);
          state2.linkText = false;
          state2.inline = state2.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal;
          return type;
        }
        if (ch === "<" && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
          state2.f = state2.inline = linkInline;
          if (modeCfg.highlightFormatting)
            state2.formatting = "link";
          var type = getType2(state2);
          if (type) {
            type += " ";
          } else {
            type = "";
          }
          return type + tokenTypes.linkInline;
        }
        if (ch === "<" && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
          state2.f = state2.inline = linkInline;
          if (modeCfg.highlightFormatting)
            state2.formatting = "link";
          var type = getType2(state2);
          if (type) {
            type += " ";
          } else {
            type = "";
          }
          return type + tokenTypes.linkEmail;
        }
        if (modeCfg.xml && ch === "<" && stream.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, false)) {
          var end = stream.string.indexOf(">", stream.pos);
          if (end != -1) {
            var atts = stream.string.substring(stream.start, end);
            if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts))
              state2.md_inside = true;
          }
          stream.backUp(1);
          state2.htmlState = CodeMirror2.startState(htmlMode);
          return switchBlock(stream, state2, htmlBlock);
        }
        if (modeCfg.xml && ch === "<" && stream.match(/^\/\w*?>/)) {
          state2.md_inside = false;
          return "tag";
        } else if (ch === "*" || ch === "_") {
          var len = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2);
          while (len < 3 && stream.eat(ch))
            len++;
          var after = stream.peek() || " ";
          var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before));
          var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after));
          var setEm = null, setStrong = null;
          if (len % 2) {
            if (!state2.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
              setEm = true;
            else if (state2.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
              setEm = false;
          }
          if (len > 1) {
            if (!state2.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
              setStrong = true;
            else if (state2.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
              setStrong = false;
          }
          if (setStrong != null || setEm != null) {
            if (modeCfg.highlightFormatting)
              state2.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em";
            if (setEm === true)
              state2.em = ch;
            if (setStrong === true)
              state2.strong = ch;
            var t = getType2(state2);
            if (setEm === false)
              state2.em = false;
            if (setStrong === false)
              state2.strong = false;
            return t;
          }
        } else if (ch === " ") {
          if (stream.eat("*") || stream.eat("_")) {
            if (stream.peek() === " ") {
              return getType2(state2);
            } else {
              stream.backUp(1);
            }
          }
        }
        if (modeCfg.strikethrough) {
          if (ch === "~" && stream.eatWhile(ch)) {
            if (state2.strikethrough) {
              if (modeCfg.highlightFormatting)
                state2.formatting = "strikethrough";
              var t = getType2(state2);
              state2.strikethrough = false;
              return t;
            } else if (stream.match(/^[^\s]/, false)) {
              state2.strikethrough = true;
              if (modeCfg.highlightFormatting)
                state2.formatting = "strikethrough";
              return getType2(state2);
            }
          } else if (ch === " ") {
            if (stream.match("~~", true)) {
              if (stream.peek() === " ") {
                return getType2(state2);
              } else {
                stream.backUp(2);
              }
            }
          }
        }
        if (modeCfg.emoji && ch === ":" && stream.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) {
          state2.emoji = true;
          if (modeCfg.highlightFormatting)
            state2.formatting = "emoji";
          var retType = getType2(state2);
          state2.emoji = false;
          return retType;
        }
        if (ch === " ") {
          if (stream.match(/^ +$/, false)) {
            state2.trailingSpace++;
          } else if (state2.trailingSpace) {
            state2.trailingSpaceNewLine = true;
          }
        }
        return getType2(state2);
      }
      function linkInline(stream, state2) {
        var ch = stream.next();
        if (ch === ">") {
          state2.f = state2.inline = inlineNormal;
          if (modeCfg.highlightFormatting)
            state2.formatting = "link";
          var type = getType2(state2);
          if (type) {
            type += " ";
          } else {
            type = "";
          }
          return type + tokenTypes.linkInline;
        }
        stream.match(/^[^>]+/, true);
        return tokenTypes.linkInline;
      }
      function linkHref(stream, state2) {
        if (stream.eatSpace()) {
          return null;
        }
        var ch = stream.next();
        if (ch === "(" || ch === "[") {
          state2.f = state2.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
          if (modeCfg.highlightFormatting)
            state2.formatting = "link-string";
          state2.linkHref = true;
          return getType2(state2);
        }
        return "error";
      }
      var linkRE = {
        ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
        "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
      };
      function getLinkHrefInside(endChar) {
        return function(stream, state2) {
          var ch = stream.next();
          if (ch === endChar) {
            state2.f = state2.inline = inlineNormal;
            if (modeCfg.highlightFormatting)
              state2.formatting = "link-string";
            var returnState = getType2(state2);
            state2.linkHref = false;
            return returnState;
          }
          stream.match(linkRE[endChar]);
          state2.linkHref = true;
          return getType2(state2);
        };
      }
      function footnoteLink(stream, state2) {
        if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
          state2.f = footnoteLinkInside;
          stream.next();
          if (modeCfg.highlightFormatting)
            state2.formatting = "link";
          state2.linkText = true;
          return getType2(state2);
        }
        return switchInline(stream, state2, inlineNormal);
      }
      function footnoteLinkInside(stream, state2) {
        if (stream.match("]:", true)) {
          state2.f = state2.inline = footnoteUrl;
          if (modeCfg.highlightFormatting)
            state2.formatting = "link";
          var returnType = getType2(state2);
          state2.linkText = false;
          return returnType;
        }
        stream.match(/^([^\]\\]|\\.)+/, true);
        return tokenTypes.linkText;
      }
      function footnoteUrl(stream, state2) {
        if (stream.eatSpace()) {
          return null;
        }
        stream.match(/^[^\s]+/, true);
        if (stream.peek() === void 0) {
          state2.linkTitle = true;
        } else {
          stream.match(/^(?:\s+(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+'|\((?:[^)\\]|\\.)+\)))?/, true);
        }
        state2.f = state2.inline = inlineNormal;
        return tokenTypes.linkHref + " url";
      }
      var mode = {
        startState: function() {
          return {
            f: blockNormal,
            prevLine: {stream: null},
            thisLine: {stream: null},
            block: blockNormal,
            htmlState: null,
            indentation: 0,
            inline: inlineNormal,
            text: handleText,
            formatting: false,
            linkText: false,
            linkHref: false,
            linkTitle: false,
            code: 0,
            em: false,
            strong: false,
            header: 0,
            setext: 0,
            hr: false,
            taskList: false,
            list: false,
            listStack: [],
            quote: 0,
            trailingSpace: 0,
            trailingSpaceNewLine: false,
            strikethrough: false,
            emoji: false,
            fencedEndRE: null
          };
        },
        copyState: function(s) {
          return {
            f: s.f,
            prevLine: s.prevLine,
            thisLine: s.thisLine,
            block: s.block,
            htmlState: s.htmlState && CodeMirror2.copyState(htmlMode, s.htmlState),
            indentation: s.indentation,
            localMode: s.localMode,
            localState: s.localMode ? CodeMirror2.copyState(s.localMode, s.localState) : null,
            inline: s.inline,
            text: s.text,
            formatting: false,
            linkText: s.linkText,
            linkTitle: s.linkTitle,
            linkHref: s.linkHref,
            code: s.code,
            em: s.em,
            strong: s.strong,
            strikethrough: s.strikethrough,
            emoji: s.emoji,
            header: s.header,
            setext: s.setext,
            hr: s.hr,
            taskList: s.taskList,
            list: s.list,
            listStack: s.listStack.slice(0),
            quote: s.quote,
            indentedCode: s.indentedCode,
            trailingSpace: s.trailingSpace,
            trailingSpaceNewLine: s.trailingSpaceNewLine,
            md_inside: s.md_inside,
            fencedEndRE: s.fencedEndRE
          };
        },
        token: function(stream, state2) {
          state2.formatting = false;
          if (stream != state2.thisLine.stream) {
            state2.header = 0;
            state2.hr = false;
            if (stream.match(/^\s*$/, true)) {
              blankLine(state2);
              return null;
            }
            state2.prevLine = state2.thisLine;
            state2.thisLine = {stream};
            state2.taskList = false;
            state2.trailingSpace = 0;
            state2.trailingSpaceNewLine = false;
            if (!state2.localState) {
              state2.f = state2.block;
              if (state2.f != htmlBlock) {
                var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
                state2.indentation = indentation;
                state2.indentationDiff = null;
                if (indentation > 0)
                  return null;
              }
            }
          }
          return state2.f(stream, state2);
        },
        innerMode: function(state2) {
          if (state2.block == htmlBlock)
            return {state: state2.htmlState, mode: htmlMode};
          if (state2.localState)
            return {state: state2.localState, mode: state2.localMode};
          return {state: state2, mode};
        },
        indent: function(state2, textAfter, line) {
          if (state2.block == htmlBlock && htmlMode.indent)
            return htmlMode.indent(state2.htmlState, textAfter, line);
          if (state2.localState && state2.localMode.indent)
            return state2.localMode.indent(state2.localState, textAfter, line);
          return CodeMirror2.Pass;
        },
        blankLine,
        getType: getType2,
        blockCommentStart: "<!--",
        blockCommentEnd: "-->",
        closeBrackets: "()[]{}''\"\"``",
        fold: "markdown"
      };
      return mode;
    }, "xml");
    CodeMirror2.defineMIME("text/markdown", "markdown");
    CodeMirror2.defineMIME("text/x-markdown", "markdown");
  });
});

// node_modules/codemirror/addon/mode/overlay.js
var require_overlay = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror());
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    "use strict";
    CodeMirror2.overlayMode = function(base, overlay, combine) {
      return {
        startState: function() {
          return {
            base: CodeMirror2.startState(base),
            overlay: CodeMirror2.startState(overlay),
            basePos: 0,
            baseCur: null,
            overlayPos: 0,
            overlayCur: null,
            streamSeen: null
          };
        },
        copyState: function(state2) {
          return {
            base: CodeMirror2.copyState(base, state2.base),
            overlay: CodeMirror2.copyState(overlay, state2.overlay),
            basePos: state2.basePos,
            baseCur: null,
            overlayPos: state2.overlayPos,
            overlayCur: null
          };
        },
        token: function(stream, state2) {
          if (stream != state2.streamSeen || Math.min(state2.basePos, state2.overlayPos) < stream.start) {
            state2.streamSeen = stream;
            state2.basePos = state2.overlayPos = stream.start;
          }
          if (stream.start == state2.basePos) {
            state2.baseCur = base.token(stream, state2.base);
            state2.basePos = stream.pos;
          }
          if (stream.start == state2.overlayPos) {
            stream.pos = stream.start;
            state2.overlayCur = overlay.token(stream, state2.overlay);
            state2.overlayPos = stream.pos;
          }
          stream.pos = Math.min(state2.basePos, state2.overlayPos);
          if (state2.overlayCur == null)
            return state2.baseCur;
          else if (state2.baseCur != null && state2.overlay.combineTokens || combine && state2.overlay.combineTokens == null)
            return state2.baseCur + " " + state2.overlayCur;
          else
            return state2.overlayCur;
        },
        indent: base.indent && function(state2, textAfter, line) {
          return base.indent(state2.base, textAfter, line);
        },
        electricChars: base.electricChars,
        innerMode: function(state2) {
          return {state: state2.base, mode: base};
        },
        blankLine: function(state2) {
          var baseToken, overlayToken;
          if (base.blankLine)
            baseToken = base.blankLine(state2.base);
          if (overlay.blankLine)
            overlayToken = overlay.blankLine(state2.overlay);
          return overlayToken == null ? baseToken : combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken;
        }
      };
    };
  });
});

// node_modules/codemirror/addon/display/placeholder.js
var require_placeholder = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror());
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    CodeMirror2.defineOption("placeholder", "", function(cm, val, old) {
      var prev = old && old != CodeMirror2.Init;
      if (val && !prev) {
        cm.on("blur", onBlur);
        cm.on("change", onChange);
        cm.on("swapDoc", onChange);
        CodeMirror2.on(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose = function() {
          onComposition(cm);
        });
        onChange(cm);
      } else if (!val && prev) {
        cm.off("blur", onBlur);
        cm.off("change", onChange);
        cm.off("swapDoc", onChange);
        CodeMirror2.off(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose);
        clearPlaceholder(cm);
        var wrapper3 = cm.getWrapperElement();
        wrapper3.className = wrapper3.className.replace(" CodeMirror-empty", "");
      }
      if (val && !cm.hasFocus())
        onBlur(cm);
    });
    function clearPlaceholder(cm) {
      if (cm.state.placeholder) {
        cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
        cm.state.placeholder = null;
      }
    }
    function setPlaceholder(cm) {
      clearPlaceholder(cm);
      var elt = cm.state.placeholder = document.createElement("pre");
      elt.style.cssText = "height: 0; overflow: visible";
      elt.style.direction = cm.getOption("direction");
      elt.className = "CodeMirror-placeholder CodeMirror-line-like";
      var placeHolder = cm.getOption("placeholder");
      if (typeof placeHolder == "string")
        placeHolder = document.createTextNode(placeHolder);
      elt.appendChild(placeHolder);
      cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
    }
    function onComposition(cm) {
      setTimeout(function() {
        var empty = false;
        if (cm.lineCount() == 1) {
          var input = cm.getInputField();
          empty = input.nodeName == "TEXTAREA" ? !cm.getLine(0).length : !/[^\u200b]/.test(input.querySelector(".CodeMirror-line").textContent);
        }
        if (empty)
          setPlaceholder(cm);
        else
          clearPlaceholder(cm);
      }, 20);
    }
    function onBlur(cm) {
      if (isEmpty2(cm))
        setPlaceholder(cm);
    }
    function onChange(cm) {
      var wrapper3 = cm.getWrapperElement(), empty = isEmpty2(cm);
      wrapper3.className = wrapper3.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");
      if (empty)
        setPlaceholder(cm);
      else
        clearPlaceholder(cm);
    }
    function isEmpty2(cm) {
      return cm.lineCount() === 1 && cm.getLine(0) === "";
    }
  });
});

// node_modules/codemirror/addon/display/autorefresh.js
var require_autorefresh = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror());
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    "use strict";
    CodeMirror2.defineOption("autoRefresh", false, function(cm, val) {
      if (cm.state.autoRefresh) {
        stopListening(cm, cm.state.autoRefresh);
        cm.state.autoRefresh = null;
      }
      if (val && cm.display.wrapper.offsetHeight == 0)
        startListening(cm, cm.state.autoRefresh = {delay: val.delay || 250});
    });
    function startListening(cm, state2) {
      function check() {
        if (cm.display.wrapper.offsetHeight) {
          stopListening(cm, state2);
          if (cm.display.lastWrapHeight != cm.display.wrapper.clientHeight)
            cm.refresh();
        } else {
          state2.timeout = setTimeout(check, state2.delay);
        }
      }
      state2.timeout = setTimeout(check, state2.delay);
      state2.hurry = function() {
        clearTimeout(state2.timeout);
        state2.timeout = setTimeout(check, 50);
      };
      CodeMirror2.on(window, "mouseup", state2.hurry);
      CodeMirror2.on(window, "keyup", state2.hurry);
    }
    function stopListening(_cm, state2) {
      clearTimeout(state2.timeout);
      CodeMirror2.off(window, "mouseup", state2.hurry);
      CodeMirror2.off(window, "keyup", state2.hurry);
    }
  });
});

// node_modules/codemirror/addon/selection/mark-selection.js
var require_mark_selection = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror());
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    "use strict";
    CodeMirror2.defineOption("styleSelectedText", false, function(cm, val, old) {
      var prev = old && old != CodeMirror2.Init;
      if (val && !prev) {
        cm.state.markedSelection = [];
        cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";
        reset(cm);
        cm.on("cursorActivity", onCursorActivity);
        cm.on("change", onChange);
      } else if (!val && prev) {
        cm.off("cursorActivity", onCursorActivity);
        cm.off("change", onChange);
        clear2(cm);
        cm.state.markedSelection = cm.state.markedSelectionStyle = null;
      }
    });
    function onCursorActivity(cm) {
      if (cm.state.markedSelection)
        cm.operation(function() {
          update(cm);
        });
    }
    function onChange(cm) {
      if (cm.state.markedSelection && cm.state.markedSelection.length)
        cm.operation(function() {
          clear2(cm);
        });
    }
    var CHUNK_SIZE = 8;
    var Pos = CodeMirror2.Pos;
    var cmp = CodeMirror2.cmpPos;
    function coverRange(cm, from, to, addAt) {
      if (cmp(from, to) == 0)
        return;
      var array = cm.state.markedSelection;
      var cls = cm.state.markedSelectionStyle;
      for (var line = from.line; ; ) {
        var start = line == from.line ? from : Pos(line, 0);
        var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;
        var end = atEnd ? to : Pos(endLine, 0);
        var mark = cm.markText(start, end, {className: cls});
        if (addAt == null)
          array.push(mark);
        else
          array.splice(addAt++, 0, mark);
        if (atEnd)
          break;
        line = endLine;
      }
    }
    function clear2(cm) {
      var array = cm.state.markedSelection;
      for (var i = 0; i < array.length; ++i)
        array[i].clear();
      array.length = 0;
    }
    function reset(cm) {
      clear2(cm);
      var ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++)
        coverRange(cm, ranges[i].from(), ranges[i].to());
    }
    function update(cm) {
      if (!cm.somethingSelected())
        return clear2(cm);
      if (cm.listSelections().length > 1)
        return reset(cm);
      var from = cm.getCursor("start"), to = cm.getCursor("end");
      var array = cm.state.markedSelection;
      if (!array.length)
        return coverRange(cm, from, to);
      var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();
      if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE || cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)
        return reset(cm);
      while (cmp(from, coverStart.from) > 0) {
        array.shift().clear();
        coverStart = array[0].find();
      }
      if (cmp(from, coverStart.from) < 0) {
        if (coverStart.to.line - from.line < CHUNK_SIZE) {
          array.shift().clear();
          coverRange(cm, from, coverStart.to, 0);
        } else {
          coverRange(cm, from, coverStart.from, 0);
        }
      }
      while (cmp(to, coverEnd.to) < 0) {
        array.pop().clear();
        coverEnd = array[array.length - 1].find();
      }
      if (cmp(to, coverEnd.to) > 0) {
        if (to.line - coverEnd.from.line < CHUNK_SIZE) {
          array.pop().clear();
          coverRange(cm, coverEnd.from, to);
        } else {
          coverRange(cm, coverEnd.to, to);
        }
      }
    }
  });
});

// node_modules/codemirror/addon/search/searchcursor.js
var require_searchcursor = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror());
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    "use strict";
    var Pos = CodeMirror2.Pos;
    function regexpFlags(regexp) {
      var flags = regexp.flags;
      return flags != null ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");
    }
    function ensureFlags(regexp, flags) {
      var current = regexpFlags(regexp), target = current;
      for (var i = 0; i < flags.length; i++)
        if (target.indexOf(flags.charAt(i)) == -1)
          target += flags.charAt(i);
      return current == target ? regexp : new RegExp(regexp.source, target);
    }
    function maybeMultiline(regexp) {
      return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source);
    }
    function searchRegexpForward(doc, regexp, start) {
      regexp = ensureFlags(regexp, "g");
      for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
        regexp.lastIndex = ch;
        var string = doc.getLine(line), match = regexp.exec(string);
        if (match)
          return {
            from: Pos(line, match.index),
            to: Pos(line, match.index + match[0].length),
            match
          };
      }
    }
    function searchRegexpForwardMultiline(doc, regexp, start) {
      if (!maybeMultiline(regexp))
        return searchRegexpForward(doc, regexp, start);
      regexp = ensureFlags(regexp, "gm");
      var string, chunk = 1;
      for (var line = start.line, last = doc.lastLine(); line <= last; ) {
        for (var i = 0; i < chunk; i++) {
          if (line > last)
            break;
          var curLine = doc.getLine(line++);
          string = string == null ? curLine : string + "\n" + curLine;
        }
        chunk = chunk * 2;
        regexp.lastIndex = start.ch;
        var match = regexp.exec(string);
        if (match) {
          var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n");
          var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length;
          return {
            from: Pos(startLine, startCh),
            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
            match
          };
        }
      }
    }
    function lastMatchIn(string, regexp, endMargin) {
      var match, from = 0;
      while (from <= string.length) {
        regexp.lastIndex = from;
        var newMatch = regexp.exec(string);
        if (!newMatch)
          break;
        var end = newMatch.index + newMatch[0].length;
        if (end > string.length - endMargin)
          break;
        if (!match || end > match.index + match[0].length)
          match = newMatch;
        from = newMatch.index + 1;
      }
      return match;
    }
    function searchRegexpBackward(doc, regexp, start) {
      regexp = ensureFlags(regexp, "g");
      for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
        var string = doc.getLine(line);
        var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch);
        if (match)
          return {
            from: Pos(line, match.index),
            to: Pos(line, match.index + match[0].length),
            match
          };
      }
    }
    function searchRegexpBackwardMultiline(doc, regexp, start) {
      if (!maybeMultiline(regexp))
        return searchRegexpBackward(doc, regexp, start);
      regexp = ensureFlags(regexp, "gm");
      var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch;
      for (var line = start.line, first = doc.firstLine(); line >= first; ) {
        for (var i = 0; i < chunkSize && line >= first; i++) {
          var curLine = doc.getLine(line--);
          string = string == null ? curLine : curLine + "\n" + string;
        }
        chunkSize *= 2;
        var match = lastMatchIn(string, regexp, endMargin);
        if (match) {
          var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n");
          var startLine = line + before.length, startCh = before[before.length - 1].length;
          return {
            from: Pos(startLine, startCh),
            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
            match
          };
        }
      }
    }
    var doFold, noFold;
    if (String.prototype.normalize) {
      doFold = function(str) {
        return str.normalize("NFD").toLowerCase();
      };
      noFold = function(str) {
        return str.normalize("NFD");
      };
    } else {
      doFold = function(str) {
        return str.toLowerCase();
      };
      noFold = function(str) {
        return str;
      };
    }
    function adjustPos(orig, folded, pos, foldFunc) {
      if (orig.length == folded.length)
        return pos;
      for (var min = 0, max = pos + Math.max(0, orig.length - folded.length); ; ) {
        if (min == max)
          return min;
        var mid = min + max >> 1;
        var len = foldFunc(orig.slice(0, mid)).length;
        if (len == pos)
          return mid;
        else if (len > pos)
          max = mid;
        else
          min = mid + 1;
      }
    }
    function searchStringForward(doc, query, start, caseFold) {
      if (!query.length)
        return null;
      var fold = caseFold ? doFold : noFold;
      var lines = fold(query).split(/\r|\n\r?/);
      search:
        for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
          var orig = doc.getLine(line).slice(ch), string = fold(orig);
          if (lines.length == 1) {
            var found = string.indexOf(lines[0]);
            if (found == -1)
              continue search;
            var start = adjustPos(orig, string, found, fold) + ch;
            return {
              from: Pos(line, adjustPos(orig, string, found, fold) + ch),
              to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)
            };
          } else {
            var cutFrom = string.length - lines[0].length;
            if (string.slice(cutFrom) != lines[0])
              continue search;
            for (var i = 1; i < lines.length - 1; i++)
              if (fold(doc.getLine(line + i)) != lines[i])
                continue search;
            var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1];
            if (endString.slice(0, lastLine.length) != lastLine)
              continue search;
            return {
              from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
              to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))
            };
          }
        }
    }
    function searchStringBackward(doc, query, start, caseFold) {
      if (!query.length)
        return null;
      var fold = caseFold ? doFold : noFold;
      var lines = fold(query).split(/\r|\n\r?/);
      search:
        for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
          var orig = doc.getLine(line);
          if (ch > -1)
            orig = orig.slice(0, ch);
          var string = fold(orig);
          if (lines.length == 1) {
            var found = string.lastIndexOf(lines[0]);
            if (found == -1)
              continue search;
            return {
              from: Pos(line, adjustPos(orig, string, found, fold)),
              to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))
            };
          } else {
            var lastLine = lines[lines.length - 1];
            if (string.slice(0, lastLine.length) != lastLine)
              continue search;
            for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)
              if (fold(doc.getLine(start + i)) != lines[i])
                continue search;
            var top = doc.getLine(line + 1 - lines.length), topString = fold(top);
            if (topString.slice(topString.length - lines[0].length) != lines[0])
              continue search;
            return {
              from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
              to: Pos(line, adjustPos(orig, string, lastLine.length, fold))
            };
          }
        }
    }
    function SearchCursor(doc, query, pos, options) {
      this.atOccurrence = false;
      this.afterEmptyMatch = false;
      this.doc = doc;
      pos = pos ? doc.clipPos(pos) : Pos(0, 0);
      this.pos = {from: pos, to: pos};
      var caseFold;
      if (typeof options == "object") {
        caseFold = options.caseFold;
      } else {
        caseFold = options;
        options = null;
      }
      if (typeof query == "string") {
        if (caseFold == null)
          caseFold = false;
        this.matches = function(reverse, pos2) {
          return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos2, caseFold);
        };
      } else {
        query = ensureFlags(query, "gm");
        if (!options || options.multiline !== false)
          this.matches = function(reverse, pos2) {
            return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos2);
          };
        else
          this.matches = function(reverse, pos2) {
            return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos2);
          };
      }
    }
    SearchCursor.prototype = {
      findNext: function() {
        return this.find(false);
      },
      findPrevious: function() {
        return this.find(true);
      },
      find: function(reverse) {
        var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
        if (this.afterEmptyMatch && this.atOccurrence) {
          head = Pos(head.line, head.ch);
          if (reverse) {
            head.ch--;
            if (head.ch < 0) {
              head.line--;
              head.ch = (this.doc.getLine(head.line) || "").length;
            }
          } else {
            head.ch++;
            if (head.ch > (this.doc.getLine(head.line) || "").length) {
              head.ch = 0;
              head.line++;
            }
          }
          if (CodeMirror2.cmpPos(head, this.doc.clipPos(head)) != 0) {
            return this.atOccurrence = false;
          }
        }
        var result = this.matches(reverse, head);
        this.afterEmptyMatch = result && CodeMirror2.cmpPos(result.from, result.to) == 0;
        if (result) {
          this.pos = result;
          this.atOccurrence = true;
          return this.pos.match || true;
        } else {
          var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
          this.pos = {from: end, to: end};
          return this.atOccurrence = false;
        }
      },
      from: function() {
        if (this.atOccurrence)
          return this.pos.from;
      },
      to: function() {
        if (this.atOccurrence)
          return this.pos.to;
      },
      replace: function(newText, origin) {
        if (!this.atOccurrence)
          return;
        var lines = CodeMirror2.splitLines(newText);
        this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
        this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
      }
    };
    CodeMirror2.defineExtension("getSearchCursor", function(query, pos, caseFold) {
      return new SearchCursor(this.doc, query, pos, caseFold);
    });
    CodeMirror2.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
      return new SearchCursor(this, query, pos, caseFold);
    });
    CodeMirror2.defineExtension("selectMatches", function(query, caseFold) {
      var ranges = [];
      var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
      while (cur.findNext()) {
        if (CodeMirror2.cmpPos(cur.to(), this.getCursor("to")) > 0)
          break;
        ranges.push({anchor: cur.from(), head: cur.to()});
      }
      if (ranges.length)
        this.setSelections(ranges, 0);
    });
  });
});

// node_modules/codemirror/mode/gfm/gfm.js
var require_gfm = __commonJS((exports, module) => {
  (function(mod) {
    if (typeof exports == "object" && typeof module == "object")
      mod(require_codemirror(), require_markdown(), require_overlay());
    else if (typeof define == "function" && define.amd)
      define(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], mod);
    else
      mod(CodeMirror);
  })(function(CodeMirror2) {
    "use strict";
    var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?]))/i;
    CodeMirror2.defineMode("gfm", function(config, modeConfig) {
      var codeDepth = 0;
      function blankLine(state2) {
        state2.code = false;
        return null;
      }
      var gfmOverlay = {
        startState: function() {
          return {
            code: false,
            codeBlock: false,
            ateSpace: false
          };
        },
        copyState: function(s) {
          return {
            code: s.code,
            codeBlock: s.codeBlock,
            ateSpace: s.ateSpace
          };
        },
        token: function(stream, state2) {
          state2.combineTokens = null;
          if (state2.codeBlock) {
            if (stream.match(/^```+/)) {
              state2.codeBlock = false;
              return null;
            }
            stream.skipToEnd();
            return null;
          }
          if (stream.sol()) {
            state2.code = false;
          }
          if (stream.sol() && stream.match(/^```+/)) {
            stream.skipToEnd();
            state2.codeBlock = true;
            return null;
          }
          if (stream.peek() === "`") {
            stream.next();
            var before = stream.pos;
            stream.eatWhile("`");
            var difference = 1 + stream.pos - before;
            if (!state2.code) {
              codeDepth = difference;
              state2.code = true;
            } else {
              if (difference === codeDepth) {
                state2.code = false;
              }
            }
            return null;
          } else if (state2.code) {
            stream.next();
            return null;
          }
          if (stream.eatSpace()) {
            state2.ateSpace = true;
            return null;
          }
          if (stream.sol() || state2.ateSpace) {
            state2.ateSpace = false;
            if (modeConfig.gitHubSpice !== false) {
              if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?=.{0,6}\d)(?:[a-f0-9]{7,40}\b)/)) {
                state2.combineTokens = true;
                return "link";
              } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
                state2.combineTokens = true;
                return "link";
              }
            }
          }
          if (stream.match(urlRE) && stream.string.slice(stream.start - 2, stream.start) != "](" && (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
            state2.combineTokens = true;
            return "link";
          }
          stream.next();
          return null;
        },
        blankLine
      };
      var markdownConfig = {
        taskLists: true,
        strikethrough: true,
        emoji: true
      };
      for (var attr2 in modeConfig) {
        markdownConfig[attr2] = modeConfig[attr2];
      }
      markdownConfig.name = "markdown";
      return CodeMirror2.overlayMode(CodeMirror2.getMode(config, markdownConfig), gfmOverlay);
    }, "markdown");
    CodeMirror2.defineMIME("text/x-gfm", "gfm");
  });
});

// (disabled):fs
var require_fs = __commonJS(() => {
});

// node_modules/typo-js/typo.js
var require_typo = __commonJS((exports, module) => {
  var Typo;
  (function() {
    "use strict";
    Typo = function(dictionary, affData, wordsData, settings) {
      settings = settings || {};
      this.dictionary = null;
      this.rules = {};
      this.dictionaryTable = {};
      this.compoundRules = [];
      this.compoundRuleCodes = {};
      this.replacementTable = [];
      this.flags = settings.flags || {};
      this.memoized = {};
      this.loaded = false;
      var self2 = this;
      var path;
      var i, j, _len, _jlen;
      if (dictionary) {
        self2.dictionary = dictionary;
        if (affData && wordsData) {
          setup();
        } else if (typeof window !== "undefined" && "chrome" in window && "extension" in window.chrome && "getURL" in window.chrome.extension) {
          if (settings.dictionaryPath) {
            path = settings.dictionaryPath;
          } else {
            path = "typo/dictionaries";
          }
          if (!affData)
            readDataFile(chrome.extension.getURL(path + "/" + dictionary + "/" + dictionary + ".aff"), setAffData);
          if (!wordsData)
            readDataFile(chrome.extension.getURL(path + "/" + dictionary + "/" + dictionary + ".dic"), setWordsData);
        } else {
          if (settings.dictionaryPath) {
            path = settings.dictionaryPath;
          } else if (typeof __dirname !== "undefined") {
            path = __dirname + "/dictionaries";
          } else {
            path = "./dictionaries";
          }
          if (!affData)
            readDataFile(path + "/" + dictionary + "/" + dictionary + ".aff", setAffData);
          if (!wordsData)
            readDataFile(path + "/" + dictionary + "/" + dictionary + ".dic", setWordsData);
        }
      }
      function readDataFile(url, setFunc) {
        var response = self2._readFile(url, null, settings.asyncLoad);
        if (settings.asyncLoad) {
          response.then(function(data3) {
            setFunc(data3);
          });
        } else {
          setFunc(response);
        }
      }
      function setAffData(data3) {
        affData = data3;
        if (wordsData) {
          setup();
        }
      }
      function setWordsData(data3) {
        wordsData = data3;
        if (affData) {
          setup();
        }
      }
      function setup() {
        self2.rules = self2._parseAFF(affData);
        self2.compoundRuleCodes = {};
        for (i = 0, _len = self2.compoundRules.length; i < _len; i++) {
          var rule = self2.compoundRules[i];
          for (j = 0, _jlen = rule.length; j < _jlen; j++) {
            self2.compoundRuleCodes[rule[j]] = [];
          }
        }
        if ("ONLYINCOMPOUND" in self2.flags) {
          self2.compoundRuleCodes[self2.flags.ONLYINCOMPOUND] = [];
        }
        self2.dictionaryTable = self2._parseDIC(wordsData);
        for (i in self2.compoundRuleCodes) {
          if (self2.compoundRuleCodes[i].length === 0) {
            delete self2.compoundRuleCodes[i];
          }
        }
        for (i = 0, _len = self2.compoundRules.length; i < _len; i++) {
          var ruleText = self2.compoundRules[i];
          var expressionText = "";
          for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {
            var character = ruleText[j];
            if (character in self2.compoundRuleCodes) {
              expressionText += "(" + self2.compoundRuleCodes[character].join("|") + ")";
            } else {
              expressionText += character;
            }
          }
          self2.compoundRules[i] = new RegExp(expressionText, "i");
        }
        self2.loaded = true;
        if (settings.asyncLoad && settings.loadedCallback) {
          settings.loadedCallback(self2);
        }
      }
      return this;
    };
    Typo.prototype = {
      load: function(obj) {
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            this[i] = obj[i];
          }
        }
        return this;
      },
      _readFile: function(path, charset, async) {
        charset = charset || "utf8";
        if (typeof XMLHttpRequest !== "undefined") {
          var promise;
          var req = new XMLHttpRequest();
          req.open("GET", path, async);
          if (async) {
            promise = new Promise(function(resolve, reject) {
              req.onload = function() {
                if (req.status === 200) {
                  resolve(req.responseText);
                } else {
                  reject(req.statusText);
                }
              };
              req.onerror = function() {
                reject(req.statusText);
              };
            });
          }
          if (req.overrideMimeType)
            req.overrideMimeType("text/plain; charset=" + charset);
          req.send(null);
          return async ? promise : req.responseText;
        } else if (true) {
          var fs = require_fs();
          try {
            if (fs.existsSync(path)) {
              return fs.readFileSync(path, charset);
            } else {
              console.log("Path " + path + " does not exist.");
            }
          } catch (e) {
            console.log(e);
            return "";
          }
        }
      },
      _parseAFF: function(data3) {
        var rules = {};
        var line, subline, numEntries, lineParts;
        var i, j, _len, _jlen;
        var lines = data3.split(/\r?\n/);
        for (i = 0, _len = lines.length; i < _len; i++) {
          line = this._removeAffixComments(lines[i]);
          line = line.trim();
          if (!line) {
            continue;
          }
          var definitionParts = line.split(/\s+/);
          var ruleType = definitionParts[0];
          if (ruleType == "PFX" || ruleType == "SFX") {
            var ruleCode = definitionParts[1];
            var combineable = definitionParts[2];
            numEntries = parseInt(definitionParts[3], 10);
            var entries = [];
            for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
              subline = lines[j];
              lineParts = subline.split(/\s+/);
              var charactersToRemove = lineParts[2];
              var additionParts = lineParts[3].split("/");
              var charactersToAdd = additionParts[0];
              if (charactersToAdd === "0")
                charactersToAdd = "";
              var continuationClasses = this.parseRuleCodes(additionParts[1]);
              var regexToMatch = lineParts[4];
              var entry = {};
              entry.add = charactersToAdd;
              if (continuationClasses.length > 0)
                entry.continuationClasses = continuationClasses;
              if (regexToMatch !== ".") {
                if (ruleType === "SFX") {
                  entry.match = new RegExp(regexToMatch + "$");
                } else {
                  entry.match = new RegExp("^" + regexToMatch);
                }
              }
              if (charactersToRemove != "0") {
                if (ruleType === "SFX") {
                  entry.remove = new RegExp(charactersToRemove + "$");
                } else {
                  entry.remove = charactersToRemove;
                }
              }
              entries.push(entry);
            }
            rules[ruleCode] = {type: ruleType, combineable: combineable == "Y", entries};
            i += numEntries;
          } else if (ruleType === "COMPOUNDRULE") {
            numEntries = parseInt(definitionParts[1], 10);
            for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
              line = lines[j];
              lineParts = line.split(/\s+/);
              this.compoundRules.push(lineParts[1]);
            }
            i += numEntries;
          } else if (ruleType === "REP") {
            lineParts = line.split(/\s+/);
            if (lineParts.length === 3) {
              this.replacementTable.push([lineParts[1], lineParts[2]]);
            }
          } else {
            this.flags[ruleType] = definitionParts[1];
          }
        }
        return rules;
      },
      _removeAffixComments: function(line) {
        if (line.match(/^\s*#/, "")) {
          return "";
        }
        return line;
      },
      _parseDIC: function(data3) {
        data3 = this._removeDicComments(data3);
        var lines = data3.split(/\r?\n/);
        var dictionaryTable = {};
        function addWord(word2, rules) {
          if (!dictionaryTable.hasOwnProperty(word2)) {
            dictionaryTable[word2] = null;
          }
          if (rules.length > 0) {
            if (dictionaryTable[word2] === null) {
              dictionaryTable[word2] = [];
            }
            dictionaryTable[word2].push(rules);
          }
        }
        for (var i = 1, _len = lines.length; i < _len; i++) {
          var line = lines[i];
          if (!line) {
            continue;
          }
          var parts = line.split("/", 2);
          var word = parts[0];
          if (parts.length > 1) {
            var ruleCodesArray = this.parseRuleCodes(parts[1]);
            if (!("NEEDAFFIX" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {
              addWord(word, ruleCodesArray);
            }
            for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {
              var code = ruleCodesArray[j];
              var rule = this.rules[code];
              if (rule) {
                var newWords = this._applyRule(word, rule);
                for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
                  var newWord = newWords[ii];
                  addWord(newWord, []);
                  if (rule.combineable) {
                    for (var k = j + 1; k < _jlen; k++) {
                      var combineCode = ruleCodesArray[k];
                      var combineRule = this.rules[combineCode];
                      if (combineRule) {
                        if (combineRule.combineable && rule.type != combineRule.type) {
                          var otherNewWords = this._applyRule(newWord, combineRule);
                          for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
                            var otherNewWord = otherNewWords[iii];
                            addWord(otherNewWord, []);
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (code in this.compoundRuleCodes) {
                this.compoundRuleCodes[code].push(word);
              }
            }
          } else {
            addWord(word.trim(), []);
          }
        }
        return dictionaryTable;
      },
      _removeDicComments: function(data3) {
        data3 = data3.replace(/^\t.*$/mg, "");
        return data3;
      },
      parseRuleCodes: function(textCodes) {
        if (!textCodes) {
          return [];
        } else if (!("FLAG" in this.flags)) {
          return textCodes.split("");
        } else if (this.flags.FLAG === "long") {
          var flags = [];
          for (var i = 0, _len = textCodes.length; i < _len; i += 2) {
            flags.push(textCodes.substr(i, 2));
          }
          return flags;
        } else if (this.flags.FLAG === "num") {
          return textCodes.split(",");
        }
      },
      _applyRule: function(word, rule) {
        var entries = rule.entries;
        var newWords = [];
        for (var i = 0, _len = entries.length; i < _len; i++) {
          var entry = entries[i];
          if (!entry.match || word.match(entry.match)) {
            var newWord = word;
            if (entry.remove) {
              newWord = newWord.replace(entry.remove, "");
            }
            if (rule.type === "SFX") {
              newWord = newWord + entry.add;
            } else {
              newWord = entry.add + newWord;
            }
            newWords.push(newWord);
            if ("continuationClasses" in entry) {
              for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {
                var continuationRule = this.rules[entry.continuationClasses[j]];
                if (continuationRule) {
                  newWords = newWords.concat(this._applyRule(newWord, continuationRule));
                }
              }
            }
          }
        }
        return newWords;
      },
      check: function(aWord) {
        if (!this.loaded) {
          throw "Dictionary not loaded.";
        }
        var trimmedWord = aWord.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        if (this.checkExact(trimmedWord)) {
          return true;
        }
        if (trimmedWord.toUpperCase() === trimmedWord) {
          var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();
          if (this.hasFlag(capitalizedWord, "KEEPCASE")) {
            return false;
          }
          if (this.checkExact(capitalizedWord)) {
            return true;
          }
          if (this.checkExact(trimmedWord.toLowerCase())) {
            return true;
          }
        }
        var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);
        if (uncapitalizedWord !== trimmedWord) {
          if (this.hasFlag(uncapitalizedWord, "KEEPCASE")) {
            return false;
          }
          if (this.checkExact(uncapitalizedWord)) {
            return true;
          }
        }
        return false;
      },
      checkExact: function(word) {
        if (!this.loaded) {
          throw "Dictionary not loaded.";
        }
        var ruleCodes = this.dictionaryTable[word];
        var i, _len;
        if (typeof ruleCodes === "undefined") {
          if ("COMPOUNDMIN" in this.flags && word.length >= this.flags.COMPOUNDMIN) {
            for (i = 0, _len = this.compoundRules.length; i < _len; i++) {
              if (word.match(this.compoundRules[i])) {
                return true;
              }
            }
          }
        } else if (ruleCodes === null) {
          return true;
        } else if (typeof ruleCodes === "object") {
          for (i = 0, _len = ruleCodes.length; i < _len; i++) {
            if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i])) {
              return true;
            }
          }
        }
        return false;
      },
      hasFlag: function(word, flag, wordFlags) {
        if (!this.loaded) {
          throw "Dictionary not loaded.";
        }
        if (flag in this.flags) {
          if (typeof wordFlags === "undefined") {
            wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);
          }
          if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {
            return true;
          }
        }
        return false;
      },
      alphabet: "",
      suggest: function(word, limit2) {
        if (!this.loaded) {
          throw "Dictionary not loaded.";
        }
        limit2 = limit2 || 5;
        if (this.memoized.hasOwnProperty(word)) {
          var memoizedLimit = this.memoized[word]["limit"];
          if (limit2 <= memoizedLimit || this.memoized[word]["suggestions"].length < memoizedLimit) {
            return this.memoized[word]["suggestions"].slice(0, limit2);
          }
        }
        if (this.check(word))
          return [];
        for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {
          var replacementEntry = this.replacementTable[i];
          if (word.indexOf(replacementEntry[0]) !== -1) {
            var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);
            if (this.check(correctedWord)) {
              return [correctedWord];
            }
          }
        }
        var self2 = this;
        self2.alphabet = "abcdefghijklmnopqrstuvwxyz";
        function edits1(words, known_only) {
          var rv = {};
          var i2, j, _iilen, _len2, _jlen, _edit;
          var alphabetLength = self2.alphabet.length;
          if (typeof words == "string") {
            var word2 = words;
            words = {};
            words[word2] = true;
          }
          for (var word2 in words) {
            for (i2 = 0, _len2 = word2.length + 1; i2 < _len2; i2++) {
              var s = [word2.substring(0, i2), word2.substring(i2)];
              if (s[1]) {
                _edit = s[0] + s[1].substring(1);
                if (!known_only || self2.check(_edit)) {
                  if (!(_edit in rv)) {
                    rv[_edit] = 1;
                  } else {
                    rv[_edit] += 1;
                  }
                }
              }
              if (s[1].length > 1 && s[1][1] !== s[1][0]) {
                _edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);
                if (!known_only || self2.check(_edit)) {
                  if (!(_edit in rv)) {
                    rv[_edit] = 1;
                  } else {
                    rv[_edit] += 1;
                  }
                }
              }
              if (s[1]) {
                var lettercase = s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? "uppercase" : "lowercase";
                for (j = 0; j < alphabetLength; j++) {
                  var replacementLetter = self2.alphabet[j];
                  if (lettercase === "uppercase") {
                    replacementLetter = replacementLetter.toUpperCase();
                  }
                  if (replacementLetter != s[1].substring(0, 1)) {
                    _edit = s[0] + replacementLetter + s[1].substring(1);
                    if (!known_only || self2.check(_edit)) {
                      if (!(_edit in rv)) {
                        rv[_edit] = 1;
                      } else {
                        rv[_edit] += 1;
                      }
                    }
                  }
                }
              }
              if (s[1]) {
                for (j = 0; j < alphabetLength; j++) {
                  var lettercase = s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? "uppercase" : "lowercase";
                  var replacementLetter = self2.alphabet[j];
                  if (lettercase === "uppercase") {
                    replacementLetter = replacementLetter.toUpperCase();
                  }
                  _edit = s[0] + replacementLetter + s[1];
                  if (!known_only || self2.check(_edit)) {
                    if (!(_edit in rv)) {
                      rv[_edit] = 1;
                    } else {
                      rv[_edit] += 1;
                    }
                  }
                }
              }
            }
          }
          return rv;
        }
        function correct(word2) {
          var ed1 = edits1(word2);
          var ed2 = edits1(ed1, true);
          var weighted_corrections = ed2;
          for (var ed1word in ed1) {
            if (!self2.check(ed1word)) {
              continue;
            }
            if (ed1word in weighted_corrections) {
              weighted_corrections[ed1word] += ed1[ed1word];
            } else {
              weighted_corrections[ed1word] = ed1[ed1word];
            }
          }
          var i2, _len2;
          var sorted_corrections = [];
          for (i2 in weighted_corrections) {
            if (weighted_corrections.hasOwnProperty(i2)) {
              sorted_corrections.push([i2, weighted_corrections[i2]]);
            }
          }
          function sorter(a, b) {
            var a_val = a[1];
            var b_val = b[1];
            if (a_val < b_val) {
              return -1;
            } else if (a_val > b_val) {
              return 1;
            }
            return b[0].localeCompare(a[0]);
          }
          sorted_corrections.sort(sorter).reverse();
          var rv = [];
          var capitalization_scheme = "lowercase";
          if (word2.toUpperCase() === word2) {
            capitalization_scheme = "uppercase";
          } else if (word2.substr(0, 1).toUpperCase() + word2.substr(1).toLowerCase() === word2) {
            capitalization_scheme = "capitalized";
          }
          var working_limit = limit2;
          for (i2 = 0; i2 < Math.min(working_limit, sorted_corrections.length); i2++) {
            if (capitalization_scheme === "uppercase") {
              sorted_corrections[i2][0] = sorted_corrections[i2][0].toUpperCase();
            } else if (capitalization_scheme === "capitalized") {
              sorted_corrections[i2][0] = sorted_corrections[i2][0].substr(0, 1).toUpperCase() + sorted_corrections[i2][0].substr(1);
            }
            if (!self2.hasFlag(sorted_corrections[i2][0], "NOSUGGEST") && rv.indexOf(sorted_corrections[i2][0]) == -1) {
              rv.push(sorted_corrections[i2][0]);
            } else {
              working_limit++;
            }
          }
          return rv;
        }
        this.memoized[word] = {
          suggestions: correct(word),
          limit: limit2
        };
        return this.memoized[word]["suggestions"];
      }
    };
  })();
  if (typeof module !== "undefined") {
    module.exports = Typo;
  }
});

// node_modules/codemirror-spell-checker/src/js/spell-checker.js
var require_spell_checker = __commonJS((exports, module) => {
  "use strict";
  var Typo = require_typo();
  function CodeMirrorSpellChecker(options) {
    options = options || {};
    if (typeof options.codeMirrorInstance !== "function" || typeof options.codeMirrorInstance.defineMode !== "function") {
      console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`");
      return;
    }
    if (!String.prototype.includes) {
      String.prototype.includes = function() {
        "use strict";
        return String.prototype.indexOf.apply(this, arguments) !== -1;
      };
    }
    options.codeMirrorInstance.defineMode("spell-checker", function(config) {
      if (!CodeMirrorSpellChecker.aff_loading) {
        CodeMirrorSpellChecker.aff_loading = true;
        var xhr_aff = new XMLHttpRequest();
        xhr_aff.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", true);
        xhr_aff.onload = function() {
          if (xhr_aff.readyState === 4 && xhr_aff.status === 200) {
            CodeMirrorSpellChecker.aff_data = xhr_aff.responseText;
            CodeMirrorSpellChecker.num_loaded++;
            if (CodeMirrorSpellChecker.num_loaded == 2) {
              CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
                platform: "any"
              });
            }
          }
        };
        xhr_aff.send(null);
      }
      if (!CodeMirrorSpellChecker.dic_loading) {
        CodeMirrorSpellChecker.dic_loading = true;
        var xhr_dic = new XMLHttpRequest();
        xhr_dic.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", true);
        xhr_dic.onload = function() {
          if (xhr_dic.readyState === 4 && xhr_dic.status === 200) {
            CodeMirrorSpellChecker.dic_data = xhr_dic.responseText;
            CodeMirrorSpellChecker.num_loaded++;
            if (CodeMirrorSpellChecker.num_loaded == 2) {
              CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
                platform: "any"
              });
            }
          }
        };
        xhr_dic.send(null);
      }
      var rx_word = '!"#$%&()*+,-./:;<=>?@[\\]^_`{|}~ ';
      var overlay = {
        token: function(stream) {
          var ch = stream.peek();
          var word = "";
          if (rx_word.includes(ch)) {
            stream.next();
            return null;
          }
          while ((ch = stream.peek()) != null && !rx_word.includes(ch)) {
            word += ch;
            stream.next();
          }
          if (CodeMirrorSpellChecker.typo && !CodeMirrorSpellChecker.typo.check(word))
            return "spell-error";
          return null;
        }
      };
      var mode = options.codeMirrorInstance.getMode(config, config.backdrop || "text/plain");
      return options.codeMirrorInstance.overlayMode(mode, overlay, true);
    });
  }
  CodeMirrorSpellChecker.num_loaded = 0;
  CodeMirrorSpellChecker.aff_loading = false;
  CodeMirrorSpellChecker.dic_loading = false;
  CodeMirrorSpellChecker.aff_data = "";
  CodeMirrorSpellChecker.dic_data = "";
  CodeMirrorSpellChecker.typo;
  module.exports = CodeMirrorSpellChecker;
});

// node_modules/marked/lib/marked.esm.js
var require_marked_esm = __commonJS((exports) => {
  __markAsModule(exports);
  __export(exports, {
    Lexer: () => Lexer,
    Parser: () => Parser,
    Renderer: () => Renderer,
    Slugger: () => Slugger,
    TextRenderer: () => TextRenderer,
    Tokenizer: () => Tokenizer,
    defaults: () => defaults3,
    getDefaults: () => getDefaults,
    lexer: () => lexer,
    marked: () => marked,
    options: () => options,
    parse: () => parse4,
    parseInline: () => parseInline,
    parser: () => parser,
    setOptions: () => setOptions2,
    use: () => use,
    walkTokens: () => walkTokens
  });
  function getDefaults() {
    return {
      baseUrl: null,
      breaks: false,
      extensions: null,
      gfm: true,
      headerIds: true,
      headerPrefix: "",
      highlight: null,
      langPrefix: "language-",
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartLists: false,
      smartypants: false,
      tokenizer: null,
      walkTokens: null,
      xhtml: false
    };
  }
  var defaults3 = getDefaults();
  function changeDefaults(newDefaults) {
    defaults3 = newDefaults;
  }
  var escapeTest = /[&<>"']/;
  var escapeReplace = /[&<>"']/g;
  var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
  var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
  var escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape(html, encode) {
    if (encode) {
      if (escapeTest.test(html)) {
        return html.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html)) {
        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html;
  }
  var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
  function unescape2(html) {
    return html.replace(unescapeTest, (_, n) => {
      n = n.toLowerCase();
      if (n === "colon")
        return ":";
      if (n.charAt(0) === "#") {
        return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }
      return "";
    });
  }
  var caret = /(^|[^\[])\^/g;
  function edit(regex, opt) {
    regex = typeof regex === "string" ? regex : regex.source;
    opt = opt || "";
    const obj = {
      replace: (name2, val) => {
        val = val.source || val;
        val = val.replace(caret, "$1");
        regex = regex.replace(name2, val);
        return obj;
      },
      getRegex: () => {
        return new RegExp(regex, opt);
      }
    };
    return obj;
  }
  var nonWordAndColonTest = /[^\w:]/g;
  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
  function cleanUrl(sanitize, base, href) {
    if (sanitize) {
      let prot;
      try {
        prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
      } catch (e) {
        return null;
      }
      if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
        return null;
      }
    }
    if (base && !originIndependentUrl.test(href)) {
      href = resolveUrl(base, href);
    }
    try {
      href = encodeURI(href).replace(/%25/g, "%");
    } catch (e) {
      return null;
    }
    return href;
  }
  var baseUrls = {};
  var justDomain = /^[^:]+:\/*[^/]*$/;
  var protocol = /^([^:]+:)[\s\S]*$/;
  var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
  function resolveUrl(base, href) {
    if (!baseUrls[" " + base]) {
      if (justDomain.test(base)) {
        baseUrls[" " + base] = base + "/";
      } else {
        baseUrls[" " + base] = rtrim(base, "/", true);
      }
    }
    base = baseUrls[" " + base];
    const relativeBase = base.indexOf(":") === -1;
    if (href.substring(0, 2) === "//") {
      if (relativeBase) {
        return href;
      }
      return base.replace(protocol, "$1") + href;
    } else if (href.charAt(0) === "/") {
      if (relativeBase) {
        return href;
      }
      return base.replace(domain, "$1") + href;
    } else {
      return base + href;
    }
  }
  var noopTest = {exec: function noopTest2() {
  }};
  function merge(obj) {
    let i = 1, target, key;
    for (; i < arguments.length; i++) {
      target = arguments[i];
      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }
    return obj;
  }
  function splitCells(tableRow, count) {
    const row = tableRow.replace(/\|/g, (match, offset, str) => {
      let escaped = false, curr = offset;
      while (--curr >= 0 && str[curr] === "\\")
        escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(/ \|/);
    let i = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
      cells.pop();
    }
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
    for (; i < cells.length; i++) {
      cells[i] = cells[i].trim().replace(/\\\|/g, "|");
    }
    return cells;
  }
  function rtrim(str, c, invert) {
    const l = str.length;
    if (l === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l) {
      const currChar = str.charAt(l - suffLen - 1);
      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }
    return str.slice(0, l - suffLen);
  }
  function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }
    const l = str.length;
    let level = 0, i = 0;
    for (; i < l; i++) {
      if (str[i] === "\\") {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;
        if (level < 0) {
          return i;
        }
      }
    }
    return -1;
  }
  function checkSanitizeDeprecation(opt) {
    if (opt && opt.sanitize && !opt.silent) {
      console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
    }
  }
  function repeatString(pattern, count) {
    if (count < 1) {
      return "";
    }
    let result = "";
    while (count > 1) {
      if (count & 1) {
        result += pattern;
      }
      count >>= 1;
      pattern += pattern;
    }
    return result + pattern;
  }
  function outputLink(cap, link, raw, lexer2) {
    const href = link.href;
    const title = link.title ? escape(link.title) : null;
    const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
    if (cap[0].charAt(0) !== "!") {
      lexer2.state.inLink = true;
      const token = {
        type: "link",
        raw,
        href,
        title,
        text: text2,
        tokens: lexer2.inlineTokens(text2, [])
      };
      lexer2.state.inLink = false;
      return token;
    }
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape(text2)
    };
  }
  function indentCodeCompensation(raw, text2) {
    const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
      return text2;
    }
    const indentToCode = matchIndentToCode[1];
    return text2.split("\n").map((node) => {
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  var Tokenizer = class {
    constructor(options2) {
      this.options = options2 || defaults3;
    }
    space(src) {
      const cap = this.rules.block.newline.exec(src);
      if (cap && cap[0].length > 0) {
        return {
          type: "space",
          raw: cap[0]
        };
      }
    }
    code(src) {
      const cap = this.rules.block.code.exec(src);
      if (cap) {
        const text2 = cap[0].replace(/^ {1,4}/gm, "");
        return {
          type: "code",
          raw: cap[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text2, "\n") : text2
        };
      }
    }
    fences(src) {
      const cap = this.rules.block.fences.exec(src);
      if (cap) {
        const raw = cap[0];
        const text2 = indentCodeCompensation(raw, cap[3] || "");
        return {
          type: "code",
          raw,
          lang: cap[2] ? cap[2].trim() : cap[2],
          text: text2
        };
      }
    }
    heading(src) {
      const cap = this.rules.block.heading.exec(src);
      if (cap) {
        let text2 = cap[2].trim();
        if (/#$/.test(text2)) {
          const trimmed = rtrim(text2, "#");
          if (this.options.pedantic) {
            text2 = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            text2 = trimmed.trim();
          }
        }
        const token = {
          type: "heading",
          raw: cap[0],
          depth: cap[1].length,
          text: text2,
          tokens: []
        };
        this.lexer.inline(token.text, token.tokens);
        return token;
      }
    }
    hr(src) {
      const cap = this.rules.block.hr.exec(src);
      if (cap) {
        return {
          type: "hr",
          raw: cap[0]
        };
      }
    }
    blockquote(src) {
      const cap = this.rules.block.blockquote.exec(src);
      if (cap) {
        const text2 = cap[0].replace(/^ *>[ \t]?/gm, "");
        return {
          type: "blockquote",
          raw: cap[0],
          tokens: this.lexer.blockTokens(text2, []),
          text: text2
        };
      }
    }
    list(src) {
      let cap = this.rules.block.list.exec(src);
      if (cap) {
        let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
        let bull = cap[1].trim();
        const isordered = bull.length > 1;
        const list2 = {
          type: "list",
          raw: "",
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : "",
          loose: false,
          items: []
        };
        bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
        if (this.options.pedantic) {
          bull = isordered ? bull : "[*+-]";
        }
        const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
        while (src) {
          endEarly = false;
          if (!(cap = itemRegex.exec(src))) {
            break;
          }
          if (this.rules.block.hr.test(src)) {
            break;
          }
          raw = cap[0];
          src = src.substring(raw.length);
          line = cap[2].split("\n", 1)[0];
          nextLine = src.split("\n", 1)[0];
          if (this.options.pedantic) {
            indent = 2;
            itemContents = line.trimLeft();
          } else {
            indent = cap[2].search(/[^ ]/);
            indent = indent > 4 ? 1 : indent;
            itemContents = line.slice(indent);
            indent += cap[1].length;
          }
          blankLine = false;
          if (!line && /^ *$/.test(nextLine)) {
            raw += nextLine + "\n";
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }
          if (!endEarly) {
            const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))`);
            const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
            while (src) {
              rawLine = src.split("\n", 1)[0];
              line = rawLine;
              if (this.options.pedantic) {
                line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
              }
              if (nextBulletRegex.test(line)) {
                break;
              }
              if (hrRegex.test(src)) {
                break;
              }
              if (line.search(/[^ ]/) >= indent || !line.trim()) {
                itemContents += "\n" + line.slice(indent);
              } else if (!blankLine) {
                itemContents += "\n" + line;
              } else {
                break;
              }
              if (!blankLine && !line.trim()) {
                blankLine = true;
              }
              raw += rawLine + "\n";
              src = src.substring(rawLine.length + 1);
            }
          }
          if (!list2.loose) {
            if (endsWithBlankLine) {
              list2.loose = true;
            } else if (/\n *\n *$/.test(raw)) {
              endsWithBlankLine = true;
            }
          }
          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.exec(itemContents);
            if (istask) {
              ischecked = istask[0] !== "[ ] ";
              itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
            }
          }
          list2.items.push({
            type: "list_item",
            raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents
          });
          list2.raw += raw;
        }
        list2.items[list2.items.length - 1].raw = raw.trimRight();
        list2.items[list2.items.length - 1].text = itemContents.trimRight();
        list2.raw = list2.raw.trimRight();
        const l = list2.items.length;
        for (i = 0; i < l; i++) {
          this.lexer.state.top = false;
          list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
          const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.every((t) => {
            const chars = t.raw.split("");
            let lineBreaks = 0;
            for (const char of chars) {
              if (char === "\n") {
                lineBreaks += 1;
              }
              if (lineBreaks > 1) {
                return true;
              }
            }
            return false;
          });
          if (!list2.loose && spacers.length && hasMultipleLineBreaks) {
            list2.loose = true;
            list2.items[i].loose = true;
          }
        }
        return list2;
      }
    }
    html(src) {
      const cap = this.rules.block.html.exec(src);
      if (cap) {
        const token = {
          type: "html",
          raw: cap[0],
          pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
          text: cap[0]
        };
        if (this.options.sanitize) {
          token.type = "paragraph";
          token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
          token.tokens = [];
          this.lexer.inline(token.text, token.tokens);
        }
        return token;
      }
    }
    def(src) {
      const cap = this.rules.block.def.exec(src);
      if (cap) {
        if (cap[3])
          cap[3] = cap[3].substring(1, cap[3].length - 1);
        const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
        return {
          type: "def",
          tag,
          raw: cap[0],
          href: cap[2],
          title: cap[3]
        };
      }
    }
    table(src) {
      const cap = this.rules.block.table.exec(src);
      if (cap) {
        const item2 = {
          type: "table",
          header: splitCells(cap[1]).map((c) => {
            return {text: c};
          }),
          align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
          rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
        };
        if (item2.header.length === item2.align.length) {
          item2.raw = cap[0];
          let l = item2.align.length;
          let i, j, k, row;
          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item2.align[i])) {
              item2.align[i] = "right";
            } else if (/^ *:-+: *$/.test(item2.align[i])) {
              item2.align[i] = "center";
            } else if (/^ *:-+ *$/.test(item2.align[i])) {
              item2.align[i] = "left";
            } else {
              item2.align[i] = null;
            }
          }
          l = item2.rows.length;
          for (i = 0; i < l; i++) {
            item2.rows[i] = splitCells(item2.rows[i], item2.header.length).map((c) => {
              return {text: c};
            });
          }
          l = item2.header.length;
          for (j = 0; j < l; j++) {
            item2.header[j].tokens = [];
            this.lexer.inline(item2.header[j].text, item2.header[j].tokens);
          }
          l = item2.rows.length;
          for (j = 0; j < l; j++) {
            row = item2.rows[j];
            for (k = 0; k < row.length; k++) {
              row[k].tokens = [];
              this.lexer.inline(row[k].text, row[k].tokens);
            }
          }
          return item2;
        }
      }
    }
    lheading(src) {
      const cap = this.rules.block.lheading.exec(src);
      if (cap) {
        const token = {
          type: "heading",
          raw: cap[0],
          depth: cap[2].charAt(0) === "=" ? 1 : 2,
          text: cap[1],
          tokens: []
        };
        this.lexer.inline(token.text, token.tokens);
        return token;
      }
    }
    paragraph(src) {
      const cap = this.rules.block.paragraph.exec(src);
      if (cap) {
        const token = {
          type: "paragraph",
          raw: cap[0],
          text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
          tokens: []
        };
        this.lexer.inline(token.text, token.tokens);
        return token;
      }
    }
    text(src) {
      const cap = this.rules.block.text.exec(src);
      if (cap) {
        const token = {
          type: "text",
          raw: cap[0],
          text: cap[0],
          tokens: []
        };
        this.lexer.inline(token.text, token.tokens);
        return token;
      }
    }
    escape(src) {
      const cap = this.rules.inline.escape.exec(src);
      if (cap) {
        return {
          type: "escape",
          raw: cap[0],
          text: escape(cap[1])
        };
      }
    }
    tag(src) {
      const cap = this.rules.inline.tag.exec(src);
      if (cap) {
        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
          this.lexer.state.inLink = false;
        }
        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }
        return {
          type: this.options.sanitize ? "text" : "html",
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
        };
      }
    }
    link(src) {
      const cap = this.rules.inline.link.exec(src);
      if (cap) {
        const trimmedUrl = cap[2].trim();
        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          if (!/>$/.test(trimmedUrl)) {
            return;
          }
          const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          const lastParenIndex = findClosingBracket(cap[2], "()");
          if (lastParenIndex > -1) {
            const start = cap[0].indexOf("!") === 0 ? 5 : 4;
            const linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
        }
        let href = cap[2];
        let title = "";
        if (this.options.pedantic) {
          const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
          if (link) {
            href = link[1];
            title = link[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : "";
        }
        href = href.trim();
        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }
        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
          title: title ? title.replace(this.rules.inline._escapes, "$1") : title
        }, cap[0], this.lexer);
      }
    }
    reflink(src, links) {
      let cap;
      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
        link = links[link.toLowerCase()];
        if (!link || !link.href) {
          const text2 = cap[0].charAt(0);
          return {
            type: "text",
            raw: text2,
            text: text2
          };
        }
        return outputLink(cap, link, cap[0], this.lexer);
      }
    }
    emStrong(src, maskedSrc, prevChar = "") {
      let match = this.rules.inline.emStrong.lDelim.exec(src);
      if (!match)
        return;
      if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
        return;
      const nextChar = match[1] || match[2] || "";
      if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
        const lLength = match[0].length - 1;
        let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
        const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim)
            continue;
          rLength = rDelim.length;
          if (match[3] || match[4]) {
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue;
            }
          }
          delimTotal -= rLength;
          if (delimTotal > 0)
            continue;
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          if (Math.min(lLength, rLength) % 2) {
            const text3 = src.slice(1, lLength + match.index + rLength);
            return {
              type: "em",
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: text3,
              tokens: this.lexer.inlineTokens(text3, [])
            };
          }
          const text2 = src.slice(2, lLength + match.index + rLength - 1);
          return {
            type: "strong",
            raw: src.slice(0, lLength + match.index + rLength + 1),
            text: text2,
            tokens: this.lexer.inlineTokens(text2, [])
          };
        }
      }
    }
    codespan(src) {
      const cap = this.rules.inline.code.exec(src);
      if (cap) {
        let text2 = cap[2].replace(/\n/g, " ");
        const hasNonSpaceChars = /[^ ]/.test(text2);
        const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text2 = text2.substring(1, text2.length - 1);
        }
        text2 = escape(text2, true);
        return {
          type: "codespan",
          raw: cap[0],
          text: text2
        };
      }
    }
    br(src) {
      const cap = this.rules.inline.br.exec(src);
      if (cap) {
        return {
          type: "br",
          raw: cap[0]
        };
      }
    }
    del(src) {
      const cap = this.rules.inline.del.exec(src);
      if (cap) {
        return {
          type: "del",
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2], [])
        };
      }
    }
    autolink(src, mangle2) {
      const cap = this.rules.inline.autolink.exec(src);
      if (cap) {
        let text2, href;
        if (cap[2] === "@") {
          text2 = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
          href = "mailto:" + text2;
        } else {
          text2 = escape(cap[1]);
          href = text2;
        }
        return {
          type: "link",
          raw: cap[0],
          text: text2,
          href,
          tokens: [
            {
              type: "text",
              raw: text2,
              text: text2
            }
          ]
        };
      }
    }
    url(src, mangle2) {
      let cap;
      if (cap = this.rules.inline.url.exec(src)) {
        let text2, href;
        if (cap[2] === "@") {
          text2 = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
          href = "mailto:" + text2;
        } else {
          let prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);
          text2 = escape(cap[0]);
          if (cap[1] === "www.") {
            href = "http://" + text2;
          } else {
            href = text2;
          }
        }
        return {
          type: "link",
          raw: cap[0],
          text: text2,
          href,
          tokens: [
            {
              type: "text",
              raw: text2,
              text: text2
            }
          ]
        };
      }
    }
    inlineText(src, smartypants2) {
      const cap = this.rules.inline.text.exec(src);
      if (cap) {
        let text2;
        if (this.lexer.state.inRawBlock) {
          text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
        } else {
          text2 = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
        }
        return {
          type: "text",
          raw: cap[0],
          text: text2
        };
      }
    }
  };
  var block = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
    html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
    def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
    table: noopTest,
    lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
  block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
  block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
  block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
  block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
  block.normal = merge({}, block);
  block.gfm = merge({}, block.normal, {
    table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  });
  block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
  block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
  block.pedantic = merge({}, block.normal, {
    html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
  });
  var inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest,
    tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(ref)\]/,
    nolink: /^!?\[(ref)\](?:\[\])?/,
    reflinkSearch: "reflink|nolink(?!\\()",
    emStrong: {
      lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
      rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
      rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\spunctuation])/
  };
  inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
  inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
  inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
  inline.escapedEmSt = /\\\*|\\_/g;
  inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
  inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
  inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
  inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
  inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
  inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
  inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
  inline.normal = merge({}, inline);
  inline.pedantic = merge({}, inline.normal, {
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
  });
  inline.gfm = merge({}, inline.normal, {
    escape: edit(inline.escape).replace("])", "~|])").getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  });
  inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
  inline.breaks = merge({}, inline.gfm, {
    br: edit(inline.br).replace("{2,}", "*").getRegex(),
    text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  });
  function smartypants(text2) {
    return text2.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
  }
  function mangle(text2) {
    let out = "", i, ch;
    const l = text2.length;
    for (i = 0; i < l; i++) {
      ch = text2.charCodeAt(i);
      if (Math.random() > 0.5) {
        ch = "x" + ch.toString(16);
      }
      out += "&#" + ch + ";";
    }
    return out;
  }
  var Lexer = class {
    constructor(options2) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options2 || defaults3;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const rules = {
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    static get rules() {
      return {
        block,
        inline
      };
    }
    static lex(src, options2) {
      const lexer2 = new Lexer(options2);
      return lexer2.lex(src);
    }
    static lexInline(src, options2) {
      const lexer2 = new Lexer(options2);
      return lexer2.inlineTokens(src);
    }
    lex(src) {
      src = src.replace(/\r\n|\r/g, "\n");
      this.blockTokens(src, this.tokens);
      let next;
      while (next = this.inlineQueue.shift()) {
        this.inlineTokens(next.src, next.tokens);
      }
      return this.tokens;
    }
    blockTokens(src, tokens = []) {
      if (this.options.pedantic) {
        src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
      } else {
        src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
          return leading + "    ".repeat(tabs.length);
        });
      }
      let token, lastToken, cutSrc, lastParagraphClipped;
      while (src) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
          if (token = extTokenizer.call({lexer: this}, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);
          if (token.raw.length === 1 && tokens.length > 0) {
            tokens[tokens.length - 1].raw += "\n";
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }
        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startBlock) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startBlock.forEach(function(getStartIndex) {
            tempStart = getStartIndex.call({lexer: this}, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens[tokens.length - 1];
          if (lastParagraphClipped && lastToken.type === "paragraph") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        }
        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens;
    }
    inline(src, tokens) {
      this.inlineQueue.push({src, tokens});
    }
    inlineTokens(src, tokens = []) {
      let token, lastToken, cutSrc;
      let maskedSrc = src;
      let match;
      let keepPrevChar, prevChar;
      if (this.tokens.links) {
        const links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      }
      while (src) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
          if (token = extTokenizer.call({lexer: this}, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.autolink(src, mangle)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src;
        if (this.options.extensions && this.options.extensions.startInline) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startInline.forEach(function(getStartIndex) {
            tempStart = getStartIndex.call({lexer: this}, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
          src = src.substring(token.raw.length);
          if (token.raw.slice(-1) !== "_") {
            prevChar = token.raw.slice(-1);
          }
          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
  };
  var Renderer = class {
    constructor(options2) {
      this.options = options2 || defaults3;
    }
    code(code, infostring, escaped) {
      const lang = (infostring || "").match(/\S*/)[0];
      if (this.options.highlight) {
        const out = this.options.highlight(code, lang);
        if (out != null && out !== code) {
          escaped = true;
          code = out;
        }
      }
      code = code.replace(/\n$/, "") + "\n";
      if (!lang) {
        return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    blockquote(quote) {
      return `<blockquote>
${quote}</blockquote>
`;
    }
    html(html) {
      return html;
    }
    heading(text2, level, raw, slugger) {
      if (this.options.headerIds) {
        const id = this.options.headerPrefix + slugger.slug(raw);
        return `<h${level} id="${id}">${text2}</h${level}>
`;
      }
      return `<h${level}>${text2}</h${level}>
`;
    }
    hr() {
      return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
    }
    list(body, ordered, start) {
      const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
      return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
    }
    listitem(text2) {
      return `<li>${text2}</li>
`;
    }
    checkbox(checked) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
    }
    paragraph(text2) {
      return `<p>${text2}</p>
`;
    }
    table(header, body) {
      if (body)
        body = `<tbody>${body}</tbody>`;
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    }
    tablerow(content) {
      return `<tr>
${content}</tr>
`;
    }
    tablecell(content, flags) {
      const type = flags.header ? "th" : "td";
      const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
      return tag + content + `</${type}>
`;
    }
    strong(text2) {
      return `<strong>${text2}</strong>`;
    }
    em(text2) {
      return `<em>${text2}</em>`;
    }
    codespan(text2) {
      return `<code>${text2}</code>`;
    }
    br() {
      return this.options.xhtml ? "<br/>" : "<br>";
    }
    del(text2) {
      return `<del>${text2}</del>`;
    }
    link(href, title, text2) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text2;
      }
      let out = '<a href="' + escape(href) + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += ">" + text2 + "</a>";
      return out;
    }
    image(href, title, text2) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text2;
      }
      let out = `<img src="${href}" alt="${text2}"`;
      if (title) {
        out += ` title="${title}"`;
      }
      out += this.options.xhtml ? "/>" : ">";
      return out;
    }
    text(text2) {
      return text2;
    }
  };
  var TextRenderer = class {
    strong(text2) {
      return text2;
    }
    em(text2) {
      return text2;
    }
    codespan(text2) {
      return text2;
    }
    del(text2) {
      return text2;
    }
    html(text2) {
      return text2;
    }
    text(text2) {
      return text2;
    }
    link(href, title, text2) {
      return "" + text2;
    }
    image(href, title, text2) {
      return "" + text2;
    }
    br() {
      return "";
    }
  };
  var Slugger = class {
    constructor() {
      this.seen = {};
    }
    serialize(value) {
      return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
    }
    getNextSafeSlug(originalSlug, isDryRun) {
      let slug = originalSlug;
      let occurenceAccumulator = 0;
      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];
        do {
          occurenceAccumulator++;
          slug = originalSlug + "-" + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }
      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }
      return slug;
    }
    slug(value, options2 = {}) {
      const slug = this.serialize(value);
      return this.getNextSafeSlug(slug, options2.dryrun);
    }
  };
  var Parser = class {
    constructor(options2) {
      this.options = options2 || defaults3;
      this.options.renderer = this.options.renderer || new Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer();
      this.slugger = new Slugger();
    }
    static parse(tokens, options2) {
      const parser2 = new Parser(options2);
      return parser2.parse(tokens);
    }
    static parseInline(tokens, options2) {
      const parser2 = new Parser(options2);
      return parser2.parseInline(tokens);
    }
    parse(tokens, top = true) {
      let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item2, checked, task, checkbox, ret;
      const l = tokens.length;
      for (i = 0; i < l; i++) {
        token = tokens[i];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({parser: this}, token);
          if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
            out += ret || "";
            continue;
          }
        }
        switch (token.type) {
          case "space": {
            continue;
          }
          case "hr": {
            out += this.renderer.hr();
            continue;
          }
          case "heading": {
            out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape2(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
            continue;
          }
          case "code": {
            out += this.renderer.code(token.text, token.lang, token.escaped);
            continue;
          }
          case "table": {
            header = "";
            cell = "";
            l2 = token.header.length;
            for (j = 0; j < l2; j++) {
              cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {header: true, align: token.align[j]});
            }
            header += this.renderer.tablerow(cell);
            body = "";
            l2 = token.rows.length;
            for (j = 0; j < l2; j++) {
              row = token.rows[j];
              cell = "";
              l3 = row.length;
              for (k = 0; k < l3; k++) {
                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {header: false, align: token.align[k]});
              }
              body += this.renderer.tablerow(cell);
            }
            out += this.renderer.table(header, body);
            continue;
          }
          case "blockquote": {
            body = this.parse(token.tokens);
            out += this.renderer.blockquote(body);
            continue;
          }
          case "list": {
            ordered = token.ordered;
            start = token.start;
            loose = token.loose;
            l2 = token.items.length;
            body = "";
            for (j = 0; j < l2; j++) {
              item2 = token.items[j];
              checked = item2.checked;
              task = item2.task;
              itemBody = "";
              if (item2.task) {
                checkbox = this.renderer.checkbox(checked);
                if (loose) {
                  if (item2.tokens.length > 0 && item2.tokens[0].type === "paragraph") {
                    item2.tokens[0].text = checkbox + " " + item2.tokens[0].text;
                    if (item2.tokens[0].tokens && item2.tokens[0].tokens.length > 0 && item2.tokens[0].tokens[0].type === "text") {
                      item2.tokens[0].tokens[0].text = checkbox + " " + item2.tokens[0].tokens[0].text;
                    }
                  } else {
                    item2.tokens.unshift({
                      type: "text",
                      text: checkbox
                    });
                  }
                } else {
                  itemBody += checkbox;
                }
              }
              itemBody += this.parse(item2.tokens, loose);
              body += this.renderer.listitem(itemBody, task, checked);
            }
            out += this.renderer.list(body, ordered, start);
            continue;
          }
          case "html": {
            out += this.renderer.html(token.text);
            continue;
          }
          case "paragraph": {
            out += this.renderer.paragraph(this.parseInline(token.tokens));
            continue;
          }
          case "text": {
            body = token.tokens ? this.parseInline(token.tokens) : token.text;
            while (i + 1 < l && tokens[i + 1].type === "text") {
              token = tokens[++i];
              body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
            }
            out += top ? this.renderer.paragraph(body) : body;
            continue;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
    parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      let out = "", i, token, ret;
      const l = tokens.length;
      for (i = 0; i < l; i++) {
        token = tokens[i];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({parser: this}, token);
          if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
            out += ret || "";
            continue;
          }
        }
        switch (token.type) {
          case "escape": {
            out += renderer.text(token.text);
            break;
          }
          case "html": {
            out += renderer.html(token.text);
            break;
          }
          case "link": {
            out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
            break;
          }
          case "image": {
            out += renderer.image(token.href, token.title, token.text);
            break;
          }
          case "strong": {
            out += renderer.strong(this.parseInline(token.tokens, renderer));
            break;
          }
          case "em": {
            out += renderer.em(this.parseInline(token.tokens, renderer));
            break;
          }
          case "codespan": {
            out += renderer.codespan(token.text);
            break;
          }
          case "br": {
            out += renderer.br();
            break;
          }
          case "del": {
            out += renderer.del(this.parseInline(token.tokens, renderer));
            break;
          }
          case "text": {
            out += renderer.text(token.text);
            break;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
  };
  function marked(src, opt, callback) {
    if (typeof src === "undefined" || src === null) {
      throw new Error("marked(): input parameter is undefined or null");
    }
    if (typeof src !== "string") {
      throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
    }
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);
    if (callback) {
      const highlight = opt.highlight;
      let tokens;
      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }
      const done = function(err) {
        let out;
        if (!err) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            out = Parser.parse(tokens, opt);
          } catch (e) {
            err = e;
          }
        }
        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      marked.walkTokens(tokens, function(token) {
        if (token.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token.text, token.lang, function(err, code) {
              if (err) {
                return done(err);
              }
              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    try {
      const tokens = Lexer.lex(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }
      return Parser.parse(tokens, opt);
    } catch (e) {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (opt.silent) {
        return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
      }
      throw e;
    }
  }
  marked.options = marked.setOptions = function(opt) {
    merge(marked.defaults, opt);
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.getDefaults = getDefaults;
  marked.defaults = defaults3;
  marked.use = function(...args) {
    const opts = merge({}, ...args);
    const extensions = marked.defaults.extensions || {renderers: {}, childTokens: {}};
    let hasExtensions;
    args.forEach((pack) => {
      if (pack.extensions) {
        hasExtensions = true;
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if (ext.renderer) {
            const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if (ext.tokenizer) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            if (extensions[ext.level]) {
              extensions[ext.level].unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if (ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
      }
      if (pack.renderer) {
        const renderer = marked.defaults.renderer || new Renderer();
        for (const prop in pack.renderer) {
          const prevRenderer = renderer[prop];
          renderer[prop] = (...args2) => {
            let ret = pack.renderer[prop].apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret;
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = marked.defaults.tokenizer || new Tokenizer();
        for (const prop in pack.tokenizer) {
          const prevTokenizer = tokenizer[prop];
          tokenizer[prop] = (...args2) => {
            let ret = pack.tokenizer[prop].apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.walkTokens) {
        const walkTokens2 = marked.defaults.walkTokens;
        opts.walkTokens = function(token) {
          pack.walkTokens.call(this, token);
          if (walkTokens2) {
            walkTokens2.call(this, token);
          }
        };
      }
      if (hasExtensions) {
        opts.extensions = extensions;
      }
      marked.setOptions(opts);
    });
  };
  marked.walkTokens = function(tokens, callback) {
    for (const token of tokens) {
      callback.call(marked, token);
      switch (token.type) {
        case "table": {
          for (const cell of token.header) {
            marked.walkTokens(cell.tokens, callback);
          }
          for (const row of token.rows) {
            for (const cell of row) {
              marked.walkTokens(cell.tokens, callback);
            }
          }
          break;
        }
        case "list": {
          marked.walkTokens(token.items, callback);
          break;
        }
        default: {
          if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
            marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
              marked.walkTokens(token[childTokens], callback);
            });
          } else if (token.tokens) {
            marked.walkTokens(token.tokens, callback);
          }
        }
      }
    }
  };
  marked.parseInline = function(src, opt) {
    if (typeof src === "undefined" || src === null) {
      throw new Error("marked.parseInline(): input parameter is undefined or null");
    }
    if (typeof src !== "string") {
      throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
    }
    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);
    try {
      const tokens = Lexer.lexInline(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }
      return Parser.parseInline(tokens, opt);
    } catch (e) {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (opt.silent) {
        return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
      }
      throw e;
    }
  };
  marked.Parser = Parser;
  marked.parser = Parser.parse;
  marked.Renderer = Renderer;
  marked.TextRenderer = TextRenderer;
  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;
  marked.Tokenizer = Tokenizer;
  marked.Slugger = Slugger;
  marked.parse = marked;
  var options = marked.options;
  var setOptions2 = marked.setOptions;
  var use = marked.use;
  var walkTokens = marked.walkTokens;
  var parseInline = marked.parseInline;
  var parse4 = marked;
  var parser = Parser.parse;
  var lexer = Lexer.lex;
});

// node_modules/easymde/src/js/easymde.js
var require_easymde = __commonJS((exports, module) => {
  "use strict";
  var CodeMirror2 = require_codemirror();
  require_continuelist();
  require_tablist();
  require_fullscreen();
  require_markdown();
  require_overlay();
  require_placeholder();
  require_autorefresh();
  require_mark_selection();
  require_searchcursor();
  require_gfm();
  require_xml();
  var CodeMirrorSpellChecker = require_spell_checker();
  var marked = require_marked_esm().marked;
  var isMac = /Mac/.test(navigator.platform);
  var anchorToExternalRegex = new RegExp(/(<a.*?https?:\/\/.*?[^a]>)+?/g);
  var bindings = {
    toggleBold,
    toggleItalic,
    drawLink,
    toggleHeadingSmaller,
    toggleHeadingBigger,
    drawImage: drawImage2,
    toggleBlockquote,
    toggleOrderedList,
    toggleUnorderedList,
    toggleCodeBlock,
    togglePreview,
    toggleStrikethrough,
    toggleHeading1,
    toggleHeading2,
    toggleHeading3,
    cleanBlock,
    drawTable,
    drawHorizontalRule,
    undo,
    redo,
    toggleSideBySide,
    toggleFullScreen
  };
  var shortcuts = {
    toggleBold: "Cmd-B",
    toggleItalic: "Cmd-I",
    drawLink: "Cmd-K",
    toggleHeadingSmaller: "Cmd-H",
    toggleHeadingBigger: "Shift-Cmd-H",
    cleanBlock: "Cmd-E",
    drawImage: "Cmd-Alt-I",
    toggleBlockquote: "Cmd-'",
    toggleOrderedList: "Cmd-Alt-L",
    toggleUnorderedList: "Cmd-L",
    toggleCodeBlock: "Cmd-Alt-C",
    togglePreview: "Cmd-P",
    toggleSideBySide: "F9",
    toggleFullScreen: "F11"
  };
  var getBindingName = function(f) {
    for (var key in bindings) {
      if (bindings[key] === f) {
        return key;
      }
    }
    return null;
  };
  var isMobile = function() {
    var check = false;
    (function(a) {
      if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(a.substr(0, 4)))
        check = true;
    })(navigator.userAgent || navigator.vendor || window.opera);
    return check;
  };
  function addAnchorTargetBlank(htmlText) {
    var match;
    while ((match = anchorToExternalRegex.exec(htmlText)) !== null) {
      var linkString = match[0];
      if (linkString.indexOf("target=") === -1) {
        var fixedLinkString = linkString.replace(/>$/, ' target="_blank">');
        htmlText = htmlText.replace(linkString, fixedLinkString);
      }
    }
    return htmlText;
  }
  function removeListStyleWhenCheckbox(htmlText) {
    var parser = new DOMParser();
    var htmlDoc = parser.parseFromString(htmlText, "text/html");
    var listItems = htmlDoc.getElementsByTagName("li");
    for (var i = 0; i < listItems.length; i++) {
      var listItem = listItems[i];
      for (var j = 0; j < listItem.children.length; j++) {
        var listItemChild = listItem.children[j];
        if (listItemChild instanceof HTMLInputElement && listItemChild.type === "checkbox") {
          listItem.style.marginLeft = "-1.5em";
          listItem.style.listStyleType = "none";
        }
      }
    }
    return htmlDoc.documentElement.innerHTML;
  }
  function fixShortcut(name2) {
    if (isMac) {
      name2 = name2.replace("Ctrl", "Cmd");
    } else {
      name2 = name2.replace("Cmd", "Ctrl");
    }
    return name2;
  }
  var CLASS_REGEX = {};
  function getClassRegex(className) {
    return CLASS_REGEX[className] || (CLASS_REGEX[className] = new RegExp("\\s*" + className + "(\\s*)", "g"));
  }
  function addClass(el, className) {
    if (!el || !className)
      return;
    var classRegex = getClassRegex(className);
    if (el.className.match(classRegex))
      return;
    el.className += " " + className;
  }
  function removeClass(el, className) {
    if (!el || !className)
      return;
    var classRegex = getClassRegex(className);
    if (!el.className.match(classRegex))
      return;
    el.className = el.className.replace(classRegex, "$1");
  }
  function createToolbarDropdown(options, enableTooltips, shortcuts2, parent) {
    var el = createToolbarButton(options, false, enableTooltips, shortcuts2, "button", parent);
    el.className += " easymde-dropdown";
    el.onclick = function() {
      el.focus();
    };
    var content = document.createElement("div");
    content.className = "easymde-dropdown-content";
    for (var childrenIndex = 0; childrenIndex < options.children.length; childrenIndex++) {
      var child = options.children[childrenIndex];
      var childElement;
      if (typeof child === "string" && child in toolbarBuiltInButtons) {
        childElement = createToolbarButton(toolbarBuiltInButtons[child], true, enableTooltips, shortcuts2, "button", parent);
      } else {
        childElement = createToolbarButton(child, true, enableTooltips, shortcuts2, "button", parent);
      }
      childElement.addEventListener("click", function(e) {
        e.stopPropagation();
      }, false);
      content.appendChild(childElement);
    }
    el.appendChild(content);
    return el;
  }
  function createToolbarButton(options, enableActions, enableTooltips, shortcuts2, markup, parent) {
    options = options || {};
    var el = document.createElement(markup);
    if (options.attributes) {
      for (var attribute in options.attributes) {
        if (Object.prototype.hasOwnProperty.call(options.attributes, attribute)) {
          el.setAttribute(attribute, options.attributes[attribute]);
        }
      }
    }
    el.className = options.name;
    el.setAttribute("type", markup);
    enableTooltips = enableTooltips == void 0 ? true : enableTooltips;
    if (options.name && options.name in shortcuts2) {
      bindings[options.name] = options.action;
    }
    if (options.title && enableTooltips) {
      el.title = createTooltip(options.title, options.action, shortcuts2);
      if (isMac) {
        el.title = el.title.replace("Ctrl", "\u2318");
        el.title = el.title.replace("Alt", "\u2325");
      }
    }
    if (options.noDisable) {
      el.classList.add("no-disable");
    }
    if (options.noMobile) {
      el.classList.add("no-mobile");
    }
    var classNameParts = [];
    if (typeof options.className !== "undefined") {
      classNameParts = options.className.split(" ");
    }
    var iconClasses = [];
    for (var classNameIndex = 0; classNameIndex < classNameParts.length; classNameIndex++) {
      var classNamePart = classNameParts[classNameIndex];
      if (classNamePart.match(/^fa([srlb]|(-[\w-]*)|$)/)) {
        iconClasses.push(classNamePart);
      } else {
        el.classList.add(classNamePart);
      }
    }
    el.tabIndex = -1;
    var icon = document.createElement("i");
    for (var iconClassIndex = 0; iconClassIndex < iconClasses.length; iconClassIndex++) {
      var iconClass = iconClasses[iconClassIndex];
      icon.classList.add(iconClass);
    }
    el.appendChild(icon);
    if (typeof options.icon !== "undefined") {
      el.innerHTML = options.icon;
    }
    if (options.action && enableActions) {
      if (typeof options.action === "function") {
        el.onclick = function(e) {
          e.preventDefault();
          options.action(parent);
        };
      } else if (typeof options.action === "string") {
        el.onclick = function(e) {
          e.preventDefault();
          window.open(options.action, "_blank");
        };
      }
    }
    return el;
  }
  function createSep() {
    var el = document.createElement("i");
    el.className = "separator";
    el.innerHTML = "|";
    return el;
  }
  function createTooltip(title, action, shortcuts2) {
    var actionName;
    var tooltip = title;
    if (action) {
      actionName = getBindingName(action);
      if (shortcuts2[actionName]) {
        tooltip += " (" + fixShortcut(shortcuts2[actionName]) + ")";
      }
    }
    return tooltip;
  }
  function getState(cm, pos) {
    pos = pos || cm.getCursor("start");
    var stat = cm.getTokenAt(pos);
    if (!stat.type)
      return {};
    var types = stat.type.split(" ");
    var ret = {}, data3, text2;
    for (var i = 0; i < types.length; i++) {
      data3 = types[i];
      if (data3 === "strong") {
        ret.bold = true;
      } else if (data3 === "variable-2") {
        text2 = cm.getLine(pos.line);
        if (/^\s*\d+\.\s/.test(text2)) {
          ret["ordered-list"] = true;
        } else {
          ret["unordered-list"] = true;
        }
      } else if (data3 === "atom") {
        ret.quote = true;
      } else if (data3 === "em") {
        ret.italic = true;
      } else if (data3 === "quote") {
        ret.quote = true;
      } else if (data3 === "strikethrough") {
        ret.strikethrough = true;
      } else if (data3 === "comment") {
        ret.code = true;
      } else if (data3 === "link") {
        ret.link = true;
      } else if (data3 === "tag") {
        ret.image = true;
      } else if (data3.match(/^header(-[1-6])?$/)) {
        ret[data3.replace("header", "heading")] = true;
      }
    }
    return ret;
  }
  var saved_overflow = "";
  function toggleFullScreen(editor) {
    var cm = editor.codemirror;
    cm.setOption("fullScreen", !cm.getOption("fullScreen"));
    if (cm.getOption("fullScreen")) {
      saved_overflow = document.body.style.overflow;
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = saved_overflow;
    }
    var wrapper3 = cm.getWrapperElement();
    var sidebyside = wrapper3.nextSibling;
    if (/editor-preview-active-side/.test(sidebyside.className)) {
      if (editor.options.sideBySideFullscreen === false) {
        var easyMDEContainer = wrapper3.parentNode;
        if (cm.getOption("fullScreen")) {
          removeClass(easyMDEContainer, "sided--no-fullscreen");
        } else {
          addClass(easyMDEContainer, "sided--no-fullscreen");
        }
      } else {
        toggleSideBySide(editor);
      }
    }
    if (editor.options.onToggleFullScreen) {
      editor.options.onToggleFullScreen(cm.getOption("fullScreen") || false);
    }
    if (typeof editor.options.maxHeight !== "undefined") {
      if (cm.getOption("fullScreen")) {
        cm.getScrollerElement().style.removeProperty("height");
        sidebyside.style.removeProperty("height");
      } else {
        cm.getScrollerElement().style.height = editor.options.maxHeight;
        editor.setPreviewMaxHeight();
      }
    }
    if (!/fullscreen/.test(editor.toolbar_div.className)) {
      editor.toolbar_div.className += " fullscreen";
    } else {
      editor.toolbar_div.className = editor.toolbar_div.className.replace(/\s*fullscreen\b/, "");
    }
    if (editor.toolbarElements && editor.toolbarElements.fullscreen) {
      var toolbarButton = editor.toolbarElements.fullscreen;
      if (!/active/.test(toolbarButton.className)) {
        toolbarButton.className += " active";
      } else {
        toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
      }
    }
  }
  function toggleBold(editor) {
    _toggleBlock(editor, "bold", editor.options.blockStyles.bold);
  }
  function toggleItalic(editor) {
    _toggleBlock(editor, "italic", editor.options.blockStyles.italic);
  }
  function toggleStrikethrough(editor) {
    _toggleBlock(editor, "strikethrough", "~~");
  }
  function toggleCodeBlock(editor) {
    var fenceCharsToInsert = editor.options.blockStyles.code;
    function fencing_line(line2) {
      if (typeof line2 !== "object") {
        throw "fencing_line() takes a 'line' object (not a line number, or line text).  Got: " + typeof line2 + ": " + line2;
      }
      return line2.styles && line2.styles[2] && line2.styles[2].indexOf("formatting-code-block") !== -1;
    }
    function token_state(token) {
      return token.state.base.base || token.state.base;
    }
    function code_type(cm2, line_num, line2, firstTok, lastTok) {
      line2 = line2 || cm2.getLineHandle(line_num);
      firstTok = firstTok || cm2.getTokenAt({
        line: line_num,
        ch: 1
      });
      lastTok = lastTok || !!line2.text && cm2.getTokenAt({
        line: line_num,
        ch: line2.text.length - 1
      });
      var types = firstTok.type ? firstTok.type.split(" ") : [];
      if (lastTok && token_state(lastTok).indentedCode) {
        return "indented";
      } else if (types.indexOf("comment") === -1) {
        return false;
      } else if (token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line2)) {
        return "fenced";
      } else {
        return "single";
      }
    }
    function insertFencingAtSelection(cm2, cur_start2, cur_end2, fenceCharsToInsert2) {
      var start_line_sel = cur_start2.line + 1, end_line_sel = cur_end2.line + 1, sel_multi2 = cur_start2.line !== cur_end2.line, repl_start = fenceCharsToInsert2 + "\n", repl_end = "\n" + fenceCharsToInsert2;
      if (sel_multi2) {
        end_line_sel++;
      }
      if (sel_multi2 && cur_end2.ch === 0) {
        repl_end = fenceCharsToInsert2 + "\n";
        end_line_sel--;
      }
      _replaceSelection(cm2, false, [repl_start, repl_end]);
      cm2.setSelection({
        line: start_line_sel,
        ch: 0
      }, {
        line: end_line_sel,
        ch: 0
      });
    }
    var cm = editor.codemirror, cur_start = cm.getCursor("start"), cur_end = cm.getCursor("end"), tok = cm.getTokenAt({
      line: cur_start.line,
      ch: cur_start.ch || 1
    }), line = cm.getLineHandle(cur_start.line), is_code = code_type(cm, cur_start.line, line, tok);
    var block_start, block_end, lineCount;
    if (is_code === "single") {
      var start = line.text.slice(0, cur_start.ch).replace("`", ""), end = line.text.slice(cur_start.ch).replace("`", "");
      cm.replaceRange(start + end, {
        line: cur_start.line,
        ch: 0
      }, {
        line: cur_start.line,
        ch: 99999999999999
      });
      cur_start.ch--;
      if (cur_start !== cur_end) {
        cur_end.ch--;
      }
      cm.setSelection(cur_start, cur_end);
      cm.focus();
    } else if (is_code === "fenced") {
      if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
        for (block_start = cur_start.line; block_start >= 0; block_start--) {
          line = cm.getLineHandle(block_start);
          if (fencing_line(line)) {
            break;
          }
        }
        var fencedTok = cm.getTokenAt({
          line: block_start,
          ch: 1
        });
        var fence_chars = token_state(fencedTok).fencedChars;
        var start_text, start_line;
        var end_text, end_line;
        if (fencing_line(cm.getLineHandle(cur_start.line))) {
          start_text = "";
          start_line = cur_start.line;
        } else if (fencing_line(cm.getLineHandle(cur_start.line - 1))) {
          start_text = "";
          start_line = cur_start.line - 1;
        } else {
          start_text = fence_chars + "\n";
          start_line = cur_start.line;
        }
        if (fencing_line(cm.getLineHandle(cur_end.line))) {
          end_text = "";
          end_line = cur_end.line;
          if (cur_end.ch === 0) {
            end_line += 1;
          }
        } else if (cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {
          end_text = "";
          end_line = cur_end.line + 1;
        } else {
          end_text = fence_chars + "\n";
          end_line = cur_end.line + 1;
        }
        if (cur_end.ch === 0) {
          end_line -= 1;
        }
        cm.operation(function() {
          cm.replaceRange(end_text, {
            line: end_line,
            ch: 0
          }, {
            line: end_line + (end_text ? 0 : 1),
            ch: 0
          });
          cm.replaceRange(start_text, {
            line: start_line,
            ch: 0
          }, {
            line: start_line + (start_text ? 0 : 1),
            ch: 0
          });
        });
        cm.setSelection({
          line: start_line + (start_text ? 1 : 0),
          ch: 0
        }, {
          line: end_line + (start_text ? 1 : -1),
          ch: 0
        });
        cm.focus();
      } else {
        var search_from = cur_start.line;
        if (fencing_line(cm.getLineHandle(cur_start.line))) {
          if (code_type(cm, cur_start.line + 1) === "fenced") {
            block_start = cur_start.line;
            search_from = cur_start.line + 1;
          } else {
            block_end = cur_start.line;
            search_from = cur_start.line - 1;
          }
        }
        if (block_start === void 0) {
          for (block_start = search_from; block_start >= 0; block_start--) {
            line = cm.getLineHandle(block_start);
            if (fencing_line(line)) {
              break;
            }
          }
        }
        if (block_end === void 0) {
          lineCount = cm.lineCount();
          for (block_end = search_from; block_end < lineCount; block_end++) {
            line = cm.getLineHandle(block_end);
            if (fencing_line(line)) {
              break;
            }
          }
        }
        cm.operation(function() {
          cm.replaceRange("", {
            line: block_start,
            ch: 0
          }, {
            line: block_start + 1,
            ch: 0
          });
          cm.replaceRange("", {
            line: block_end - 1,
            ch: 0
          }, {
            line: block_end,
            ch: 0
          });
        });
        cm.focus();
      }
    } else if (is_code === "indented") {
      if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
        block_start = cur_start.line;
        block_end = cur_end.line;
        if (cur_end.ch === 0) {
          block_end--;
        }
      } else {
        for (block_start = cur_start.line; block_start >= 0; block_start--) {
          line = cm.getLineHandle(block_start);
          if (line.text.match(/^\s*$/)) {
            continue;
          } else {
            if (code_type(cm, block_start, line) !== "indented") {
              block_start += 1;
              break;
            }
          }
        }
        lineCount = cm.lineCount();
        for (block_end = cur_start.line; block_end < lineCount; block_end++) {
          line = cm.getLineHandle(block_end);
          if (line.text.match(/^\s*$/)) {
            continue;
          } else {
            if (code_type(cm, block_end, line) !== "indented") {
              block_end -= 1;
              break;
            }
          }
        }
      }
      var next_line = cm.getLineHandle(block_end + 1), next_line_last_tok = next_line && cm.getTokenAt({
        line: block_end + 1,
        ch: next_line.text.length - 1
      }), next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;
      if (next_line_indented) {
        cm.replaceRange("\n", {
          line: block_end + 1,
          ch: 0
        });
      }
      for (var i = block_start; i <= block_end; i++) {
        cm.indentLine(i, "subtract");
      }
      cm.focus();
    } else {
      var no_sel_and_starting_of_line = cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0;
      var sel_multi = cur_start.line !== cur_end.line;
      if (no_sel_and_starting_of_line || sel_multi) {
        insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);
      } else {
        _replaceSelection(cm, false, ["`", "`"]);
      }
    }
  }
  function toggleBlockquote(editor) {
    var cm = editor.codemirror;
    _toggleLine(cm, "quote");
  }
  function toggleHeadingSmaller(editor) {
    var cm = editor.codemirror;
    _toggleHeading(cm, "smaller");
  }
  function toggleHeadingBigger(editor) {
    var cm = editor.codemirror;
    _toggleHeading(cm, "bigger");
  }
  function toggleHeading1(editor) {
    var cm = editor.codemirror;
    _toggleHeading(cm, void 0, 1);
  }
  function toggleHeading2(editor) {
    var cm = editor.codemirror;
    _toggleHeading(cm, void 0, 2);
  }
  function toggleHeading3(editor) {
    var cm = editor.codemirror;
    _toggleHeading(cm, void 0, 3);
  }
  function toggleUnorderedList(editor) {
    var cm = editor.codemirror;
    var listStyle = "*";
    if (["-", "+", "*"].includes(editor.options.unorderedListStyle)) {
      listStyle = editor.options.unorderedListStyle;
    }
    _toggleLine(cm, "unordered-list", listStyle);
  }
  function toggleOrderedList(editor) {
    var cm = editor.codemirror;
    _toggleLine(cm, "ordered-list");
  }
  function cleanBlock(editor) {
    var cm = editor.codemirror;
    _cleanBlock(cm);
  }
  function drawLink(editor) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    var url = "https://";
    if (options.promptURLs) {
      url = prompt(options.promptTexts.link, "https://");
      if (!url) {
        return false;
      }
    }
    _replaceSelection(cm, stat.link, options.insertTexts.link, url);
  }
  function drawImage2(editor) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    var url = "https://";
    if (options.promptURLs) {
      url = prompt(options.promptTexts.image, "https://");
      if (!url) {
        return false;
      }
    }
    _replaceSelection(cm, stat.image, options.insertTexts.image, url);
  }
  function drawUploadedImage(editor) {
    editor.openBrowseFileWindow();
  }
  function afterImageUploaded(editor, url) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    var imageName = url.substr(url.lastIndexOf("/") + 1);
    var ext = imageName.substring(imageName.lastIndexOf(".") + 1).replace(/\?.*$/, "").toLowerCase();
    if (["png", "jpg", "jpeg", "gif", "svg"].includes(ext)) {
      _replaceSelection(cm, stat.image, options.insertTexts.uploadedImage, url);
    } else {
      var text_link = options.insertTexts.link;
      text_link[0] = "[" + imageName;
      _replaceSelection(cm, stat.link, text_link, url);
    }
    editor.updateStatusBar("upload-image", editor.options.imageTexts.sbOnUploaded.replace("#image_name#", imageName));
    setTimeout(function() {
      editor.updateStatusBar("upload-image", editor.options.imageTexts.sbInit);
    }, 1e3);
  }
  function drawTable(editor) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    _replaceSelection(cm, stat.table, options.insertTexts.table);
  }
  function drawHorizontalRule(editor) {
    var cm = editor.codemirror;
    var stat = getState(cm);
    var options = editor.options;
    _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);
  }
  function undo(editor) {
    var cm = editor.codemirror;
    cm.undo();
    cm.focus();
  }
  function redo(editor) {
    var cm = editor.codemirror;
    cm.redo();
    cm.focus();
  }
  function toggleSideBySide(editor) {
    var cm = editor.codemirror;
    var wrapper3 = cm.getWrapperElement();
    var preview = wrapper3.nextSibling;
    var toolbarButton = editor.toolbarElements && editor.toolbarElements["side-by-side"];
    var useSideBySideListener = false;
    var easyMDEContainer = wrapper3.parentNode;
    if (/editor-preview-active-side/.test(preview.className)) {
      if (editor.options.sideBySideFullscreen === false) {
        removeClass(easyMDEContainer, "sided--no-fullscreen");
      }
      preview.className = preview.className.replace(/\s*editor-preview-active-side\s*/g, "");
      if (toolbarButton)
        toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
      wrapper3.className = wrapper3.className.replace(/\s*CodeMirror-sided\s*/g, " ");
    } else {
      setTimeout(function() {
        if (!cm.getOption("fullScreen")) {
          if (editor.options.sideBySideFullscreen === false) {
            addClass(easyMDEContainer, "sided--no-fullscreen");
          } else {
            toggleFullScreen(editor);
          }
        }
        preview.className += " editor-preview-active-side";
      }, 1);
      if (toolbarButton)
        toolbarButton.className += " active";
      wrapper3.className += " CodeMirror-sided";
      useSideBySideListener = true;
    }
    var previewNormal = wrapper3.lastChild;
    if (/editor-preview-active/.test(previewNormal.className)) {
      previewNormal.className = previewNormal.className.replace(/\s*editor-preview-active\s*/g, "");
      var toolbar = editor.toolbarElements.preview;
      var toolbar_div = editor.toolbar_div;
      toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
      toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
    }
    var sideBySideRenderingFunction = function() {
      var newValue2 = editor.options.previewRender(editor.value(), preview);
      if (newValue2 != null) {
        preview.innerHTML = newValue2;
      }
    };
    if (!cm.sideBySideRenderingFunction) {
      cm.sideBySideRenderingFunction = sideBySideRenderingFunction;
    }
    if (useSideBySideListener) {
      var newValue = editor.options.previewRender(editor.value(), preview);
      if (newValue != null) {
        preview.innerHTML = newValue;
      }
      cm.on("update", cm.sideBySideRenderingFunction);
    } else {
      cm.off("update", cm.sideBySideRenderingFunction);
    }
    cm.refresh();
  }
  function togglePreview(editor) {
    var cm = editor.codemirror;
    var wrapper3 = cm.getWrapperElement();
    var toolbar_div = editor.toolbar_div;
    var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;
    var preview = wrapper3.lastChild;
    var sidebyside = cm.getWrapperElement().nextSibling;
    if (/editor-preview-active-side/.test(sidebyside.className))
      toggleSideBySide(editor);
    if (!preview || !/editor-preview-full/.test(preview.className)) {
      preview = document.createElement("div");
      preview.className = "editor-preview-full";
      if (editor.options.previewClass) {
        if (Array.isArray(editor.options.previewClass)) {
          for (var i = 0; i < editor.options.previewClass.length; i++) {
            preview.className += " " + editor.options.previewClass[i];
          }
        } else if (typeof editor.options.previewClass === "string") {
          preview.className += " " + editor.options.previewClass;
        }
      }
      wrapper3.appendChild(preview);
    }
    if (/editor-preview-active/.test(preview.className)) {
      preview.className = preview.className.replace(/\s*editor-preview-active\s*/g, "");
      if (toolbar) {
        toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
        toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
      }
    } else {
      setTimeout(function() {
        preview.className += " editor-preview-active";
      }, 1);
      if (toolbar) {
        toolbar.className += " active";
        toolbar_div.className += " disabled-for-preview";
      }
    }
    preview.innerHTML = editor.options.previewRender(editor.value(), preview);
  }
  function _replaceSelection(cm, active, startEnd, url) {
    if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
      return;
    var text2;
    var start = startEnd[0];
    var end = startEnd[1];
    var startPoint = {}, endPoint = {};
    Object.assign(startPoint, cm.getCursor("start"));
    Object.assign(endPoint, cm.getCursor("end"));
    if (url) {
      start = start.replace("#url#", url);
      end = end.replace("#url#", url);
    }
    if (active) {
      text2 = cm.getLine(startPoint.line);
      start = text2.slice(0, startPoint.ch);
      end = text2.slice(startPoint.ch);
      cm.replaceRange(start + end, {
        line: startPoint.line,
        ch: 0
      });
    } else {
      text2 = cm.getSelection();
      cm.replaceSelection(start + text2 + end);
      startPoint.ch += start.length;
      if (startPoint !== endPoint) {
        endPoint.ch += start.length;
      }
    }
    cm.setSelection(startPoint, endPoint);
    cm.focus();
  }
  function _toggleHeading(cm, direction, size) {
    if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
      return;
    var startPoint = cm.getCursor("start");
    var endPoint = cm.getCursor("end");
    for (var i = startPoint.line; i <= endPoint.line; i++) {
      (function(i2) {
        var text2 = cm.getLine(i2);
        var currHeadingLevel = text2.search(/[^#]/);
        if (direction !== void 0) {
          if (currHeadingLevel <= 0) {
            if (direction == "bigger") {
              text2 = "###### " + text2;
            } else {
              text2 = "# " + text2;
            }
          } else if (currHeadingLevel == 6 && direction == "smaller") {
            text2 = text2.substr(7);
          } else if (currHeadingLevel == 1 && direction == "bigger") {
            text2 = text2.substr(2);
          } else {
            if (direction == "bigger") {
              text2 = text2.substr(1);
            } else {
              text2 = "#" + text2;
            }
          }
        } else {
          if (size == 1) {
            if (currHeadingLevel <= 0) {
              text2 = "# " + text2;
            } else if (currHeadingLevel == size) {
              text2 = text2.substr(currHeadingLevel + 1);
            } else {
              text2 = "# " + text2.substr(currHeadingLevel + 1);
            }
          } else if (size == 2) {
            if (currHeadingLevel <= 0) {
              text2 = "## " + text2;
            } else if (currHeadingLevel == size) {
              text2 = text2.substr(currHeadingLevel + 1);
            } else {
              text2 = "## " + text2.substr(currHeadingLevel + 1);
            }
          } else {
            if (currHeadingLevel <= 0) {
              text2 = "### " + text2;
            } else if (currHeadingLevel == size) {
              text2 = text2.substr(currHeadingLevel + 1);
            } else {
              text2 = "### " + text2.substr(currHeadingLevel + 1);
            }
          }
        }
        cm.replaceRange(text2, {
          line: i2,
          ch: 0
        }, {
          line: i2,
          ch: 99999999999999
        });
      })(i);
    }
    cm.focus();
  }
  function _toggleLine(cm, name2, liststyle) {
    if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
      return;
    var listRegexp = /^(\s*)(\*|-|\+|\d*\.)(\s+)/;
    var whitespacesRegexp = /^\s*/;
    var stat = getState(cm);
    var startPoint = cm.getCursor("start");
    var endPoint = cm.getCursor("end");
    var repl = {
      quote: /^(\s*)>\s+/,
      "unordered-list": listRegexp,
      "ordered-list": listRegexp
    };
    var _getChar = function(name3, i2) {
      var map2 = {
        quote: ">",
        "unordered-list": liststyle,
        "ordered-list": "%%i."
      };
      return map2[name3].replace("%%i", i2);
    };
    var _checkChar = function(name3, char) {
      var map2 = {
        quote: ">",
        "unordered-list": "\\" + liststyle,
        "ordered-list": "\\d+."
      };
      var rt = new RegExp(map2[name3]);
      return char && rt.test(char);
    };
    var _toggle = function(name3, text2, untoggleOnly) {
      var arr = listRegexp.exec(text2);
      var char = _getChar(name3, line);
      if (arr !== null) {
        if (_checkChar(name3, arr[2])) {
          char = "";
        }
        text2 = arr[1] + char + arr[3] + text2.replace(whitespacesRegexp, "").replace(repl[name3], "$1");
      } else if (untoggleOnly == false) {
        text2 = char + " " + text2;
      }
      return text2;
    };
    var line = 1;
    for (var i = startPoint.line; i <= endPoint.line; i++) {
      (function(i2) {
        var text2 = cm.getLine(i2);
        if (stat[name2]) {
          text2 = text2.replace(repl[name2], "$1");
        } else {
          if (name2 == "unordered-list") {
            text2 = _toggle("ordered-list", text2, true);
          }
          text2 = _toggle(name2, text2, false);
          line += 1;
        }
        cm.replaceRange(text2, {
          line: i2,
          ch: 0
        }, {
          line: i2,
          ch: 99999999999999
        });
      })(i);
    }
    cm.focus();
  }
  function _toggleBlock(editor, type, start_chars, end_chars) {
    if (/editor-preview-active/.test(editor.codemirror.getWrapperElement().lastChild.className))
      return;
    end_chars = typeof end_chars === "undefined" ? start_chars : end_chars;
    var cm = editor.codemirror;
    var stat = getState(cm);
    var text2;
    var start = start_chars;
    var end = end_chars;
    var startPoint = cm.getCursor("start");
    var endPoint = cm.getCursor("end");
    if (stat[type]) {
      text2 = cm.getLine(startPoint.line);
      start = text2.slice(0, startPoint.ch);
      end = text2.slice(startPoint.ch);
      if (type == "bold") {
        start = start.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, "");
        end = end.replace(/(\*\*|__)/, "");
      } else if (type == "italic") {
        start = start.replace(/(\*|_)(?![\s\S]*(\*|_))/, "");
        end = end.replace(/(\*|_)/, "");
      } else if (type == "strikethrough") {
        start = start.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, "");
        end = end.replace(/(\*\*|~~)/, "");
      }
      cm.replaceRange(start + end, {
        line: startPoint.line,
        ch: 0
      }, {
        line: startPoint.line,
        ch: 99999999999999
      });
      if (type == "bold" || type == "strikethrough") {
        startPoint.ch -= 2;
        if (startPoint !== endPoint) {
          endPoint.ch -= 2;
        }
      } else if (type == "italic") {
        startPoint.ch -= 1;
        if (startPoint !== endPoint) {
          endPoint.ch -= 1;
        }
      }
    } else {
      text2 = cm.getSelection();
      if (type == "bold") {
        text2 = text2.split("**").join("");
        text2 = text2.split("__").join("");
      } else if (type == "italic") {
        text2 = text2.split("*").join("");
        text2 = text2.split("_").join("");
      } else if (type == "strikethrough") {
        text2 = text2.split("~~").join("");
      }
      cm.replaceSelection(start + text2 + end);
      startPoint.ch += start_chars.length;
      endPoint.ch = startPoint.ch + text2.length;
    }
    cm.setSelection(startPoint, endPoint);
    cm.focus();
  }
  function _cleanBlock(cm) {
    if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
      return;
    var startPoint = cm.getCursor("start");
    var endPoint = cm.getCursor("end");
    var text2;
    for (var line = startPoint.line; line <= endPoint.line; line++) {
      text2 = cm.getLine(line);
      text2 = text2.replace(/^[ ]*([# ]+|\*|-|[> ]+|[0-9]+(.|\)))[ ]*/, "");
      cm.replaceRange(text2, {
        line,
        ch: 0
      }, {
        line,
        ch: 99999999999999
      });
    }
  }
  function humanFileSize(bytes, units) {
    if (Math.abs(bytes) < 1024) {
      return "" + bytes + units[0];
    }
    var u = 0;
    do {
      bytes /= 1024;
      ++u;
    } while (Math.abs(bytes) >= 1024 && u < units.length);
    return "" + bytes.toFixed(1) + units[u];
  }
  function _mergeProperties(target, source) {
    for (var property in source) {
      if (Object.prototype.hasOwnProperty.call(source, property)) {
        if (source[property] instanceof Array) {
          target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);
        } else if (source[property] !== null && typeof source[property] === "object" && source[property].constructor === Object) {
          target[property] = _mergeProperties(target[property] || {}, source[property]);
        } else {
          target[property] = source[property];
        }
      }
    }
    return target;
  }
  function extend2(target) {
    for (var i = 1; i < arguments.length; i++) {
      target = _mergeProperties(target, arguments[i]);
    }
    return target;
  }
  function wordCount(data3) {
    var pattern = /[a-zA-Z0-9_\u00A0-\u02AF\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g;
    var m = data3.match(pattern);
    var count = 0;
    if (m === null)
      return count;
    for (var i = 0; i < m.length; i++) {
      if (m[i].charCodeAt(0) >= 19968) {
        count += m[i].length;
      } else {
        count += 1;
      }
    }
    return count;
  }
  var toolbarBuiltInButtons = {
    bold: {
      name: "bold",
      action: toggleBold,
      className: "fa fa-bold",
      title: "Bold",
      default: true
    },
    italic: {
      name: "italic",
      action: toggleItalic,
      className: "fa fa-italic",
      title: "Italic",
      default: true
    },
    strikethrough: {
      name: "strikethrough",
      action: toggleStrikethrough,
      className: "fa fa-strikethrough",
      title: "Strikethrough"
    },
    heading: {
      name: "heading",
      action: toggleHeadingSmaller,
      className: "fa fa-header fa-heading",
      title: "Heading",
      default: true
    },
    "heading-smaller": {
      name: "heading-smaller",
      action: toggleHeadingSmaller,
      className: "fa fa-header fa-heading header-smaller",
      title: "Smaller Heading"
    },
    "heading-bigger": {
      name: "heading-bigger",
      action: toggleHeadingBigger,
      className: "fa fa-header fa-heading header-bigger",
      title: "Bigger Heading"
    },
    "heading-1": {
      name: "heading-1",
      action: toggleHeading1,
      className: "fa fa-header fa-heading header-1",
      title: "Big Heading"
    },
    "heading-2": {
      name: "heading-2",
      action: toggleHeading2,
      className: "fa fa-header fa-heading header-2",
      title: "Medium Heading"
    },
    "heading-3": {
      name: "heading-3",
      action: toggleHeading3,
      className: "fa fa-header fa-heading header-3",
      title: "Small Heading"
    },
    "separator-1": {
      name: "separator-1"
    },
    code: {
      name: "code",
      action: toggleCodeBlock,
      className: "fa fa-code",
      title: "Code"
    },
    quote: {
      name: "quote",
      action: toggleBlockquote,
      className: "fa fa-quote-left",
      title: "Quote",
      default: true
    },
    "unordered-list": {
      name: "unordered-list",
      action: toggleUnorderedList,
      className: "fa fa-list-ul",
      title: "Generic List",
      default: true
    },
    "ordered-list": {
      name: "ordered-list",
      action: toggleOrderedList,
      className: "fa fa-list-ol",
      title: "Numbered List",
      default: true
    },
    "clean-block": {
      name: "clean-block",
      action: cleanBlock,
      className: "fa fa-eraser",
      title: "Clean block"
    },
    "separator-2": {
      name: "separator-2"
    },
    link: {
      name: "link",
      action: drawLink,
      className: "fa fa-link",
      title: "Create Link",
      default: true
    },
    image: {
      name: "image",
      action: drawImage2,
      className: "fa fa-image",
      title: "Insert Image",
      default: true
    },
    "upload-image": {
      name: "upload-image",
      action: drawUploadedImage,
      className: "fa fa-image",
      title: "Import an image"
    },
    table: {
      name: "table",
      action: drawTable,
      className: "fa fa-table",
      title: "Insert Table"
    },
    "horizontal-rule": {
      name: "horizontal-rule",
      action: drawHorizontalRule,
      className: "fa fa-minus",
      title: "Insert Horizontal Line"
    },
    "separator-3": {
      name: "separator-3"
    },
    preview: {
      name: "preview",
      action: togglePreview,
      className: "fa fa-eye",
      noDisable: true,
      title: "Toggle Preview",
      default: true
    },
    "side-by-side": {
      name: "side-by-side",
      action: toggleSideBySide,
      className: "fa fa-columns",
      noDisable: true,
      noMobile: true,
      title: "Toggle Side by Side",
      default: true
    },
    fullscreen: {
      name: "fullscreen",
      action: toggleFullScreen,
      className: "fa fa-arrows-alt",
      noDisable: true,
      noMobile: true,
      title: "Toggle Fullscreen",
      default: true
    },
    "separator-4": {
      name: "separator-4"
    },
    guide: {
      name: "guide",
      action: "https://www.markdownguide.org/basic-syntax/",
      className: "fa fa-question-circle",
      noDisable: true,
      title: "Markdown Guide",
      default: true
    },
    "separator-5": {
      name: "separator-5"
    },
    undo: {
      name: "undo",
      action: undo,
      className: "fa fa-undo",
      noDisable: true,
      title: "Undo"
    },
    redo: {
      name: "redo",
      action: redo,
      className: "fa fa-repeat fa-redo",
      noDisable: true,
      title: "Redo"
    }
  };
  var insertTexts = {
    link: ["[", "](#url#)"],
    image: ["![](", "#url#)"],
    uploadedImage: ["![](#url#)", ""],
    table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n"],
    horizontalRule: ["", "\n\n-----\n\n"]
  };
  var promptTexts = {
    link: "URL for the link:",
    image: "URL of the image:"
  };
  var timeFormat = {
    locale: "en-US",
    format: {
      hour: "2-digit",
      minute: "2-digit"
    }
  };
  var blockStyles = {
    bold: "**",
    code: "```",
    italic: "*"
  };
  var imageTexts = {
    sbInit: "Attach files by drag and dropping or pasting from clipboard.",
    sbOnDragEnter: "Drop image to upload it.",
    sbOnDrop: "Uploading image #images_names#...",
    sbProgress: "Uploading #file_name#: #progress#%",
    sbOnUploaded: "Uploaded #image_name#",
    sizeUnits: " B, KB, MB"
  };
  var errorMessages = {
    noFileGiven: "You must select a file.",
    typeNotAllowed: "This image type is not allowed.",
    fileTooLarge: "Image #image_name# is too big (#image_size#).\nMaximum file size is #image_max_size#.",
    importError: "Something went wrong when uploading the image #image_name#."
  };
  function EasyMDE2(options) {
    options = options || {};
    options.parent = this;
    var autoDownloadFA = true;
    if (options.autoDownloadFontAwesome === false) {
      autoDownloadFA = false;
    }
    if (options.autoDownloadFontAwesome !== true) {
      var styleSheets = document.styleSheets;
      for (var i = 0; i < styleSheets.length; i++) {
        if (!styleSheets[i].href)
          continue;
        if (styleSheets[i].href.indexOf("//maxcdn.bootstrapcdn.com/font-awesome/") > -1) {
          autoDownloadFA = false;
        }
      }
    }
    if (autoDownloadFA) {
      var link = document.createElement("link");
      link.rel = "stylesheet";
      link.href = "https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css";
      document.getElementsByTagName("head")[0].appendChild(link);
    }
    if (options.element) {
      this.element = options.element;
    } else if (options.element === null) {
      console.log("EasyMDE: Error. No element was found.");
      return;
    }
    if (options.toolbar === void 0) {
      options.toolbar = [];
      for (var key in toolbarBuiltInButtons) {
        if (Object.prototype.hasOwnProperty.call(toolbarBuiltInButtons, key)) {
          if (key.indexOf("separator-") != -1) {
            options.toolbar.push("|");
          }
          if (toolbarBuiltInButtons[key].default === true || options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1) {
            options.toolbar.push(key);
          }
        }
      }
    }
    if (!Object.prototype.hasOwnProperty.call(options, "previewClass")) {
      options.previewClass = "editor-preview";
    }
    if (!Object.prototype.hasOwnProperty.call(options, "status")) {
      options.status = ["autosave", "lines", "words", "cursor"];
      if (options.uploadImage) {
        options.status.unshift("upload-image");
      }
    }
    if (!options.previewRender) {
      options.previewRender = function(plainText) {
        return this.parent.markdown(plainText);
      };
    }
    options.parsingConfig = extend2({
      highlightFormatting: true
    }, options.parsingConfig || {});
    options.insertTexts = extend2({}, insertTexts, options.insertTexts || {});
    options.promptTexts = extend2({}, promptTexts, options.promptTexts || {});
    options.blockStyles = extend2({}, blockStyles, options.blockStyles || {});
    if (options.autosave != void 0) {
      options.autosave.timeFormat = extend2({}, timeFormat, options.autosave.timeFormat || {});
    }
    options.shortcuts = extend2({}, shortcuts, options.shortcuts || {});
    options.maxHeight = options.maxHeight || void 0;
    options.direction = options.direction || "ltr";
    if (typeof options.maxHeight !== "undefined") {
      options.minHeight = options.maxHeight;
    } else {
      options.minHeight = options.minHeight || "300px";
    }
    options.errorCallback = options.errorCallback || function(errorMessage) {
      alert(errorMessage);
    };
    options.uploadImage = options.uploadImage || false;
    options.imageMaxSize = options.imageMaxSize || 2097152;
    options.imageAccept = options.imageAccept || "image/png, image/jpeg";
    options.imageTexts = extend2({}, imageTexts, options.imageTexts || {});
    options.errorMessages = extend2({}, errorMessages, options.errorMessages || {});
    if (options.autosave != void 0 && options.autosave.unique_id != void 0 && options.autosave.unique_id != "")
      options.autosave.uniqueId = options.autosave.unique_id;
    if (options.overlayMode && options.overlayMode.combine === void 0) {
      options.overlayMode.combine = true;
    }
    this.options = options;
    this.render();
    if (options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {
      this.value(options.initialValue);
    }
    if (options.uploadImage) {
      var self2 = this;
      this.codemirror.on("dragenter", function(cm, event) {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbOnDragEnter);
        event.stopPropagation();
        event.preventDefault();
      });
      this.codemirror.on("dragend", function(cm, event) {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbInit);
        event.stopPropagation();
        event.preventDefault();
      });
      this.codemirror.on("dragleave", function(cm, event) {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbInit);
        event.stopPropagation();
        event.preventDefault();
      });
      this.codemirror.on("dragover", function(cm, event) {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbOnDragEnter);
        event.stopPropagation();
        event.preventDefault();
      });
      this.codemirror.on("drop", function(cm, event) {
        event.stopPropagation();
        event.preventDefault();
        if (options.imageUploadFunction) {
          self2.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.dataTransfer.files);
        } else {
          self2.uploadImages(event.dataTransfer.files);
        }
      });
      this.codemirror.on("paste", function(cm, event) {
        if (options.imageUploadFunction) {
          self2.uploadImagesUsingCustomFunction(options.imageUploadFunction, event.clipboardData.files);
        } else {
          self2.uploadImages(event.clipboardData.files);
        }
      });
    }
  }
  EasyMDE2.prototype.uploadImages = function(files, onSuccess, onError) {
    if (files.length === 0) {
      return;
    }
    var names = [];
    for (var i = 0; i < files.length; i++) {
      names.push(files[i].name);
      this.uploadImage(files[i], onSuccess, onError);
    }
    this.updateStatusBar("upload-image", this.options.imageTexts.sbOnDrop.replace("#images_names#", names.join(", ")));
  };
  EasyMDE2.prototype.uploadImagesUsingCustomFunction = function(imageUploadFunction, files) {
    if (files.length === 0) {
      return;
    }
    var names = [];
    for (var i = 0; i < files.length; i++) {
      names.push(files[i].name);
      this.uploadImageUsingCustomFunction(imageUploadFunction, files[i]);
    }
    this.updateStatusBar("upload-image", this.options.imageTexts.sbOnDrop.replace("#images_names#", names.join(", ")));
  };
  EasyMDE2.prototype.updateStatusBar = function(itemName, content) {
    if (!this.gui.statusbar) {
      return;
    }
    var matchingClasses = this.gui.statusbar.getElementsByClassName(itemName);
    if (matchingClasses.length === 1) {
      this.gui.statusbar.getElementsByClassName(itemName)[0].textContent = content;
    } else if (matchingClasses.length === 0) {
      console.log("EasyMDE: status bar item " + itemName + " was not found.");
    } else {
      console.log("EasyMDE: Several status bar items named " + itemName + " was found.");
    }
  };
  EasyMDE2.prototype.markdown = function(text2) {
    if (marked) {
      var markedOptions;
      if (this.options && this.options.renderingConfig && this.options.renderingConfig.markedOptions) {
        markedOptions = this.options.renderingConfig.markedOptions;
      } else {
        markedOptions = {};
      }
      if (this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {
        markedOptions.breaks = false;
      } else {
        markedOptions.breaks = true;
      }
      if (this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true) {
        var hljs = this.options.renderingConfig.hljs || window.hljs;
        if (hljs) {
          markedOptions.highlight = function(code, language) {
            if (language && hljs.getLanguage(language)) {
              return hljs.highlight(language, code).value;
            } else {
              return hljs.highlightAuto(code).value;
            }
          };
        }
      }
      marked.setOptions(markedOptions);
      var htmlText = marked.parse(text2);
      if (this.options.renderingConfig && typeof this.options.renderingConfig.sanitizerFunction === "function") {
        htmlText = this.options.renderingConfig.sanitizerFunction.call(this, htmlText);
      }
      htmlText = addAnchorTargetBlank(htmlText);
      htmlText = removeListStyleWhenCheckbox(htmlText);
      return htmlText;
    }
  };
  EasyMDE2.prototype.render = function(el) {
    if (!el) {
      el = this.element || document.getElementsByTagName("textarea")[0];
    }
    if (this._rendered && this._rendered === el) {
      return;
    }
    this.element = el;
    var options = this.options;
    var self2 = this;
    var keyMaps = {};
    for (var key in options.shortcuts) {
      if (options.shortcuts[key] !== null && bindings[key] !== null) {
        (function(key2) {
          keyMaps[fixShortcut(options.shortcuts[key2])] = function() {
            var action = bindings[key2];
            if (typeof action === "function") {
              action(self2);
            } else if (typeof action === "string") {
              window.open(action, "_blank");
            }
          };
        })(key);
      }
    }
    keyMaps["Enter"] = "newlineAndIndentContinueMarkdownList";
    keyMaps["Tab"] = "tabAndIndentMarkdownList";
    keyMaps["Shift-Tab"] = "shiftTabAndUnindentMarkdownList";
    keyMaps["Esc"] = function(cm2) {
      if (cm2.getOption("fullScreen"))
        toggleFullScreen(self2);
    };
    this.documentOnKeyDown = function(e) {
      e = e || window.event;
      if (e.keyCode == 27) {
        if (self2.codemirror.getOption("fullScreen"))
          toggleFullScreen(self2);
      }
    };
    document.addEventListener("keydown", this.documentOnKeyDown, false);
    var mode, backdrop;
    if (options.overlayMode) {
      CodeMirror2.defineMode("overlay-mode", function(config) {
        return CodeMirror2.overlayMode(CodeMirror2.getMode(config, options.spellChecker !== false ? "spell-checker" : "gfm"), options.overlayMode.mode, options.overlayMode.combine);
      });
      mode = "overlay-mode";
      backdrop = options.parsingConfig;
      backdrop.gitHubSpice = false;
    } else {
      mode = options.parsingConfig;
      mode.name = "gfm";
      mode.gitHubSpice = false;
    }
    if (options.spellChecker !== false) {
      mode = "spell-checker";
      backdrop = options.parsingConfig;
      backdrop.name = "gfm";
      backdrop.gitHubSpice = false;
      if (typeof options.spellChecker === "function") {
        options.spellChecker({
          codeMirrorInstance: CodeMirror2
        });
      } else {
        CodeMirrorSpellChecker({
          codeMirrorInstance: CodeMirror2
        });
      }
    }
    function configureMouse(cm2, repeat, event) {
      return {
        addNew: false
      };
    }
    this.codemirror = CodeMirror2.fromTextArea(el, {
      mode,
      backdrop,
      theme: options.theme != void 0 ? options.theme : "easymde",
      tabSize: options.tabSize != void 0 ? options.tabSize : 2,
      indentUnit: options.tabSize != void 0 ? options.tabSize : 2,
      indentWithTabs: options.indentWithTabs === false ? false : true,
      lineNumbers: options.lineNumbers === true ? true : false,
      autofocus: options.autofocus === true ? true : false,
      extraKeys: keyMaps,
      direction: options.direction,
      lineWrapping: options.lineWrapping === false ? false : true,
      allowDropFileTypes: ["text/plain"],
      placeholder: options.placeholder || el.getAttribute("placeholder") || "",
      styleSelectedText: options.styleSelectedText != void 0 ? options.styleSelectedText : !isMobile(),
      scrollbarStyle: options.scrollbarStyle != void 0 ? options.scrollbarStyle : "native",
      configureMouse,
      inputStyle: options.inputStyle != void 0 ? options.inputStyle : isMobile() ? "contenteditable" : "textarea",
      spellcheck: options.nativeSpellcheck != void 0 ? options.nativeSpellcheck : true,
      autoRefresh: options.autoRefresh != void 0 ? options.autoRefresh : false
    });
    this.codemirror.getScrollerElement().style.minHeight = options.minHeight;
    if (typeof options.maxHeight !== "undefined") {
      this.codemirror.getScrollerElement().style.height = options.maxHeight;
    }
    if (options.forceSync === true) {
      var cm = this.codemirror;
      cm.on("change", function() {
        cm.save();
      });
    }
    this.gui = {};
    var easyMDEContainer = document.createElement("div");
    easyMDEContainer.classList.add("EasyMDEContainer");
    var cmWrapper = this.codemirror.getWrapperElement();
    cmWrapper.parentNode.insertBefore(easyMDEContainer, cmWrapper);
    easyMDEContainer.appendChild(cmWrapper);
    if (options.toolbar !== false) {
      this.gui.toolbar = this.createToolbar();
    }
    if (options.status !== false) {
      this.gui.statusbar = this.createStatusbar();
    }
    if (options.autosave != void 0 && options.autosave.enabled === true) {
      this.autosave();
      this.codemirror.on("change", function() {
        clearTimeout(self2._autosave_timeout);
        self2._autosave_timeout = setTimeout(function() {
          self2.autosave();
        }, self2.options.autosave.submit_delay || self2.options.autosave.delay || 1e3);
      });
    }
    function calcHeight(naturalWidth, naturalHeight) {
      var height;
      var viewportWidth = window.getComputedStyle(document.querySelector(".CodeMirror-sizer")).width.replace("px", "");
      if (naturalWidth < viewportWidth) {
        height = naturalHeight + "px";
      } else {
        height = naturalHeight / naturalWidth * 100 + "%";
      }
      return height;
    }
    var _vm = this;
    function assignImageBlockAttributes(parentEl2, img) {
      parentEl2.setAttribute("data-img-src", img.url);
      parentEl2.setAttribute("style", "--bg-image:url(" + img.url + ");--width:" + img.naturalWidth + "px;--height:" + calcHeight(img.naturalWidth, img.naturalHeight));
      _vm.codemirror.setSize();
    }
    function handleImages() {
      if (!options.previewImagesInEditor) {
        return;
      }
      easyMDEContainer.querySelectorAll(".cm-image-marker").forEach(function(e) {
        var parentEl2 = e.parentElement;
        if (!parentEl2.innerText.match(/^!\[.*?\]\(.*\)/g)) {
          return;
        }
        if (!parentEl2.hasAttribute("data-img-src")) {
          var srcAttr = parentEl2.innerText.match("\\((.*)\\)");
          if (!window.EMDEimagesCache) {
            window.EMDEimagesCache = {};
          }
          if (srcAttr && srcAttr.length >= 2) {
            var keySrc = srcAttr[1];
            if (!window.EMDEimagesCache[keySrc]) {
              var img = document.createElement("img");
              img.onload = function() {
                window.EMDEimagesCache[keySrc] = {
                  naturalWidth: img.naturalWidth,
                  naturalHeight: img.naturalHeight,
                  url: keySrc
                };
                assignImageBlockAttributes(parentEl2, window.EMDEimagesCache[keySrc]);
              };
              img.src = keySrc;
            } else {
              assignImageBlockAttributes(parentEl2, window.EMDEimagesCache[keySrc]);
            }
          }
        }
      });
    }
    this.codemirror.on("update", function() {
      handleImages();
    });
    this.gui.sideBySide = this.createSideBySide();
    this._rendered = this.element;
    var temp_cm = this.codemirror;
    setTimeout(function() {
      temp_cm.refresh();
    }.bind(temp_cm), 0);
  };
  EasyMDE2.prototype.cleanup = function() {
    document.removeEventListener("keydown", this.documentOnKeyDown);
  };
  function isLocalStorageAvailable() {
    if (typeof localStorage === "object") {
      try {
        localStorage.setItem("smde_localStorage", 1);
        localStorage.removeItem("smde_localStorage");
      } catch (e) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  EasyMDE2.prototype.autosave = function() {
    if (isLocalStorageAvailable()) {
      var easyMDE = this;
      if (this.options.autosave.uniqueId == void 0 || this.options.autosave.uniqueId == "") {
        console.log("EasyMDE: You must set a uniqueId to use the autosave feature");
        return;
      }
      if (this.options.autosave.binded !== true) {
        if (easyMDE.element.form != null && easyMDE.element.form != void 0) {
          easyMDE.element.form.addEventListener("submit", function() {
            clearTimeout(easyMDE.autosaveTimeoutId);
            easyMDE.autosaveTimeoutId = void 0;
            localStorage.removeItem("smde_" + easyMDE.options.autosave.uniqueId);
          });
        }
        this.options.autosave.binded = true;
      }
      if (this.options.autosave.loaded !== true) {
        if (typeof localStorage.getItem("smde_" + this.options.autosave.uniqueId) == "string" && localStorage.getItem("smde_" + this.options.autosave.uniqueId) != "") {
          this.codemirror.setValue(localStorage.getItem("smde_" + this.options.autosave.uniqueId));
          this.options.autosave.foundSavedValue = true;
        }
        this.options.autosave.loaded = true;
      }
      var value = easyMDE.value();
      if (value !== "") {
        localStorage.setItem("smde_" + this.options.autosave.uniqueId, value);
      } else {
        localStorage.removeItem("smde_" + this.options.autosave.uniqueId);
      }
      var el = document.getElementById("autosaved");
      if (el != null && el != void 0 && el != "") {
        var d = new Date();
        var dd = new Intl.DateTimeFormat([this.options.autosave.timeFormat.locale, "en-US"], this.options.autosave.timeFormat.format).format(d);
        var save2 = this.options.autosave.text == void 0 ? "Autosaved: " : this.options.autosave.text;
        el.innerHTML = save2 + dd;
      }
    } else {
      console.log("EasyMDE: localStorage not available, cannot autosave");
    }
  };
  EasyMDE2.prototype.clearAutosavedValue = function() {
    if (isLocalStorageAvailable()) {
      if (this.options.autosave == void 0 || this.options.autosave.uniqueId == void 0 || this.options.autosave.uniqueId == "") {
        console.log("EasyMDE: You must set a uniqueId to clear the autosave value");
        return;
      }
      localStorage.removeItem("smde_" + this.options.autosave.uniqueId);
    } else {
      console.log("EasyMDE: localStorage not available, cannot autosave");
    }
  };
  EasyMDE2.prototype.openBrowseFileWindow = function(onSuccess, onError) {
    var self2 = this;
    var imageInput = this.gui.toolbar.getElementsByClassName("imageInput")[0];
    imageInput.click();
    function onChange(event) {
      if (self2.options.imageUploadFunction) {
        self2.uploadImagesUsingCustomFunction(self2.options.imageUploadFunction, event.target.files);
      } else {
        self2.uploadImages(event.target.files, onSuccess, onError);
      }
      imageInput.removeEventListener("change", onChange);
    }
    imageInput.addEventListener("change", onChange);
  };
  EasyMDE2.prototype.uploadImage = function(file2, onSuccess, onError) {
    var self2 = this;
    onSuccess = onSuccess || function onSuccess2(imageUrl) {
      afterImageUploaded(self2, imageUrl);
    };
    function onErrorSup(errorMessage) {
      self2.updateStatusBar("upload-image", errorMessage);
      setTimeout(function() {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbInit);
      }, 1e4);
      if (onError && typeof onError === "function") {
        onError(errorMessage);
      }
      self2.options.errorCallback(errorMessage);
    }
    function fillErrorMessage(errorMessage) {
      var units = self2.options.imageTexts.sizeUnits.split(",");
      return errorMessage.replace("#image_name#", file2.name).replace("#image_size#", humanFileSize(file2.size, units)).replace("#image_max_size#", humanFileSize(self2.options.imageMaxSize, units));
    }
    if (file2.size > this.options.imageMaxSize) {
      onErrorSup(fillErrorMessage(this.options.errorMessages.fileTooLarge));
      return;
    }
    var formData = new FormData();
    formData.append("image", file2);
    if (self2.options.imageCSRFToken) {
      formData.append("csrfmiddlewaretoken", self2.options.imageCSRFToken);
    }
    var request = new XMLHttpRequest();
    request.upload.onprogress = function(event) {
      if (event.lengthComputable) {
        var progress = "" + Math.round(event.loaded * 100 / event.total);
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbProgress.replace("#file_name#", file2.name).replace("#progress#", progress));
      }
    };
    request.open("POST", this.options.imageUploadEndpoint);
    request.onload = function() {
      try {
        var response = JSON.parse(this.responseText);
      } catch (error2) {
        console.error("EasyMDE: The server did not return a valid json.");
        onErrorSup(fillErrorMessage(self2.options.errorMessages.importError));
        return;
      }
      if (this.status === 200 && response && !response.error && response.data && response.data.filePath) {
        onSuccess((self2.options.imagePathAbsolute ? "" : window.location.origin + "/") + response.data.filePath);
      } else {
        if (response.error && response.error in self2.options.errorMessages) {
          onErrorSup(fillErrorMessage(self2.options.errorMessages[response.error]));
        } else if (response.error) {
          onErrorSup(fillErrorMessage(response.error));
        } else {
          console.error("EasyMDE: Received an unexpected response after uploading the image." + this.status + " (" + this.statusText + ")");
          onErrorSup(fillErrorMessage(self2.options.errorMessages.importError));
        }
      }
    };
    request.onerror = function(event) {
      console.error("EasyMDE: An unexpected error occurred when trying to upload the image." + event.target.status + " (" + event.target.statusText + ")");
      onErrorSup(self2.options.errorMessages.importError);
    };
    request.send(formData);
  };
  EasyMDE2.prototype.uploadImageUsingCustomFunction = function(imageUploadFunction, file2) {
    var self2 = this;
    function onSuccess(imageUrl) {
      afterImageUploaded(self2, imageUrl);
    }
    function onError(errorMessage) {
      var filledErrorMessage = fillErrorMessage(errorMessage);
      self2.updateStatusBar("upload-image", filledErrorMessage);
      setTimeout(function() {
        self2.updateStatusBar("upload-image", self2.options.imageTexts.sbInit);
      }, 1e4);
      self2.options.errorCallback(filledErrorMessage);
    }
    function fillErrorMessage(errorMessage) {
      var units = self2.options.imageTexts.sizeUnits.split(",");
      return errorMessage.replace("#image_name#", file2.name).replace("#image_size#", humanFileSize(file2.size, units)).replace("#image_max_size#", humanFileSize(self2.options.imageMaxSize, units));
    }
    imageUploadFunction.apply(this, [file2, onSuccess, onError]);
  };
  EasyMDE2.prototype.setPreviewMaxHeight = function() {
    var cm = this.codemirror;
    var wrapper3 = cm.getWrapperElement();
    var preview = wrapper3.nextSibling;
    var paddingTop = parseInt(window.getComputedStyle(wrapper3).paddingTop);
    var borderTopWidth = parseInt(window.getComputedStyle(wrapper3).borderTopWidth);
    var optionsMaxHeight = parseInt(this.options.maxHeight);
    var wrapperMaxHeight = optionsMaxHeight + paddingTop * 2 + borderTopWidth * 2;
    var previewMaxHeight = wrapperMaxHeight.toString() + "px";
    preview.style.height = previewMaxHeight;
  };
  EasyMDE2.prototype.createSideBySide = function() {
    var cm = this.codemirror;
    var wrapper3 = cm.getWrapperElement();
    var preview = wrapper3.nextSibling;
    if (!preview || !/editor-preview-side/.test(preview.className)) {
      preview = document.createElement("div");
      preview.className = "editor-preview-side";
      if (this.options.previewClass) {
        if (Array.isArray(this.options.previewClass)) {
          for (var i = 0; i < this.options.previewClass.length; i++) {
            preview.className += " " + this.options.previewClass[i];
          }
        } else if (typeof this.options.previewClass === "string") {
          preview.className += " " + this.options.previewClass;
        }
      }
      wrapper3.parentNode.insertBefore(preview, wrapper3.nextSibling);
    }
    if (typeof this.options.maxHeight !== "undefined") {
      this.setPreviewMaxHeight();
    }
    if (this.options.syncSideBySidePreviewScroll === false)
      return preview;
    var cScroll = false;
    var pScroll = false;
    cm.on("scroll", function(v) {
      if (cScroll) {
        cScroll = false;
        return;
      }
      pScroll = true;
      var height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;
      var ratio = parseFloat(v.getScrollInfo().top) / height;
      var move = (preview.scrollHeight - preview.clientHeight) * ratio;
      preview.scrollTop = move;
    });
    preview.onscroll = function() {
      if (pScroll) {
        pScroll = false;
        return;
      }
      cScroll = true;
      var height = preview.scrollHeight - preview.clientHeight;
      var ratio = parseFloat(preview.scrollTop) / height;
      var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;
      cm.scrollTo(0, move);
    };
    return preview;
  };
  EasyMDE2.prototype.createToolbar = function(items) {
    items = items || this.options.toolbar;
    if (!items || items.length === 0) {
      return;
    }
    var i;
    for (i = 0; i < items.length; i++) {
      if (toolbarBuiltInButtons[items[i]] != void 0) {
        items[i] = toolbarBuiltInButtons[items[i]];
      }
    }
    var bar = document.createElement("div");
    bar.className = "editor-toolbar";
    var self2 = this;
    var toolbarData = {};
    self2.toolbar = items;
    for (i = 0; i < items.length; i++) {
      if (items[i].name == "guide" && self2.options.toolbarGuideIcon === false)
        continue;
      if (self2.options.hideIcons && self2.options.hideIcons.indexOf(items[i].name) != -1)
        continue;
      if ((items[i].name == "fullscreen" || items[i].name == "side-by-side") && isMobile())
        continue;
      if (items[i] === "|") {
        var nonSeparatorIconsFollow = false;
        for (var x = i + 1; x < items.length; x++) {
          if (items[x] !== "|" && (!self2.options.hideIcons || self2.options.hideIcons.indexOf(items[x].name) == -1)) {
            nonSeparatorIconsFollow = true;
          }
        }
        if (!nonSeparatorIconsFollow)
          continue;
      }
      (function(item2) {
        var el;
        if (item2 === "|") {
          el = createSep();
        } else if (item2.children) {
          el = createToolbarDropdown(item2, self2.options.toolbarTips, self2.options.shortcuts, self2);
        } else {
          el = createToolbarButton(item2, true, self2.options.toolbarTips, self2.options.shortcuts, "button", self2);
        }
        toolbarData[item2.name || item2] = el;
        bar.appendChild(el);
        if (item2.name === "upload-image") {
          var imageInput = document.createElement("input");
          imageInput.className = "imageInput";
          imageInput.type = "file";
          imageInput.multiple = true;
          imageInput.name = "image";
          imageInput.accept = self2.options.imageAccept;
          imageInput.style.display = "none";
          imageInput.style.opacity = 0;
          bar.appendChild(imageInput);
        }
      })(items[i]);
    }
    self2.toolbar_div = bar;
    self2.toolbarElements = toolbarData;
    var cm = this.codemirror;
    cm.on("cursorActivity", function() {
      var stat = getState(cm);
      for (var key in toolbarData) {
        (function(key2) {
          var el = toolbarData[key2];
          if (stat[key2]) {
            el.className += " active";
          } else if (key2 != "fullscreen" && key2 != "side-by-side") {
            el.className = el.className.replace(/\s*active\s*/g, "");
          }
        })(key);
      }
    });
    var cmWrapper = cm.getWrapperElement();
    cmWrapper.parentNode.insertBefore(bar, cmWrapper);
    return bar;
  };
  EasyMDE2.prototype.createStatusbar = function(status) {
    status = status || this.options.status;
    var options = this.options;
    var cm = this.codemirror;
    if (!status || status.length === 0) {
      return;
    }
    var items = [];
    var i, onUpdate, onActivity, defaultValue;
    for (i = 0; i < status.length; i++) {
      onUpdate = void 0;
      onActivity = void 0;
      defaultValue = void 0;
      if (typeof status[i] === "object") {
        items.push({
          className: status[i].className,
          defaultValue: status[i].defaultValue,
          onUpdate: status[i].onUpdate,
          onActivity: status[i].onActivity
        });
      } else {
        var name2 = status[i];
        if (name2 === "words") {
          defaultValue = function(el2) {
            el2.innerHTML = wordCount(cm.getValue());
          };
          onUpdate = function(el2) {
            el2.innerHTML = wordCount(cm.getValue());
          };
        } else if (name2 === "lines") {
          defaultValue = function(el2) {
            el2.innerHTML = cm.lineCount();
          };
          onUpdate = function(el2) {
            el2.innerHTML = cm.lineCount();
          };
        } else if (name2 === "cursor") {
          defaultValue = function(el2) {
            el2.innerHTML = "1:1";
          };
          onActivity = function(el2) {
            var pos = cm.getCursor();
            var posLine = pos.line + 1;
            var posColumn = pos.ch + 1;
            el2.innerHTML = posLine + ":" + posColumn;
          };
        } else if (name2 === "autosave") {
          defaultValue = function(el2) {
            if (options.autosave != void 0 && options.autosave.enabled === true) {
              el2.setAttribute("id", "autosaved");
            }
          };
        } else if (name2 === "upload-image") {
          defaultValue = function(el2) {
            el2.innerHTML = options.imageTexts.sbInit;
          };
        }
        items.push({
          className: name2,
          defaultValue,
          onUpdate,
          onActivity
        });
      }
    }
    var bar = document.createElement("div");
    bar.className = "editor-statusbar";
    for (i = 0; i < items.length; i++) {
      var item2 = items[i];
      var el = document.createElement("span");
      el.className = item2.className;
      if (typeof item2.defaultValue === "function") {
        item2.defaultValue(el);
      }
      if (typeof item2.onUpdate === "function") {
        this.codemirror.on("update", function(el2, item3) {
          return function() {
            item3.onUpdate(el2);
          };
        }(el, item2));
      }
      if (typeof item2.onActivity === "function") {
        this.codemirror.on("cursorActivity", function(el2, item3) {
          return function() {
            item3.onActivity(el2);
          };
        }(el, item2));
      }
      bar.appendChild(el);
    }
    var cmWrapper = this.codemirror.getWrapperElement();
    cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);
    return bar;
  };
  EasyMDE2.prototype.value = function(val) {
    var cm = this.codemirror;
    if (val === void 0) {
      return cm.getValue();
    } else {
      cm.getDoc().setValue(val);
      if (this.isPreviewActive()) {
        var wrapper3 = cm.getWrapperElement();
        var preview = wrapper3.lastChild;
        preview.innerHTML = this.options.previewRender(val, preview);
      }
      return this;
    }
  };
  EasyMDE2.toggleBold = toggleBold;
  EasyMDE2.toggleItalic = toggleItalic;
  EasyMDE2.toggleStrikethrough = toggleStrikethrough;
  EasyMDE2.toggleBlockquote = toggleBlockquote;
  EasyMDE2.toggleHeadingSmaller = toggleHeadingSmaller;
  EasyMDE2.toggleHeadingBigger = toggleHeadingBigger;
  EasyMDE2.toggleHeading1 = toggleHeading1;
  EasyMDE2.toggleHeading2 = toggleHeading2;
  EasyMDE2.toggleHeading3 = toggleHeading3;
  EasyMDE2.toggleCodeBlock = toggleCodeBlock;
  EasyMDE2.toggleUnorderedList = toggleUnorderedList;
  EasyMDE2.toggleOrderedList = toggleOrderedList;
  EasyMDE2.cleanBlock = cleanBlock;
  EasyMDE2.drawLink = drawLink;
  EasyMDE2.drawImage = drawImage2;
  EasyMDE2.drawUploadedImage = drawUploadedImage;
  EasyMDE2.drawTable = drawTable;
  EasyMDE2.drawHorizontalRule = drawHorizontalRule;
  EasyMDE2.undo = undo;
  EasyMDE2.redo = redo;
  EasyMDE2.togglePreview = togglePreview;
  EasyMDE2.toggleSideBySide = toggleSideBySide;
  EasyMDE2.toggleFullScreen = toggleFullScreen;
  EasyMDE2.prototype.toggleBold = function() {
    toggleBold(this);
  };
  EasyMDE2.prototype.toggleItalic = function() {
    toggleItalic(this);
  };
  EasyMDE2.prototype.toggleStrikethrough = function() {
    toggleStrikethrough(this);
  };
  EasyMDE2.prototype.toggleBlockquote = function() {
    toggleBlockquote(this);
  };
  EasyMDE2.prototype.toggleHeadingSmaller = function() {
    toggleHeadingSmaller(this);
  };
  EasyMDE2.prototype.toggleHeadingBigger = function() {
    toggleHeadingBigger(this);
  };
  EasyMDE2.prototype.toggleHeading1 = function() {
    toggleHeading1(this);
  };
  EasyMDE2.prototype.toggleHeading2 = function() {
    toggleHeading2(this);
  };
  EasyMDE2.prototype.toggleHeading3 = function() {
    toggleHeading3(this);
  };
  EasyMDE2.prototype.toggleCodeBlock = function() {
    toggleCodeBlock(this);
  };
  EasyMDE2.prototype.toggleUnorderedList = function() {
    toggleUnorderedList(this);
  };
  EasyMDE2.prototype.toggleOrderedList = function() {
    toggleOrderedList(this);
  };
  EasyMDE2.prototype.cleanBlock = function() {
    cleanBlock(this);
  };
  EasyMDE2.prototype.drawLink = function() {
    drawLink(this);
  };
  EasyMDE2.prototype.drawImage = function() {
    drawImage2(this);
  };
  EasyMDE2.prototype.drawUploadedImage = function() {
    drawUploadedImage(this);
  };
  EasyMDE2.prototype.drawTable = function() {
    drawTable(this);
  };
  EasyMDE2.prototype.drawHorizontalRule = function() {
    drawHorizontalRule(this);
  };
  EasyMDE2.prototype.undo = function() {
    undo(this);
  };
  EasyMDE2.prototype.redo = function() {
    redo(this);
  };
  EasyMDE2.prototype.togglePreview = function() {
    togglePreview(this);
  };
  EasyMDE2.prototype.toggleSideBySide = function() {
    toggleSideBySide(this);
  };
  EasyMDE2.prototype.toggleFullScreen = function() {
    toggleFullScreen(this);
  };
  EasyMDE2.prototype.isPreviewActive = function() {
    var cm = this.codemirror;
    var wrapper3 = cm.getWrapperElement();
    var preview = wrapper3.lastChild;
    return /editor-preview-active/.test(preview.className);
  };
  EasyMDE2.prototype.isSideBySideActive = function() {
    var cm = this.codemirror;
    var wrapper3 = cm.getWrapperElement();
    var preview = wrapper3.nextSibling;
    return /editor-preview-active-side/.test(preview.className);
  };
  EasyMDE2.prototype.isFullscreenActive = function() {
    var cm = this.codemirror;
    return cm.getOption("fullScreen");
  };
  EasyMDE2.prototype.getState = function() {
    var cm = this.codemirror;
    return getState(cm);
  };
  EasyMDE2.prototype.toTextArea = function() {
    var cm = this.codemirror;
    var wrapper3 = cm.getWrapperElement();
    var easyMDEContainer = wrapper3.parentNode;
    if (easyMDEContainer) {
      if (this.gui.toolbar) {
        easyMDEContainer.removeChild(this.gui.toolbar);
      }
      if (this.gui.statusbar) {
        easyMDEContainer.removeChild(this.gui.statusbar);
      }
      if (this.gui.sideBySide) {
        easyMDEContainer.removeChild(this.gui.sideBySide);
      }
    }
    easyMDEContainer.parentNode.insertBefore(wrapper3, easyMDEContainer);
    easyMDEContainer.remove();
    cm.toTextArea();
    if (this.autosaveTimeoutId) {
      clearTimeout(this.autosaveTimeoutId);
      this.autosaveTimeoutId = void 0;
      this.clearAutosavedValue();
    }
  };
  module.exports = EasyMDE2;
});

// node_modules/trix/dist/trix.js
var require_trix = __commonJS((exports, module) => {
  (function() {
  }).call(exports), function() {
    var t;
    window.Set == null && (window.Set = t = function() {
      function t2() {
        this.clear();
      }
      return t2.prototype.clear = function() {
        return this.values = [];
      }, t2.prototype.has = function(t3) {
        return this.values.indexOf(t3) !== -1;
      }, t2.prototype.add = function(t3) {
        return this.has(t3) || this.values.push(t3), this;
      }, t2.prototype["delete"] = function(t3) {
        var e;
        return (e = this.values.indexOf(t3)) === -1 ? false : (this.values.splice(e, 1), true);
      }, t2.prototype.forEach = function() {
        var t3;
        return (t3 = this.values).forEach.apply(t3, arguments);
      }, t2;
    }());
  }.call(exports), function(t) {
    function e() {
    }
    function n(t2, e2) {
      return function() {
        t2.apply(e2, arguments);
      };
    }
    function i(t2) {
      if (typeof this != "object")
        throw new TypeError("Promises must be constructed via new");
      if (typeof t2 != "function")
        throw new TypeError("not a function");
      this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], c(t2, this);
    }
    function o(t2, e2) {
      for (; t2._state === 3; )
        t2 = t2._value;
      return t2._state === 0 ? void t2._deferreds.push(e2) : (t2._handled = true, void h(function() {
        var n2 = t2._state === 1 ? e2.onFulfilled : e2.onRejected;
        if (n2 === null)
          return void (t2._state === 1 ? r : s)(e2.promise, t2._value);
        var i2;
        try {
          i2 = n2(t2._value);
        } catch (o2) {
          return void s(e2.promise, o2);
        }
        r(e2.promise, i2);
      }));
    }
    function r(t2, e2) {
      try {
        if (e2 === t2)
          throw new TypeError("A promise cannot be resolved with itself.");
        if (e2 && (typeof e2 == "object" || typeof e2 == "function")) {
          var o2 = e2.then;
          if (e2 instanceof i)
            return t2._state = 3, t2._value = e2, void a(t2);
          if (typeof o2 == "function")
            return void c(n(o2, e2), t2);
        }
        t2._state = 1, t2._value = e2, a(t2);
      } catch (r2) {
        s(t2, r2);
      }
    }
    function s(t2, e2) {
      t2._state = 2, t2._value = e2, a(t2);
    }
    function a(t2) {
      t2._state === 2 && t2._deferreds.length === 0 && setTimeout(function() {
        t2._handled || p(t2._value);
      }, 1);
      for (var e2 = 0, n2 = t2._deferreds.length; n2 > e2; e2++)
        o(t2, t2._deferreds[e2]);
      t2._deferreds = null;
    }
    function u(t2, e2, n2) {
      this.onFulfilled = typeof t2 == "function" ? t2 : null, this.onRejected = typeof e2 == "function" ? e2 : null, this.promise = n2;
    }
    function c(t2, e2) {
      var n2 = false;
      try {
        t2(function(t3) {
          n2 || (n2 = true, r(e2, t3));
        }, function(t3) {
          n2 || (n2 = true, s(e2, t3));
        });
      } catch (i2) {
        if (n2)
          return;
        n2 = true, s(e2, i2);
      }
    }
    var l = setTimeout, h = typeof setImmediate == "function" && setImmediate || function(t2) {
      l(t2, 1);
    }, p = function(t2) {
      typeof console != "undefined" && console && console.warn("Possible Unhandled Promise Rejection:", t2);
    };
    i.prototype["catch"] = function(t2) {
      return this.then(null, t2);
    }, i.prototype.then = function(t2, n2) {
      var r2 = new i(e);
      return o(this, new u(t2, n2, r2)), r2;
    }, i.all = function(t2) {
      var e2 = Array.prototype.slice.call(t2);
      return new i(function(t3, n2) {
        function i2(r3, s2) {
          try {
            if (s2 && (typeof s2 == "object" || typeof s2 == "function")) {
              var a2 = s2.then;
              if (typeof a2 == "function")
                return void a2.call(s2, function(t4) {
                  i2(r3, t4);
                }, n2);
            }
            e2[r3] = s2, --o2 === 0 && t3(e2);
          } catch (u2) {
            n2(u2);
          }
        }
        if (e2.length === 0)
          return t3([]);
        for (var o2 = e2.length, r2 = 0; r2 < e2.length; r2++)
          i2(r2, e2[r2]);
      });
    }, i.resolve = function(t2) {
      return t2 && typeof t2 == "object" && t2.constructor === i ? t2 : new i(function(e2) {
        e2(t2);
      });
    }, i.reject = function(t2) {
      return new i(function(e2, n2) {
        n2(t2);
      });
    }, i.race = function(t2) {
      return new i(function(e2, n2) {
        for (var i2 = 0, o2 = t2.length; o2 > i2; i2++)
          t2[i2].then(e2, n2);
      });
    }, i._setImmediateFn = function(t2) {
      h = t2;
    }, i._setUnhandledRejectionFn = function(t2) {
      p = t2;
    }, typeof module != "undefined" && module.exports ? module.exports = i : t.Promise || (t.Promise = i);
  }(exports), function() {
    var t = typeof window.customElements == "object", e = typeof document.registerElement == "function", n = t || e;
    n || (typeof WeakMap == "undefined" && !function() {
      var t2 = Object.defineProperty, e2 = Date.now() % 1e9, n2 = function() {
        this.name = "__st" + (1e9 * Math.random() >>> 0) + (e2++ + "__");
      };
      n2.prototype = {set: function(e3, n3) {
        var i = e3[this.name];
        return i && i[0] === e3 ? i[1] = n3 : t2(e3, this.name, {value: [e3, n3], writable: true}), this;
      }, get: function(t3) {
        var e3;
        return (e3 = t3[this.name]) && e3[0] === t3 ? e3[1] : void 0;
      }, delete: function(t3) {
        var e3 = t3[this.name];
        return e3 && e3[0] === t3 ? (e3[0] = e3[1] = void 0, true) : false;
      }, has: function(t3) {
        var e3 = t3[this.name];
        return e3 ? e3[0] === t3 : false;
      }}, window.WeakMap = n2;
    }(), function(t2) {
      function e2(t3) {
        A.push(t3), b || (b = true, g(i));
      }
      function n2(t3) {
        return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(t3) || t3;
      }
      function i() {
        b = false;
        var t3 = A;
        A = [], t3.sort(function(t4, e4) {
          return t4.uid_ - e4.uid_;
        });
        var e3 = false;
        t3.forEach(function(t4) {
          var n3 = t4.takeRecords();
          o(t4), n3.length && (t4.callback_(n3, t4), e3 = true);
        }), e3 && i();
      }
      function o(t3) {
        t3.nodes_.forEach(function(e3) {
          var n3 = m.get(e3);
          n3 && n3.forEach(function(e4) {
            e4.observer === t3 && e4.removeTransientObservers();
          });
        });
      }
      function r(t3, e3) {
        for (var n3 = t3; n3; n3 = n3.parentNode) {
          var i2 = m.get(n3);
          if (i2)
            for (var o2 = 0; o2 < i2.length; o2++) {
              var r2 = i2[o2], s2 = r2.options;
              if (n3 === t3 || s2.subtree) {
                var a2 = e3(s2);
                a2 && r2.enqueue(a2);
              }
            }
        }
      }
      function s(t3) {
        this.callback_ = t3, this.nodes_ = [], this.records_ = [], this.uid_ = ++C3;
      }
      function a(t3, e3) {
        this.type = t3, this.target = e3, this.addedNodes = [], this.removedNodes = [], this.previousSibling = null, this.nextSibling = null, this.attributeName = null, this.attributeNamespace = null, this.oldValue = null;
      }
      function u(t3) {
        var e3 = new a(t3.type, t3.target);
        return e3.addedNodes = t3.addedNodes.slice(), e3.removedNodes = t3.removedNodes.slice(), e3.previousSibling = t3.previousSibling, e3.nextSibling = t3.nextSibling, e3.attributeName = t3.attributeName, e3.attributeNamespace = t3.attributeNamespace, e3.oldValue = t3.oldValue, e3;
      }
      function c(t3, e3) {
        return x = new a(t3, e3);
      }
      function l(t3) {
        return w ? w : (w = u(x), w.oldValue = t3, w);
      }
      function h() {
        x = w = void 0;
      }
      function p(t3) {
        return t3 === w || t3 === x;
      }
      function d(t3, e3) {
        return t3 === e3 ? t3 : w && p(t3) ? w : null;
      }
      function f(t3, e3, n3) {
        this.observer = t3, this.target = e3, this.options = n3, this.transientObservedNodes = [];
      }
      if (!t2.JsMutationObserver) {
        var g, m = new WeakMap();
        if (/Trident|Edge/.test(navigator.userAgent))
          g = setTimeout;
        else if (window.setImmediate)
          g = window.setImmediate;
        else {
          var v = [], y = String(Math.random());
          window.addEventListener("message", function(t3) {
            if (t3.data === y) {
              var e3 = v;
              v = [], e3.forEach(function(t4) {
                t4();
              });
            }
          }), g = function(t3) {
            v.push(t3), window.postMessage(y, "*");
          };
        }
        var b = false, A = [], C3 = 0;
        s.prototype = {observe: function(t3, e3) {
          if (t3 = n2(t3), !e3.childList && !e3.attributes && !e3.characterData || e3.attributeOldValue && !e3.attributes || e3.attributeFilter && e3.attributeFilter.length && !e3.attributes || e3.characterDataOldValue && !e3.characterData)
            throw new SyntaxError();
          var i2 = m.get(t3);
          i2 || m.set(t3, i2 = []);
          for (var o2, r2 = 0; r2 < i2.length; r2++)
            if (i2[r2].observer === this) {
              o2 = i2[r2], o2.removeListeners(), o2.options = e3;
              break;
            }
          o2 || (o2 = new f(this, t3, e3), i2.push(o2), this.nodes_.push(t3)), o2.addListeners();
        }, disconnect: function() {
          this.nodes_.forEach(function(t3) {
            for (var e3 = m.get(t3), n3 = 0; n3 < e3.length; n3++) {
              var i2 = e3[n3];
              if (i2.observer === this) {
                i2.removeListeners(), e3.splice(n3, 1);
                break;
              }
            }
          }, this), this.records_ = [];
        }, takeRecords: function() {
          var t3 = this.records_;
          return this.records_ = [], t3;
        }};
        var x, w;
        f.prototype = {enqueue: function(t3) {
          var n3 = this.observer.records_, i2 = n3.length;
          if (n3.length > 0) {
            var o2 = n3[i2 - 1], r2 = d(o2, t3);
            if (r2)
              return void (n3[i2 - 1] = r2);
          } else
            e2(this.observer);
          n3[i2] = t3;
        }, addListeners: function() {
          this.addListeners_(this.target);
        }, addListeners_: function(t3) {
          var e3 = this.options;
          e3.attributes && t3.addEventListener("DOMAttrModified", this, true), e3.characterData && t3.addEventListener("DOMCharacterDataModified", this, true), e3.childList && t3.addEventListener("DOMNodeInserted", this, true), (e3.childList || e3.subtree) && t3.addEventListener("DOMNodeRemoved", this, true);
        }, removeListeners: function() {
          this.removeListeners_(this.target);
        }, removeListeners_: function(t3) {
          var e3 = this.options;
          e3.attributes && t3.removeEventListener("DOMAttrModified", this, true), e3.characterData && t3.removeEventListener("DOMCharacterDataModified", this, true), e3.childList && t3.removeEventListener("DOMNodeInserted", this, true), (e3.childList || e3.subtree) && t3.removeEventListener("DOMNodeRemoved", this, true);
        }, addTransientObserver: function(t3) {
          if (t3 !== this.target) {
            this.addListeners_(t3), this.transientObservedNodes.push(t3);
            var e3 = m.get(t3);
            e3 || m.set(t3, e3 = []), e3.push(this);
          }
        }, removeTransientObservers: function() {
          var t3 = this.transientObservedNodes;
          this.transientObservedNodes = [], t3.forEach(function(t4) {
            this.removeListeners_(t4);
            for (var e3 = m.get(t4), n3 = 0; n3 < e3.length; n3++)
              if (e3[n3] === this) {
                e3.splice(n3, 1);
                break;
              }
          }, this);
        }, handleEvent: function(t3) {
          switch (t3.stopImmediatePropagation(), t3.type) {
            case "DOMAttrModified":
              var e3 = t3.attrName, n3 = t3.relatedNode.namespaceURI, i2 = t3.target, o2 = new c("attributes", i2);
              o2.attributeName = e3, o2.attributeNamespace = n3;
              var s2 = t3.attrChange === MutationEvent.ADDITION ? null : t3.prevValue;
              r(i2, function(t4) {
                return !t4.attributes || t4.attributeFilter && t4.attributeFilter.length && t4.attributeFilter.indexOf(e3) === -1 && t4.attributeFilter.indexOf(n3) === -1 ? void 0 : t4.attributeOldValue ? l(s2) : o2;
              });
              break;
            case "DOMCharacterDataModified":
              var i2 = t3.target, o2 = c("characterData", i2), s2 = t3.prevValue;
              r(i2, function(t4) {
                return t4.characterData ? t4.characterDataOldValue ? l(s2) : o2 : void 0;
              });
              break;
            case "DOMNodeRemoved":
              this.addTransientObserver(t3.target);
            case "DOMNodeInserted":
              var a2, u2, p2 = t3.target;
              t3.type === "DOMNodeInserted" ? (a2 = [p2], u2 = []) : (a2 = [], u2 = [p2]);
              var d2 = p2.previousSibling, f2 = p2.nextSibling, o2 = c("childList", t3.target.parentNode);
              o2.addedNodes = a2, o2.removedNodes = u2, o2.previousSibling = d2, o2.nextSibling = f2, r(t3.relatedNode, function(t4) {
                return t4.childList ? o2 : void 0;
              });
          }
          h();
        }}, t2.JsMutationObserver = s, t2.MutationObserver || (t2.MutationObserver = s, s._isPolyfilled = true);
      }
    }(self), function() {
      "use strict";
      if (!window.performance || !window.performance.now) {
        var t2 = Date.now();
        window.performance = {now: function() {
          return Date.now() - t2;
        }};
      }
      window.requestAnimationFrame || (window.requestAnimationFrame = function() {
        var t3 = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
        return t3 ? function(e3) {
          return t3(function() {
            e3(performance.now());
          });
        } : function(t4) {
          return window.setTimeout(t4, 1e3 / 60);
        };
      }()), window.cancelAnimationFrame || (window.cancelAnimationFrame = function() {
        return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(t3) {
          clearTimeout(t3);
        };
      }());
      var e2 = function() {
        var t3 = document.createEvent("Event");
        return t3.initEvent("foo", true, true), t3.preventDefault(), t3.defaultPrevented;
      }();
      if (!e2) {
        var n2 = Event.prototype.preventDefault;
        Event.prototype.preventDefault = function() {
          this.cancelable && (n2.call(this), Object.defineProperty(this, "defaultPrevented", {get: function() {
            return true;
          }, configurable: true}));
        };
      }
      var i = /Trident/.test(navigator.userAgent);
      if ((!window.CustomEvent || i && typeof window.CustomEvent != "function") && (window.CustomEvent = function(t3, e3) {
        e3 = e3 || {};
        var n3 = document.createEvent("CustomEvent");
        return n3.initCustomEvent(t3, Boolean(e3.bubbles), Boolean(e3.cancelable), e3.detail), n3;
      }, window.CustomEvent.prototype = window.Event.prototype), !window.Event || i && typeof window.Event != "function") {
        var o = window.Event;
        window.Event = function(t3, e3) {
          e3 = e3 || {};
          var n3 = document.createEvent("Event");
          return n3.initEvent(t3, Boolean(e3.bubbles), Boolean(e3.cancelable)), n3;
        }, window.Event.prototype = o.prototype;
      }
    }(window.WebComponents), window.CustomElements = window.CustomElements || {flags: {}}, function(t2) {
      var e2 = t2.flags, n2 = [], i = function(t3) {
        n2.push(t3);
      }, o = function() {
        n2.forEach(function(e3) {
          e3(t2);
        });
      };
      t2.addModule = i, t2.initializeModules = o, t2.hasNative = Boolean(document.registerElement), t2.isIE = /Trident/.test(navigator.userAgent), t2.useNative = !e2.register && t2.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);
    }(window.CustomElements), window.CustomElements.addModule(function(t2) {
      function e2(t3, e3) {
        n2(t3, function(t4) {
          return e3(t4) ? true : void i(t4, e3);
        }), i(t3, e3);
      }
      function n2(t3, e3, i2) {
        var o2 = t3.firstElementChild;
        if (!o2)
          for (o2 = t3.firstChild; o2 && o2.nodeType !== Node.ELEMENT_NODE; )
            o2 = o2.nextSibling;
        for (; o2; )
          e3(o2, i2) !== true && n2(o2, e3, i2), o2 = o2.nextElementSibling;
        return null;
      }
      function i(t3, n3) {
        for (var i2 = t3.shadowRoot; i2; )
          e2(i2, n3), i2 = i2.olderShadowRoot;
      }
      function o(t3, e3) {
        r(t3, e3, []);
      }
      function r(t3, e3, n3) {
        if (t3 = window.wrap(t3), !(n3.indexOf(t3) >= 0)) {
          n3.push(t3);
          for (var i2, o2 = t3.querySelectorAll("link[rel=" + s + "]"), a = 0, u = o2.length; u > a && (i2 = o2[a]); a++)
            i2.import && r(i2.import, e3, n3);
          e3(t3);
        }
      }
      var s = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : "none";
      t2.forDocumentTree = o, t2.forSubtree = e2;
    }), window.CustomElements.addModule(function(t2) {
      function e2(t3, e3) {
        return n2(t3, e3) || i(t3, e3);
      }
      function n2(e3, n3) {
        return t2.upgrade(e3, n3) ? true : void (n3 && s(e3));
      }
      function i(t3, e3) {
        b(t3, function(t4) {
          return n2(t4, e3) ? true : void 0;
        });
      }
      function o(t3) {
        w.push(t3), x || (x = true, setTimeout(r));
      }
      function r() {
        x = false;
        for (var t3, e3 = w, n3 = 0, i2 = e3.length; i2 > n3 && (t3 = e3[n3]); n3++)
          t3();
        w = [];
      }
      function s(t3) {
        C3 ? o(function() {
          a(t3);
        }) : a(t3);
      }
      function a(t3) {
        t3.__upgraded__ && !t3.__attached && (t3.__attached = true, t3.attachedCallback && t3.attachedCallback());
      }
      function u(t3) {
        c(t3), b(t3, function(t4) {
          c(t4);
        });
      }
      function c(t3) {
        C3 ? o(function() {
          l(t3);
        }) : l(t3);
      }
      function l(t3) {
        t3.__upgraded__ && t3.__attached && (t3.__attached = false, t3.detachedCallback && t3.detachedCallback());
      }
      function h(t3) {
        for (var e3 = t3, n3 = window.wrap(document); e3; ) {
          if (e3 == n3)
            return true;
          e3 = e3.parentNode || e3.nodeType === Node.DOCUMENT_FRAGMENT_NODE && e3.host;
        }
      }
      function p(t3) {
        if (t3.shadowRoot && !t3.shadowRoot.__watched) {
          y.dom && console.log("watching shadow-root for: ", t3.localName);
          for (var e3 = t3.shadowRoot; e3; )
            g(e3), e3 = e3.olderShadowRoot;
        }
      }
      function d(t3, n3) {
        if (y.dom) {
          var i2 = n3[0];
          if (i2 && i2.type === "childList" && i2.addedNodes && i2.addedNodes) {
            for (var o2 = i2.addedNodes[0]; o2 && o2 !== document && !o2.host; )
              o2 = o2.parentNode;
            var r2 = o2 && (o2.URL || o2._URL || o2.host && o2.host.localName) || "";
            r2 = r2.split("/?").shift().split("/").pop();
          }
          console.group("mutations (%d) [%s]", n3.length, r2 || "");
        }
        var s2 = h(t3);
        n3.forEach(function(t4) {
          t4.type === "childList" && (E(t4.addedNodes, function(t5) {
            t5.localName && e2(t5, s2);
          }), E(t4.removedNodes, function(t5) {
            t5.localName && u(t5);
          }));
        }), y.dom && console.groupEnd();
      }
      function f(t3) {
        for (t3 = window.wrap(t3), t3 || (t3 = window.wrap(document)); t3.parentNode; )
          t3 = t3.parentNode;
        var e3 = t3.__observer;
        e3 && (d(t3, e3.takeRecords()), r());
      }
      function g(t3) {
        if (!t3.__observer) {
          var e3 = new MutationObserver(d.bind(this, t3));
          e3.observe(t3, {childList: true, subtree: true}), t3.__observer = e3;
        }
      }
      function m(t3) {
        t3 = window.wrap(t3), y.dom && console.group("upgradeDocument: ", t3.baseURI.split("/").pop());
        var n3 = t3 === window.wrap(document);
        e2(t3, n3), g(t3), y.dom && console.groupEnd();
      }
      function v(t3) {
        A(t3, m);
      }
      var y = t2.flags, b = t2.forSubtree, A = t2.forDocumentTree, C3 = window.MutationObserver._isPolyfilled && y["throttle-attached"];
      t2.hasPolyfillMutations = C3, t2.hasThrottledAttached = C3;
      var x = false, w = [], E = Array.prototype.forEach.call.bind(Array.prototype.forEach), S2 = Element.prototype.createShadowRoot;
      S2 && (Element.prototype.createShadowRoot = function() {
        var t3 = S2.call(this);
        return window.CustomElements.watchShadow(this), t3;
      }), t2.watchShadow = p, t2.upgradeDocumentTree = v, t2.upgradeDocument = m, t2.upgradeSubtree = i, t2.upgradeAll = e2, t2.attached = s, t2.takeRecords = f;
    }), window.CustomElements.addModule(function(t2) {
      function e2(e3, i2) {
        if (e3.localName === "template" && window.HTMLTemplateElement && HTMLTemplateElement.decorate && HTMLTemplateElement.decorate(e3), !e3.__upgraded__ && e3.nodeType === Node.ELEMENT_NODE) {
          var o2 = e3.getAttribute("is"), r2 = t2.getRegisteredDefinition(e3.localName) || t2.getRegisteredDefinition(o2);
          if (r2 && (o2 && r2.tag == e3.localName || !o2 && !r2.extends))
            return n2(e3, r2, i2);
        }
      }
      function n2(e3, n3, o2) {
        return s.upgrade && console.group("upgrade:", e3.localName), n3.is && e3.setAttribute("is", n3.is), i(e3, n3), e3.__upgraded__ = true, r(e3), o2 && t2.attached(e3), t2.upgradeSubtree(e3, o2), s.upgrade && console.groupEnd(), e3;
      }
      function i(t3, e3) {
        Object.__proto__ ? t3.__proto__ = e3.prototype : (o(t3, e3.prototype, e3.native), t3.__proto__ = e3.prototype);
      }
      function o(t3, e3, n3) {
        for (var i2 = {}, o2 = e3; o2 !== n3 && o2 !== HTMLElement.prototype; ) {
          for (var r2, s2 = Object.getOwnPropertyNames(o2), a = 0; r2 = s2[a]; a++)
            i2[r2] || (Object.defineProperty(t3, r2, Object.getOwnPropertyDescriptor(o2, r2)), i2[r2] = 1);
          o2 = Object.getPrototypeOf(o2);
        }
      }
      function r(t3) {
        t3.createdCallback && t3.createdCallback();
      }
      var s = t2.flags;
      t2.upgrade = e2, t2.upgradeWithDefinition = n2, t2.implementPrototype = i;
    }), window.CustomElements.addModule(function(t2) {
      function e2(e3, i2) {
        var u2 = i2 || {};
        if (!e3)
          throw new Error("document.registerElement: first argument `name` must not be empty");
        if (e3.indexOf("-") < 0)
          throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(e3) + "'.");
        if (o(e3))
          throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(e3) + "'. The type name is invalid.");
        if (c(e3))
          throw new Error("DuplicateDefinitionError: a type with name '" + String(e3) + "' is already registered");
        return u2.prototype || (u2.prototype = Object.create(HTMLElement.prototype)), u2.__name = e3.toLowerCase(), u2.extends && (u2.extends = u2.extends.toLowerCase()), u2.lifecycle = u2.lifecycle || {}, u2.ancestry = r(u2.extends), s(u2), a(u2), n2(u2.prototype), l(u2.__name, u2), u2.ctor = h(u2), u2.ctor.prototype = u2.prototype, u2.prototype.constructor = u2.ctor, t2.ready && m(document), u2.ctor;
      }
      function n2(t3) {
        if (!t3.setAttribute._polyfilled) {
          var e3 = t3.setAttribute;
          t3.setAttribute = function(t4, n4) {
            i.call(this, t4, n4, e3);
          };
          var n3 = t3.removeAttribute;
          t3.removeAttribute = function(t4) {
            i.call(this, t4, null, n3);
          }, t3.setAttribute._polyfilled = true;
        }
      }
      function i(t3, e3, n3) {
        t3 = t3.toLowerCase();
        var i2 = this.getAttribute(t3);
        n3.apply(this, arguments);
        var o2 = this.getAttribute(t3);
        this.attributeChangedCallback && o2 !== i2 && this.attributeChangedCallback(t3, i2, o2);
      }
      function o(t3) {
        for (var e3 = 0; e3 < C3.length; e3++)
          if (t3 === C3[e3])
            return true;
      }
      function r(t3) {
        var e3 = c(t3);
        return e3 ? r(e3.extends).concat([e3]) : [];
      }
      function s(t3) {
        for (var e3, n3 = t3.extends, i2 = 0; e3 = t3.ancestry[i2]; i2++)
          n3 = e3.is && e3.tag;
        t3.tag = n3 || t3.__name, n3 && (t3.is = t3.__name);
      }
      function a(t3) {
        if (!Object.__proto__) {
          var e3 = HTMLElement.prototype;
          if (t3.is) {
            var n3 = document.createElement(t3.tag);
            e3 = Object.getPrototypeOf(n3);
          }
          for (var i2, o2 = t3.prototype, r2 = false; o2; )
            o2 == e3 && (r2 = true), i2 = Object.getPrototypeOf(o2), i2 && (o2.__proto__ = i2), o2 = i2;
          r2 || console.warn(t3.tag + " prototype not found in prototype chain for " + t3.is), t3.native = e3;
        }
      }
      function u(t3) {
        return y(E(t3.tag), t3);
      }
      function c(t3) {
        return t3 ? x[t3.toLowerCase()] : void 0;
      }
      function l(t3, e3) {
        x[t3] = e3;
      }
      function h(t3) {
        return function() {
          return u(t3);
        };
      }
      function p(t3, e3, n3) {
        return t3 === w ? d(e3, n3) : S2(t3, e3);
      }
      function d(t3, e3) {
        t3 && (t3 = t3.toLowerCase()), e3 && (e3 = e3.toLowerCase());
        var n3 = c(e3 || t3);
        if (n3) {
          if (t3 == n3.tag && e3 == n3.is)
            return new n3.ctor();
          if (!e3 && !n3.is)
            return new n3.ctor();
        }
        var i2;
        return e3 ? (i2 = d(t3), i2.setAttribute("is", e3), i2) : (i2 = E(t3), t3.indexOf("-") >= 0 && b(i2, HTMLElement), i2);
      }
      function f(t3, e3) {
        var n3 = t3[e3];
        t3[e3] = function() {
          var t4 = n3.apply(this, arguments);
          return v(t4), t4;
        };
      }
      var g, m = (t2.isIE, t2.upgradeDocumentTree), v = t2.upgradeAll, y = t2.upgradeWithDefinition, b = t2.implementPrototype, A = t2.useNative, C3 = ["annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph"], x = {}, w = "http://www.w3.org/1999/xhtml", E = document.createElement.bind(document), S2 = document.createElementNS.bind(document);
      g = Object.__proto__ || A ? function(t3, e3) {
        return t3 instanceof e3;
      } : function(t3, e3) {
        if (t3 instanceof e3)
          return true;
        for (var n3 = t3; n3; ) {
          if (n3 === e3.prototype)
            return true;
          n3 = n3.__proto__;
        }
        return false;
      }, f(Node.prototype, "cloneNode"), f(document, "importNode"), document.registerElement = e2, document.createElement = d, document.createElementNS = p, t2.registry = x, t2.instanceof = g, t2.reservedTagList = C3, t2.getRegisteredDefinition = c, document.register = document.registerElement;
    }), function(t2) {
      function e2() {
        r(window.wrap(document)), window.CustomElements.ready = true;
        var t3 = window.requestAnimationFrame || function(t4) {
          setTimeout(t4, 16);
        };
        t3(function() {
          setTimeout(function() {
            window.CustomElements.readyTime = Date.now(), window.HTMLImports && (window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime), document.dispatchEvent(new CustomEvent("WebComponentsReady", {bubbles: true}));
          });
        });
      }
      var n2 = t2.useNative, i = t2.initializeModules;
      if (t2.isIE, n2) {
        var o = function() {
        };
        t2.watchShadow = o, t2.upgrade = o, t2.upgradeAll = o, t2.upgradeDocumentTree = o, t2.upgradeSubtree = o, t2.takeRecords = o, t2.instanceof = function(t3, e3) {
          return t3 instanceof e3;
        };
      } else
        i();
      var r = t2.upgradeDocumentTree, s = t2.upgradeDocument;
      if (window.wrap || (window.ShadowDOMPolyfill ? (window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded, window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded) : window.wrap = window.unwrap = function(t3) {
        return t3;
      }), window.HTMLImports && (window.HTMLImports.__importsParsingHook = function(t3) {
        t3.import && s(wrap(t3.import));
      }), document.readyState === "complete" || t2.flags.eager)
        e2();
      else if (document.readyState !== "interactive" || window.attachEvent || window.HTMLImports && !window.HTMLImports.ready) {
        var a = window.HTMLImports && !window.HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
        window.addEventListener(a, e2);
      } else
        e2();
    }(window.CustomElements));
  }.call(exports), function() {
  }.call(exports), function() {
    var t = this;
    (function() {
      (function() {
        this.Trix = {VERSION: "1.3.1", ZERO_WIDTH_SPACE: "\uFEFF", NON_BREAKING_SPACE: "\xA0", OBJECT_REPLACEMENT_CHARACTER: "\uFFFC", browser: {composesExistingText: /Android.*Chrome/.test(navigator.userAgent), forcesObjectResizing: /Trident.*rv:11/.test(navigator.userAgent), supportsInputEvents: function() {
          var t2, e2, n, i;
          if (typeof InputEvent == "undefined")
            return false;
          for (i = ["data", "getTargetRanges", "inputType"], t2 = 0, e2 = i.length; e2 > t2; t2++)
            if (n = i[t2], !(n in InputEvent.prototype))
              return false;
          return true;
        }()}, config: {}};
      }).call(this);
    }).call(t);
    var e = t.Trix;
    (function() {
      (function() {
        e.BasicObject = function() {
          function t2() {
          }
          var e2, n, i;
          return t2.proxyMethod = function(t3) {
            var i2, o, r, s, a;
            return r = n(t3), i2 = r.name, s = r.toMethod, a = r.toProperty, o = r.optional, this.prototype[i2] = function() {
              var t4, n2;
              return t4 = s != null ? o ? typeof this[s] == "function" ? this[s]() : void 0 : this[s]() : a != null ? this[a] : void 0, o ? (n2 = t4 != null ? t4[i2] : void 0, n2 != null ? e2.call(n2, t4, arguments) : void 0) : (n2 = t4[i2], e2.call(n2, t4, arguments));
            };
          }, n = function(t3) {
            var e3, n2;
            if (!(n2 = t3.match(i)))
              throw new Error("can't parse @proxyMethod expression: " + t3);
            return e3 = {name: n2[4]}, n2[2] != null ? e3.toMethod = n2[1] : e3.toProperty = n2[1], n2[3] != null && (e3.optional = true), e3;
          }, e2 = Function.prototype.apply, i = /^(.+?)(\(\))?(\?)?\.(.+?)$/, t2;
        }();
      }).call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.Object = function(n2) {
          function i() {
            this.id = ++o;
          }
          var o;
          return t2(i, n2), o = 0, i.fromJSONString = function(t3) {
            return this.fromJSON(JSON.parse(t3));
          }, i.prototype.hasSameConstructorAs = function(t3) {
            return this.constructor === (t3 != null ? t3.constructor : void 0);
          }, i.prototype.isEqualTo = function(t3) {
            return this === t3;
          }, i.prototype.inspect = function() {
            var t3, e2, n3;
            return t3 = function() {
              var t4, i2, o2;
              i2 = (t4 = this.contentsForInspection()) != null ? t4 : {}, o2 = [];
              for (e2 in i2)
                n3 = i2[e2], o2.push(e2 + "=" + n3);
              return o2;
            }.call(this), "#<" + this.constructor.name + ":" + this.id + (t3.length ? " " + t3.join(", ") : "") + ">";
          }, i.prototype.contentsForInspection = function() {
          }, i.prototype.toJSONString = function() {
            return JSON.stringify(this);
          }, i.prototype.toUTF16String = function() {
            return e.UTF16String.box(this);
          }, i.prototype.getCacheKey = function() {
            return this.id.toString();
          }, i;
        }(e.BasicObject);
      }.call(this), function() {
        e.extend = function(t2) {
          var e2, n;
          for (e2 in t2)
            n = t2[e2], this[e2] = n;
          return this;
        };
      }.call(this), function() {
        e.extend({defer: function(t2) {
          return setTimeout(t2, 1);
        }});
      }.call(this), function() {
        var t2, n;
        e.extend({normalizeSpaces: function(t3) {
          return t3.replace(RegExp("" + e.ZERO_WIDTH_SPACE, "g"), "").replace(RegExp("" + e.NON_BREAKING_SPACE, "g"), " ");
        }, normalizeNewlines: function(t3) {
          return t3.replace(/\r\n/g, "\n");
        }, breakableWhitespacePattern: RegExp("[^\\S" + e.NON_BREAKING_SPACE + "]"), squishBreakableWhitespace: function(t3) {
          return t3.replace(RegExp("" + e.breakableWhitespacePattern.source, "g"), " ").replace(/\ {2,}/g, " ");
        }, summarizeStringChange: function(t3, i) {
          var o, r, s, a;
          return t3 = e.UTF16String.box(t3), i = e.UTF16String.box(i), i.length < t3.length ? (r = n(t3, i), a = r[0], o = r[1]) : (s = n(i, t3), o = s[0], a = s[1]), {added: o, removed: a};
        }}), n = function(n2, i) {
          var o, r, s, a, u;
          return n2.isEqualTo(i) ? ["", ""] : (r = t2(n2, i), a = r.utf16String.length, s = a ? (u = r.offset, r, o = n2.codepoints.slice(0, u).concat(n2.codepoints.slice(u + a)), t2(i, e.UTF16String.fromCodepoints(o))) : t2(i, n2), [r.utf16String.toString(), s.utf16String.toString()]);
        }, t2 = function(t3, e2) {
          var n2, i, o;
          for (n2 = 0, i = t3.length, o = e2.length; i > n2 && t3.charAt(n2).isEqualTo(e2.charAt(n2)); )
            n2++;
          for (; i > n2 + 1 && t3.charAt(i - 1).isEqualTo(e2.charAt(o - 1)); )
            i--, o--;
          return {utf16String: t3.slice(n2, i), offset: n2};
        };
      }.call(this), function() {
        e.extend({copyObject: function(t2) {
          var e2, n, i;
          t2 == null && (t2 = {}), n = {};
          for (e2 in t2)
            i = t2[e2], n[e2] = i;
          return n;
        }, objectsAreEqual: function(t2, e2) {
          var n, i;
          if (t2 == null && (t2 = {}), e2 == null && (e2 = {}), Object.keys(t2).length !== Object.keys(e2).length)
            return false;
          for (n in t2)
            if (i = t2[n], i !== e2[n])
              return false;
          return true;
        }});
      }.call(this), function() {
        var t2 = [].slice;
        e.extend({arraysAreEqual: function(t3, e2) {
          var n, i, o, r;
          if (t3 == null && (t3 = []), e2 == null && (e2 = []), t3.length !== e2.length)
            return false;
          for (i = n = 0, o = t3.length; o > n; i = ++n)
            if (r = t3[i], r !== e2[i])
              return false;
          return true;
        }, arrayStartsWith: function(t3, n) {
          return t3 == null && (t3 = []), n == null && (n = []), e.arraysAreEqual(t3.slice(0, n.length), n);
        }, spliceArray: function() {
          var e2, n, i;
          return n = arguments[0], e2 = 2 <= arguments.length ? t2.call(arguments, 1) : [], i = n.slice(0), i.splice.apply(i, e2), i;
        }, summarizeArrayChange: function(t3, e2) {
          var n, i, o, r, s, a, u, c, l, h, p;
          for (t3 == null && (t3 = []), e2 == null && (e2 = []), n = [], h = [], o = new Set(), r = 0, u = t3.length; u > r; r++)
            p = t3[r], o.add(p);
          for (i = new Set(), s = 0, c = e2.length; c > s; s++)
            p = e2[s], i.add(p), o.has(p) || n.push(p);
          for (a = 0, l = t3.length; l > a; a++)
            p = t3[a], i.has(p) || h.push(p);
          return {added: n, removed: h};
        }});
      }.call(this), function() {
        var t2, n, i, o;
        t2 = null, n = null, o = null, i = null, e.extend({getAllAttributeNames: function() {
          return t2 != null ? t2 : t2 = e.getTextAttributeNames().concat(e.getBlockAttributeNames());
        }, getBlockConfig: function(t3) {
          return e.config.blockAttributes[t3];
        }, getBlockAttributeNames: function() {
          return n != null ? n : n = Object.keys(e.config.blockAttributes);
        }, getTextConfig: function(t3) {
          return e.config.textAttributes[t3];
        }, getTextAttributeNames: function() {
          return o != null ? o : o = Object.keys(e.config.textAttributes);
        }, getListAttributeNames: function() {
          var t3, n2;
          return i != null ? i : i = function() {
            var i2, o2;
            i2 = e.config.blockAttributes, o2 = [];
            for (t3 in i2)
              n2 = i2[t3].listAttribute, n2 != null && o2.push(n2);
            return o2;
          }();
        }});
      }.call(this), function() {
        var t2, n, i, o, r, s = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        };
        t2 = document.documentElement, n = (i = (o = (r = t2.matchesSelector) != null ? r : t2.webkitMatchesSelector) != null ? o : t2.msMatchesSelector) != null ? i : t2.mozMatchesSelector, e.extend({handleEvent: function(n2, i2) {
          var o2, r2, s2, a, u, c, l, h, p, d, f, g;
          return h = i2 != null ? i2 : {}, c = h.onElement, u = h.matchingSelector, g = h.withCallback, a = h.inPhase, l = h.preventDefault, d = h.times, r2 = c != null ? c : t2, p = u, o2 = g, f = a === "capturing", s2 = function(t3) {
            var n3;
            return d != null && --d === 0 && s2.destroy(), n3 = e.findClosestElementFromNode(t3.target, {matchingSelector: p}), n3 != null && (g != null && g.call(n3, t3, n3), l) ? t3.preventDefault() : void 0;
          }, s2.destroy = function() {
            return r2.removeEventListener(n2, s2, f);
          }, r2.addEventListener(n2, s2, f), s2;
        }, handleEventOnce: function(t3, n2) {
          return n2 == null && (n2 = {}), n2.times = 1, e.handleEvent(t3, n2);
        }, triggerEvent: function(n2, i2) {
          var o2, r2, s2, a, u, c, l;
          return l = i2 != null ? i2 : {}, c = l.onElement, r2 = l.bubbles, s2 = l.cancelable, o2 = l.attributes, a = c != null ? c : t2, r2 = r2 !== false, s2 = s2 !== false, u = document.createEvent("Events"), u.initEvent(n2, r2, s2), o2 != null && e.extend.call(u, o2), a.dispatchEvent(u);
        }, elementMatchesSelector: function(t3, e2) {
          return (t3 != null ? t3.nodeType : void 0) === 1 ? n.call(t3, e2) : void 0;
        }, findClosestElementFromNode: function(t3, n2) {
          var i2, o2, r2;
          for (o2 = n2 != null ? n2 : {}, i2 = o2.matchingSelector, r2 = o2.untilNode; t3 != null && t3.nodeType !== Node.ELEMENT_NODE; )
            t3 = t3.parentNode;
          if (t3 != null) {
            if (i2 == null)
              return t3;
            if (t3.closest && r2 == null)
              return t3.closest(i2);
            for (; t3 && t3 !== r2; ) {
              if (e.elementMatchesSelector(t3, i2))
                return t3;
              t3 = t3.parentNode;
            }
          }
        }, findInnerElement: function(t3) {
          for (; t3 != null ? t3.firstElementChild : void 0; )
            t3 = t3.firstElementChild;
          return t3;
        }, innerElementIsActive: function(t3) {
          return document.activeElement !== t3 && e.elementContainsNode(t3, document.activeElement);
        }, elementContainsNode: function(t3, e2) {
          if (t3 && e2)
            for (; e2; ) {
              if (e2 === t3)
                return true;
              e2 = e2.parentNode;
            }
        }, findNodeFromContainerAndOffset: function(t3, e2) {
          var n2;
          if (t3)
            return t3.nodeType === Node.TEXT_NODE ? t3 : e2 === 0 ? (n2 = t3.firstChild) != null ? n2 : t3 : t3.childNodes.item(e2 - 1);
        }, findElementFromContainerAndOffset: function(t3, n2) {
          var i2;
          return i2 = e.findNodeFromContainerAndOffset(t3, n2), e.findClosestElementFromNode(i2);
        }, findChildIndexOfNode: function(t3) {
          var e2;
          if (t3 != null ? t3.parentNode : void 0) {
            for (e2 = 0; t3 = t3.previousSibling; )
              e2++;
            return e2;
          }
        }, removeNode: function(t3) {
          var e2;
          return t3 != null && (e2 = t3.parentNode) != null ? e2.removeChild(t3) : void 0;
        }, walkTree: function(t3, e2) {
          var n2, i2, o2, r2, s2;
          return o2 = e2 != null ? e2 : {}, i2 = o2.onlyNodesOfType, r2 = o2.usingFilter, n2 = o2.expandEntityReferences, s2 = function() {
            switch (i2) {
              case "element":
                return NodeFilter.SHOW_ELEMENT;
              case "text":
                return NodeFilter.SHOW_TEXT;
              case "comment":
                return NodeFilter.SHOW_COMMENT;
              default:
                return NodeFilter.SHOW_ALL;
            }
          }(), document.createTreeWalker(t3, s2, r2 != null ? r2 : null, n2 === true);
        }, tagName: function(t3) {
          var e2;
          return t3 != null && (e2 = t3.tagName) != null ? e2.toLowerCase() : void 0;
        }, makeElement: function(t3, e2) {
          var n2, i2, o2, r2, s2, a, u, c, l, h, p, d, f, g;
          if (e2 == null && (e2 = {}), typeof t3 == "object" ? (e2 = t3, t3 = e2.tagName) : e2 = {attributes: e2}, o2 = document.createElement(t3), e2.editable != null && (e2.attributes == null && (e2.attributes = {}), e2.attributes.contenteditable = e2.editable), e2.attributes) {
            l = e2.attributes;
            for (a in l)
              g = l[a], o2.setAttribute(a, g);
          }
          if (e2.style) {
            h = e2.style;
            for (a in h)
              g = h[a], o2.style[a] = g;
          }
          if (e2.data) {
            p = e2.data;
            for (a in p)
              g = p[a], o2.dataset[a] = g;
          }
          if (e2.className)
            for (d = e2.className.split(" "), r2 = 0, u = d.length; u > r2; r2++)
              i2 = d[r2], o2.classList.add(i2);
          if (e2.textContent && (o2.textContent = e2.textContent), e2.childNodes)
            for (f = [].concat(e2.childNodes), s2 = 0, c = f.length; c > s2; s2++)
              n2 = f[s2], o2.appendChild(n2);
          return o2;
        }, getBlockTagNames: function() {
          var t3, n2;
          return e.blockTagNames != null ? e.blockTagNames : e.blockTagNames = function() {
            var i2, o2;
            i2 = e.config.blockAttributes, o2 = [];
            for (t3 in i2)
              n2 = i2[t3].tagName, n2 && o2.push(n2);
            return o2;
          }();
        }, nodeIsBlockContainer: function(t3) {
          return e.nodeIsBlockStartComment(t3 != null ? t3.firstChild : void 0);
        }, nodeProbablyIsBlockContainer: function(t3) {
          var n2, i2;
          return n2 = e.tagName(t3), s.call(e.getBlockTagNames(), n2) >= 0 && (i2 = e.tagName(t3.firstChild), s.call(e.getBlockTagNames(), i2) < 0);
        }, nodeIsBlockStart: function(t3, n2) {
          var i2;
          return i2 = (n2 != null ? n2 : {strict: true}).strict, i2 ? e.nodeIsBlockStartComment(t3) : e.nodeIsBlockStartComment(t3) || !e.nodeIsBlockStartComment(t3.firstChild) && e.nodeProbablyIsBlockContainer(t3);
        }, nodeIsBlockStartComment: function(t3) {
          return e.nodeIsCommentNode(t3) && (t3 != null ? t3.data : void 0) === "block";
        }, nodeIsCommentNode: function(t3) {
          return (t3 != null ? t3.nodeType : void 0) === Node.COMMENT_NODE;
        }, nodeIsCursorTarget: function(t3, n2) {
          var i2;
          return i2 = (n2 != null ? n2 : {}).name, t3 ? e.nodeIsTextNode(t3) ? t3.data === e.ZERO_WIDTH_SPACE ? i2 ? t3.parentNode.dataset.trixCursorTarget === i2 : true : void 0 : e.nodeIsCursorTarget(t3.firstChild) : void 0;
        }, nodeIsAttachmentElement: function(t3) {
          return e.elementMatchesSelector(t3, e.AttachmentView.attachmentSelector);
        }, nodeIsEmptyTextNode: function(t3) {
          return e.nodeIsTextNode(t3) && (t3 != null ? t3.data : void 0) === "";
        }, nodeIsTextNode: function(t3) {
          return (t3 != null ? t3.nodeType : void 0) === Node.TEXT_NODE;
        }});
      }.call(this), function() {
        var t2, n, i, o, r;
        t2 = e.copyObject, o = e.objectsAreEqual, e.extend({normalizeRange: i = function(t3) {
          var e2;
          if (t3 != null)
            return Array.isArray(t3) || (t3 = [t3, t3]), [n(t3[0]), n((e2 = t3[1]) != null ? e2 : t3[0])];
        }, rangeIsCollapsed: function(t3) {
          var e2, n2, o2;
          if (t3 != null)
            return n2 = i(t3), o2 = n2[0], e2 = n2[1], r(o2, e2);
        }, rangesAreEqual: function(t3, e2) {
          var n2, o2, s, a, u, c;
          if (t3 != null && e2 != null)
            return s = i(t3), o2 = s[0], n2 = s[1], a = i(e2), c = a[0], u = a[1], r(o2, c) && r(n2, u);
        }}), n = function(e2) {
          return typeof e2 == "number" ? e2 : t2(e2);
        }, r = function(t3, e2) {
          return typeof t3 == "number" ? t3 === e2 : o(t3, e2);
        };
      }.call(this), function() {
        var t2, n, i, o, r, s, a;
        e.registerElement = function(t3, e2) {
          var n2, i2;
          return e2 == null && (e2 = {}), t3 = t3.toLowerCase(), e2 = a(e2), i2 = s(e2), (n2 = i2.defaultCSS) && (delete i2.defaultCSS, o(n2, t3)), r(t3, i2);
        }, o = function(t3, e2) {
          var n2;
          return n2 = i(e2), n2.textContent = t3.replace(/%t/g, e2);
        }, i = function(e2) {
          var n2, i2;
          return n2 = document.createElement("style"), n2.setAttribute("type", "text/css"), n2.setAttribute("data-tag-name", e2.toLowerCase()), (i2 = t2()) && n2.setAttribute("nonce", i2), document.head.insertBefore(n2, document.head.firstChild), n2;
        }, t2 = function() {
          var t3;
          return (t3 = n("trix-csp-nonce") || n("csp-nonce")) ? t3.getAttribute("content") : void 0;
        }, n = function(t3) {
          return document.head.querySelector("meta[name=" + t3 + "]");
        }, s = function(t3) {
          var e2, n2, i2;
          n2 = {};
          for (e2 in t3)
            i2 = t3[e2], n2[e2] = typeof i2 == "function" ? {value: i2} : i2;
          return n2;
        }, a = function() {
          var t3;
          return t3 = function(t4) {
            var e2, n2, i2, o2, r2;
            for (e2 = {}, r2 = ["initialize", "connect", "disconnect"], n2 = 0, o2 = r2.length; o2 > n2; n2++)
              i2 = r2[n2], e2[i2] = t4[i2], delete t4[i2];
            return e2;
          }, window.customElements ? function(e2) {
            var n2, i2, o2, r2, s2;
            return s2 = t3(e2), o2 = s2.initialize, n2 = s2.connect, i2 = s2.disconnect, o2 && (r2 = n2, n2 = function() {
              return this.initialized || (this.initialized = true, o2.call(this)), r2 != null ? r2.call(this) : void 0;
            }), n2 && (e2.connectedCallback = n2), i2 && (e2.disconnectedCallback = i2), e2;
          } : function(e2) {
            var n2, i2, o2, r2;
            return r2 = t3(e2), o2 = r2.initialize, n2 = r2.connect, i2 = r2.disconnect, o2 && (e2.createdCallback = o2), n2 && (e2.attachedCallback = n2), i2 && (e2.detachedCallback = i2), e2;
          };
        }(), r = function() {
          return window.customElements ? function(t3, e2) {
            var n2;
            return n2 = function() {
              return typeof Reflect == "object" ? Reflect.construct(HTMLElement, [], n2) : HTMLElement.apply(this);
            }, Object.setPrototypeOf(n2.prototype, HTMLElement.prototype), Object.setPrototypeOf(n2, HTMLElement), Object.defineProperties(n2.prototype, e2), window.customElements.define(t3, n2), n2;
          } : function(t3, e2) {
            var n2, i2;
            return i2 = Object.create(HTMLElement.prototype, e2), n2 = document.registerElement(t3, {prototype: i2}), Object.defineProperty(i2, "constructor", {value: n2}), n2;
          };
        }();
      }.call(this), function() {
        var t2, n;
        e.extend({getDOMSelection: function() {
          var t3;
          return t3 = window.getSelection(), t3.rangeCount > 0 ? t3 : void 0;
        }, getDOMRange: function() {
          var n2, i;
          return (n2 = (i = e.getDOMSelection()) != null ? i.getRangeAt(0) : void 0) && !t2(n2) ? n2 : void 0;
        }, setDOMRange: function(t3) {
          var n2;
          return n2 = window.getSelection(), n2.removeAllRanges(), n2.addRange(t3), e.selectionChangeObserver.update();
        }}), t2 = function(t3) {
          return n(t3.startContainer) || n(t3.endContainer);
        }, n = function(t3) {
          return !Object.getPrototypeOf(t3);
        };
      }.call(this), function() {
        var t2;
        t2 = {"application/x-trix-feature-detection": "test"}, e.extend({dataTransferIsPlainText: function(t3) {
          var e2, n, i;
          return i = t3.getData("text/plain"), n = t3.getData("text/html"), i && n ? (e2 = new DOMParser().parseFromString(n, "text/html").body, e2.textContent === i ? !e2.querySelector("*") : void 0) : i != null ? i.length : void 0;
        }, dataTransferIsWritable: function(e2) {
          var n, i;
          if ((e2 != null ? e2.setData : void 0) != null) {
            for (n in t2)
              if (i = t2[n], !function() {
                try {
                  return e2.setData(n, i), e2.getData(n) === i;
                } catch (t3) {
                }
              }())
                return;
            return true;
          }
        }, keyEventIsKeyboardCommand: function() {
          return /Mac|^iP/.test(navigator.platform) ? function(t3) {
            return t3.metaKey;
          } : function(t3) {
            return t3.ctrlKey;
          };
        }()});
      }.call(this), function() {
        e.extend({RTL_PATTERN: /[\u05BE\u05C0\u05C3\u05D0-\u05EA\u05F0-\u05F4\u061B\u061F\u0621-\u063A\u0640-\u064A\u066D\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D5\u06E5\u06E6\u200F\u202B\u202E\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE72\uFE74\uFE76-\uFEFC]/, getDirection: function() {
          var t2, n, i, o;
          return n = e.makeElement("input", {dir: "auto", name: "x", dirName: "x.dir"}), t2 = e.makeElement("form"), t2.appendChild(n), i = function() {
            try {
              return new FormData(t2).has(n.dirName);
            } catch (e2) {
            }
          }(), o = function() {
            try {
              return n.matches(":dir(ltr),:dir(rtl)");
            } catch (t3) {
            }
          }(), i ? function(e2) {
            return n.value = e2, new FormData(t2).get(n.dirName);
          } : o ? function(t3) {
            return n.value = t3, n.matches(":dir(rtl)") ? "rtl" : "ltr";
          } : function(t3) {
            var n2;
            return n2 = t3.trim().charAt(0), e.RTL_PATTERN.test(n2) ? "rtl" : "ltr";
          };
        }()});
      }.call(this), function() {
      }.call(this), function() {
        var t2, n = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var o in e2)
            i.call(e2, o) && (t3[o] = e2[o]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, i = {}.hasOwnProperty;
        t2 = e.arraysAreEqual, e.Hash = function(i2) {
          function o(t3) {
            t3 == null && (t3 = {}), this.values = s(t3), o.__super__.constructor.apply(this, arguments);
          }
          var r, s, a, u, c;
          return n(o, i2), o.fromCommonAttributesOfObjects = function(t3) {
            var e2, n2, i3, o2, s2, a2;
            if (t3 == null && (t3 = []), !t3.length)
              return new this();
            for (e2 = r(t3[0]), i3 = e2.getKeys(), a2 = t3.slice(1), n2 = 0, o2 = a2.length; o2 > n2; n2++)
              s2 = a2[n2], i3 = e2.getKeysCommonToHash(r(s2)), e2 = e2.slice(i3);
            return e2;
          }, o.box = function(t3) {
            return r(t3);
          }, o.prototype.add = function(t3, e2) {
            return this.merge(u(t3, e2));
          }, o.prototype.remove = function(t3) {
            return new e.Hash(s(this.values, t3));
          }, o.prototype.get = function(t3) {
            return this.values[t3];
          }, o.prototype.has = function(t3) {
            return t3 in this.values;
          }, o.prototype.merge = function(t3) {
            return new e.Hash(a(this.values, c(t3)));
          }, o.prototype.slice = function(t3) {
            var n2, i3, o2, r2;
            for (r2 = {}, n2 = 0, o2 = t3.length; o2 > n2; n2++)
              i3 = t3[n2], this.has(i3) && (r2[i3] = this.values[i3]);
            return new e.Hash(r2);
          }, o.prototype.getKeys = function() {
            return Object.keys(this.values);
          }, o.prototype.getKeysCommonToHash = function(t3) {
            var e2, n2, i3, o2, s2;
            for (t3 = r(t3), o2 = this.getKeys(), s2 = [], e2 = 0, i3 = o2.length; i3 > e2; e2++)
              n2 = o2[e2], this.values[n2] === t3.values[n2] && s2.push(n2);
            return s2;
          }, o.prototype.isEqualTo = function(e2) {
            return t2(this.toArray(), r(e2).toArray());
          }, o.prototype.isEmpty = function() {
            return this.getKeys().length === 0;
          }, o.prototype.toArray = function() {
            var t3, e2, n2;
            return (this.array != null ? this.array : this.array = function() {
              var i3;
              e2 = [], i3 = this.values;
              for (t3 in i3)
                n2 = i3[t3], e2.push(t3, n2);
              return e2;
            }.call(this)).slice(0);
          }, o.prototype.toObject = function() {
            return s(this.values);
          }, o.prototype.toJSON = function() {
            return this.toObject();
          }, o.prototype.contentsForInspection = function() {
            return {values: JSON.stringify(this.values)};
          }, u = function(t3, e2) {
            var n2;
            return n2 = {}, n2[t3] = e2, n2;
          }, a = function(t3, e2) {
            var n2, i3, o2;
            i3 = s(t3);
            for (n2 in e2)
              o2 = e2[n2], i3[n2] = o2;
            return i3;
          }, s = function(t3, e2) {
            var n2, i3, o2, r2, s2;
            for (r2 = {}, s2 = Object.keys(t3).sort(), n2 = 0, o2 = s2.length; o2 > n2; n2++)
              i3 = s2[n2], i3 !== e2 && (r2[i3] = t3[i3]);
            return r2;
          }, r = function(t3) {
            return t3 instanceof e.Hash ? t3 : new e.Hash(t3);
          }, c = function(t3) {
            return t3 instanceof e.Hash ? t3.values : t3;
          }, o;
        }(e.Object);
      }.call(this), function() {
        e.ObjectGroup = function() {
          function t2(t3, e2) {
            var n, i;
            this.objects = t3 != null ? t3 : [], i = e2.depth, n = e2.asTree, n && (this.depth = i, this.objects = this.constructor.groupObjects(this.objects, {asTree: n, depth: this.depth + 1}));
          }
          return t2.groupObjects = function(t3, e2) {
            var n, i, o, r, s, a, u, c, l;
            for (t3 == null && (t3 = []), l = e2 != null ? e2 : {}, o = l.depth, n = l.asTree, n && o == null && (o = 0), c = [], s = 0, a = t3.length; a > s; s++) {
              if (u = t3[s], r) {
                if ((typeof u.canBeGrouped == "function" ? u.canBeGrouped(o) : void 0) && (typeof (i = r[r.length - 1]).canBeGroupedWith == "function" ? i.canBeGroupedWith(u, o) : void 0)) {
                  r.push(u);
                  continue;
                }
                c.push(new this(r, {depth: o, asTree: n})), r = null;
              }
              (typeof u.canBeGrouped == "function" ? u.canBeGrouped(o) : void 0) ? r = [u] : c.push(u);
            }
            return r && c.push(new this(r, {depth: o, asTree: n})), c;
          }, t2.prototype.getObjects = function() {
            return this.objects;
          }, t2.prototype.getDepth = function() {
            return this.depth;
          }, t2.prototype.getCacheKey = function() {
            var t3, e2, n, i, o;
            for (e2 = ["objectGroup"], o = this.getObjects(), t3 = 0, n = o.length; n > t3; t3++)
              i = o[t3], e2.push(i.getCacheKey());
            return e2.join("/");
          }, t2;
        }();
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.ObjectMap = function(e2) {
          function n2(t3) {
            var e3, n3, i, o, r;
            for (t3 == null && (t3 = []), this.objects = {}, i = 0, o = t3.length; o > i; i++)
              r = t3[i], n3 = JSON.stringify(r), (e3 = this.objects)[n3] == null && (e3[n3] = r);
          }
          return t2(n2, e2), n2.prototype.find = function(t3) {
            var e3;
            return e3 = JSON.stringify(t3), this.objects[e3];
          }, n2;
        }(e.BasicObject);
      }.call(this), function() {
        e.ElementStore = function() {
          function t2(t3) {
            this.reset(t3);
          }
          var e2;
          return t2.prototype.add = function(t3) {
            var n;
            return n = e2(t3), this.elements[n] = t3;
          }, t2.prototype.remove = function(t3) {
            var n, i;
            return n = e2(t3), (i = this.elements[n]) ? (delete this.elements[n], i) : void 0;
          }, t2.prototype.reset = function(t3) {
            var e3, n, i;
            for (t3 == null && (t3 = []), this.elements = {}, n = 0, i = t3.length; i > n; n++)
              e3 = t3[n], this.add(e3);
            return t3;
          }, e2 = function(t3) {
            return t3.dataset.trixStoreKey;
          }, t2;
        }();
      }.call(this), function() {
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.Operation = function(e2) {
          function n2() {
            return n2.__super__.constructor.apply(this, arguments);
          }
          return t2(n2, e2), n2.prototype.isPerforming = function() {
            return this.performing === true;
          }, n2.prototype.hasPerformed = function() {
            return this.performed === true;
          }, n2.prototype.hasSucceeded = function() {
            return this.performed && this.succeeded;
          }, n2.prototype.hasFailed = function() {
            return this.performed && !this.succeeded;
          }, n2.prototype.getPromise = function() {
            return this.promise != null ? this.promise : this.promise = new Promise(function(t3) {
              return function(e3, n3) {
                return t3.performing = true, t3.perform(function(i, o) {
                  return t3.succeeded = i, t3.performing = false, t3.performed = true, t3.succeeded ? e3(o) : n3(o);
                });
              };
            }(this));
          }, n2.prototype.perform = function(t3) {
            return t3(false);
          }, n2.prototype.release = function() {
            var t3;
            return (t3 = this.promise) != null && typeof t3.cancel == "function" && t3.cancel(), this.promise = null, this.performing = null, this.performed = null, this.succeeded = null;
          }, n2.proxyMethod("getPromise().then"), n2.proxyMethod("getPromise().catch"), n2;
        }(e.BasicObject);
      }.call(this), function() {
        var t2, n, i, o, r, s = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            a.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, a = {}.hasOwnProperty;
        e.UTF16String = function(t3) {
          function e2(t4, e3) {
            this.ucs2String = t4, this.codepoints = e3, this.length = this.codepoints.length, this.ucs2Length = this.ucs2String.length;
          }
          return s(e2, t3), e2.box = function(t4) {
            return t4 == null && (t4 = ""), t4 instanceof this ? t4 : this.fromUCS2String(t4 != null ? t4.toString() : void 0);
          }, e2.fromUCS2String = function(t4) {
            return new this(t4, o(t4));
          }, e2.fromCodepoints = function(t4) {
            return new this(r(t4), t4);
          }, e2.prototype.offsetToUCS2Offset = function(t4) {
            return r(this.codepoints.slice(0, Math.max(0, t4))).length;
          }, e2.prototype.offsetFromUCS2Offset = function(t4) {
            return o(this.ucs2String.slice(0, Math.max(0, t4))).length;
          }, e2.prototype.slice = function() {
            var t4;
            return this.constructor.fromCodepoints((t4 = this.codepoints).slice.apply(t4, arguments));
          }, e2.prototype.charAt = function(t4) {
            return this.slice(t4, t4 + 1);
          }, e2.prototype.isEqualTo = function(t4) {
            return this.constructor.box(t4).ucs2String === this.ucs2String;
          }, e2.prototype.toJSON = function() {
            return this.ucs2String;
          }, e2.prototype.getCacheKey = function() {
            return this.ucs2String;
          }, e2.prototype.toString = function() {
            return this.ucs2String;
          }, e2;
        }(e.BasicObject), t2 = (typeof Array.from == "function" ? Array.from("\u{1F47C}").length : void 0) === 1, n = (typeof " ".codePointAt == "function" ? " ".codePointAt(0) : void 0) != null, i = (typeof String.fromCodePoint == "function" ? String.fromCodePoint(32, 128124) : void 0) === " \u{1F47C}", o = t2 && n ? function(t3) {
          return Array.from(t3).map(function(t4) {
            return t4.codePointAt(0);
          });
        } : function(t3) {
          var e2, n2, i2, o2, r2;
          for (o2 = [], e2 = 0, i2 = t3.length; i2 > e2; )
            r2 = t3.charCodeAt(e2++), r2 >= 55296 && 56319 >= r2 && i2 > e2 && (n2 = t3.charCodeAt(e2++), (64512 & n2) === 56320 ? r2 = ((1023 & r2) << 10) + (1023 & n2) + 65536 : e2--), o2.push(r2);
          return o2;
        }, r = i ? function(t3) {
          return String.fromCodePoint.apply(String, t3);
        } : function(t3) {
          var e2, n2, i2;
          return e2 = function() {
            var e3, o2, r2;
            for (r2 = [], e3 = 0, o2 = t3.length; o2 > e3; e3++)
              i2 = t3[e3], n2 = "", i2 > 65535 && (i2 -= 65536, n2 += String.fromCharCode(i2 >>> 10 & 1023 | 55296), i2 = 56320 | 1023 & i2), r2.push(n2 + String.fromCharCode(i2));
            return r2;
          }(), e2.join("");
        };
      }.call(this), function() {
      }.call(this), function() {
      }.call(this), function() {
        e.config.lang = {attachFiles: "Attach Files", bold: "Bold", bullets: "Bullets", byte: "Byte", bytes: "Bytes", captionPlaceholder: "Add a caption\u2026", code: "Code", heading1: "Heading", indent: "Increase Level", italic: "Italic", link: "Link", numbers: "Numbers", outdent: "Decrease Level", quote: "Quote", redo: "Redo", remove: "Remove", strike: "Strikethrough", undo: "Undo", unlink: "Unlink", url: "URL", urlPlaceholder: "Enter a URL\u2026", GB: "GB", KB: "KB", MB: "MB", PB: "PB", TB: "TB"};
      }.call(this), function() {
        e.config.css = {attachment: "attachment", attachmentCaption: "attachment__caption", attachmentCaptionEditor: "attachment__caption-editor", attachmentMetadata: "attachment__metadata", attachmentMetadataContainer: "attachment__metadata-container", attachmentName: "attachment__name", attachmentProgress: "attachment__progress", attachmentSize: "attachment__size", attachmentToolbar: "attachment__toolbar", attachmentGallery: "attachment-gallery"};
      }.call(this), function() {
        var t2;
        e.config.blockAttributes = t2 = {default: {tagName: "div", parse: false}, quote: {tagName: "blockquote", nestable: true}, heading1: {tagName: "h1", terminal: true, breakOnReturn: true, group: false}, code: {tagName: "pre", terminal: true, text: {plaintext: true}}, bulletList: {tagName: "ul", parse: false}, bullet: {tagName: "li", listAttribute: "bulletList", group: false, nestable: true, test: function(n) {
          return e.tagName(n.parentNode) === t2[this.listAttribute].tagName;
        }}, numberList: {tagName: "ol", parse: false}, number: {tagName: "li", listAttribute: "numberList", group: false, nestable: true, test: function(n) {
          return e.tagName(n.parentNode) === t2[this.listAttribute].tagName;
        }}, attachmentGallery: {tagName: "div", exclusive: true, terminal: true, parse: false, group: false}};
      }.call(this), function() {
        var t2, n;
        t2 = e.config.lang, n = [t2.bytes, t2.KB, t2.MB, t2.GB, t2.TB, t2.PB], e.config.fileSize = {prefix: "IEC", precision: 2, formatter: function(e2) {
          var i, o, r, s, a;
          switch (e2) {
            case 0:
              return "0 " + t2.bytes;
            case 1:
              return "1 " + t2.byte;
            default:
              return i = function() {
                switch (this.prefix) {
                  case "SI":
                    return 1e3;
                  case "IEC":
                    return 1024;
                }
              }.call(this), o = Math.floor(Math.log(e2) / Math.log(i)), r = e2 / Math.pow(i, o), s = r.toFixed(this.precision), a = s.replace(/0*$/, "").replace(/\.$/, ""), a + " " + n[o];
          }
        }};
      }.call(this), function() {
        e.config.textAttributes = {bold: {tagName: "strong", inheritable: true, parser: function(t2) {
          var e2;
          return e2 = window.getComputedStyle(t2), e2.fontWeight === "bold" || e2.fontWeight >= 600;
        }}, italic: {tagName: "em", inheritable: true, parser: function(t2) {
          var e2;
          return e2 = window.getComputedStyle(t2), e2.fontStyle === "italic";
        }}, href: {groupTagName: "a", parser: function(t2) {
          var n, i, o;
          return n = e.AttachmentView.attachmentSelector, o = "a:not(" + n + ")", (i = e.findClosestElementFromNode(t2, {matchingSelector: o})) ? i.getAttribute("href") : void 0;
        }}, strike: {tagName: "del", inheritable: true}, frozen: {style: {backgroundColor: "highlight"}}};
      }.call(this), function() {
        var t2, n, i, o, r;
        r = "[data-trix-serialize=false]", o = ["contenteditable", "data-trix-id", "data-trix-store-key", "data-trix-mutable", "data-trix-placeholder", "tabindex"], n = "data-trix-serialized-attributes", i = "[" + n + "]", t2 = new RegExp("<!--block-->", "g"), e.extend({serializers: {"application/json": function(t3) {
          var n2;
          if (t3 instanceof e.Document)
            n2 = t3;
          else {
            if (!(t3 instanceof HTMLElement))
              throw new Error("unserializable object");
            n2 = e.Document.fromHTML(t3.innerHTML);
          }
          return n2.toSerializableDocument().toJSONString();
        }, "text/html": function(s) {
          var a, u, c, l, h, p, d, f, g, m, v, y, b, A, C3, x, w;
          if (s instanceof e.Document)
            l = e.DocumentView.render(s);
          else {
            if (!(s instanceof HTMLElement))
              throw new Error("unserializable object");
            l = s.cloneNode(true);
          }
          for (A = l.querySelectorAll(r), h = 0, g = A.length; g > h; h++)
            c = A[h], e.removeNode(c);
          for (p = 0, m = o.length; m > p; p++)
            for (a = o[p], C3 = l.querySelectorAll("[" + a + "]"), d = 0, v = C3.length; v > d; d++)
              c = C3[d], c.removeAttribute(a);
          for (x = l.querySelectorAll(i), f = 0, y = x.length; y > f; f++) {
            c = x[f];
            try {
              u = JSON.parse(c.getAttribute(n)), c.removeAttribute(n);
              for (b in u)
                w = u[b], c.setAttribute(b, w);
            } catch (E) {
            }
          }
          return l.innerHTML.replace(t2, "");
        }}, deserializers: {"application/json": function(t3) {
          return e.Document.fromJSONString(t3);
        }, "text/html": function(t3) {
          return e.Document.fromHTML(t3);
        }}, serializeToContentType: function(t3, n2) {
          var i2;
          if (i2 = e.serializers[n2])
            return i2(t3);
          throw new Error("unknown content type: " + n2);
        }, deserializeFromContentType: function(t3, n2) {
          var i2;
          if (i2 = e.deserializers[n2])
            return i2(t3);
          throw new Error("unknown content type: " + n2);
        }});
      }.call(this), function() {
        var t2;
        t2 = e.config.lang, e.config.toolbar = {getDefaultHTML: function() {
          return '<div class="trix-button-row">\n  <span class="trix-button-group trix-button-group--text-tools" data-trix-button-group="text-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-bold" data-trix-attribute="bold" data-trix-key="b" title="' + t2.bold + '" tabindex="-1">' + t2.bold + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-italic" data-trix-attribute="italic" data-trix-key="i" title="' + t2.italic + '" tabindex="-1">' + t2.italic + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-strike" data-trix-attribute="strike" title="' + t2.strike + '" tabindex="-1">' + t2.strike + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-link" data-trix-attribute="href" data-trix-action="link" data-trix-key="k" title="' + t2.link + '" tabindex="-1">' + t2.link + '</button>\n  </span>\n\n  <span class="trix-button-group trix-button-group--block-tools" data-trix-button-group="block-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-heading-1" data-trix-attribute="heading1" title="' + t2.heading1 + '" tabindex="-1">' + t2.heading1 + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-quote" data-trix-attribute="quote" title="' + t2.quote + '" tabindex="-1">' + t2.quote + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-code" data-trix-attribute="code" title="' + t2.code + '" tabindex="-1">' + t2.code + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-bullet-list" data-trix-attribute="bullet" title="' + t2.bullets + '" tabindex="-1">' + t2.bullets + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-number-list" data-trix-attribute="number" title="' + t2.numbers + '" tabindex="-1">' + t2.numbers + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-decrease-nesting-level" data-trix-action="decreaseNestingLevel" title="' + t2.outdent + '" tabindex="-1">' + t2.outdent + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-increase-nesting-level" data-trix-action="increaseNestingLevel" title="' + t2.indent + '" tabindex="-1">' + t2.indent + '</button>\n  </span>\n\n  <span class="trix-button-group trix-button-group--file-tools" data-trix-button-group="file-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-attach" data-trix-action="attachFiles" title="' + t2.attachFiles + '" tabindex="-1">' + t2.attachFiles + '</button>\n  </span>\n\n  <span class="trix-button-group-spacer"></span>\n\n  <span class="trix-button-group trix-button-group--history-tools" data-trix-button-group="history-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-undo" data-trix-action="undo" data-trix-key="z" title="' + t2.undo + '" tabindex="-1">' + t2.undo + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-redo" data-trix-action="redo" data-trix-key="shift+z" title="' + t2.redo + '" tabindex="-1">' + t2.redo + '</button>\n  </span>\n</div>\n\n<div class="trix-dialogs" data-trix-dialogs>\n  <div class="trix-dialog trix-dialog--link" data-trix-dialog="href" data-trix-dialog-attribute="href">\n    <div class="trix-dialog__link-fields">\n      <input type="url" name="href" class="trix-input trix-input--dialog" placeholder="' + t2.urlPlaceholder + '" aria-label="' + t2.url + '" required data-trix-input>\n      <div class="trix-button-group">\n        <input type="button" class="trix-button trix-button--dialog" value="' + t2.link + '" data-trix-method="setAttribute">\n        <input type="button" class="trix-button trix-button--dialog" value="' + t2.unlink + '" data-trix-method="removeAttribute">\n      </div>\n    </div>\n  </div>\n</div>';
        }};
      }.call(this), function() {
        e.config.undoInterval = 5e3;
      }.call(this), function() {
        e.config.attachments = {preview: {presentation: "gallery", caption: {name: true, size: true}}, file: {caption: {size: true}}};
      }.call(this), function() {
        e.config.keyNames = {8: "backspace", 9: "tab", 13: "return", 27: "escape", 37: "left", 39: "right", 46: "delete", 68: "d", 72: "h", 79: "o"};
      }.call(this), function() {
        e.config.input = {level2Enabled: true, getLevel: function() {
          return this.level2Enabled && e.browser.supportsInputEvents ? 2 : 0;
        }, pickFiles: function(t2) {
          var n;
          return n = e.makeElement("input", {type: "file", multiple: true, hidden: true, id: this.fileInputId}), n.addEventListener("change", function() {
            return t2(n.files), e.removeNode(n);
          }), e.removeNode(document.getElementById(this.fileInputId)), document.body.appendChild(n), n.click();
        }, fileInputId: "trix-file-input-" + Date.now().toString(16)};
      }.call(this), function() {
      }.call(this), function() {
        e.registerElement("trix-toolbar", {defaultCSS: "%t {\n  display: block;\n}\n\n%t {\n  white-space: nowrap;\n}\n\n%t [data-trix-dialog] {\n  display: none;\n}\n\n%t [data-trix-dialog][data-trix-active] {\n  display: block;\n}\n\n%t [data-trix-dialog] [data-trix-validate]:invalid {\n  background-color: #ffdddd;\n}", initialize: function() {
          return this.innerHTML === "" ? this.innerHTML = e.config.toolbar.getDefaultHTML() : void 0;
        }});
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i2() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i2.prototype = e2.prototype, t3.prototype = new i2(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty, i = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        };
        e.ObjectView = function(n2) {
          function o(t3, e2) {
            this.object = t3, this.options = e2 != null ? e2 : {}, this.childViews = [], this.rootView = this;
          }
          return t2(o, n2), o.prototype.getNodes = function() {
            var t3, e2, n3, i2, o2;
            for (this.nodes == null && (this.nodes = this.createNodes()), i2 = this.nodes, o2 = [], t3 = 0, e2 = i2.length; e2 > t3; t3++)
              n3 = i2[t3], o2.push(n3.cloneNode(true));
            return o2;
          }, o.prototype.invalidate = function() {
            var t3;
            return this.nodes = null, this.childViews = [], (t3 = this.parentView) != null ? t3.invalidate() : void 0;
          }, o.prototype.invalidateViewForObject = function(t3) {
            var e2;
            return (e2 = this.findViewForObject(t3)) != null ? e2.invalidate() : void 0;
          }, o.prototype.findOrCreateCachedChildView = function(t3, e2) {
            var n3;
            return (n3 = this.getCachedViewForObject(e2)) ? this.recordChildView(n3) : (n3 = this.createChildView.apply(this, arguments), this.cacheViewForObject(n3, e2)), n3;
          }, o.prototype.createChildView = function(t3, n3, i2) {
            var o2;
            return i2 == null && (i2 = {}), n3 instanceof e.ObjectGroup && (i2.viewClass = t3, t3 = e.ObjectGroupView), o2 = new t3(n3, i2), this.recordChildView(o2);
          }, o.prototype.recordChildView = function(t3) {
            return t3.parentView = this, t3.rootView = this.rootView, this.childViews.push(t3), t3;
          }, o.prototype.getAllChildViews = function() {
            var t3, e2, n3, i2, o2;
            for (o2 = [], i2 = this.childViews, e2 = 0, n3 = i2.length; n3 > e2; e2++)
              t3 = i2[e2], o2.push(t3), o2 = o2.concat(t3.getAllChildViews());
            return o2;
          }, o.prototype.findElement = function() {
            return this.findElementForObject(this.object);
          }, o.prototype.findElementForObject = function(t3) {
            var e2;
            return (e2 = t3 != null ? t3.id : void 0) ? this.rootView.element.querySelector("[data-trix-id='" + e2 + "']") : void 0;
          }, o.prototype.findViewForObject = function(t3) {
            var e2, n3, i2, o2;
            for (i2 = this.getAllChildViews(), e2 = 0, n3 = i2.length; n3 > e2; e2++)
              if (o2 = i2[e2], o2.object === t3)
                return o2;
          }, o.prototype.getViewCache = function() {
            return this.rootView !== this ? this.rootView.getViewCache() : this.isViewCachingEnabled() ? this.viewCache != null ? this.viewCache : this.viewCache = {} : void 0;
          }, o.prototype.isViewCachingEnabled = function() {
            return this.shouldCacheViews !== false;
          }, o.prototype.enableViewCaching = function() {
            return this.shouldCacheViews = true;
          }, o.prototype.disableViewCaching = function() {
            return this.shouldCacheViews = false;
          }, o.prototype.getCachedViewForObject = function(t3) {
            var e2;
            return (e2 = this.getViewCache()) != null ? e2[t3.getCacheKey()] : void 0;
          }, o.prototype.cacheViewForObject = function(t3, e2) {
            var n3;
            return (n3 = this.getViewCache()) != null ? n3[e2.getCacheKey()] = t3 : void 0;
          }, o.prototype.garbageCollectCachedViews = function() {
            var t3, e2, n3, o2, r, s;
            if (t3 = this.getViewCache()) {
              s = this.getAllChildViews().concat(this), n3 = function() {
                var t4, e3, n4;
                for (n4 = [], t4 = 0, e3 = s.length; e3 > t4; t4++)
                  r = s[t4], n4.push(r.object.getCacheKey());
                return n4;
              }(), o2 = [];
              for (e2 in t3)
                i.call(n3, e2) < 0 && o2.push(delete t3[e2]);
              return o2;
            }
          }, o;
        }(e.BasicObject);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.ObjectGroupView = function(e2) {
          function n2() {
            n2.__super__.constructor.apply(this, arguments), this.objectGroup = this.object, this.viewClass = this.options.viewClass, delete this.options.viewClass;
          }
          return t2(n2, e2), n2.prototype.getChildViews = function() {
            var t3, e3, n3, i;
            if (!this.childViews.length)
              for (i = this.objectGroup.getObjects(), t3 = 0, e3 = i.length; e3 > t3; t3++)
                n3 = i[t3], this.findOrCreateCachedChildView(this.viewClass, n3, this.options);
            return this.childViews;
          }, n2.prototype.createNodes = function() {
            var t3, e3, n3, i, o, r, s, a, u;
            for (t3 = this.createContainerElement(), s = this.getChildViews(), e3 = 0, i = s.length; i > e3; e3++)
              for (u = s[e3], a = u.getNodes(), n3 = 0, o = a.length; o > n3; n3++)
                r = a[n3], t3.appendChild(r);
            return [t3];
          }, n2.prototype.createContainerElement = function(t3) {
            return t3 == null && (t3 = this.objectGroup.getDepth()), this.getChildViews()[0].createContainerElement(t3);
          }, n2;
        }(e.ObjectView);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.Controller = function(e2) {
          function n2() {
            return n2.__super__.constructor.apply(this, arguments);
          }
          return t2(n2, e2), n2;
        }(e.BasicObject);
      }.call(this), function() {
        var t2, n, i, o, r, s, a = function(t3, e2) {
          return function() {
            return t3.apply(e2, arguments);
          };
        }, u = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            c.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, c = {}.hasOwnProperty, l = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        };
        t2 = e.findClosestElementFromNode, i = e.nodeIsEmptyTextNode, n = e.nodeIsBlockStartComment, o = e.normalizeSpaces, r = e.summarizeStringChange, s = e.tagName, e.MutationObserver = function(e2) {
          function c2(t3) {
            this.element = t3, this.didMutate = a(this.didMutate, this), this.observer = new window.MutationObserver(this.didMutate), this.start();
          }
          var h, p, d, f;
          return u(c2, e2), p = "data-trix-mutable", d = "[" + p + "]", f = {attributes: true, childList: true, characterData: true, characterDataOldValue: true, subtree: true}, c2.prototype.start = function() {
            return this.reset(), this.observer.observe(this.element, f);
          }, c2.prototype.stop = function() {
            return this.observer.disconnect();
          }, c2.prototype.didMutate = function(t3) {
            var e3, n2;
            return (e3 = this.mutations).push.apply(e3, this.findSignificantMutations(t3)), this.mutations.length ? ((n2 = this.delegate) != null && typeof n2.elementDidMutate == "function" && n2.elementDidMutate(this.getMutationSummary()), this.reset()) : void 0;
          }, c2.prototype.reset = function() {
            return this.mutations = [];
          }, c2.prototype.findSignificantMutations = function(t3) {
            var e3, n2, i2, o2;
            for (o2 = [], e3 = 0, n2 = t3.length; n2 > e3; e3++)
              i2 = t3[e3], this.mutationIsSignificant(i2) && o2.push(i2);
            return o2;
          }, c2.prototype.mutationIsSignificant = function(t3) {
            var e3, n2, i2, o2;
            if (this.nodeIsMutable(t3.target))
              return false;
            for (o2 = this.nodesModifiedByMutation(t3), e3 = 0, n2 = o2.length; n2 > e3; e3++)
              if (i2 = o2[e3], this.nodeIsSignificant(i2))
                return true;
            return false;
          }, c2.prototype.nodeIsSignificant = function(t3) {
            return t3 !== this.element && !this.nodeIsMutable(t3) && !i(t3);
          }, c2.prototype.nodeIsMutable = function(e3) {
            return t2(e3, {matchingSelector: d});
          }, c2.prototype.nodesModifiedByMutation = function(t3) {
            var e3;
            switch (e3 = [], t3.type) {
              case "attributes":
                t3.attributeName !== p && e3.push(t3.target);
                break;
              case "characterData":
                e3.push(t3.target.parentNode), e3.push(t3.target);
                break;
              case "childList":
                e3.push.apply(e3, t3.addedNodes), e3.push.apply(e3, t3.removedNodes);
            }
            return e3;
          }, c2.prototype.getMutationSummary = function() {
            return this.getTextMutationSummary();
          }, c2.prototype.getTextMutationSummary = function() {
            var t3, e3, n2, i2, o2, r2, s2, a2, u2, c3, h2;
            for (a2 = this.getTextChangesFromCharacterData(), n2 = a2.additions, o2 = a2.deletions, h2 = this.getTextChangesFromChildList(), u2 = h2.additions, r2 = 0, s2 = u2.length; s2 > r2; r2++)
              e3 = u2[r2], l.call(n2, e3) < 0 && n2.push(e3);
            return o2.push.apply(o2, h2.deletions), c3 = {}, (t3 = n2.join("")) && (c3.textAdded = t3), (i2 = o2.join("")) && (c3.textDeleted = i2), c3;
          }, c2.prototype.getMutationsByType = function(t3) {
            var e3, n2, i2, o2, r2;
            for (o2 = this.mutations, r2 = [], e3 = 0, n2 = o2.length; n2 > e3; e3++)
              i2 = o2[e3], i2.type === t3 && r2.push(i2);
            return r2;
          }, c2.prototype.getTextChangesFromChildList = function() {
            var t3, e3, i2, r2, s2, a2, u2, c3, l2, p2, d2;
            for (t3 = [], u2 = [], a2 = this.getMutationsByType("childList"), e3 = 0, r2 = a2.length; r2 > e3; e3++)
              s2 = a2[e3], t3.push.apply(t3, s2.addedNodes), u2.push.apply(u2, s2.removedNodes);
            return c3 = t3.length === 0 && u2.length === 1 && n(u2[0]), c3 ? (p2 = [], d2 = ["\n"]) : (p2 = h(t3), d2 = h(u2)), {additions: function() {
              var t4, e4, n2;
              for (n2 = [], i2 = t4 = 0, e4 = p2.length; e4 > t4; i2 = ++t4)
                l2 = p2[i2], l2 !== d2[i2] && n2.push(o(l2));
              return n2;
            }(), deletions: function() {
              var t4, e4, n2;
              for (n2 = [], i2 = t4 = 0, e4 = d2.length; e4 > t4; i2 = ++t4)
                l2 = d2[i2], l2 !== p2[i2] && n2.push(o(l2));
              return n2;
            }()};
          }, c2.prototype.getTextChangesFromCharacterData = function() {
            var t3, e3, n2, i2, s2, a2, u2, c3;
            return e3 = this.getMutationsByType("characterData"), e3.length && (c3 = e3[0], n2 = e3[e3.length - 1], s2 = o(c3.oldValue), i2 = o(n2.target.data), a2 = r(s2, i2), t3 = a2.added, u2 = a2.removed), {additions: t3 ? [t3] : [], deletions: u2 ? [u2] : []};
          }, h = function(t3) {
            var e3, n2, i2, o2;
            for (t3 == null && (t3 = []), o2 = [], e3 = 0, n2 = t3.length; n2 > e3; e3++)
              switch (i2 = t3[e3], i2.nodeType) {
                case Node.TEXT_NODE:
                  o2.push(i2.data);
                  break;
                case Node.ELEMENT_NODE:
                  s(i2) === "br" ? o2.push("\n") : o2.push.apply(o2, h(i2.childNodes));
              }
            return o2;
          }, c2;
        }(e.BasicObject);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.FileVerificationOperation = function(e2) {
          function n2(t3) {
            this.file = t3;
          }
          return t2(n2, e2), n2.prototype.perform = function(t3) {
            var e3;
            return e3 = new FileReader(), e3.onerror = function() {
              return t3(false);
            }, e3.onload = function(n3) {
              return function() {
                e3.onerror = null;
                try {
                  e3.abort();
                } catch (i) {
                }
                return t3(true, n3.file);
              };
            }(this), e3.readAsArrayBuffer(this.file);
          }, n2;
        }(e.Operation);
      }.call(this), function() {
        var t2, n, i = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            o.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, o = {}.hasOwnProperty;
        t2 = e.handleEvent, n = e.innerElementIsActive, e.InputController = function(o2) {
          function r(n2) {
            var i2;
            this.element = n2, this.mutationObserver = new e.MutationObserver(this.element), this.mutationObserver.delegate = this;
            for (i2 in this.events)
              t2(i2, {onElement: this.element, withCallback: this.handlerFor(i2)});
          }
          return i(r, o2), r.prototype.events = {}, r.prototype.elementDidMutate = function() {
          }, r.prototype.editorWillSyncDocumentView = function() {
            return this.mutationObserver.stop();
          }, r.prototype.editorDidSyncDocumentView = function() {
            return this.mutationObserver.start();
          }, r.prototype.requestRender = function() {
            var t3;
            return (t3 = this.delegate) != null && typeof t3.inputControllerDidRequestRender == "function" ? t3.inputControllerDidRequestRender() : void 0;
          }, r.prototype.requestReparse = function() {
            var t3;
            return (t3 = this.delegate) != null && typeof t3.inputControllerDidRequestReparse == "function" && t3.inputControllerDidRequestReparse(), this.requestRender();
          }, r.prototype.attachFiles = function(t3) {
            var n2, i2;
            return i2 = function() {
              var i3, o3, r2;
              for (r2 = [], i3 = 0, o3 = t3.length; o3 > i3; i3++)
                n2 = t3[i3], r2.push(new e.FileVerificationOperation(n2));
              return r2;
            }(), Promise.all(i2).then(function(t4) {
              return function(e2) {
                return t4.handleInput(function() {
                  var t5, n3;
                  return (t5 = this.delegate) != null && t5.inputControllerWillAttachFiles(), (n3 = this.responder) != null && n3.insertFiles(e2), this.requestRender();
                });
              };
            }(this));
          }, r.prototype.handlerFor = function(t3) {
            return function(e2) {
              return function(i2) {
                return i2.defaultPrevented ? void 0 : e2.handleInput(function() {
                  return n(this.element) ? void 0 : (this.eventName = t3, this.events[t3].call(this, i2));
                });
              };
            }(this);
          }, r.prototype.handleInput = function(t3) {
            var e2, n2;
            try {
              return (e2 = this.delegate) != null && e2.inputControllerWillHandleInput(), t3.call(this);
            } finally {
              (n2 = this.delegate) != null && n2.inputControllerDidHandleInput();
            }
          }, r.prototype.createLinkHTML = function(t3, e2) {
            var n2;
            return n2 = document.createElement("a"), n2.href = t3, n2.textContent = e2 != null ? e2 : t3, n2.outerHTML;
          }, r;
        }(e.BasicObject);
      }.call(this), function() {
        var t2, n, i, o, r, s, a, u, c, l, h, p, d, f = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            g.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, g = {}.hasOwnProperty, m = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        };
        c = e.makeElement, l = e.objectsAreEqual, d = e.tagName, n = e.browser, a = e.keyEventIsKeyboardCommand, o = e.dataTransferIsWritable, i = e.dataTransferIsPlainText, u = e.config.keyNames, e.Level0InputController = function(n2) {
          function s2() {
            s2.__super__.constructor.apply(this, arguments), this.resetInputSummary();
          }
          var d2;
          return f(s2, n2), d2 = 0, s2.prototype.setInputSummary = function(t3) {
            var e2, n3;
            t3 == null && (t3 = {}), this.inputSummary.eventName = this.eventName;
            for (e2 in t3)
              n3 = t3[e2], this.inputSummary[e2] = n3;
            return this.inputSummary;
          }, s2.prototype.resetInputSummary = function() {
            return this.inputSummary = {};
          }, s2.prototype.reset = function() {
            return this.resetInputSummary(), e.selectionChangeObserver.reset();
          }, s2.prototype.elementDidMutate = function(t3) {
            var e2;
            return this.isComposing() ? (e2 = this.delegate) != null && typeof e2.inputControllerDidAllowUnhandledInput == "function" ? e2.inputControllerDidAllowUnhandledInput() : void 0 : this.handleInput(function() {
              return this.mutationIsSignificant(t3) && (this.mutationIsExpected(t3) ? this.requestRender() : this.requestReparse()), this.reset();
            });
          }, s2.prototype.mutationIsExpected = function(t3) {
            var e2, n3, i2, o2, r2, s3, a2, u2, c2, l2;
            return a2 = t3.textAdded, u2 = t3.textDeleted, this.inputSummary.preferDocument ? true : (e2 = a2 != null ? a2 === this.inputSummary.textAdded : !this.inputSummary.textAdded, n3 = u2 != null ? this.inputSummary.didDelete : !this.inputSummary.didDelete, c2 = (a2 === "\n" || a2 === " \n") && !e2, l2 = u2 === "\n" && !n3, s3 = c2 && !l2 || l2 && !c2, s3 && (o2 = this.getSelectedRange()) && (i2 = c2 ? a2.replace(/\n$/, "").length || -1 : (a2 != null ? a2.length : void 0) || 1, (r2 = this.responder) != null ? r2.positionIsBlockBreak(o2[1] + i2) : void 0) ? true : e2 && n3);
          }, s2.prototype.mutationIsSignificant = function(t3) {
            var e2, n3, i2;
            return i2 = Object.keys(t3).length > 0, e2 = ((n3 = this.compositionInput) != null ? n3.getEndData() : void 0) === "", i2 || !e2;
          }, s2.prototype.events = {keydown: function(t3) {
            var n3, i2, o2, r2, s3, c2, l2, h2, p2;
            if (this.isComposing() || this.resetInputSummary(), this.inputSummary.didInput = true, r2 = u[t3.keyCode]) {
              for (i2 = this.keys, h2 = ["ctrl", "alt", "shift", "meta"], o2 = 0, c2 = h2.length; c2 > o2; o2++)
                l2 = h2[o2], t3[l2 + "Key"] && (l2 === "ctrl" && (l2 = "control"), i2 = i2 != null ? i2[l2] : void 0);
              (i2 != null ? i2[r2] : void 0) != null && (this.setInputSummary({keyName: r2}), e.selectionChangeObserver.reset(), i2[r2].call(this, t3));
            }
            return a(t3) && (n3 = String.fromCharCode(t3.keyCode).toLowerCase()) && (s3 = function() {
              var e2, n4, i3, o3;
              for (i3 = ["alt", "shift"], o3 = [], e2 = 0, n4 = i3.length; n4 > e2; e2++)
                l2 = i3[e2], t3[l2 + "Key"] && o3.push(l2);
              return o3;
            }(), s3.push(n3), (p2 = this.delegate) != null ? p2.inputControllerDidReceiveKeyboardCommand(s3) : void 0) ? t3.preventDefault() : void 0;
          }, keypress: function(t3) {
            var e2, n3, i2;
            if (this.inputSummary.eventName == null && !t3.metaKey && (!t3.ctrlKey || t3.altKey))
              return (i2 = p(t3)) ? ((e2 = this.delegate) != null && e2.inputControllerWillPerformTyping(), (n3 = this.responder) != null && n3.insertString(i2), this.setInputSummary({textAdded: i2, didDelete: this.selectionIsExpanded()})) : void 0;
          }, textInput: function(t3) {
            var e2, n3, i2, o2;
            return e2 = t3.data, o2 = this.inputSummary.textAdded, o2 && o2 !== e2 && o2.toUpperCase() === e2 ? (n3 = this.getSelectedRange(), this.setSelectedRange([n3[0], n3[1] + o2.length]), (i2 = this.responder) != null && i2.insertString(e2), this.setInputSummary({textAdded: e2}), this.setSelectedRange(n3)) : void 0;
          }, dragenter: function(t3) {
            return t3.preventDefault();
          }, dragstart: function(t3) {
            var e2, n3;
            return n3 = t3.target, this.serializeSelectionToDataTransfer(t3.dataTransfer), this.draggedRange = this.getSelectedRange(), (e2 = this.delegate) != null && typeof e2.inputControllerDidStartDrag == "function" ? e2.inputControllerDidStartDrag() : void 0;
          }, dragover: function(t3) {
            var e2, n3;
            return !this.draggedRange && !this.canAcceptDataTransfer(t3.dataTransfer) || (t3.preventDefault(), e2 = {x: t3.clientX, y: t3.clientY}, l(e2, this.draggingPoint)) ? void 0 : (this.draggingPoint = e2, (n3 = this.delegate) != null && typeof n3.inputControllerDidReceiveDragOverPoint == "function" ? n3.inputControllerDidReceiveDragOverPoint(this.draggingPoint) : void 0);
          }, dragend: function() {
            var t3;
            return (t3 = this.delegate) != null && typeof t3.inputControllerDidCancelDrag == "function" && t3.inputControllerDidCancelDrag(), this.draggedRange = null, this.draggingPoint = null;
          }, drop: function(t3) {
            var n3, i2, o2, r2, s3, a2, u2, c2, l2;
            return t3.preventDefault(), o2 = (s3 = t3.dataTransfer) != null ? s3.files : void 0, r2 = {x: t3.clientX, y: t3.clientY}, (a2 = this.responder) != null && a2.setLocationRangeFromPointRange(r2), (o2 != null ? o2.length : void 0) ? this.attachFiles(o2) : this.draggedRange ? ((u2 = this.delegate) != null && u2.inputControllerWillMoveText(), (c2 = this.responder) != null && c2.moveTextFromRange(this.draggedRange), this.draggedRange = null, this.requestRender()) : (i2 = t3.dataTransfer.getData("application/x-trix-document")) && (n3 = e.Document.fromJSONString(i2), (l2 = this.responder) != null && l2.insertDocument(n3), this.requestRender()), this.draggedRange = null, this.draggingPoint = null;
          }, cut: function(t3) {
            var e2, n3;
            return ((e2 = this.responder) != null ? e2.selectionIsExpanded() : void 0) && (this.serializeSelectionToDataTransfer(t3.clipboardData) && t3.preventDefault(), (n3 = this.delegate) != null && n3.inputControllerWillCutText(), this.deleteInDirection("backward"), t3.defaultPrevented) ? this.requestRender() : void 0;
          }, copy: function(t3) {
            var e2;
            return ((e2 = this.responder) != null ? e2.selectionIsExpanded() : void 0) && this.serializeSelectionToDataTransfer(t3.clipboardData) ? t3.preventDefault() : void 0;
          }, paste: function(t3) {
            var n3, o2, s3, a2, u2, c2, l2, p2, f2, g2, v, y, b, A, C3, x, w, E, S2, R, k, D2, L2;
            return n3 = (p2 = t3.clipboardData) != null ? p2 : t3.testClipboardData, l2 = {clipboard: n3}, n3 == null || h(t3) ? void this.getPastedHTMLUsingHiddenElement(function(t4) {
              return function(e2) {
                var n4, i2, o3;
                return l2.type = "text/html", l2.html = e2, (n4 = t4.delegate) != null && n4.inputControllerWillPaste(l2), (i2 = t4.responder) != null && i2.insertHTML(l2.html), t4.requestRender(), (o3 = t4.delegate) != null ? o3.inputControllerDidPaste(l2) : void 0;
              };
            }(this)) : ((a2 = n3.getData("URL")) ? (l2.type = "text/html", L2 = (c2 = n3.getData("public.url-name")) ? e.squishBreakableWhitespace(c2).trim() : a2, l2.html = this.createLinkHTML(a2, L2), (f2 = this.delegate) != null && f2.inputControllerWillPaste(l2), this.setInputSummary({textAdded: L2, didDelete: this.selectionIsExpanded()}), (C3 = this.responder) != null && C3.insertHTML(l2.html), this.requestRender(), (x = this.delegate) != null && x.inputControllerDidPaste(l2)) : i(n3) ? (l2.type = "text/plain", l2.string = n3.getData("text/plain"), (w = this.delegate) != null && w.inputControllerWillPaste(l2), this.setInputSummary({textAdded: l2.string, didDelete: this.selectionIsExpanded()}), (E = this.responder) != null && E.insertString(l2.string), this.requestRender(), (S2 = this.delegate) != null && S2.inputControllerDidPaste(l2)) : (u2 = n3.getData("text/html")) ? (l2.type = "text/html", l2.html = u2, (R = this.delegate) != null && R.inputControllerWillPaste(l2), (k = this.responder) != null && k.insertHTML(l2.html), this.requestRender(), (D2 = this.delegate) != null && D2.inputControllerDidPaste(l2)) : m.call(n3.types, "Files") >= 0 && (s3 = (g2 = n3.items) != null && (v = g2[0]) != null && typeof v.getAsFile == "function" ? v.getAsFile() : void 0) && (!s3.name && (o2 = r(s3)) && (s3.name = "pasted-file-" + ++d2 + "." + o2), l2.type = "File", l2.file = s3, (y = this.delegate) != null && y.inputControllerWillAttachFiles(), (b = this.responder) != null && b.insertFile(l2.file), this.requestRender(), (A = this.delegate) != null && A.inputControllerDidPaste(l2)), t3.preventDefault());
          }, compositionstart: function(t3) {
            return this.getCompositionInput().start(t3.data);
          }, compositionupdate: function(t3) {
            return this.getCompositionInput().update(t3.data);
          }, compositionend: function(t3) {
            return this.getCompositionInput().end(t3.data);
          }, beforeinput: function() {
            return this.inputSummary.didInput = true;
          }, input: function(t3) {
            return this.inputSummary.didInput = true, t3.stopPropagation();
          }}, s2.prototype.keys = {backspace: function(t3) {
            var e2;
            return (e2 = this.delegate) != null && e2.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t3);
          }, delete: function(t3) {
            var e2;
            return (e2 = this.delegate) != null && e2.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t3);
          }, return: function() {
            var t3, e2;
            return this.setInputSummary({preferDocument: true}), (t3 = this.delegate) != null && t3.inputControllerWillPerformTyping(), (e2 = this.responder) != null ? e2.insertLineBreak() : void 0;
          }, tab: function(t3) {
            var e2, n3;
            return ((e2 = this.responder) != null ? e2.canIncreaseNestingLevel() : void 0) ? ((n3 = this.responder) != null && n3.increaseNestingLevel(), this.requestRender(), t3.preventDefault()) : void 0;
          }, left: function(t3) {
            var e2;
            return this.selectionIsInCursorTarget() ? (t3.preventDefault(), (e2 = this.responder) != null ? e2.moveCursorInDirection("backward") : void 0) : void 0;
          }, right: function(t3) {
            var e2;
            return this.selectionIsInCursorTarget() ? (t3.preventDefault(), (e2 = this.responder) != null ? e2.moveCursorInDirection("forward") : void 0) : void 0;
          }, control: {d: function(t3) {
            var e2;
            return (e2 = this.delegate) != null && e2.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t3);
          }, h: function(t3) {
            var e2;
            return (e2 = this.delegate) != null && e2.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t3);
          }, o: function(t3) {
            var e2, n3;
            return t3.preventDefault(), (e2 = this.delegate) != null && e2.inputControllerWillPerformTyping(), (n3 = this.responder) != null && n3.insertString("\n", {updatePosition: false}), this.requestRender();
          }}, shift: {return: function(t3) {
            var e2, n3;
            return (e2 = this.delegate) != null && e2.inputControllerWillPerformTyping(), (n3 = this.responder) != null && n3.insertString("\n"), this.requestRender(), t3.preventDefault();
          }, tab: function(t3) {
            var e2, n3;
            return ((e2 = this.responder) != null ? e2.canDecreaseNestingLevel() : void 0) ? ((n3 = this.responder) != null && n3.decreaseNestingLevel(), this.requestRender(), t3.preventDefault()) : void 0;
          }, left: function(t3) {
            return this.selectionIsInCursorTarget() ? (t3.preventDefault(), this.expandSelectionInDirection("backward")) : void 0;
          }, right: function(t3) {
            return this.selectionIsInCursorTarget() ? (t3.preventDefault(), this.expandSelectionInDirection("forward")) : void 0;
          }}, alt: {backspace: function() {
            var t3;
            return this.setInputSummary({preferDocument: false}), (t3 = this.delegate) != null ? t3.inputControllerWillPerformTyping() : void 0;
          }}, meta: {backspace: function() {
            var t3;
            return this.setInputSummary({preferDocument: false}), (t3 = this.delegate) != null ? t3.inputControllerWillPerformTyping() : void 0;
          }}}, s2.prototype.getCompositionInput = function() {
            return this.isComposing() ? this.compositionInput : this.compositionInput = new t2(this);
          }, s2.prototype.isComposing = function() {
            return this.compositionInput != null && !this.compositionInput.isEnded();
          }, s2.prototype.deleteInDirection = function(t3, e2) {
            var n3;
            return ((n3 = this.responder) != null ? n3.deleteInDirection(t3) : void 0) !== false ? this.setInputSummary({didDelete: true}) : e2 ? (e2.preventDefault(), this.requestRender()) : void 0;
          }, s2.prototype.serializeSelectionToDataTransfer = function(t3) {
            var n3, i2;
            if (o(t3))
              return n3 = (i2 = this.responder) != null ? i2.getSelectedDocument().toSerializableDocument() : void 0, t3.setData("application/x-trix-document", JSON.stringify(n3)), t3.setData("text/html", e.DocumentView.render(n3).innerHTML), t3.setData("text/plain", n3.toString().replace(/\n$/, "")), true;
          }, s2.prototype.canAcceptDataTransfer = function(t3) {
            var e2, n3, i2, o2, r2, s3;
            for (s3 = {}, o2 = (i2 = t3 != null ? t3.types : void 0) != null ? i2 : [], e2 = 0, n3 = o2.length; n3 > e2; e2++)
              r2 = o2[e2], s3[r2] = true;
            return s3.Files || s3["application/x-trix-document"] || s3["text/html"] || s3["text/plain"];
          }, s2.prototype.getPastedHTMLUsingHiddenElement = function(t3) {
            var n3, i2, o2;
            return i2 = this.getSelectedRange(), o2 = {position: "absolute", left: window.pageXOffset + "px", top: window.pageYOffset + "px", opacity: 0}, n3 = c({style: o2, tagName: "div", editable: true}), document.body.appendChild(n3), n3.focus(), requestAnimationFrame(function(o3) {
              return function() {
                var r2;
                return r2 = n3.innerHTML, e.removeNode(n3), o3.setSelectedRange(i2), t3(r2);
              };
            }(this));
          }, s2.proxyMethod("responder?.getSelectedRange"), s2.proxyMethod("responder?.setSelectedRange"), s2.proxyMethod("responder?.expandSelectionInDirection"), s2.proxyMethod("responder?.selectionIsInCursorTarget"), s2.proxyMethod("responder?.selectionIsExpanded"), s2;
        }(e.InputController), r = function(t3) {
          var e2, n2;
          return (e2 = t3.type) != null && (n2 = e2.match(/\/(\w+)$/)) != null ? n2[1] : void 0;
        }, s = (typeof " ".codePointAt == "function" ? " ".codePointAt(0) : void 0) != null, p = function(t3) {
          var n2;
          return t3.key && s && t3.key.codePointAt(0) === t3.keyCode ? t3.key : (t3.which === null ? n2 = t3.keyCode : t3.which !== 0 && t3.charCode !== 0 && (n2 = t3.charCode), n2 != null && u[n2] !== "escape" ? e.UTF16String.fromCodepoints([n2]).toString() : void 0);
        }, h = function(t3) {
          var e2, n2, i2, o2, r2, s2, a2, u2, c2, l2;
          if (u2 = t3.clipboardData) {
            if (m.call(u2.types, "text/html") >= 0) {
              for (c2 = u2.types, i2 = 0, s2 = c2.length; s2 > i2; i2++)
                if (l2 = c2[i2], e2 = /^CorePasteboardFlavorType/.test(l2), n2 = /^dyn\./.test(l2) && u2.getData(l2), a2 = e2 || n2)
                  return true;
              return false;
            }
            return o2 = m.call(u2.types, "com.apple.webarchive") >= 0, r2 = m.call(u2.types, "com.apple.flat-rtfd") >= 0, o2 || r2;
          }
        }, t2 = function(t3) {
          function e2(t4) {
            var e3;
            this.inputController = t4, e3 = this.inputController, this.responder = e3.responder, this.delegate = e3.delegate, this.inputSummary = e3.inputSummary, this.data = {};
          }
          return f(e2, t3), e2.prototype.start = function(t4) {
            var e3, n2;
            return this.data.start = t4, this.isSignificant() ? (this.inputSummary.eventName === "keypress" && this.inputSummary.textAdded && (e3 = this.responder) != null && e3.deleteInDirection("left"), this.selectionIsExpanded() || (this.insertPlaceholder(), this.requestRender()), this.range = (n2 = this.responder) != null ? n2.getSelectedRange() : void 0) : void 0;
          }, e2.prototype.update = function(t4) {
            var e3;
            return this.data.update = t4, this.isSignificant() && (e3 = this.selectPlaceholder()) ? (this.forgetPlaceholder(), this.range = e3) : void 0;
          }, e2.prototype.end = function(t4) {
            var e3, n2, i2, o2;
            return this.data.end = t4, this.isSignificant() ? (this.forgetPlaceholder(), this.canApplyToDocument() ? (this.setInputSummary({preferDocument: true, didInput: false}), (e3 = this.delegate) != null && e3.inputControllerWillPerformTyping(), (n2 = this.responder) != null && n2.setSelectedRange(this.range), (i2 = this.responder) != null && i2.insertString(this.data.end), (o2 = this.responder) != null ? o2.setSelectedRange(this.range[0] + this.data.end.length) : void 0) : this.data.start != null || this.data.update != null ? (this.requestReparse(), this.inputController.reset()) : void 0) : this.inputController.reset();
          }, e2.prototype.getEndData = function() {
            return this.data.end;
          }, e2.prototype.isEnded = function() {
            return this.getEndData() != null;
          }, e2.prototype.isSignificant = function() {
            return n.composesExistingText ? this.inputSummary.didInput : true;
          }, e2.prototype.canApplyToDocument = function() {
            var t4, e3;
            return ((t4 = this.data.start) != null ? t4.length : void 0) === 0 && ((e3 = this.data.end) != null ? e3.length : void 0) > 0 && this.range != null;
          }, e2.proxyMethod("inputController.setInputSummary"), e2.proxyMethod("inputController.requestRender"), e2.proxyMethod("inputController.requestReparse"), e2.proxyMethod("responder?.selectionIsExpanded"), e2.proxyMethod("responder?.insertPlaceholder"), e2.proxyMethod("responder?.selectPlaceholder"), e2.proxyMethod("responder?.forgetPlaceholder"), e2;
        }(e.BasicObject);
      }.call(this), function() {
        var t2, n, i, o = function(t3, e2) {
          return function() {
            return t3.apply(e2, arguments);
          };
        }, r = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            s.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, s = {}.hasOwnProperty, a = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        };
        t2 = e.dataTransferIsPlainText, n = e.keyEventIsKeyboardCommand, i = e.objectsAreEqual, e.Level2InputController = function(s2) {
          function u() {
            return this.render = o(this.render, this), u.__super__.constructor.apply(this, arguments);
          }
          var c, l, h, p, d, f;
          return r(u, s2), u.prototype.elementDidMutate = function() {
            var t3;
            return this.scheduledRender ? this.composing && (t3 = this.delegate) != null && typeof t3.inputControllerDidAllowUnhandledInput == "function" ? t3.inputControllerDidAllowUnhandledInput() : void 0 : this.reparse();
          }, u.prototype.scheduleRender = function() {
            return this.scheduledRender != null ? this.scheduledRender : this.scheduledRender = requestAnimationFrame(this.render);
          }, u.prototype.render = function() {
            var t3;
            return cancelAnimationFrame(this.scheduledRender), this.scheduledRender = null, this.composing || (t3 = this.delegate) != null && t3.render(), typeof this.afterRender == "function" && this.afterRender(), this.afterRender = null;
          }, u.prototype.reparse = function() {
            var t3;
            return (t3 = this.delegate) != null ? t3.reparse() : void 0;
          }, u.prototype.events = {keydown: function(t3) {
            var e2, i2, o2, r2;
            if (n(t3)) {
              if (e2 = l(t3), (r2 = this.delegate) != null ? r2.inputControllerDidReceiveKeyboardCommand(e2) : void 0)
                return t3.preventDefault();
            } else if (o2 = t3.key, t3.altKey && (o2 += "+Alt"), t3.shiftKey && (o2 += "+Shift"), i2 = this.keys[o2])
              return this.withEvent(t3, i2);
          }, paste: function(t3) {
            var e2, n2, i2, o2, r2, s3, a2, u2, c2;
            return h(t3) ? (t3.preventDefault(), this.attachFiles(t3.clipboardData.files)) : p(t3) ? (t3.preventDefault(), n2 = {type: "text/plain", string: t3.clipboardData.getData("text/plain")}, (i2 = this.delegate) != null && i2.inputControllerWillPaste(n2), (o2 = this.responder) != null && o2.insertString(n2.string), this.render(), (r2 = this.delegate) != null ? r2.inputControllerDidPaste(n2) : void 0) : (e2 = (s3 = t3.clipboardData) != null ? s3.getData("URL") : void 0) ? (t3.preventDefault(), n2 = {type: "text/html", html: this.createLinkHTML(e2)}, (a2 = this.delegate) != null && a2.inputControllerWillPaste(n2), (u2 = this.responder) != null && u2.insertHTML(n2.html), this.render(), (c2 = this.delegate) != null ? c2.inputControllerDidPaste(n2) : void 0) : void 0;
          }, beforeinput: function(t3) {
            var e2;
            return (e2 = this.inputTypes[t3.inputType]) ? (this.withEvent(t3, e2), this.scheduleRender()) : void 0;
          }, input: function() {
            return e.selectionChangeObserver.reset();
          }, dragstart: function(t3) {
            var e2, n2;
            return ((e2 = this.responder) != null ? e2.selectionContainsAttachments() : void 0) ? (t3.dataTransfer.setData("application/x-trix-dragging", true), this.dragging = {range: (n2 = this.responder) != null ? n2.getSelectedRange() : void 0, point: d(t3)}) : void 0;
          }, dragenter: function(t3) {
            return c(t3) ? t3.preventDefault() : void 0;
          }, dragover: function(t3) {
            var e2, n2;
            if (this.dragging) {
              if (t3.preventDefault(), e2 = d(t3), !i(e2, this.dragging.point))
                return this.dragging.point = e2, (n2 = this.responder) != null ? n2.setLocationRangeFromPointRange(e2) : void 0;
            } else if (c(t3))
              return t3.preventDefault();
          }, drop: function(t3) {
            var e2, n2, i2, o2;
            return this.dragging ? (t3.preventDefault(), (n2 = this.delegate) != null && n2.inputControllerWillMoveText(), (i2 = this.responder) != null && i2.moveTextFromRange(this.dragging.range), this.dragging = null, this.scheduleRender()) : c(t3) ? (t3.preventDefault(), e2 = d(t3), (o2 = this.responder) != null && o2.setLocationRangeFromPointRange(e2), this.attachFiles(t3.dataTransfer.files)) : void 0;
          }, dragend: function() {
            var t3;
            return this.dragging ? ((t3 = this.responder) != null && t3.setSelectedRange(this.dragging.range), this.dragging = null) : void 0;
          }, compositionend: function() {
            return this.composing ? (this.composing = false, this.scheduleRender()) : void 0;
          }}, u.prototype.keys = {ArrowLeft: function() {
            var t3, e2;
            return ((t3 = this.responder) != null ? t3.shouldManageMovingCursorInDirection("backward") : void 0) ? (this.event.preventDefault(), (e2 = this.responder) != null ? e2.moveCursorInDirection("backward") : void 0) : void 0;
          }, ArrowRight: function() {
            var t3, e2;
            return ((t3 = this.responder) != null ? t3.shouldManageMovingCursorInDirection("forward") : void 0) ? (this.event.preventDefault(), (e2 = this.responder) != null ? e2.moveCursorInDirection("forward") : void 0) : void 0;
          }, Backspace: function() {
            var t3, e2, n2;
            return ((t3 = this.responder) != null ? t3.shouldManageDeletingInDirection("backward") : void 0) ? (this.event.preventDefault(), (e2 = this.delegate) != null && e2.inputControllerWillPerformTyping(), (n2 = this.responder) != null && n2.deleteInDirection("backward"), this.render()) : void 0;
          }, Tab: function() {
            var t3, e2;
            return ((t3 = this.responder) != null ? t3.canIncreaseNestingLevel() : void 0) ? (this.event.preventDefault(), (e2 = this.responder) != null && e2.increaseNestingLevel(), this.render()) : void 0;
          }, "Tab+Shift": function() {
            var t3, e2;
            return ((t3 = this.responder) != null ? t3.canDecreaseNestingLevel() : void 0) ? (this.event.preventDefault(), (e2 = this.responder) != null && e2.decreaseNestingLevel(), this.render()) : void 0;
          }}, u.prototype.inputTypes = {deleteByComposition: function() {
            return this.deleteInDirection("backward", {recordUndoEntry: false});
          }, deleteByCut: function() {
            return this.deleteInDirection("backward");
          }, deleteByDrag: function() {
            return this.event.preventDefault(), this.withTargetDOMRange(function() {
              var t3;
              return this.deleteByDragRange = (t3 = this.responder) != null ? t3.getSelectedRange() : void 0;
            });
          }, deleteCompositionText: function() {
            return this.deleteInDirection("backward", {recordUndoEntry: false});
          }, deleteContent: function() {
            return this.deleteInDirection("backward");
          }, deleteContentBackward: function() {
            return this.deleteInDirection("backward");
          }, deleteContentForward: function() {
            return this.deleteInDirection("forward");
          }, deleteEntireSoftLine: function() {
            return this.deleteInDirection("forward");
          }, deleteHardLineBackward: function() {
            return this.deleteInDirection("backward");
          }, deleteHardLineForward: function() {
            return this.deleteInDirection("forward");
          }, deleteSoftLineBackward: function() {
            return this.deleteInDirection("backward");
          }, deleteSoftLineForward: function() {
            return this.deleteInDirection("forward");
          }, deleteWordBackward: function() {
            return this.deleteInDirection("backward");
          }, deleteWordForward: function() {
            return this.deleteInDirection("forward");
          }, formatBackColor: function() {
            return this.activateAttributeIfSupported("backgroundColor", this.event.data);
          }, formatBold: function() {
            return this.toggleAttributeIfSupported("bold");
          }, formatFontColor: function() {
            return this.activateAttributeIfSupported("color", this.event.data);
          }, formatFontName: function() {
            return this.activateAttributeIfSupported("font", this.event.data);
          }, formatIndent: function() {
            var t3;
            return ((t3 = this.responder) != null ? t3.canIncreaseNestingLevel() : void 0) ? this.withTargetDOMRange(function() {
              var t4;
              return (t4 = this.responder) != null ? t4.increaseNestingLevel() : void 0;
            }) : void 0;
          }, formatItalic: function() {
            return this.toggleAttributeIfSupported("italic");
          }, formatJustifyCenter: function() {
            return this.toggleAttributeIfSupported("justifyCenter");
          }, formatJustifyFull: function() {
            return this.toggleAttributeIfSupported("justifyFull");
          }, formatJustifyLeft: function() {
            return this.toggleAttributeIfSupported("justifyLeft");
          }, formatJustifyRight: function() {
            return this.toggleAttributeIfSupported("justifyRight");
          }, formatOutdent: function() {
            var t3;
            return ((t3 = this.responder) != null ? t3.canDecreaseNestingLevel() : void 0) ? this.withTargetDOMRange(function() {
              var t4;
              return (t4 = this.responder) != null ? t4.decreaseNestingLevel() : void 0;
            }) : void 0;
          }, formatRemove: function() {
            return this.withTargetDOMRange(function() {
              var t3, e2, n2, i2;
              i2 = [];
              for (t3 in (e2 = this.responder) != null ? e2.getCurrentAttributes() : void 0)
                i2.push((n2 = this.responder) != null ? n2.removeCurrentAttribute(t3) : void 0);
              return i2;
            });
          }, formatSetBlockTextDirection: function() {
            return this.activateAttributeIfSupported("blockDir", this.event.data);
          }, formatSetInlineTextDirection: function() {
            return this.activateAttributeIfSupported("textDir", this.event.data);
          }, formatStrikeThrough: function() {
            return this.toggleAttributeIfSupported("strike");
          }, formatSubscript: function() {
            return this.toggleAttributeIfSupported("sub");
          }, formatSuperscript: function() {
            return this.toggleAttributeIfSupported("sup");
          }, formatUnderline: function() {
            return this.toggleAttributeIfSupported("underline");
          }, historyRedo: function() {
            var t3;
            return (t3 = this.delegate) != null ? t3.inputControllerWillPerformRedo() : void 0;
          }, historyUndo: function() {
            var t3;
            return (t3 = this.delegate) != null ? t3.inputControllerWillPerformUndo() : void 0;
          }, insertCompositionText: function() {
            return this.composing = true, this.insertString(this.event.data);
          }, insertFromComposition: function() {
            return this.composing = false, this.insertString(this.event.data);
          }, insertFromDrop: function() {
            var t3, e2;
            return (t3 = this.deleteByDragRange) ? (this.deleteByDragRange = null, (e2 = this.delegate) != null && e2.inputControllerWillMoveText(), this.withTargetDOMRange(function() {
              var e3;
              return (e3 = this.responder) != null ? e3.moveTextFromRange(t3) : void 0;
            })) : void 0;
          }, insertFromPaste: function() {
            var n2, i2, o2, r2, s3, a2, u2, c2, l2, h2, p2;
            return n2 = this.event.dataTransfer, s3 = {dataTransfer: n2}, (i2 = n2.getData("URL")) ? (this.event.preventDefault(), s3.type = "text/html", p2 = (r2 = n2.getData("public.url-name")) ? e.squishBreakableWhitespace(r2).trim() : i2, s3.html = this.createLinkHTML(i2, p2), (a2 = this.delegate) != null && a2.inputControllerWillPaste(s3), this.withTargetDOMRange(function() {
              var t3;
              return (t3 = this.responder) != null ? t3.insertHTML(s3.html) : void 0;
            }), this.afterRender = function(t3) {
              return function() {
                var e2;
                return (e2 = t3.delegate) != null ? e2.inputControllerDidPaste(s3) : void 0;
              };
            }(this)) : t2(n2) ? (s3.type = "text/plain", s3.string = n2.getData("text/plain"), (u2 = this.delegate) != null && u2.inputControllerWillPaste(s3), this.withTargetDOMRange(function() {
              var t3;
              return (t3 = this.responder) != null ? t3.insertString(s3.string) : void 0;
            }), this.afterRender = function(t3) {
              return function() {
                var e2;
                return (e2 = t3.delegate) != null ? e2.inputControllerDidPaste(s3) : void 0;
              };
            }(this)) : (o2 = n2.getData("text/html")) ? (this.event.preventDefault(), s3.type = "text/html", s3.html = o2, (c2 = this.delegate) != null && c2.inputControllerWillPaste(s3), this.withTargetDOMRange(function() {
              var t3;
              return (t3 = this.responder) != null ? t3.insertHTML(s3.html) : void 0;
            }), this.afterRender = function(t3) {
              return function() {
                var e2;
                return (e2 = t3.delegate) != null ? e2.inputControllerDidPaste(s3) : void 0;
              };
            }(this)) : ((l2 = n2.files) != null ? l2.length : void 0) ? (s3.type = "File", s3.file = n2.files[0], (h2 = this.delegate) != null && h2.inputControllerWillPaste(s3), this.withTargetDOMRange(function() {
              var t3;
              return (t3 = this.responder) != null ? t3.insertFile(s3.file) : void 0;
            }), this.afterRender = function(t3) {
              return function() {
                var e2;
                return (e2 = t3.delegate) != null ? e2.inputControllerDidPaste(s3) : void 0;
              };
            }(this)) : void 0;
          }, insertFromYank: function() {
            return this.insertString(this.event.data);
          }, insertLineBreak: function() {
            return this.insertString("\n");
          }, insertLink: function() {
            return this.activateAttributeIfSupported("href", this.event.data);
          }, insertOrderedList: function() {
            return this.toggleAttributeIfSupported("number");
          }, insertParagraph: function() {
            var t3;
            return (t3 = this.delegate) != null && t3.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
              var t4;
              return (t4 = this.responder) != null ? t4.insertLineBreak() : void 0;
            });
          }, insertReplacementText: function() {
            return this.insertString(this.event.dataTransfer.getData("text/plain"), {updatePosition: false});
          }, insertText: function() {
            var t3, e2;
            return this.insertString((t3 = this.event.data) != null ? t3 : (e2 = this.event.dataTransfer) != null ? e2.getData("text/plain") : void 0);
          }, insertTranspose: function() {
            return this.insertString(this.event.data);
          }, insertUnorderedList: function() {
            return this.toggleAttributeIfSupported("bullet");
          }}, u.prototype.insertString = function(t3, e2) {
            var n2;
            return t3 == null && (t3 = ""), (n2 = this.delegate) != null && n2.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
              var n3;
              return (n3 = this.responder) != null ? n3.insertString(t3, e2) : void 0;
            });
          }, u.prototype.toggleAttributeIfSupported = function(t3) {
            var n2;
            return a.call(e.getAllAttributeNames(), t3) >= 0 ? ((n2 = this.delegate) != null && n2.inputControllerWillPerformFormatting(t3), this.withTargetDOMRange(function() {
              var e2;
              return (e2 = this.responder) != null ? e2.toggleCurrentAttribute(t3) : void 0;
            })) : void 0;
          }, u.prototype.activateAttributeIfSupported = function(t3, n2) {
            var i2;
            return a.call(e.getAllAttributeNames(), t3) >= 0 ? ((i2 = this.delegate) != null && i2.inputControllerWillPerformFormatting(t3), this.withTargetDOMRange(function() {
              var e2;
              return (e2 = this.responder) != null ? e2.setCurrentAttribute(t3, n2) : void 0;
            })) : void 0;
          }, u.prototype.deleteInDirection = function(t3, e2) {
            var n2, i2, o2, r2;
            return o2 = (e2 != null ? e2 : {recordUndoEntry: true}).recordUndoEntry, o2 && (r2 = this.delegate) != null && r2.inputControllerWillPerformTyping(), i2 = function(e3) {
              return function() {
                var n3;
                return (n3 = e3.responder) != null ? n3.deleteInDirection(t3) : void 0;
              };
            }(this), (n2 = this.getTargetDOMRange({minLength: 2})) ? this.withTargetDOMRange(n2, i2) : i2();
          }, u.prototype.withTargetDOMRange = function(t3, n2) {
            var i2;
            return typeof t3 == "function" && (n2 = t3, t3 = this.getTargetDOMRange()), t3 ? (i2 = this.responder) != null ? i2.withTargetDOMRange(t3, n2.bind(this)) : void 0 : (e.selectionChangeObserver.reset(), n2.call(this));
          }, u.prototype.getTargetDOMRange = function(t3) {
            var e2, n2, i2, o2;
            return i2 = (t3 != null ? t3 : {minLength: 0}).minLength, (o2 = typeof (e2 = this.event).getTargetRanges == "function" ? e2.getTargetRanges() : void 0) && o2.length && (n2 = f(o2[0]), i2 === 0 || n2.toString().length >= i2) ? n2 : void 0;
          }, f = function(t3) {
            var e2;
            return e2 = document.createRange(), e2.setStart(t3.startContainer, t3.startOffset), e2.setEnd(t3.endContainer, t3.endOffset), e2;
          }, u.prototype.withEvent = function(t3, e2) {
            var n2;
            this.event = t3;
            try {
              n2 = e2.call(this);
            } finally {
              this.event = null;
            }
            return n2;
          }, c = function(t3) {
            var e2, n2;
            return a.call((e2 = (n2 = t3.dataTransfer) != null ? n2.types : void 0) != null ? e2 : [], "Files") >= 0;
          }, h = function(t3) {
            var e2;
            return (e2 = t3.clipboardData) ? a.call(e2.types, "Files") >= 0 && e2.types.length === 1 && e2.files.length >= 1 : void 0;
          }, p = function(t3) {
            var e2;
            return (e2 = t3.clipboardData) ? a.call(e2.types, "text/plain") >= 0 && e2.types.length === 1 : void 0;
          }, l = function(t3) {
            var e2;
            return e2 = [], t3.altKey && e2.push("alt"), t3.shiftKey && e2.push("shift"), e2.push(t3.key), e2;
          }, d = function(t3) {
            return {x: t3.clientX, y: t3.clientY};
          }, u;
        }(e.InputController);
      }.call(this), function() {
        var t2, n, i, o, r, s, a, u, c = function(t3, e2) {
          return function() {
            return t3.apply(e2, arguments);
          };
        }, l = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            h.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, h = {}.hasOwnProperty;
        n = e.defer, i = e.handleEvent, s = e.makeElement, u = e.tagName, a = e.config, r = a.lang, t2 = a.css, o = a.keyNames, e.AttachmentEditorController = function(a2) {
          function h2(t3, e2, n2, i2) {
            this.attachmentPiece = t3, this.element = e2, this.container = n2, this.options = i2 != null ? i2 : {}, this.didBlurCaption = c(this.didBlurCaption, this), this.didChangeCaption = c(this.didChangeCaption, this), this.didInputCaption = c(this.didInputCaption, this), this.didKeyDownCaption = c(this.didKeyDownCaption, this), this.didClickActionButton = c(this.didClickActionButton, this), this.didClickToolbar = c(this.didClickToolbar, this), this.attachment = this.attachmentPiece.attachment, u(this.element) === "a" && (this.element = this.element.firstChild), this.install();
          }
          var p;
          return l(h2, a2), p = function(t3) {
            return function() {
              var e2;
              return e2 = t3.apply(this, arguments), e2["do"](), this.undos == null && (this.undos = []), this.undos.push(e2.undo);
            };
          }, h2.prototype.install = function() {
            return this.makeElementMutable(), this.addToolbar(), this.attachment.isPreviewable() ? this.installCaptionEditor() : void 0;
          }, h2.prototype.uninstall = function() {
            var t3, e2;
            for (this.savePendingCaption(); e2 = this.undos.pop(); )
              e2();
            return (t3 = this.delegate) != null ? t3.didUninstallAttachmentEditor(this) : void 0;
          }, h2.prototype.savePendingCaption = function() {
            var t3, e2, n2;
            return this.pendingCaption != null ? (t3 = this.pendingCaption, this.pendingCaption = null, t3 ? (e2 = this.delegate) != null && typeof e2.attachmentEditorDidRequestUpdatingAttributesForAttachment == "function" ? e2.attachmentEditorDidRequestUpdatingAttributesForAttachment({caption: t3}, this.attachment) : void 0 : (n2 = this.delegate) != null && typeof n2.attachmentEditorDidRequestRemovingAttributeForAttachment == "function" ? n2.attachmentEditorDidRequestRemovingAttributeForAttachment("caption", this.attachment) : void 0) : void 0;
          }, h2.prototype.makeElementMutable = p(function() {
            return {do: function(t3) {
              return function() {
                return t3.element.dataset.trixMutable = true;
              };
            }(this), undo: function(t3) {
              return function() {
                return delete t3.element.dataset.trixMutable;
              };
            }(this)};
          }), h2.prototype.addToolbar = p(function() {
            var n2;
            return n2 = s({tagName: "div", className: t2.attachmentToolbar, data: {trixMutable: true}, childNodes: s({tagName: "div", className: "trix-button-row", childNodes: s({tagName: "span", className: "trix-button-group trix-button-group--actions", childNodes: s({tagName: "button", className: "trix-button trix-button--remove", textContent: r.remove, attributes: {title: r.remove}, data: {trixAction: "remove"}})})})}), this.attachment.isPreviewable() && n2.appendChild(s({tagName: "div", className: t2.attachmentMetadataContainer, childNodes: s({tagName: "span", className: t2.attachmentMetadata, childNodes: [s({tagName: "span", className: t2.attachmentName, textContent: this.attachment.getFilename(), attributes: {title: this.attachment.getFilename()}}), s({tagName: "span", className: t2.attachmentSize, textContent: this.attachment.getFormattedFilesize()})]})})), i("click", {onElement: n2, withCallback: this.didClickToolbar}), i("click", {onElement: n2, matchingSelector: "[data-trix-action]", withCallback: this.didClickActionButton}), {do: function(t3) {
              return function() {
                return t3.element.appendChild(n2);
              };
            }(this), undo: function() {
              return function() {
                return e.removeNode(n2);
              };
            }(this)};
          }), h2.prototype.installCaptionEditor = p(function() {
            var o2, a3, u2, c2, l2;
            return c2 = s({tagName: "textarea", className: t2.attachmentCaptionEditor, attributes: {placeholder: r.captionPlaceholder}, data: {trixMutable: true}}), c2.value = this.attachmentPiece.getCaption(), l2 = c2.cloneNode(), l2.classList.add("trix-autoresize-clone"), l2.tabIndex = -1, o2 = function() {
              return l2.value = c2.value, c2.style.height = l2.scrollHeight + "px";
            }, i("input", {onElement: c2, withCallback: o2}), i("input", {onElement: c2, withCallback: this.didInputCaption}), i("keydown", {onElement: c2, withCallback: this.didKeyDownCaption}), i("change", {onElement: c2, withCallback: this.didChangeCaption}), i("blur", {onElement: c2, withCallback: this.didBlurCaption}), u2 = this.element.querySelector("figcaption"), a3 = u2.cloneNode(), {do: function(e2) {
              return function() {
                return u2.style.display = "none", a3.appendChild(c2), a3.appendChild(l2), a3.classList.add(t2.attachmentCaption + "--editing"), u2.parentElement.insertBefore(a3, u2), o2(), e2.options.editCaption ? n(function() {
                  return c2.focus();
                }) : void 0;
              };
            }(this), undo: function() {
              return e.removeNode(a3), u2.style.display = null;
            }};
          }), h2.prototype.didClickToolbar = function(t3) {
            return t3.preventDefault(), t3.stopPropagation();
          }, h2.prototype.didClickActionButton = function(t3) {
            var e2, n2;
            switch (e2 = t3.target.getAttribute("data-trix-action")) {
              case "remove":
                return (n2 = this.delegate) != null ? n2.attachmentEditorDidRequestRemovalOfAttachment(this.attachment) : void 0;
            }
          }, h2.prototype.didKeyDownCaption = function(t3) {
            var e2;
            return o[t3.keyCode] === "return" ? (t3.preventDefault(), this.savePendingCaption(), (e2 = this.delegate) != null && typeof e2.attachmentEditorDidRequestDeselectingAttachment == "function" ? e2.attachmentEditorDidRequestDeselectingAttachment(this.attachment) : void 0) : void 0;
          }, h2.prototype.didInputCaption = function(t3) {
            return this.pendingCaption = t3.target.value.replace(/\s/g, " ").trim();
          }, h2.prototype.didChangeCaption = function() {
            return this.savePendingCaption();
          }, h2.prototype.didBlurCaption = function() {
            return this.savePendingCaption();
          }, h2;
        }(e.BasicObject);
      }.call(this), function() {
        var t2, n, i, o = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            r.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, r = {}.hasOwnProperty;
        i = e.makeElement, t2 = e.config.css, e.AttachmentView = function(r2) {
          function s() {
            s.__super__.constructor.apply(this, arguments), this.attachment = this.object, this.attachment.uploadProgressDelegate = this, this.attachmentPiece = this.options.piece;
          }
          var a;
          return o(s, r2), s.attachmentSelector = "[data-trix-attachment]", s.prototype.createContentNodes = function() {
            return [];
          }, s.prototype.createNodes = function() {
            var e2, n2, o2, r3, s2, u, c;
            if (e2 = r3 = i({tagName: "figure", className: this.getClassName(), data: this.getData(), editable: false}), (n2 = this.getHref()) && (r3 = i({tagName: "a", editable: false, attributes: {href: n2, tabindex: -1}}), e2.appendChild(r3)), this.attachment.hasContent())
              r3.innerHTML = this.attachment.getContent();
            else
              for (c = this.createContentNodes(), o2 = 0, s2 = c.length; s2 > o2; o2++)
                u = c[o2], r3.appendChild(u);
            return r3.appendChild(this.createCaptionElement()), this.attachment.isPending() && (this.progressElement = i({tagName: "progress", attributes: {class: t2.attachmentProgress, value: this.attachment.getUploadProgress(), max: 100}, data: {trixMutable: true, trixStoreKey: ["progressElement", this.attachment.id].join("/")}}), e2.appendChild(this.progressElement)), [a("left"), e2, a("right")];
          }, s.prototype.createCaptionElement = function() {
            var e2, n2, o2, r3, s2, a2, u;
            return o2 = i({tagName: "figcaption", className: t2.attachmentCaption}), (e2 = this.attachmentPiece.getCaption()) ? (o2.classList.add(t2.attachmentCaption + "--edited"), o2.textContent = e2) : (n2 = this.getCaptionConfig(), n2.name && (r3 = this.attachment.getFilename()), n2.size && (a2 = this.attachment.getFormattedFilesize()), r3 && (s2 = i({tagName: "span", className: t2.attachmentName, textContent: r3}), o2.appendChild(s2)), a2 && (r3 && o2.appendChild(document.createTextNode(" ")), u = i({tagName: "span", className: t2.attachmentSize, textContent: a2}), o2.appendChild(u))), o2;
          }, s.prototype.getClassName = function() {
            var e2, n2;
            return n2 = [t2.attachment, t2.attachment + "--" + this.attachment.getType()], (e2 = this.attachment.getExtension()) && n2.push(t2.attachment + "--" + e2), n2.join(" ");
          }, s.prototype.getData = function() {
            var t3, e2;
            return e2 = {trixAttachment: JSON.stringify(this.attachment), trixContentType: this.attachment.getContentType(), trixId: this.attachment.id}, t3 = this.attachmentPiece.attributes, t3.isEmpty() || (e2.trixAttributes = JSON.stringify(t3)), this.attachment.isPending() && (e2.trixSerialize = false), e2;
          }, s.prototype.getHref = function() {
            return n(this.attachment.getContent(), "a") ? void 0 : this.attachment.getHref();
          }, s.prototype.getCaptionConfig = function() {
            var t3, n2, i2;
            return i2 = this.attachment.getType(), t3 = e.copyObject((n2 = e.config.attachments[i2]) != null ? n2.caption : void 0), i2 === "file" && (t3.name = true), t3;
          }, s.prototype.findProgressElement = function() {
            var t3;
            return (t3 = this.findElement()) != null ? t3.querySelector("progress") : void 0;
          }, a = function(t3) {
            return i({tagName: "span", textContent: e.ZERO_WIDTH_SPACE, data: {trixCursorTarget: t3, trixSerialize: false}});
          }, s.prototype.attachmentDidChangeUploadProgress = function() {
            var t3, e2;
            return e2 = this.attachment.getUploadProgress(), (t3 = this.findProgressElement()) != null ? t3.value = e2 : void 0;
          }, s;
        }(e.ObjectView), n = function(t3, e2) {
          var n2;
          return n2 = i("div"), n2.innerHTML = t3 != null ? t3 : "", n2.querySelector(e2);
        };
      }.call(this), function() {
        var t2, n = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var o in e2)
            i.call(e2, o) && (t3[o] = e2[o]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, i = {}.hasOwnProperty;
        t2 = e.makeElement, e.PreviewableAttachmentView = function(i2) {
          function o() {
            o.__super__.constructor.apply(this, arguments), this.attachment.previewDelegate = this;
          }
          return n(o, i2), o.prototype.createContentNodes = function() {
            return this.image = t2({tagName: "img", attributes: {src: ""}, data: {trixMutable: true}}), this.refresh(this.image), [this.image];
          }, o.prototype.createCaptionElement = function() {
            var t3;
            return t3 = o.__super__.createCaptionElement.apply(this, arguments), t3.textContent || t3.setAttribute("data-trix-placeholder", e.config.lang.captionPlaceholder), t3;
          }, o.prototype.refresh = function(t3) {
            var e2;
            return t3 == null && (t3 = (e2 = this.findElement()) != null ? e2.querySelector("img") : void 0), t3 ? this.updateAttributesForImage(t3) : void 0;
          }, o.prototype.updateAttributesForImage = function(t3) {
            var e2, n2, i3, o2, r, s;
            return r = this.attachment.getURL(), n2 = this.attachment.getPreviewURL(), t3.src = n2 || r, n2 === r ? t3.removeAttribute("data-trix-serialized-attributes") : (i3 = JSON.stringify({src: r}), t3.setAttribute("data-trix-serialized-attributes", i3)), s = this.attachment.getWidth(), e2 = this.attachment.getHeight(), s != null && (t3.width = s), e2 != null && (t3.height = e2), o2 = ["imageElement", this.attachment.id, t3.src, t3.width, t3.height].join("/"), t3.dataset.trixStoreKey = o2;
          }, o.prototype.attachmentDidChangeAttributes = function() {
            return this.refresh(this.image), this.refresh();
          }, o;
        }(e.AttachmentView);
      }.call(this), function() {
        var t2, n, i, o = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            r.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, r = {}.hasOwnProperty;
        i = e.makeElement, t2 = e.findInnerElement, n = e.getTextConfig, e.PieceView = function(r2) {
          function s() {
            var t3;
            s.__super__.constructor.apply(this, arguments), this.piece = this.object, this.attributes = this.piece.getAttributes(), t3 = this.options, this.textConfig = t3.textConfig, this.context = t3.context, this.piece.attachment ? this.attachment = this.piece.attachment : this.string = this.piece.toString();
          }
          var a;
          return o(s, r2), s.prototype.createNodes = function() {
            var e2, n2, i2, o2, r3, s2;
            if (s2 = this.attachment ? this.createAttachmentNodes() : this.createStringNodes(), e2 = this.createElement()) {
              for (i2 = t2(e2), n2 = 0, o2 = s2.length; o2 > n2; n2++)
                r3 = s2[n2], i2.appendChild(r3);
              s2 = [e2];
            }
            return s2;
          }, s.prototype.createAttachmentNodes = function() {
            var t3, n2;
            return t3 = this.attachment.isPreviewable() ? e.PreviewableAttachmentView : e.AttachmentView, n2 = this.createChildView(t3, this.piece.attachment, {piece: this.piece}), n2.getNodes();
          }, s.prototype.createStringNodes = function() {
            var t3, e2, n2, o2, r3, s2, a2, u, c, l;
            if ((u = this.textConfig) != null ? u.plaintext : void 0)
              return [document.createTextNode(this.string)];
            for (a2 = [], c = this.string.split("\n"), n2 = e2 = 0, o2 = c.length; o2 > e2; n2 = ++e2)
              l = c[n2], n2 > 0 && (t3 = i("br"), a2.push(t3)), (r3 = l.length) && (s2 = document.createTextNode(this.preserveSpaces(l)), a2.push(s2));
            return a2;
          }, s.prototype.createElement = function() {
            var t3, e2, o2, r3, s2, a2, u, c, l;
            c = {}, a2 = this.attributes;
            for (r3 in a2)
              if (l = a2[r3], (t3 = n(r3)) && (t3.tagName && (s2 = i(t3.tagName), o2 ? (o2.appendChild(s2), o2 = s2) : e2 = o2 = s2), t3.styleProperty && (c[t3.styleProperty] = l), t3.style)) {
                u = t3.style;
                for (r3 in u)
                  l = u[r3], c[r3] = l;
              }
            if (Object.keys(c).length) {
              e2 == null && (e2 = i("span"));
              for (r3 in c)
                l = c[r3], e2.style[r3] = l;
            }
            return e2;
          }, s.prototype.createContainerElement = function() {
            var t3, e2, o2, r3, s2;
            r3 = this.attributes;
            for (o2 in r3)
              if (s2 = r3[o2], (e2 = n(o2)) && e2.groupTagName)
                return t3 = {}, t3[o2] = s2, i(e2.groupTagName, t3);
          }, a = e.NON_BREAKING_SPACE, s.prototype.preserveSpaces = function(t3) {
            return this.context.isLast && (t3 = t3.replace(/\ $/, a)), t3 = t3.replace(/(\S)\ {3}(\S)/g, "$1 " + a + " $2").replace(/\ {2}/g, a + " ").replace(/\ {2}/g, " " + a), (this.context.isFirst || this.context.followsWhitespace) && (t3 = t3.replace(/^\ /, a)), t3;
          }, s;
        }(e.ObjectView);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.TextView = function(n2) {
          function i() {
            i.__super__.constructor.apply(this, arguments), this.text = this.object, this.textConfig = this.options.textConfig;
          }
          var o;
          return t2(i, n2), i.prototype.createNodes = function() {
            var t3, n3, i2, r, s, a, u, c, l, h;
            for (a = [], c = e.ObjectGroup.groupObjects(this.getPieces()), r = c.length - 1, i2 = n3 = 0, s = c.length; s > n3; i2 = ++n3)
              u = c[i2], t3 = {}, i2 === 0 && (t3.isFirst = true), i2 === r && (t3.isLast = true), o(l) && (t3.followsWhitespace = true), h = this.findOrCreateCachedChildView(e.PieceView, u, {textConfig: this.textConfig, context: t3}), a.push.apply(a, h.getNodes()), l = u;
            return a;
          }, i.prototype.getPieces = function() {
            var t3, e2, n3, i2, o2;
            for (i2 = this.text.getPieces(), o2 = [], t3 = 0, e2 = i2.length; e2 > t3; t3++)
              n3 = i2[t3], n3.hasAttribute("blockBreak") || o2.push(n3);
            return o2;
          }, o = function(t3) {
            return /\s$/.test(t3 != null ? t3.toString() : void 0);
          }, i;
        }(e.ObjectView);
      }.call(this), function() {
        var t2, n, i, o = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            r.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, r = {}.hasOwnProperty;
        i = e.makeElement, n = e.getBlockConfig, t2 = e.config.css, e.BlockView = function(r2) {
          function s() {
            s.__super__.constructor.apply(this, arguments), this.block = this.object, this.attributes = this.block.getAttributes();
          }
          return o(s, r2), s.prototype.createNodes = function() {
            var t3, o2, r3, s2, a, u, c, l, h, p, d;
            if (o2 = document.createComment("block"), c = [o2], this.block.isEmpty() ? c.push(i("br")) : (p = (l = n(this.block.getLastAttribute())) != null ? l.text : void 0, d = this.findOrCreateCachedChildView(e.TextView, this.block.text, {textConfig: p}), c.push.apply(c, d.getNodes()), this.shouldAddExtraNewlineElement() && c.push(i("br"))), this.attributes.length)
              return c;
            for (h = e.config.blockAttributes["default"].tagName, this.block.isRTL() && (t3 = {dir: "rtl"}), r3 = i({tagName: h, attributes: t3}), s2 = 0, a = c.length; a > s2; s2++)
              u = c[s2], r3.appendChild(u);
            return [r3];
          }, s.prototype.createContainerElement = function(e2) {
            var o2, r3, s2, a, u;
            return o2 = this.attributes[e2], u = n(o2).tagName, e2 === 0 && this.block.isRTL() && (r3 = {dir: "rtl"}), o2 === "attachmentGallery" && (a = this.block.getBlockBreakPosition(), s2 = t2.attachmentGallery + " " + t2.attachmentGallery + "--" + a), i({tagName: u, className: s2, attributes: r3});
          }, s.prototype.shouldAddExtraNewlineElement = function() {
            return /\n\n$/.test(this.block.toString());
          }, s;
        }(e.ObjectView);
      }.call(this), function() {
        var t2, n, i = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            o.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, o = {}.hasOwnProperty;
        t2 = e.defer, n = e.makeElement, e.DocumentView = function(o2) {
          function r() {
            r.__super__.constructor.apply(this, arguments), this.element = this.options.element, this.elementStore = new e.ElementStore(), this.setDocument(this.object);
          }
          var s, a, u;
          return i(r, o2), r.render = function(t3) {
            var e2, i2;
            return e2 = n("div"), i2 = new this(t3, {element: e2}), i2.render(), i2.sync(), e2;
          }, r.prototype.setDocument = function(t3) {
            return t3.isEqualTo(this.document) ? void 0 : this.document = this.object = t3;
          }, r.prototype.render = function() {
            var t3, i2, o3, r2, s2, a2, u2;
            if (this.childViews = [], this.shadowElement = n("div"), !this.document.isEmpty()) {
              for (s2 = e.ObjectGroup.groupObjects(this.document.getBlocks(), {asTree: true}), a2 = [], t3 = 0, i2 = s2.length; i2 > t3; t3++)
                r2 = s2[t3], u2 = this.findOrCreateCachedChildView(e.BlockView, r2), a2.push(function() {
                  var t4, e2, n2, i3;
                  for (n2 = u2.getNodes(), i3 = [], t4 = 0, e2 = n2.length; e2 > t4; t4++)
                    o3 = n2[t4], i3.push(this.shadowElement.appendChild(o3));
                  return i3;
                }.call(this));
              return a2;
            }
          }, r.prototype.isSynced = function() {
            return s(this.shadowElement, this.element);
          }, r.prototype.sync = function() {
            var t3;
            for (t3 = this.createDocumentFragmentForSync(); this.element.lastChild; )
              this.element.removeChild(this.element.lastChild);
            return this.element.appendChild(t3), this.didSync();
          }, r.prototype.didSync = function() {
            return this.elementStore.reset(a(this.element)), t2(function(t3) {
              return function() {
                return t3.garbageCollectCachedViews();
              };
            }(this));
          }, r.prototype.createDocumentFragmentForSync = function() {
            var t3, e2, n2, i2, o3, r2, s2, u2, c, l;
            for (e2 = document.createDocumentFragment(), u2 = this.shadowElement.childNodes, n2 = 0, o3 = u2.length; o3 > n2; n2++)
              s2 = u2[n2], e2.appendChild(s2.cloneNode(true));
            for (c = a(e2), i2 = 0, r2 = c.length; r2 > i2; i2++)
              t3 = c[i2], (l = this.elementStore.remove(t3)) && t3.parentNode.replaceChild(l, t3);
            return e2;
          }, a = function(t3) {
            return t3.querySelectorAll("[data-trix-store-key]");
          }, s = function(t3, e2) {
            return u(t3.innerHTML) === u(e2.innerHTML);
          }, u = function(t3) {
            return t3.replace(/&nbsp;/g, " ");
          }, r;
        }(e.ObjectView);
      }.call(this), function() {
        var t2, n, i, o, r, s = function(t3, e2) {
          return function() {
            return t3.apply(e2, arguments);
          };
        }, a = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            u.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, u = {}.hasOwnProperty;
        i = e.findClosestElementFromNode, o = e.handleEvent, r = e.innerElementIsActive, n = e.defer, t2 = e.AttachmentView.attachmentSelector, e.CompositionController = function(u2) {
          function c(n2, i2) {
            this.element = n2, this.composition = i2, this.didClickAttachment = s(this.didClickAttachment, this), this.didBlur = s(this.didBlur, this), this.didFocus = s(this.didFocus, this), this.documentView = new e.DocumentView(this.composition.document, {element: this.element}), o("focus", {onElement: this.element, withCallback: this.didFocus}), o("blur", {onElement: this.element, withCallback: this.didBlur}), o("click", {onElement: this.element, matchingSelector: "a[contenteditable=false]", preventDefault: true}), o("mousedown", {onElement: this.element, matchingSelector: t2, withCallback: this.didClickAttachment}), o("click", {onElement: this.element, matchingSelector: "a" + t2, preventDefault: true});
          }
          return a(c, u2), c.prototype.didFocus = function() {
            var t3, e2, n2;
            return t3 = function(t4) {
              return function() {
                var e3;
                return t4.focused ? void 0 : (t4.focused = true, (e3 = t4.delegate) != null && typeof e3.compositionControllerDidFocus == "function" ? e3.compositionControllerDidFocus() : void 0);
              };
            }(this), (e2 = (n2 = this.blurPromise) != null ? n2.then(t3) : void 0) != null ? e2 : t3();
          }, c.prototype.didBlur = function() {
            return this.blurPromise = new Promise(function(t3) {
              return function(e2) {
                return n(function() {
                  var n2;
                  return r(t3.element) || (t3.focused = null, (n2 = t3.delegate) != null && typeof n2.compositionControllerDidBlur == "function" && n2.compositionControllerDidBlur()), t3.blurPromise = null, e2();
                });
              };
            }(this));
          }, c.prototype.didClickAttachment = function(t3, e2) {
            var n2, o2, r2;
            return n2 = this.findAttachmentForElement(e2), o2 = i(t3.target, {matchingSelector: "figcaption"}) != null, (r2 = this.delegate) != null && typeof r2.compositionControllerDidSelectAttachment == "function" ? r2.compositionControllerDidSelectAttachment(n2, {editCaption: o2}) : void 0;
          }, c.prototype.getSerializableElement = function() {
            return this.isEditingAttachment() ? this.documentView.shadowElement : this.element;
          }, c.prototype.render = function() {
            var t3, e2, n2;
            return this.revision !== this.composition.revision && (this.documentView.setDocument(this.composition.document), this.documentView.render(), this.revision = this.composition.revision), this.canSyncDocumentView() && !this.documentView.isSynced() && ((t3 = this.delegate) != null && typeof t3.compositionControllerWillSyncDocumentView == "function" && t3.compositionControllerWillSyncDocumentView(), this.documentView.sync(), (e2 = this.delegate) != null && typeof e2.compositionControllerDidSyncDocumentView == "function" && e2.compositionControllerDidSyncDocumentView()), (n2 = this.delegate) != null && typeof n2.compositionControllerDidRender == "function" ? n2.compositionControllerDidRender() : void 0;
          }, c.prototype.rerenderViewForObject = function(t3) {
            return this.invalidateViewForObject(t3), this.render();
          }, c.prototype.invalidateViewForObject = function(t3) {
            return this.documentView.invalidateViewForObject(t3);
          }, c.prototype.isViewCachingEnabled = function() {
            return this.documentView.isViewCachingEnabled();
          }, c.prototype.enableViewCaching = function() {
            return this.documentView.enableViewCaching();
          }, c.prototype.disableViewCaching = function() {
            return this.documentView.disableViewCaching();
          }, c.prototype.refreshViewCache = function() {
            return this.documentView.garbageCollectCachedViews();
          }, c.prototype.isEditingAttachment = function() {
            return this.attachmentEditor != null;
          }, c.prototype.installAttachmentEditorForAttachment = function(t3, n2) {
            var i2, o2, r2;
            if (((r2 = this.attachmentEditor) != null ? r2.attachment : void 0) !== t3 && (o2 = this.documentView.findElementForObject(t3)))
              return this.uninstallAttachmentEditor(), i2 = this.composition.document.getAttachmentPieceForAttachment(t3), this.attachmentEditor = new e.AttachmentEditorController(i2, o2, this.element, n2), this.attachmentEditor.delegate = this;
          }, c.prototype.uninstallAttachmentEditor = function() {
            var t3;
            return (t3 = this.attachmentEditor) != null ? t3.uninstall() : void 0;
          }, c.prototype.didUninstallAttachmentEditor = function() {
            return this.attachmentEditor = null, this.render();
          }, c.prototype.attachmentEditorDidRequestUpdatingAttributesForAttachment = function(t3, e2) {
            var n2;
            return (n2 = this.delegate) != null && typeof n2.compositionControllerWillUpdateAttachment == "function" && n2.compositionControllerWillUpdateAttachment(e2), this.composition.updateAttributesForAttachment(t3, e2);
          }, c.prototype.attachmentEditorDidRequestRemovingAttributeForAttachment = function(t3, e2) {
            var n2;
            return (n2 = this.delegate) != null && typeof n2.compositionControllerWillUpdateAttachment == "function" && n2.compositionControllerWillUpdateAttachment(e2), this.composition.removeAttributeForAttachment(t3, e2);
          }, c.prototype.attachmentEditorDidRequestRemovalOfAttachment = function(t3) {
            var e2;
            return (e2 = this.delegate) != null && typeof e2.compositionControllerDidRequestRemovalOfAttachment == "function" ? e2.compositionControllerDidRequestRemovalOfAttachment(t3) : void 0;
          }, c.prototype.attachmentEditorDidRequestDeselectingAttachment = function(t3) {
            var e2;
            return (e2 = this.delegate) != null && typeof e2.compositionControllerDidRequestDeselectingAttachment == "function" ? e2.compositionControllerDidRequestDeselectingAttachment(t3) : void 0;
          }, c.prototype.canSyncDocumentView = function() {
            return !this.isEditingAttachment();
          }, c.prototype.findAttachmentForElement = function(t3) {
            return this.composition.document.getAttachmentById(parseInt(t3.dataset.trixId, 10));
          }, c;
        }(e.BasicObject);
      }.call(this), function() {
        var t2, n, i, o = function(t3, e2) {
          return function() {
            return t3.apply(e2, arguments);
          };
        }, r = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            s.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, s = {}.hasOwnProperty;
        n = e.handleEvent, i = e.triggerEvent, t2 = e.findClosestElementFromNode, e.ToolbarController = function(e2) {
          function s2(t3) {
            this.element = t3, this.didKeyDownDialogInput = o(this.didKeyDownDialogInput, this), this.didClickDialogButton = o(this.didClickDialogButton, this), this.didClickAttributeButton = o(this.didClickAttributeButton, this), this.didClickActionButton = o(this.didClickActionButton, this), this.attributes = {}, this.actions = {}, this.resetDialogInputs(), n("mousedown", {onElement: this.element, matchingSelector: a, withCallback: this.didClickActionButton}), n("mousedown", {onElement: this.element, matchingSelector: c, withCallback: this.didClickAttributeButton}), n("click", {onElement: this.element, matchingSelector: v, preventDefault: true}), n("click", {onElement: this.element, matchingSelector: l, withCallback: this.didClickDialogButton}), n("keydown", {onElement: this.element, matchingSelector: h, withCallback: this.didKeyDownDialogInput});
          }
          var a, u, c, l, h, p, d, f, g, m, v;
          return r(s2, e2), c = "[data-trix-attribute]", a = "[data-trix-action]", v = c + ", " + a, p = "[data-trix-dialog]", u = p + "[data-trix-active]", l = p + " [data-trix-method]", h = p + " [data-trix-input]", s2.prototype.didClickActionButton = function(t3, e3) {
            var n2, i2, o2;
            return (i2 = this.delegate) != null && i2.toolbarDidClickButton(), t3.preventDefault(), n2 = d(e3), this.getDialog(n2) ? this.toggleDialog(n2) : (o2 = this.delegate) != null ? o2.toolbarDidInvokeAction(n2) : void 0;
          }, s2.prototype.didClickAttributeButton = function(t3, e3) {
            var n2, i2, o2;
            return (i2 = this.delegate) != null && i2.toolbarDidClickButton(), t3.preventDefault(), n2 = f(e3), this.getDialog(n2) ? this.toggleDialog(n2) : (o2 = this.delegate) != null && o2.toolbarDidToggleAttribute(n2), this.refreshAttributeButtons();
          }, s2.prototype.didClickDialogButton = function(e3, n2) {
            var i2, o2;
            return i2 = t2(n2, {matchingSelector: p}), o2 = n2.getAttribute("data-trix-method"), this[o2].call(this, i2);
          }, s2.prototype.didKeyDownDialogInput = function(t3, e3) {
            var n2, i2;
            return t3.keyCode === 13 && (t3.preventDefault(), n2 = e3.getAttribute("name"), i2 = this.getDialog(n2), this.setAttribute(i2)), t3.keyCode === 27 ? (t3.preventDefault(), this.hideDialog()) : void 0;
          }, s2.prototype.updateActions = function(t3) {
            return this.actions = t3, this.refreshActionButtons();
          }, s2.prototype.refreshActionButtons = function() {
            return this.eachActionButton(function(t3) {
              return function(e3, n2) {
                return e3.disabled = t3.actions[n2] === false;
              };
            }(this));
          }, s2.prototype.eachActionButton = function(t3) {
            var e3, n2, i2, o2, r2;
            for (o2 = this.element.querySelectorAll(a), r2 = [], n2 = 0, i2 = o2.length; i2 > n2; n2++)
              e3 = o2[n2], r2.push(t3(e3, d(e3)));
            return r2;
          }, s2.prototype.updateAttributes = function(t3) {
            return this.attributes = t3, this.refreshAttributeButtons();
          }, s2.prototype.refreshAttributeButtons = function() {
            return this.eachAttributeButton(function(t3) {
              return function(e3, n2) {
                return e3.disabled = t3.attributes[n2] === false, t3.attributes[n2] || t3.dialogIsVisible(n2) ? (e3.setAttribute("data-trix-active", ""), e3.classList.add("trix-active")) : (e3.removeAttribute("data-trix-active"), e3.classList.remove("trix-active"));
              };
            }(this));
          }, s2.prototype.eachAttributeButton = function(t3) {
            var e3, n2, i2, o2, r2;
            for (o2 = this.element.querySelectorAll(c), r2 = [], n2 = 0, i2 = o2.length; i2 > n2; n2++)
              e3 = o2[n2], r2.push(t3(e3, f(e3)));
            return r2;
          }, s2.prototype.applyKeyboardCommand = function(t3) {
            var e3, n2, o2, r2, s3, a2, u2;
            for (s3 = JSON.stringify(t3.sort()), u2 = this.element.querySelectorAll("[data-trix-key]"), r2 = 0, a2 = u2.length; a2 > r2; r2++)
              if (e3 = u2[r2], o2 = e3.getAttribute("data-trix-key").split("+"), n2 = JSON.stringify(o2.sort()), n2 === s3)
                return i("mousedown", {onElement: e3}), true;
            return false;
          }, s2.prototype.dialogIsVisible = function(t3) {
            var e3;
            return (e3 = this.getDialog(t3)) ? e3.hasAttribute("data-trix-active") : void 0;
          }, s2.prototype.toggleDialog = function(t3) {
            return this.dialogIsVisible(t3) ? this.hideDialog() : this.showDialog(t3);
          }, s2.prototype.showDialog = function(t3) {
            var e3, n2, i2, o2, r2, s3, a2, u2, c2, l2;
            for (this.hideDialog(), (a2 = this.delegate) != null && a2.toolbarWillShowDialog(), i2 = this.getDialog(t3), i2.setAttribute("data-trix-active", ""), i2.classList.add("trix-active"), u2 = i2.querySelectorAll("input[disabled]"), o2 = 0, s3 = u2.length; s3 > o2; o2++)
              n2 = u2[o2], n2.removeAttribute("disabled");
            return (e3 = f(i2)) && (r2 = m(i2, t3)) && (r2.value = (c2 = this.attributes[e3]) != null ? c2 : "", r2.select()), (l2 = this.delegate) != null ? l2.toolbarDidShowDialog(t3) : void 0;
          }, s2.prototype.setAttribute = function(t3) {
            var e3, n2, i2;
            return e3 = f(t3), n2 = m(t3, e3), n2.willValidate && !n2.checkValidity() ? (n2.setAttribute("data-trix-validate", ""), n2.classList.add("trix-validate"), n2.focus()) : ((i2 = this.delegate) != null && i2.toolbarDidUpdateAttribute(e3, n2.value), this.hideDialog());
          }, s2.prototype.removeAttribute = function(t3) {
            var e3, n2;
            return e3 = f(t3), (n2 = this.delegate) != null && n2.toolbarDidRemoveAttribute(e3), this.hideDialog();
          }, s2.prototype.hideDialog = function() {
            var t3, e3;
            return (t3 = this.element.querySelector(u)) ? (t3.removeAttribute("data-trix-active"), t3.classList.remove("trix-active"), this.resetDialogInputs(), (e3 = this.delegate) != null ? e3.toolbarDidHideDialog(g(t3)) : void 0) : void 0;
          }, s2.prototype.resetDialogInputs = function() {
            var t3, e3, n2, i2, o2;
            for (i2 = this.element.querySelectorAll(h), o2 = [], t3 = 0, n2 = i2.length; n2 > t3; t3++)
              e3 = i2[t3], e3.setAttribute("disabled", "disabled"), e3.removeAttribute("data-trix-validate"), o2.push(e3.classList.remove("trix-validate"));
            return o2;
          }, s2.prototype.getDialog = function(t3) {
            return this.element.querySelector("[data-trix-dialog=" + t3 + "]");
          }, m = function(t3, e3) {
            return e3 == null && (e3 = f(t3)), t3.querySelector("[data-trix-input][name='" + e3 + "']");
          }, d = function(t3) {
            return t3.getAttribute("data-trix-action");
          }, f = function(t3) {
            var e3;
            return (e3 = t3.getAttribute("data-trix-attribute")) != null ? e3 : t3.getAttribute("data-trix-dialog-attribute");
          }, g = function(t3) {
            return t3.getAttribute("data-trix-dialog");
          }, s2;
        }(e.BasicObject);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.ImagePreloadOperation = function(e2) {
          function n2(t3) {
            this.url = t3;
          }
          return t2(n2, e2), n2.prototype.perform = function(t3) {
            var e3;
            return e3 = new Image(), e3.onload = function(n3) {
              return function() {
                return e3.width = n3.width = e3.naturalWidth, e3.height = n3.height = e3.naturalHeight, t3(true, e3);
              };
            }(this), e3.onerror = function() {
              return t3(false);
            }, e3.src = this.url;
          }, n2;
        }(e.Operation);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          return function() {
            return t3.apply(e2, arguments);
          };
        }, n = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var o in e2)
            i.call(e2, o) && (t3[o] = e2[o]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, i = {}.hasOwnProperty;
        e.Attachment = function(i2) {
          function o(n2) {
            n2 == null && (n2 = {}), this.releaseFile = t2(this.releaseFile, this), o.__super__.constructor.apply(this, arguments), this.attributes = e.Hash.box(n2), this.didChangeAttributes();
          }
          return n(o, i2), o.previewablePattern = /^image(\/(gif|png|jpe?g)|$)/, o.attachmentForFile = function(t3) {
            var e2, n2;
            return n2 = this.attributesForFile(t3), e2 = new this(n2), e2.setFile(t3), e2;
          }, o.attributesForFile = function(t3) {
            return new e.Hash({filename: t3.name, filesize: t3.size, contentType: t3.type});
          }, o.fromJSON = function(t3) {
            return new this(t3);
          }, o.prototype.getAttribute = function(t3) {
            return this.attributes.get(t3);
          }, o.prototype.hasAttribute = function(t3) {
            return this.attributes.has(t3);
          }, o.prototype.getAttributes = function() {
            return this.attributes.toObject();
          }, o.prototype.setAttributes = function(t3) {
            var e2, n2, i3;
            return t3 == null && (t3 = {}), e2 = this.attributes.merge(t3), this.attributes.isEqualTo(e2) ? void 0 : (this.attributes = e2, this.didChangeAttributes(), (n2 = this.previewDelegate) != null && typeof n2.attachmentDidChangeAttributes == "function" && n2.attachmentDidChangeAttributes(this), (i3 = this.delegate) != null && typeof i3.attachmentDidChangeAttributes == "function" ? i3.attachmentDidChangeAttributes(this) : void 0);
          }, o.prototype.didChangeAttributes = function() {
            return this.isPreviewable() ? this.preloadURL() : void 0;
          }, o.prototype.isPending = function() {
            return this.file != null && !(this.getURL() || this.getHref());
          }, o.prototype.isPreviewable = function() {
            return this.attributes.has("previewable") ? this.attributes.get("previewable") : this.constructor.previewablePattern.test(this.getContentType());
          }, o.prototype.getType = function() {
            return this.hasContent() ? "content" : this.isPreviewable() ? "preview" : "file";
          }, o.prototype.getURL = function() {
            return this.attributes.get("url");
          }, o.prototype.getHref = function() {
            return this.attributes.get("href");
          }, o.prototype.getFilename = function() {
            var t3;
            return (t3 = this.attributes.get("filename")) != null ? t3 : "";
          }, o.prototype.getFilesize = function() {
            return this.attributes.get("filesize");
          }, o.prototype.getFormattedFilesize = function() {
            var t3;
            return t3 = this.attributes.get("filesize"), typeof t3 == "number" ? e.config.fileSize.formatter(t3) : "";
          }, o.prototype.getExtension = function() {
            var t3;
            return (t3 = this.getFilename().match(/\.(\w+)$/)) != null ? t3[1].toLowerCase() : void 0;
          }, o.prototype.getContentType = function() {
            return this.attributes.get("contentType");
          }, o.prototype.hasContent = function() {
            return this.attributes.has("content");
          }, o.prototype.getContent = function() {
            return this.attributes.get("content");
          }, o.prototype.getWidth = function() {
            return this.attributes.get("width");
          }, o.prototype.getHeight = function() {
            return this.attributes.get("height");
          }, o.prototype.getFile = function() {
            return this.file;
          }, o.prototype.setFile = function(t3) {
            return this.file = t3, this.isPreviewable() ? this.preloadFile() : void 0;
          }, o.prototype.releaseFile = function() {
            return this.releasePreloadedFile(), this.file = null;
          }, o.prototype.getUploadProgress = function() {
            var t3;
            return (t3 = this.uploadProgress) != null ? t3 : 0;
          }, o.prototype.setUploadProgress = function(t3) {
            var e2;
            return this.uploadProgress !== t3 ? (this.uploadProgress = t3, (e2 = this.uploadProgressDelegate) != null && typeof e2.attachmentDidChangeUploadProgress == "function" ? e2.attachmentDidChangeUploadProgress(this) : void 0) : void 0;
          }, o.prototype.toJSON = function() {
            return this.getAttributes();
          }, o.prototype.getCacheKey = function() {
            return [o.__super__.getCacheKey.apply(this, arguments), this.attributes.getCacheKey(), this.getPreviewURL()].join("/");
          }, o.prototype.getPreviewURL = function() {
            return this.previewURL || this.preloadingURL;
          }, o.prototype.setPreviewURL = function(t3) {
            var e2, n2;
            return t3 !== this.getPreviewURL() ? (this.previewURL = t3, (e2 = this.previewDelegate) != null && typeof e2.attachmentDidChangeAttributes == "function" && e2.attachmentDidChangeAttributes(this), (n2 = this.delegate) != null && typeof n2.attachmentDidChangePreviewURL == "function" ? n2.attachmentDidChangePreviewURL(this) : void 0) : void 0;
          }, o.prototype.preloadURL = function() {
            return this.preload(this.getURL(), this.releaseFile);
          }, o.prototype.preloadFile = function() {
            return this.file ? (this.fileObjectURL = URL.createObjectURL(this.file), this.preload(this.fileObjectURL)) : void 0;
          }, o.prototype.releasePreloadedFile = function() {
            return this.fileObjectURL ? (URL.revokeObjectURL(this.fileObjectURL), this.fileObjectURL = null) : void 0;
          }, o.prototype.preload = function(t3, n2) {
            var i3;
            return t3 && t3 !== this.getPreviewURL() ? (this.preloadingURL = t3, i3 = new e.ImagePreloadOperation(t3), i3.then(function(e2) {
              return function(i4) {
                var o2, r;
                return r = i4.width, o2 = i4.height, e2.getWidth() && e2.getHeight() || e2.setAttributes({width: r, height: o2}), e2.preloadingURL = null, e2.setPreviewURL(t3), typeof n2 == "function" ? n2() : void 0;
              };
            }(this))["catch"](function(t4) {
              return function() {
                return t4.preloadingURL = null, typeof n2 == "function" ? n2() : void 0;
              };
            }(this))) : void 0;
          }, o;
        }(e.Object);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.Piece = function(n2) {
          function i(t3, n3) {
            n3 == null && (n3 = {}), i.__super__.constructor.apply(this, arguments), this.attributes = e.Hash.box(n3);
          }
          return t2(i, n2), i.types = {}, i.registerType = function(t3, e2) {
            return e2.type = t3, this.types[t3] = e2;
          }, i.fromJSON = function(t3) {
            var e2;
            return (e2 = this.types[t3.type]) ? e2.fromJSON(t3) : void 0;
          }, i.prototype.copyWithAttributes = function(t3) {
            return new this.constructor(this.getValue(), t3);
          }, i.prototype.copyWithAdditionalAttributes = function(t3) {
            return this.copyWithAttributes(this.attributes.merge(t3));
          }, i.prototype.copyWithoutAttribute = function(t3) {
            return this.copyWithAttributes(this.attributes.remove(t3));
          }, i.prototype.copy = function() {
            return this.copyWithAttributes(this.attributes);
          }, i.prototype.getAttribute = function(t3) {
            return this.attributes.get(t3);
          }, i.prototype.getAttributesHash = function() {
            return this.attributes;
          }, i.prototype.getAttributes = function() {
            return this.attributes.toObject();
          }, i.prototype.getCommonAttributes = function() {
            var t3, e2, n3;
            return (n3 = pieceList.getPieceAtIndex(0)) ? (t3 = n3.attributes, e2 = t3.getKeys(), pieceList.eachPiece(function(n4) {
              return e2 = t3.getKeysCommonToHash(n4.attributes), t3 = t3.slice(e2);
            }), t3.toObject()) : {};
          }, i.prototype.hasAttribute = function(t3) {
            return this.attributes.has(t3);
          }, i.prototype.hasSameStringValueAsPiece = function(t3) {
            return t3 != null && this.toString() === t3.toString();
          }, i.prototype.hasSameAttributesAsPiece = function(t3) {
            return t3 != null && (this.attributes === t3.attributes || this.attributes.isEqualTo(t3.attributes));
          }, i.prototype.isBlockBreak = function() {
            return false;
          }, i.prototype.isEqualTo = function(t3) {
            return i.__super__.isEqualTo.apply(this, arguments) || this.hasSameConstructorAs(t3) && this.hasSameStringValueAsPiece(t3) && this.hasSameAttributesAsPiece(t3);
          }, i.prototype.isEmpty = function() {
            return this.length === 0;
          }, i.prototype.isSerializable = function() {
            return true;
          }, i.prototype.toJSON = function() {
            return {type: this.constructor.type, attributes: this.getAttributes()};
          }, i.prototype.contentsForInspection = function() {
            return {type: this.constructor.type, attributes: this.attributes.inspect()};
          }, i.prototype.canBeGrouped = function() {
            return this.hasAttribute("href");
          }, i.prototype.canBeGroupedWith = function(t3) {
            return this.getAttribute("href") === t3.getAttribute("href");
          }, i.prototype.getLength = function() {
            return this.length;
          }, i.prototype.canBeConsolidatedWith = function() {
            return false;
          }, i;
        }(e.Object);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.Piece.registerType("attachment", e.AttachmentPiece = function(n2) {
          function i(t3) {
            this.attachment = t3, i.__super__.constructor.apply(this, arguments), this.length = 1, this.ensureAttachmentExclusivelyHasAttribute("href"), this.attachment.hasContent() || this.removeProhibitedAttributes();
          }
          return t2(i, n2), i.fromJSON = function(t3) {
            return new this(e.Attachment.fromJSON(t3.attachment), t3.attributes);
          }, i.permittedAttributes = ["caption", "presentation"], i.prototype.ensureAttachmentExclusivelyHasAttribute = function(t3) {
            return this.hasAttribute(t3) ? (this.attachment.hasAttribute(t3) || this.attachment.setAttributes(this.attributes.slice(t3)), this.attributes = this.attributes.remove(t3)) : void 0;
          }, i.prototype.removeProhibitedAttributes = function() {
            var t3;
            return t3 = this.attributes.slice(this.constructor.permittedAttributes), t3.isEqualTo(this.attributes) ? void 0 : this.attributes = t3;
          }, i.prototype.getValue = function() {
            return this.attachment;
          }, i.prototype.isSerializable = function() {
            return !this.attachment.isPending();
          }, i.prototype.getCaption = function() {
            var t3;
            return (t3 = this.attributes.get("caption")) != null ? t3 : "";
          }, i.prototype.isEqualTo = function(t3) {
            var e2;
            return i.__super__.isEqualTo.apply(this, arguments) && this.attachment.id === (t3 != null && (e2 = t3.attachment) != null ? e2.id : void 0);
          }, i.prototype.toString = function() {
            return e.OBJECT_REPLACEMENT_CHARACTER;
          }, i.prototype.toJSON = function() {
            var t3;
            return t3 = i.__super__.toJSON.apply(this, arguments), t3.attachment = this.attachment, t3;
          }, i.prototype.getCacheKey = function() {
            return [i.__super__.getCacheKey.apply(this, arguments), this.attachment.getCacheKey()].join("/");
          }, i.prototype.toConsole = function() {
            return JSON.stringify(this.toString());
          }, i;
        }(e.Piece));
      }.call(this), function() {
        var t2, n = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var o in e2)
            i.call(e2, o) && (t3[o] = e2[o]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, i = {}.hasOwnProperty;
        t2 = e.normalizeNewlines, e.Piece.registerType("string", e.StringPiece = function(e2) {
          function i2(e3) {
            i2.__super__.constructor.apply(this, arguments), this.string = t2(e3), this.length = this.string.length;
          }
          return n(i2, e2), i2.fromJSON = function(t3) {
            return new this(t3.string, t3.attributes);
          }, i2.prototype.getValue = function() {
            return this.string;
          }, i2.prototype.toString = function() {
            return this.string.toString();
          }, i2.prototype.isBlockBreak = function() {
            return this.toString() === "\n" && this.getAttribute("blockBreak") === true;
          }, i2.prototype.toJSON = function() {
            var t3;
            return t3 = i2.__super__.toJSON.apply(this, arguments), t3.string = this.string, t3;
          }, i2.prototype.canBeConsolidatedWith = function(t3) {
            return t3 != null && this.hasSameConstructorAs(t3) && this.hasSameAttributesAsPiece(t3);
          }, i2.prototype.consolidateWith = function(t3) {
            return new this.constructor(this.toString() + t3.toString(), this.attributes);
          }, i2.prototype.splitAtOffset = function(t3) {
            var e3, n2;
            return t3 === 0 ? (e3 = null, n2 = this) : t3 === this.length ? (e3 = this, n2 = null) : (e3 = new this.constructor(this.string.slice(0, t3), this.attributes), n2 = new this.constructor(this.string.slice(t3), this.attributes)), [e3, n2];
          }, i2.prototype.toConsole = function() {
            var t3;
            return t3 = this.string, t3.length > 15 && (t3 = t3.slice(0, 14) + "\u2026"), JSON.stringify(t3.toString());
          }, i2;
        }(e.Piece));
      }.call(this), function() {
        var t2, n = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var o2 in e2)
            i.call(e2, o2) && (t3[o2] = e2[o2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, i = {}.hasOwnProperty, o = [].slice;
        t2 = e.spliceArray, e.SplittableList = function(e2) {
          function i2(t3) {
            t3 == null && (t3 = []), i2.__super__.constructor.apply(this, arguments), this.objects = t3.slice(0), this.length = this.objects.length;
          }
          var r, s, a;
          return n(i2, e2), i2.box = function(t3) {
            return t3 instanceof this ? t3 : new this(t3);
          }, i2.prototype.indexOf = function(t3) {
            return this.objects.indexOf(t3);
          }, i2.prototype.splice = function() {
            var e3;
            return e3 = 1 <= arguments.length ? o.call(arguments, 0) : [], new this.constructor(t2.apply(null, [this.objects].concat(o.call(e3))));
          }, i2.prototype.eachObject = function(t3) {
            var e3, n2, i3, o2, r2, s2;
            for (r2 = this.objects, s2 = [], n2 = e3 = 0, i3 = r2.length; i3 > e3; n2 = ++e3)
              o2 = r2[n2], s2.push(t3(o2, n2));
            return s2;
          }, i2.prototype.insertObjectAtIndex = function(t3, e3) {
            return this.splice(e3, 0, t3);
          }, i2.prototype.insertSplittableListAtIndex = function(t3, e3) {
            return this.splice.apply(this, [e3, 0].concat(o.call(t3.objects)));
          }, i2.prototype.insertSplittableListAtPosition = function(t3, e3) {
            var n2, i3, o2;
            return o2 = this.splitObjectAtPosition(e3), i3 = o2[0], n2 = o2[1], new this.constructor(i3).insertSplittableListAtIndex(t3, n2);
          }, i2.prototype.editObjectAtIndex = function(t3, e3) {
            return this.replaceObjectAtIndex(e3(this.objects[t3]), t3);
          }, i2.prototype.replaceObjectAtIndex = function(t3, e3) {
            return this.splice(e3, 1, t3);
          }, i2.prototype.removeObjectAtIndex = function(t3) {
            return this.splice(t3, 1);
          }, i2.prototype.getObjectAtIndex = function(t3) {
            return this.objects[t3];
          }, i2.prototype.getSplittableListInRange = function(t3) {
            var e3, n2, i3, o2;
            return i3 = this.splitObjectsAtRange(t3), n2 = i3[0], e3 = i3[1], o2 = i3[2], new this.constructor(n2.slice(e3, o2 + 1));
          }, i2.prototype.selectSplittableList = function(t3) {
            var e3, n2;
            return n2 = function() {
              var n3, i3, o2, r2;
              for (o2 = this.objects, r2 = [], n3 = 0, i3 = o2.length; i3 > n3; n3++)
                e3 = o2[n3], t3(e3) && r2.push(e3);
              return r2;
            }.call(this), new this.constructor(n2);
          }, i2.prototype.removeObjectsInRange = function(t3) {
            var e3, n2, i3, o2;
            return i3 = this.splitObjectsAtRange(t3), n2 = i3[0], e3 = i3[1], o2 = i3[2], new this.constructor(n2).splice(e3, o2 - e3 + 1);
          }, i2.prototype.transformObjectsInRange = function(t3, e3) {
            var n2, i3, o2, r2, s2, a2, u;
            return s2 = this.splitObjectsAtRange(t3), r2 = s2[0], i3 = s2[1], a2 = s2[2], u = function() {
              var t4, s3, u2;
              for (u2 = [], n2 = t4 = 0, s3 = r2.length; s3 > t4; n2 = ++t4)
                o2 = r2[n2], u2.push(n2 >= i3 && a2 >= n2 ? e3(o2) : o2);
              return u2;
            }(), new this.constructor(u);
          }, i2.prototype.splitObjectsAtRange = function(t3) {
            var e3, n2, i3, o2, s2, u;
            return o2 = this.splitObjectAtPosition(a(t3)), n2 = o2[0], e3 = o2[1], i3 = o2[2], s2 = new this.constructor(n2).splitObjectAtPosition(r(t3) + i3), n2 = s2[0], u = s2[1], [n2, e3, u - 1];
          }, i2.prototype.getObjectAtPosition = function(t3) {
            var e3, n2, i3;
            return i3 = this.findIndexAndOffsetAtPosition(t3), e3 = i3.index, n2 = i3.offset, this.objects[e3];
          }, i2.prototype.splitObjectAtPosition = function(t3) {
            var e3, n2, i3, o2, r2, s2, a2, u, c, l;
            return s2 = this.findIndexAndOffsetAtPosition(t3), e3 = s2.index, r2 = s2.offset, o2 = this.objects.slice(0), e3 != null ? r2 === 0 ? (c = e3, l = 0) : (i3 = this.getObjectAtIndex(e3), a2 = i3.splitAtOffset(r2), n2 = a2[0], u = a2[1], o2.splice(e3, 1, n2, u), c = e3 + 1, l = n2.getLength() - r2) : (c = o2.length, l = 0), [o2, c, l];
          }, i2.prototype.consolidate = function() {
            var t3, e3, n2, i3, o2, r2;
            for (i3 = [], o2 = this.objects[0], r2 = this.objects.slice(1), t3 = 0, e3 = r2.length; e3 > t3; t3++)
              n2 = r2[t3], (typeof o2.canBeConsolidatedWith == "function" ? o2.canBeConsolidatedWith(n2) : void 0) ? o2 = o2.consolidateWith(n2) : (i3.push(o2), o2 = n2);
            return o2 != null && i3.push(o2), new this.constructor(i3);
          }, i2.prototype.consolidateFromIndexToIndex = function(t3, e3) {
            var n2, i3, r2;
            return i3 = this.objects.slice(0), r2 = i3.slice(t3, e3 + 1), n2 = new this.constructor(r2).consolidate().toArray(), this.splice.apply(this, [t3, r2.length].concat(o.call(n2)));
          }, i2.prototype.findIndexAndOffsetAtPosition = function(t3) {
            var e3, n2, i3, o2, r2, s2, a2;
            for (e3 = 0, a2 = this.objects, i3 = n2 = 0, o2 = a2.length; o2 > n2; i3 = ++n2) {
              if (s2 = a2[i3], r2 = e3 + s2.getLength(), t3 >= e3 && r2 > t3)
                return {index: i3, offset: t3 - e3};
              e3 = r2;
            }
            return {index: null, offset: null};
          }, i2.prototype.findPositionAtIndexAndOffset = function(t3, e3) {
            var n2, i3, o2, r2, s2, a2;
            for (s2 = 0, a2 = this.objects, n2 = i3 = 0, o2 = a2.length; o2 > i3; n2 = ++i3)
              if (r2 = a2[n2], t3 > n2)
                s2 += r2.getLength();
              else if (n2 === t3) {
                s2 += e3;
                break;
              }
            return s2;
          }, i2.prototype.getEndPosition = function() {
            var t3, e3;
            return this.endPosition != null ? this.endPosition : this.endPosition = function() {
              var n2, i3, o2;
              for (e3 = 0, o2 = this.objects, n2 = 0, i3 = o2.length; i3 > n2; n2++)
                t3 = o2[n2], e3 += t3.getLength();
              return e3;
            }.call(this);
          }, i2.prototype.toString = function() {
            return this.objects.join("");
          }, i2.prototype.toArray = function() {
            return this.objects.slice(0);
          }, i2.prototype.toJSON = function() {
            return this.toArray();
          }, i2.prototype.isEqualTo = function(t3) {
            return i2.__super__.isEqualTo.apply(this, arguments) || s(this.objects, t3 != null ? t3.objects : void 0);
          }, s = function(t3, e3) {
            var n2, i3, o2, r2, s2;
            if (e3 == null && (e3 = []), t3.length !== e3.length)
              return false;
            for (s2 = true, i3 = n2 = 0, o2 = t3.length; o2 > n2; i3 = ++n2)
              r2 = t3[i3], s2 && !r2.isEqualTo(e3[i3]) && (s2 = false);
            return s2;
          }, i2.prototype.contentsForInspection = function() {
            var t3;
            return {objects: "[" + function() {
              var e3, n2, i3, o2;
              for (i3 = this.objects, o2 = [], e3 = 0, n2 = i3.length; n2 > e3; e3++)
                t3 = i3[e3], o2.push(t3.inspect());
              return o2;
            }.call(this).join(", ") + "]"};
          }, a = function(t3) {
            return t3[0];
          }, r = function(t3) {
            return t3[1];
          }, i2;
        }(e.Object);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.Text = function(n2) {
          function i(t3) {
            var n3;
            t3 == null && (t3 = []), i.__super__.constructor.apply(this, arguments), this.pieceList = new e.SplittableList(function() {
              var e2, i2, o;
              for (o = [], e2 = 0, i2 = t3.length; i2 > e2; e2++)
                n3 = t3[e2], n3.isEmpty() || o.push(n3);
              return o;
            }());
          }
          return t2(i, n2), i.textForAttachmentWithAttributes = function(t3, n3) {
            var i2;
            return i2 = new e.AttachmentPiece(t3, n3), new this([i2]);
          }, i.textForStringWithAttributes = function(t3, n3) {
            var i2;
            return i2 = new e.StringPiece(t3, n3), new this([i2]);
          }, i.fromJSON = function(t3) {
            var n3, i2;
            return i2 = function() {
              var i3, o, r;
              for (r = [], i3 = 0, o = t3.length; o > i3; i3++)
                n3 = t3[i3], r.push(e.Piece.fromJSON(n3));
              return r;
            }(), new this(i2);
          }, i.prototype.copy = function() {
            return this.copyWithPieceList(this.pieceList);
          }, i.prototype.copyWithPieceList = function(t3) {
            return new this.constructor(t3.consolidate().toArray());
          }, i.prototype.copyUsingObjectMap = function(t3) {
            var e2, n3;
            return n3 = function() {
              var n4, i2, o, r, s;
              for (o = this.getPieces(), s = [], n4 = 0, i2 = o.length; i2 > n4; n4++)
                e2 = o[n4], s.push((r = t3.find(e2)) != null ? r : e2);
              return s;
            }.call(this), new this.constructor(n3);
          }, i.prototype.appendText = function(t3) {
            return this.insertTextAtPosition(t3, this.getLength());
          }, i.prototype.insertTextAtPosition = function(t3, e2) {
            return this.copyWithPieceList(this.pieceList.insertSplittableListAtPosition(t3.pieceList, e2));
          }, i.prototype.removeTextAtRange = function(t3) {
            return this.copyWithPieceList(this.pieceList.removeObjectsInRange(t3));
          }, i.prototype.replaceTextAtRange = function(t3, e2) {
            return this.removeTextAtRange(e2).insertTextAtPosition(t3, e2[0]);
          }, i.prototype.moveTextFromRangeToPosition = function(t3, e2) {
            var n3, i2;
            if (!(t3[0] <= e2 && e2 <= t3[1]))
              return i2 = this.getTextAtRange(t3), n3 = i2.getLength(), t3[0] < e2 && (e2 -= n3), this.removeTextAtRange(t3).insertTextAtPosition(i2, e2);
          }, i.prototype.addAttributeAtRange = function(t3, e2, n3) {
            var i2;
            return i2 = {}, i2[t3] = e2, this.addAttributesAtRange(i2, n3);
          }, i.prototype.addAttributesAtRange = function(t3, e2) {
            return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, function(e3) {
              return e3.copyWithAdditionalAttributes(t3);
            }));
          }, i.prototype.removeAttributeAtRange = function(t3, e2) {
            return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, function(e3) {
              return e3.copyWithoutAttribute(t3);
            }));
          }, i.prototype.setAttributesAtRange = function(t3, e2) {
            return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e2, function(e3) {
              return e3.copyWithAttributes(t3);
            }));
          }, i.prototype.getAttributesAtPosition = function(t3) {
            var e2, n3;
            return (e2 = (n3 = this.pieceList.getObjectAtPosition(t3)) != null ? n3.getAttributes() : void 0) != null ? e2 : {};
          }, i.prototype.getCommonAttributes = function() {
            var t3, n3;
            return t3 = function() {
              var t4, e2, i2, o;
              for (i2 = this.pieceList.toArray(), o = [], t4 = 0, e2 = i2.length; e2 > t4; t4++)
                n3 = i2[t4], o.push(n3.getAttributes());
              return o;
            }.call(this), e.Hash.fromCommonAttributesOfObjects(t3).toObject();
          }, i.prototype.getCommonAttributesAtRange = function(t3) {
            var e2;
            return (e2 = this.getTextAtRange(t3).getCommonAttributes()) != null ? e2 : {};
          }, i.prototype.getExpandedRangeForAttributeAtOffset = function(t3, e2) {
            var n3, i2, o;
            for (n3 = o = e2, i2 = this.getLength(); n3 > 0 && this.getCommonAttributesAtRange([n3 - 1, o])[t3]; )
              n3--;
            for (; i2 > o && this.getCommonAttributesAtRange([e2, o + 1])[t3]; )
              o++;
            return [n3, o];
          }, i.prototype.getTextAtRange = function(t3) {
            return this.copyWithPieceList(this.pieceList.getSplittableListInRange(t3));
          }, i.prototype.getStringAtRange = function(t3) {
            return this.pieceList.getSplittableListInRange(t3).toString();
          }, i.prototype.getStringAtPosition = function(t3) {
            return this.getStringAtRange([t3, t3 + 1]);
          }, i.prototype.startsWithString = function(t3) {
            return this.getStringAtRange([0, t3.length]) === t3;
          }, i.prototype.endsWithString = function(t3) {
            var e2;
            return e2 = this.getLength(), this.getStringAtRange([e2 - t3.length, e2]) === t3;
          }, i.prototype.getAttachmentPieces = function() {
            var t3, e2, n3, i2, o;
            for (i2 = this.pieceList.toArray(), o = [], t3 = 0, e2 = i2.length; e2 > t3; t3++)
              n3 = i2[t3], n3.attachment != null && o.push(n3);
            return o;
          }, i.prototype.getAttachments = function() {
            var t3, e2, n3, i2, o;
            for (i2 = this.getAttachmentPieces(), o = [], t3 = 0, e2 = i2.length; e2 > t3; t3++)
              n3 = i2[t3], o.push(n3.attachment);
            return o;
          }, i.prototype.getAttachmentAndPositionById = function(t3) {
            var e2, n3, i2, o, r, s;
            for (o = 0, r = this.pieceList.toArray(), e2 = 0, n3 = r.length; n3 > e2; e2++) {
              if (i2 = r[e2], ((s = i2.attachment) != null ? s.id : void 0) === t3)
                return {attachment: i2.attachment, position: o};
              o += i2.length;
            }
            return {attachment: null, position: null};
          }, i.prototype.getAttachmentById = function(t3) {
            var e2, n3, i2;
            return i2 = this.getAttachmentAndPositionById(t3), e2 = i2.attachment, n3 = i2.position, e2;
          }, i.prototype.getRangeOfAttachment = function(t3) {
            var e2, n3;
            return n3 = this.getAttachmentAndPositionById(t3.id), t3 = n3.attachment, e2 = n3.position, t3 != null ? [e2, e2 + 1] : void 0;
          }, i.prototype.updateAttributesForAttachment = function(t3, e2) {
            var n3;
            return (n3 = this.getRangeOfAttachment(e2)) ? this.addAttributesAtRange(t3, n3) : this;
          }, i.prototype.getLength = function() {
            return this.pieceList.getEndPosition();
          }, i.prototype.isEmpty = function() {
            return this.getLength() === 0;
          }, i.prototype.isEqualTo = function(t3) {
            var e2;
            return i.__super__.isEqualTo.apply(this, arguments) || (t3 != null && (e2 = t3.pieceList) != null ? e2.isEqualTo(this.pieceList) : void 0);
          }, i.prototype.isBlockBreak = function() {
            return this.getLength() === 1 && this.pieceList.getObjectAtIndex(0).isBlockBreak();
          }, i.prototype.eachPiece = function(t3) {
            return this.pieceList.eachObject(t3);
          }, i.prototype.getPieces = function() {
            return this.pieceList.toArray();
          }, i.prototype.getPieceAtPosition = function(t3) {
            return this.pieceList.getObjectAtPosition(t3);
          }, i.prototype.contentsForInspection = function() {
            return {pieceList: this.pieceList.inspect()};
          }, i.prototype.toSerializableText = function() {
            var t3;
            return t3 = this.pieceList.selectSplittableList(function(t4) {
              return t4.isSerializable();
            }), this.copyWithPieceList(t3);
          }, i.prototype.toString = function() {
            return this.pieceList.toString();
          }, i.prototype.toJSON = function() {
            return this.pieceList.toJSON();
          }, i.prototype.toConsole = function() {
            var t3;
            return JSON.stringify(function() {
              var e2, n3, i2, o;
              for (i2 = this.pieceList.toArray(), o = [], e2 = 0, n3 = i2.length; n3 > e2; e2++)
                t3 = i2[e2], o.push(JSON.parse(t3.toConsole()));
              return o;
            }.call(this));
          }, i.prototype.getDirection = function() {
            return e.getDirection(this.toString());
          }, i.prototype.isRTL = function() {
            return this.getDirection() === "rtl";
          }, i;
        }(e.Object);
      }.call(this), function() {
        var t2, n, i, o, r, s = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            a.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, a = {}.hasOwnProperty, u = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        }, c = [].slice;
        t2 = e.arraysAreEqual, r = e.spliceArray, i = e.getBlockConfig, n = e.getBlockAttributeNames, o = e.getListAttributeNames, e.Block = function(n2) {
          function a2(t3, n3) {
            t3 == null && (t3 = new e.Text()), n3 == null && (n3 = []), a2.__super__.constructor.apply(this, arguments), this.text = h(t3), this.attributes = n3;
          }
          var l, h, p, d, f, g, m, v, y;
          return s(a2, n2), a2.fromJSON = function(t3) {
            var n3;
            return n3 = e.Text.fromJSON(t3.text), new this(n3, t3.attributes);
          }, a2.prototype.isEmpty = function() {
            return this.text.isBlockBreak();
          }, a2.prototype.isEqualTo = function(e2) {
            return a2.__super__.isEqualTo.apply(this, arguments) || this.text.isEqualTo(e2 != null ? e2.text : void 0) && t2(this.attributes, e2 != null ? e2.attributes : void 0);
          }, a2.prototype.copyWithText = function(t3) {
            return new this.constructor(t3, this.attributes);
          }, a2.prototype.copyWithoutText = function() {
            return this.copyWithText(null);
          }, a2.prototype.copyWithAttributes = function(t3) {
            return new this.constructor(this.text, t3);
          }, a2.prototype.copyWithoutAttributes = function() {
            return this.copyWithAttributes(null);
          }, a2.prototype.copyUsingObjectMap = function(t3) {
            var e2;
            return this.copyWithText((e2 = t3.find(this.text)) ? e2 : this.text.copyUsingObjectMap(t3));
          }, a2.prototype.addAttribute = function(t3) {
            var e2;
            return e2 = this.attributes.concat(d(t3)), this.copyWithAttributes(e2);
          }, a2.prototype.removeAttribute = function(t3) {
            var e2, n3;
            return n3 = i(t3).listAttribute, e2 = g(g(this.attributes, t3), n3), this.copyWithAttributes(e2);
          }, a2.prototype.removeLastAttribute = function() {
            return this.removeAttribute(this.getLastAttribute());
          }, a2.prototype.getLastAttribute = function() {
            return f(this.attributes);
          }, a2.prototype.getAttributes = function() {
            return this.attributes.slice(0);
          }, a2.prototype.getAttributeLevel = function() {
            return this.attributes.length;
          }, a2.prototype.getAttributeAtLevel = function(t3) {
            return this.attributes[t3 - 1];
          }, a2.prototype.hasAttribute = function(t3) {
            return u.call(this.attributes, t3) >= 0;
          }, a2.prototype.hasAttributes = function() {
            return this.getAttributeLevel() > 0;
          }, a2.prototype.getLastNestableAttribute = function() {
            return f(this.getNestableAttributes());
          }, a2.prototype.getNestableAttributes = function() {
            var t3, e2, n3, o2, r2;
            for (o2 = this.attributes, r2 = [], e2 = 0, n3 = o2.length; n3 > e2; e2++)
              t3 = o2[e2], i(t3).nestable && r2.push(t3);
            return r2;
          }, a2.prototype.getNestingLevel = function() {
            return this.getNestableAttributes().length;
          }, a2.prototype.decreaseNestingLevel = function() {
            var t3;
            return (t3 = this.getLastNestableAttribute()) ? this.removeAttribute(t3) : this;
          }, a2.prototype.increaseNestingLevel = function() {
            var t3, e2, n3;
            return (t3 = this.getLastNestableAttribute()) ? (n3 = this.attributes.lastIndexOf(t3), e2 = r.apply(null, [this.attributes, n3 + 1, 0].concat(c.call(d(t3)))), this.copyWithAttributes(e2)) : this;
          }, a2.prototype.getListItemAttributes = function() {
            var t3, e2, n3, o2, r2;
            for (o2 = this.attributes, r2 = [], e2 = 0, n3 = o2.length; n3 > e2; e2++)
              t3 = o2[e2], i(t3).listAttribute && r2.push(t3);
            return r2;
          }, a2.prototype.isListItem = function() {
            var t3;
            return (t3 = i(this.getLastAttribute())) != null ? t3.listAttribute : void 0;
          }, a2.prototype.isTerminalBlock = function() {
            var t3;
            return (t3 = i(this.getLastAttribute())) != null ? t3.terminal : void 0;
          }, a2.prototype.breaksOnReturn = function() {
            var t3;
            return (t3 = i(this.getLastAttribute())) != null ? t3.breakOnReturn : void 0;
          }, a2.prototype.findLineBreakInDirectionFromPosition = function(t3, e2) {
            var n3, i2;
            return i2 = this.toString(), n3 = function() {
              switch (t3) {
                case "forward":
                  return i2.indexOf("\n", e2);
                case "backward":
                  return i2.slice(0, e2).lastIndexOf("\n");
              }
            }(), n3 !== -1 ? n3 : void 0;
          }, a2.prototype.contentsForInspection = function() {
            return {text: this.text.inspect(), attributes: this.attributes};
          }, a2.prototype.toString = function() {
            return this.text.toString();
          }, a2.prototype.toJSON = function() {
            return {text: this.text, attributes: this.attributes};
          }, a2.prototype.getDirection = function() {
            return this.text.getDirection();
          }, a2.prototype.isRTL = function() {
            return this.text.isRTL();
          }, a2.prototype.getLength = function() {
            return this.text.getLength();
          }, a2.prototype.canBeConsolidatedWith = function(t3) {
            return !this.hasAttributes() && !t3.hasAttributes() && this.getDirection() === t3.getDirection();
          }, a2.prototype.consolidateWith = function(t3) {
            var n3, i2;
            return n3 = e.Text.textForStringWithAttributes("\n"), i2 = this.getTextWithoutBlockBreak().appendText(n3), this.copyWithText(i2.appendText(t3.text));
          }, a2.prototype.splitAtOffset = function(t3) {
            var e2, n3;
            return t3 === 0 ? (e2 = null, n3 = this) : t3 === this.getLength() ? (e2 = this, n3 = null) : (e2 = this.copyWithText(this.text.getTextAtRange([0, t3])), n3 = this.copyWithText(this.text.getTextAtRange([t3, this.getLength()]))), [e2, n3];
          }, a2.prototype.getBlockBreakPosition = function() {
            return this.text.getLength() - 1;
          }, a2.prototype.getTextWithoutBlockBreak = function() {
            return m(this.text) ? this.text.getTextAtRange([0, this.getBlockBreakPosition()]) : this.text.copy();
          }, a2.prototype.canBeGrouped = function(t3) {
            return this.attributes[t3];
          }, a2.prototype.canBeGroupedWith = function(t3, e2) {
            var n3, r2, s2, a3;
            return s2 = t3.getAttributes(), r2 = s2[e2], n3 = this.attributes[e2], !(n3 !== r2 || i(n3).group === false && (a3 = s2[e2 + 1], u.call(o(), a3) < 0) || this.getDirection() !== t3.getDirection() && !t3.isEmpty());
          }, h = function(t3) {
            return t3 = y(t3), t3 = l(t3);
          }, y = function(t3) {
            var n3, i2, o2, r2, s2, a3;
            return r2 = false, a3 = t3.getPieces(), i2 = 2 <= a3.length ? c.call(a3, 0, n3 = a3.length - 1) : (n3 = 0, []), o2 = a3[n3++], o2 == null ? t3 : (i2 = function() {
              var t4, e2, n4;
              for (n4 = [], t4 = 0, e2 = i2.length; e2 > t4; t4++)
                s2 = i2[t4], s2.isBlockBreak() ? (r2 = true, n4.push(v(s2))) : n4.push(s2);
              return n4;
            }(), r2 ? new e.Text(c.call(i2).concat([o2])) : t3);
          }, p = e.Text.textForStringWithAttributes("\n", {blockBreak: true}), l = function(t3) {
            return m(t3) ? t3 : t3.appendText(p);
          }, m = function(t3) {
            var e2, n3;
            return n3 = t3.getLength(), n3 === 0 ? false : (e2 = t3.getTextAtRange([n3 - 1, n3]), e2.isBlockBreak());
          }, v = function(t3) {
            return t3.copyWithoutAttribute("blockBreak");
          }, d = function(t3) {
            var e2;
            return e2 = i(t3).listAttribute, e2 != null ? [e2, t3] : [t3];
          }, f = function(t3) {
            return t3.slice(-1)[0];
          }, g = function(t3, e2) {
            var n3;
            return n3 = t3.lastIndexOf(e2), n3 === -1 ? t3 : r(t3, n3, 1);
          }, a2;
        }(e.Object);
      }.call(this), function() {
        var t2, n, i, o = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            r.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, r = {}.hasOwnProperty, s = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        }, a = [].slice;
        n = e.tagName, i = e.walkTree, t2 = e.nodeIsAttachmentElement, e.HTMLSanitizer = function(r2) {
          function u(t3, e2) {
            var n2;
            n2 = e2 != null ? e2 : {}, this.allowedAttributes = n2.allowedAttributes, this.forbiddenProtocols = n2.forbiddenProtocols, this.forbiddenElements = n2.forbiddenElements, this.allowedAttributes == null && (this.allowedAttributes = c), this.forbiddenProtocols == null && (this.forbiddenProtocols = h), this.forbiddenElements == null && (this.forbiddenElements = l), this.body = p(t3);
          }
          var c, l, h, p;
          return o(u, r2), c = "style href src width height class".split(" "), h = "javascript:".split(" "), l = "script iframe".split(" "), u.sanitize = function(t3, e2) {
            var n2;
            return n2 = new this(t3, e2), n2.sanitize(), n2;
          }, u.prototype.sanitize = function() {
            return this.sanitizeElements(), this.normalizeListElementNesting();
          }, u.prototype.getHTML = function() {
            return this.body.innerHTML;
          }, u.prototype.getBody = function() {
            return this.body;
          }, u.prototype.sanitizeElements = function() {
            var t3, n2, o2, r3, s2;
            for (s2 = i(this.body), r3 = []; s2.nextNode(); )
              switch (o2 = s2.currentNode, o2.nodeType) {
                case Node.ELEMENT_NODE:
                  this.elementIsRemovable(o2) ? r3.push(o2) : this.sanitizeElement(o2);
                  break;
                case Node.COMMENT_NODE:
                  r3.push(o2);
              }
            for (t3 = 0, n2 = r3.length; n2 > t3; t3++)
              o2 = r3[t3], e.removeNode(o2);
            return this.body;
          }, u.prototype.sanitizeElement = function(t3) {
            var e2, n2, i2, o2, r3;
            for (t3.hasAttribute("href") && (o2 = t3.protocol, s.call(this.forbiddenProtocols, o2) >= 0 && t3.removeAttribute("href")), r3 = a.call(t3.attributes), e2 = 0, n2 = r3.length; n2 > e2; e2++)
              i2 = r3[e2].name, s.call(this.allowedAttributes, i2) >= 0 || i2.indexOf("data-trix") === 0 || t3.removeAttribute(i2);
            return t3;
          }, u.prototype.normalizeListElementNesting = function() {
            var t3, e2, i2, o2, r3;
            for (r3 = a.call(this.body.querySelectorAll("ul,ol")), t3 = 0, e2 = r3.length; e2 > t3; t3++)
              i2 = r3[t3], (o2 = i2.previousElementSibling) && n(o2) === "li" && o2.appendChild(i2);
            return this.body;
          }, u.prototype.elementIsRemovable = function(t3) {
            return (t3 != null ? t3.nodeType : void 0) === Node.ELEMENT_NODE ? this.elementIsForbidden(t3) || this.elementIsntSerializable(t3) : void 0;
          }, u.prototype.elementIsForbidden = function(t3) {
            var e2;
            return e2 = n(t3), s.call(this.forbiddenElements, e2) >= 0;
          }, u.prototype.elementIsntSerializable = function(e2) {
            return e2.getAttribute("data-trix-serialize") === "false" && !t2(e2);
          }, p = function(t3) {
            var e2, n2, i2, o2, r3;
            for (t3 == null && (t3 = ""), t3 = t3.replace(/<\/html[^>]*>[^]*$/i, "</html>"), e2 = document.implementation.createHTMLDocument(""), e2.documentElement.innerHTML = t3, r3 = e2.head.querySelectorAll("style"), i2 = 0, o2 = r3.length; o2 > i2; i2++)
              n2 = r3[i2], e2.body.appendChild(n2);
            return e2.body;
          }, u;
        }(e.BasicObject);
      }.call(this), function() {
        var t2, n, i, o, r, s, a, u, c, l, h, p = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            d.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, d = {}.hasOwnProperty, f = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        };
        t2 = e.arraysAreEqual, s = e.makeElement, l = e.tagName, r = e.getBlockTagNames, h = e.walkTree, o = e.findClosestElementFromNode, i = e.elementContainsNode, a = e.nodeIsAttachmentElement, u = e.normalizeSpaces, n = e.breakableWhitespacePattern, c = e.squishBreakableWhitespace, e.HTMLParser = function(d2) {
          function g(t3, e2) {
            this.html = t3, this.referenceElement = (e2 != null ? e2 : {}).referenceElement, this.blocks = [], this.blockElements = [], this.processedElements = [];
          }
          var m, v, y, b, A, C3, x, w, E, S2, R, k;
          return p(g, d2), g.parse = function(t3, e2) {
            var n2;
            return n2 = new this(t3, e2), n2.parse(), n2;
          }, g.prototype.getDocument = function() {
            return e.Document.fromJSON(this.blocks);
          }, g.prototype.parse = function() {
            var t3, n2;
            try {
              for (this.createHiddenContainer(), t3 = e.HTMLSanitizer.sanitize(this.html).getHTML(), this.containerElement.innerHTML = t3, n2 = h(this.containerElement, {usingFilter: x}); n2.nextNode(); )
                this.processNode(n2.currentNode);
              return this.translateBlockElementMarginsToNewlines();
            } finally {
              this.removeHiddenContainer();
            }
          }, g.prototype.createHiddenContainer = function() {
            return this.referenceElement ? (this.containerElement = this.referenceElement.cloneNode(false), this.containerElement.removeAttribute("id"), this.containerElement.setAttribute("data-trix-internal", ""), this.containerElement.style.display = "none", this.referenceElement.parentNode.insertBefore(this.containerElement, this.referenceElement.nextSibling)) : (this.containerElement = s({tagName: "div", style: {display: "none"}}), document.body.appendChild(this.containerElement));
          }, g.prototype.removeHiddenContainer = function() {
            return e.removeNode(this.containerElement);
          }, x = function(t3) {
            return l(t3) === "style" ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
          }, g.prototype.processNode = function(t3) {
            switch (t3.nodeType) {
              case Node.TEXT_NODE:
                if (!this.isInsignificantTextNode(t3))
                  return this.appendBlockForTextNode(t3), this.processTextNode(t3);
                break;
              case Node.ELEMENT_NODE:
                return this.appendBlockForElement(t3), this.processElement(t3);
            }
          }, g.prototype.appendBlockForTextNode = function(e2) {
            var n2, i2, o2;
            return i2 = e2.parentNode, i2 === this.currentBlockElement && this.isBlockElement(e2.previousSibling) ? this.appendStringWithAttributes("\n") : i2 !== this.containerElement && !this.isBlockElement(i2) || (n2 = this.getBlockAttributes(i2), t2(n2, (o2 = this.currentBlock) != null ? o2.attributes : void 0)) ? void 0 : (this.currentBlock = this.appendBlockForAttributesWithElement(n2, i2), this.currentBlockElement = i2);
          }, g.prototype.appendBlockForElement = function(e2) {
            var n2, o2, r2, s2;
            if (r2 = this.isBlockElement(e2), o2 = i(this.currentBlockElement, e2), r2 && !this.isBlockElement(e2.firstChild)) {
              if ((!this.isInsignificantTextNode(e2.firstChild) || !this.isBlockElement(e2.firstElementChild)) && (n2 = this.getBlockAttributes(e2), e2.firstChild))
                return o2 && t2(n2, this.currentBlock.attributes) ? this.appendStringWithAttributes("\n") : (this.currentBlock = this.appendBlockForAttributesWithElement(n2, e2), this.currentBlockElement = e2);
            } else if (this.currentBlockElement && !o2 && !r2)
              return (s2 = this.findParentBlockElement(e2)) ? this.appendBlockForElement(s2) : (this.currentBlock = this.appendEmptyBlock(), this.currentBlockElement = null);
          }, g.prototype.findParentBlockElement = function(t3) {
            var e2;
            for (e2 = t3.parentElement; e2 && e2 !== this.containerElement; ) {
              if (this.isBlockElement(e2) && f.call(this.blockElements, e2) >= 0)
                return e2;
              e2 = e2.parentElement;
            }
            return null;
          }, g.prototype.processTextNode = function(t3) {
            var e2, n2;
            return n2 = t3.data, v(t3.parentNode) || (n2 = c(n2), R((e2 = t3.previousSibling) != null ? e2.textContent : void 0) && (n2 = A(n2))), this.appendStringWithAttributes(n2, this.getTextAttributes(t3.parentNode));
          }, g.prototype.processElement = function(t3) {
            var e2, n2, i2, o2, r2;
            if (a(t3))
              return e2 = w(t3, "attachment"), Object.keys(e2).length && (o2 = this.getTextAttributes(t3), this.appendAttachmentWithAttributes(e2, o2), t3.innerHTML = ""), this.processedElements.push(t3);
            switch (l(t3)) {
              case "br":
                return this.isExtraBR(t3) || this.isBlockElement(t3.nextSibling) || this.appendStringWithAttributes("\n", this.getTextAttributes(t3)), this.processedElements.push(t3);
              case "img":
                e2 = {url: t3.getAttribute("src"), contentType: "image"}, i2 = b(t3);
                for (n2 in i2)
                  r2 = i2[n2], e2[n2] = r2;
                return this.appendAttachmentWithAttributes(e2, this.getTextAttributes(t3)), this.processedElements.push(t3);
              case "tr":
                if (t3.parentNode.firstChild !== t3)
                  return this.appendStringWithAttributes("\n");
                break;
              case "td":
                if (t3.parentNode.firstChild !== t3)
                  return this.appendStringWithAttributes(" | ");
            }
          }, g.prototype.appendBlockForAttributesWithElement = function(t3, e2) {
            var n2;
            return this.blockElements.push(e2), n2 = m(t3), this.blocks.push(n2), n2;
          }, g.prototype.appendEmptyBlock = function() {
            return this.appendBlockForAttributesWithElement([], null);
          }, g.prototype.appendStringWithAttributes = function(t3, e2) {
            return this.appendPiece(S2(t3, e2));
          }, g.prototype.appendAttachmentWithAttributes = function(t3, e2) {
            return this.appendPiece(E(t3, e2));
          }, g.prototype.appendPiece = function(t3) {
            return this.blocks.length === 0 && this.appendEmptyBlock(), this.blocks[this.blocks.length - 1].text.push(t3);
          }, g.prototype.appendStringToTextAtIndex = function(t3, e2) {
            var n2, i2;
            return i2 = this.blocks[e2].text, n2 = i2[i2.length - 1], (n2 != null ? n2.type : void 0) === "string" ? n2.string += t3 : i2.push(S2(t3));
          }, g.prototype.prependStringToTextAtIndex = function(t3, e2) {
            var n2, i2;
            return i2 = this.blocks[e2].text, n2 = i2[0], (n2 != null ? n2.type : void 0) === "string" ? n2.string = t3 + n2.string : i2.unshift(S2(t3));
          }, S2 = function(t3, e2) {
            var n2;
            return e2 == null && (e2 = {}), n2 = "string", t3 = u(t3), {string: t3, attributes: e2, type: n2};
          }, E = function(t3, e2) {
            var n2;
            return e2 == null && (e2 = {}), n2 = "attachment", {attachment: t3, attributes: e2, type: n2};
          }, m = function(t3) {
            var e2;
            return t3 == null && (t3 = {}), e2 = [], {text: e2, attributes: t3};
          }, g.prototype.getTextAttributes = function(t3) {
            var n2, i2, r2, s2, u2, c2, l2, h2, p2, d3, f2, g2;
            r2 = {}, p2 = e.config.textAttributes;
            for (n2 in p2)
              if (u2 = p2[n2], u2.tagName && o(t3, {matchingSelector: u2.tagName, untilNode: this.containerElement}))
                r2[n2] = true;
              else if (u2.parser) {
                if (g2 = u2.parser(t3)) {
                  for (i2 = false, d3 = this.findBlockElementAncestors(t3), c2 = 0, h2 = d3.length; h2 > c2; c2++)
                    if (s2 = d3[c2], u2.parser(s2) === g2) {
                      i2 = true;
                      break;
                    }
                  i2 || (r2[n2] = g2);
                }
              } else
                u2.styleProperty && (g2 = t3.style[u2.styleProperty]) && (r2[n2] = g2);
            if (a(t3)) {
              f2 = w(t3, "attributes");
              for (l2 in f2)
                g2 = f2[l2], r2[l2] = g2;
            }
            return r2;
          }, g.prototype.getBlockAttributes = function(t3) {
            var n2, i2, o2, r2;
            for (i2 = []; t3 && t3 !== this.containerElement; ) {
              r2 = e.config.blockAttributes;
              for (n2 in r2)
                o2 = r2[n2], o2.parse !== false && l(t3) === o2.tagName && ((typeof o2.test == "function" ? o2.test(t3) : void 0) || !o2.test) && (i2.push(n2), o2.listAttribute && i2.push(o2.listAttribute));
              t3 = t3.parentNode;
            }
            return i2.reverse();
          }, g.prototype.findBlockElementAncestors = function(t3) {
            var e2, n2;
            for (e2 = []; t3 && t3 !== this.containerElement; )
              n2 = l(t3), f.call(r(), n2) >= 0 && e2.push(t3), t3 = t3.parentNode;
            return e2;
          }, w = function(t3, e2) {
            try {
              return JSON.parse(t3.getAttribute("data-trix-" + e2));
            } catch (n2) {
              return {};
            }
          }, b = function(t3) {
            var e2, n2, i2;
            return i2 = t3.getAttribute("width"), n2 = t3.getAttribute("height"), e2 = {}, i2 && (e2.width = parseInt(i2, 10)), n2 && (e2.height = parseInt(n2, 10)), e2;
          }, g.prototype.isBlockElement = function(t3) {
            var e2;
            if ((t3 != null ? t3.nodeType : void 0) === Node.ELEMENT_NODE && !a(t3) && !o(t3, {matchingSelector: "td", untilNode: this.containerElement}))
              return e2 = l(t3), f.call(r(), e2) >= 0 || window.getComputedStyle(t3).display === "block";
          }, g.prototype.isInsignificantTextNode = function(t3) {
            var e2, n2, i2;
            if ((t3 != null ? t3.nodeType : void 0) === Node.TEXT_NODE && k(t3.data) && (n2 = t3.parentNode, i2 = t3.previousSibling, e2 = t3.nextSibling, (!C3(n2.previousSibling) || this.isBlockElement(n2.previousSibling)) && !v(n2)))
              return !i2 || this.isBlockElement(i2) || !e2 || this.isBlockElement(e2);
          }, g.prototype.isExtraBR = function(t3) {
            return l(t3) === "br" && this.isBlockElement(t3.parentNode) && t3.parentNode.lastChild === t3;
          }, v = function(t3) {
            var e2;
            return e2 = window.getComputedStyle(t3).whiteSpace, e2 === "pre" || e2 === "pre-wrap" || e2 === "pre-line";
          }, C3 = function(t3) {
            return t3 && !R(t3.textContent);
          }, g.prototype.translateBlockElementMarginsToNewlines = function() {
            var t3, e2, n2, i2, o2, r2, s2, a2;
            for (e2 = this.getMarginOfDefaultBlockElement(), s2 = this.blocks, a2 = [], i2 = n2 = 0, o2 = s2.length; o2 > n2; i2 = ++n2)
              t3 = s2[i2], (r2 = this.getMarginOfBlockElementAtIndex(i2)) && (r2.top > 2 * e2.top && this.prependStringToTextAtIndex("\n", i2), a2.push(r2.bottom > 2 * e2.bottom ? this.appendStringToTextAtIndex("\n", i2) : void 0));
            return a2;
          }, g.prototype.getMarginOfBlockElementAtIndex = function(t3) {
            var e2, n2;
            return !(e2 = this.blockElements[t3]) || !e2.textContent || (n2 = l(e2), f.call(r(), n2) >= 0 || f.call(this.processedElements, e2) >= 0) ? void 0 : y(e2);
          }, g.prototype.getMarginOfDefaultBlockElement = function() {
            var t3;
            return t3 = s(e.config.blockAttributes["default"].tagName), this.containerElement.appendChild(t3), y(t3);
          }, y = function(t3) {
            var e2;
            return e2 = window.getComputedStyle(t3), e2.display === "block" ? {top: parseInt(e2.marginTop), bottom: parseInt(e2.marginBottom)} : void 0;
          }, A = function(t3) {
            return t3.replace(RegExp("^" + n.source + "+"), "");
          }, k = function(t3) {
            return RegExp("^" + n.source + "*$").test(t3);
          }, R = function(t3) {
            return /\s$/.test(t3);
          }, g;
        }(e.BasicObject);
      }.call(this), function() {
        var t2, n, i, o, r = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            s.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, s = {}.hasOwnProperty, a = [].slice, u = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        };
        t2 = e.arraysAreEqual, i = e.normalizeRange, o = e.rangeIsCollapsed, n = e.getBlockConfig, e.Document = function(s2) {
          function c(t3) {
            t3 == null && (t3 = []), c.__super__.constructor.apply(this, arguments), t3.length === 0 && (t3 = [new e.Block()]), this.blockList = e.SplittableList.box(t3);
          }
          var l;
          return r(c, s2), c.fromJSON = function(t3) {
            var n2, i2;
            return i2 = function() {
              var i3, o2, r2;
              for (r2 = [], i3 = 0, o2 = t3.length; o2 > i3; i3++)
                n2 = t3[i3], r2.push(e.Block.fromJSON(n2));
              return r2;
            }(), new this(i2);
          }, c.fromHTML = function(t3, n2) {
            return e.HTMLParser.parse(t3, n2).getDocument();
          }, c.fromString = function(t3, n2) {
            var i2;
            return i2 = e.Text.textForStringWithAttributes(t3, n2), new this([new e.Block(i2)]);
          }, c.prototype.isEmpty = function() {
            var t3;
            return this.blockList.length === 1 && (t3 = this.getBlockAtIndex(0), t3.isEmpty() && !t3.hasAttributes());
          }, c.prototype.copy = function(t3) {
            var e2;
            return t3 == null && (t3 = {}), e2 = t3.consolidateBlocks ? this.blockList.consolidate().toArray() : this.blockList.toArray(), new this.constructor(e2);
          }, c.prototype.copyUsingObjectsFromDocument = function(t3) {
            var n2;
            return n2 = new e.ObjectMap(t3.getObjects()), this.copyUsingObjectMap(n2);
          }, c.prototype.copyUsingObjectMap = function(t3) {
            var e2, n2, i2;
            return n2 = function() {
              var n3, o2, r2, s3;
              for (r2 = this.getBlocks(), s3 = [], n3 = 0, o2 = r2.length; o2 > n3; n3++)
                e2 = r2[n3], s3.push((i2 = t3.find(e2)) ? i2 : e2.copyUsingObjectMap(t3));
              return s3;
            }.call(this), new this.constructor(n2);
          }, c.prototype.copyWithBaseBlockAttributes = function(t3) {
            var e2, n2, i2;
            return t3 == null && (t3 = []), i2 = function() {
              var i3, o2, r2, s3;
              for (r2 = this.getBlocks(), s3 = [], i3 = 0, o2 = r2.length; o2 > i3; i3++)
                n2 = r2[i3], e2 = t3.concat(n2.getAttributes()), s3.push(n2.copyWithAttributes(e2));
              return s3;
            }.call(this), new this.constructor(i2);
          }, c.prototype.replaceBlock = function(t3, e2) {
            var n2;
            return n2 = this.blockList.indexOf(t3), n2 === -1 ? this : new this.constructor(this.blockList.replaceObjectAtIndex(e2, n2));
          }, c.prototype.insertDocumentAtRange = function(t3, e2) {
            var n2, r2, s3, a2, u2, c2, l2;
            return r2 = t3.blockList, u2 = (e2 = i(e2))[0], c2 = this.locationFromPosition(u2), s3 = c2.index, a2 = c2.offset, l2 = this, n2 = this.getBlockAtPosition(u2), o(e2) && n2.isEmpty() && !n2.hasAttributes() ? l2 = new this.constructor(l2.blockList.removeObjectAtIndex(s3)) : n2.getBlockBreakPosition() === a2 && u2++, l2 = l2.removeTextAtRange(e2), new this.constructor(l2.blockList.insertSplittableListAtPosition(r2, u2));
          }, c.prototype.mergeDocumentAtRange = function(e2, n2) {
            var o2, r2, s3, a2, u2, c2, l2, h, p, d, f, g;
            return f = (n2 = i(n2))[0], d = this.locationFromPosition(f), r2 = this.getBlockAtIndex(d.index).getAttributes(), o2 = e2.getBaseBlockAttributes(), g = r2.slice(-o2.length), t2(o2, g) ? (l2 = r2.slice(0, -o2.length), c2 = e2.copyWithBaseBlockAttributes(l2)) : c2 = e2.copy({consolidateBlocks: true}).copyWithBaseBlockAttributes(r2), s3 = c2.getBlockCount(), a2 = c2.getBlockAtIndex(0), t2(r2, a2.getAttributes()) ? (u2 = a2.getTextWithoutBlockBreak(), p = this.insertTextAtRange(u2, n2), s3 > 1 && (c2 = new this.constructor(c2.getBlocks().slice(1)), h = f + u2.getLength(), p = p.insertDocumentAtRange(c2, h))) : p = this.insertDocumentAtRange(c2, n2), p;
          }, c.prototype.insertTextAtRange = function(t3, e2) {
            var n2, o2, r2, s3, a2;
            return a2 = (e2 = i(e2))[0], s3 = this.locationFromPosition(a2), o2 = s3.index, r2 = s3.offset, n2 = this.removeTextAtRange(e2), new this.constructor(n2.blockList.editObjectAtIndex(o2, function(e3) {
              return e3.copyWithText(e3.text.insertTextAtPosition(t3, r2));
            }));
          }, c.prototype.removeTextAtRange = function(t3) {
            var e2, n2, r2, s3, a2, u2, c2, l2, h, p, d, f, g, m, v, y, b, A, C3, x, w;
            return p = t3 = i(t3), l2 = p[0], A = p[1], o(t3) ? this : (d = this.locationRangeFromRange(t3), u2 = d[0], y = d[1], a2 = u2.index, c2 = u2.offset, s3 = this.getBlockAtIndex(a2), v = y.index, b = y.offset, m = this.getBlockAtIndex(v), f = A - l2 === 1 && s3.getBlockBreakPosition() === c2 && m.getBlockBreakPosition() !== b && m.text.getStringAtPosition(b) === "\n", f ? r2 = this.blockList.editObjectAtIndex(v, function(t4) {
              return t4.copyWithText(t4.text.removeTextAtRange([b, b + 1]));
            }) : (h = s3.text.getTextAtRange([0, c2]), C3 = m.text.getTextAtRange([b, m.getLength()]), x = h.appendText(C3), g = a2 !== v && c2 === 0, w = g && s3.getAttributeLevel() >= m.getAttributeLevel(), n2 = w ? m.copyWithText(x) : s3.copyWithText(x), e2 = v + 1 - a2, r2 = this.blockList.splice(a2, e2, n2)), new this.constructor(r2));
          }, c.prototype.moveTextFromRangeToPosition = function(t3, e2) {
            var n2, o2, r2, s3, u2, c2, l2, h, p, d;
            return c2 = t3 = i(t3), p = c2[0], r2 = c2[1], e2 >= p && r2 >= e2 ? this : (o2 = this.getDocumentAtRange(t3), h = this.removeTextAtRange(t3), u2 = e2 > p, u2 && (e2 -= o2.getLength()), l2 = o2.getBlocks(), s3 = l2[0], n2 = 2 <= l2.length ? a.call(l2, 1) : [], n2.length === 0 ? (d = s3.getTextWithoutBlockBreak(), u2 && (e2 += 1)) : d = s3.text, h = h.insertTextAtRange(d, e2), n2.length === 0 ? h : (o2 = new this.constructor(n2), e2 += d.getLength(), h.insertDocumentAtRange(o2, e2)));
          }, c.prototype.addAttributeAtRange = function(t3, e2, i2) {
            var o2;
            return o2 = this.blockList, this.eachBlockAtRange(i2, function(i3, r2, s3) {
              return o2 = o2.editObjectAtIndex(s3, function() {
                return n(t3) ? i3.addAttribute(t3, e2) : r2[0] === r2[1] ? i3 : i3.copyWithText(i3.text.addAttributeAtRange(t3, e2, r2));
              });
            }), new this.constructor(o2);
          }, c.prototype.addAttribute = function(t3, e2) {
            var n2;
            return n2 = this.blockList, this.eachBlock(function(i2, o2) {
              return n2 = n2.editObjectAtIndex(o2, function() {
                return i2.addAttribute(t3, e2);
              });
            }), new this.constructor(n2);
          }, c.prototype.removeAttributeAtRange = function(t3, e2) {
            var i2;
            return i2 = this.blockList, this.eachBlockAtRange(e2, function(e3, o2, r2) {
              return n(t3) ? i2 = i2.editObjectAtIndex(r2, function() {
                return e3.removeAttribute(t3);
              }) : o2[0] !== o2[1] ? i2 = i2.editObjectAtIndex(r2, function() {
                return e3.copyWithText(e3.text.removeAttributeAtRange(t3, o2));
              }) : void 0;
            }), new this.constructor(i2);
          }, c.prototype.updateAttributesForAttachment = function(t3, e2) {
            var n2, i2, o2, r2;
            return o2 = (i2 = this.getRangeOfAttachment(e2))[0], n2 = this.locationFromPosition(o2).index, r2 = this.getTextAtIndex(n2), new this.constructor(this.blockList.editObjectAtIndex(n2, function(n3) {
              return n3.copyWithText(r2.updateAttributesForAttachment(t3, e2));
            }));
          }, c.prototype.removeAttributeForAttachment = function(t3, e2) {
            var n2;
            return n2 = this.getRangeOfAttachment(e2), this.removeAttributeAtRange(t3, n2);
          }, c.prototype.insertBlockBreakAtRange = function(t3) {
            var n2, o2, r2, s3;
            return s3 = (t3 = i(t3))[0], r2 = this.locationFromPosition(s3).offset, o2 = this.removeTextAtRange(t3), r2 === 0 && (n2 = [new e.Block()]), new this.constructor(o2.blockList.insertSplittableListAtPosition(new e.SplittableList(n2), s3));
          }, c.prototype.applyBlockAttributeAtRange = function(t3, e2, i2) {
            var o2, r2, s3, a2;
            return s3 = this.expandRangeToLineBreaksAndSplitBlocks(i2), r2 = s3.document, i2 = s3.range, o2 = n(t3), o2.listAttribute ? (r2 = r2.removeLastListAttributeAtRange(i2, {exceptAttributeName: t3}), a2 = r2.convertLineBreaksToBlockBreaksInRange(i2), r2 = a2.document, i2 = a2.range) : r2 = o2.exclusive ? r2.removeBlockAttributesAtRange(i2) : o2.terminal ? r2.removeLastTerminalAttributeAtRange(i2) : r2.consolidateBlocksAtRange(i2), r2.addAttributeAtRange(t3, e2, i2);
          }, c.prototype.removeLastListAttributeAtRange = function(t3, e2) {
            var i2;
            return e2 == null && (e2 = {}), i2 = this.blockList, this.eachBlockAtRange(t3, function(t4, o2, r2) {
              var s3;
              if ((s3 = t4.getLastAttribute()) && n(s3).listAttribute && s3 !== e2.exceptAttributeName)
                return i2 = i2.editObjectAtIndex(r2, function() {
                  return t4.removeAttribute(s3);
                });
            }), new this.constructor(i2);
          }, c.prototype.removeLastTerminalAttributeAtRange = function(t3) {
            var e2;
            return e2 = this.blockList, this.eachBlockAtRange(t3, function(t4, i2, o2) {
              var r2;
              if ((r2 = t4.getLastAttribute()) && n(r2).terminal)
                return e2 = e2.editObjectAtIndex(o2, function() {
                  return t4.removeAttribute(r2);
                });
            }), new this.constructor(e2);
          }, c.prototype.removeBlockAttributesAtRange = function(t3) {
            var e2;
            return e2 = this.blockList, this.eachBlockAtRange(t3, function(t4, n2, i2) {
              return t4.hasAttributes() ? e2 = e2.editObjectAtIndex(i2, function() {
                return t4.copyWithoutAttributes();
              }) : void 0;
            }), new this.constructor(e2);
          }, c.prototype.expandRangeToLineBreaksAndSplitBlocks = function(t3) {
            var e2, n2, o2, r2, s3, a2, u2, c2, l2;
            return a2 = t3 = i(t3), l2 = a2[0], r2 = a2[1], c2 = this.locationFromPosition(l2), o2 = this.locationFromPosition(r2), e2 = this, u2 = e2.getBlockAtIndex(c2.index), (c2.offset = u2.findLineBreakInDirectionFromPosition("backward", c2.offset)) != null && (s3 = e2.positionFromLocation(c2), e2 = e2.insertBlockBreakAtRange([s3, s3 + 1]), o2.index += 1, o2.offset -= e2.getBlockAtIndex(c2.index).getLength(), c2.index += 1), c2.offset = 0, o2.offset === 0 && o2.index > c2.index ? (o2.index -= 1, o2.offset = e2.getBlockAtIndex(o2.index).getBlockBreakPosition()) : (n2 = e2.getBlockAtIndex(o2.index), n2.text.getStringAtRange([o2.offset - 1, o2.offset]) === "\n" ? o2.offset -= 1 : o2.offset = n2.findLineBreakInDirectionFromPosition("forward", o2.offset), o2.offset !== n2.getBlockBreakPosition() && (s3 = e2.positionFromLocation(o2), e2 = e2.insertBlockBreakAtRange([s3, s3 + 1]))), l2 = e2.positionFromLocation(c2), r2 = e2.positionFromLocation(o2), t3 = i([l2, r2]), {document: e2, range: t3};
          }, c.prototype.convertLineBreaksToBlockBreaksInRange = function(t3) {
            var e2, n2, o2;
            return n2 = (t3 = i(t3))[0], o2 = this.getStringAtRange(t3).slice(0, -1), e2 = this, o2.replace(/.*?\n/g, function(t4) {
              return n2 += t4.length, e2 = e2.insertBlockBreakAtRange([n2 - 1, n2]);
            }), {document: e2, range: t3};
          }, c.prototype.consolidateBlocksAtRange = function(t3) {
            var e2, n2, o2, r2, s3;
            return o2 = t3 = i(t3), s3 = o2[0], n2 = o2[1], r2 = this.locationFromPosition(s3).index, e2 = this.locationFromPosition(n2).index, new this.constructor(this.blockList.consolidateFromIndexToIndex(r2, e2));
          }, c.prototype.getDocumentAtRange = function(t3) {
            var e2;
            return t3 = i(t3), e2 = this.blockList.getSplittableListInRange(t3).toArray(), new this.constructor(e2);
          }, c.prototype.getStringAtRange = function(t3) {
            var e2, n2, o2;
            return o2 = t3 = i(t3), n2 = o2[o2.length - 1], n2 !== this.getLength() && (e2 = -1), this.getDocumentAtRange(t3).toString().slice(0, e2);
          }, c.prototype.getBlockAtIndex = function(t3) {
            return this.blockList.getObjectAtIndex(t3);
          }, c.prototype.getBlockAtPosition = function(t3) {
            var e2;
            return e2 = this.locationFromPosition(t3).index, this.getBlockAtIndex(e2);
          }, c.prototype.getTextAtIndex = function(t3) {
            var e2;
            return (e2 = this.getBlockAtIndex(t3)) != null ? e2.text : void 0;
          }, c.prototype.getTextAtPosition = function(t3) {
            var e2;
            return e2 = this.locationFromPosition(t3).index, this.getTextAtIndex(e2);
          }, c.prototype.getPieceAtPosition = function(t3) {
            var e2, n2, i2;
            return i2 = this.locationFromPosition(t3), e2 = i2.index, n2 = i2.offset, this.getTextAtIndex(e2).getPieceAtPosition(n2);
          }, c.prototype.getCharacterAtPosition = function(t3) {
            var e2, n2, i2;
            return i2 = this.locationFromPosition(t3), e2 = i2.index, n2 = i2.offset, this.getTextAtIndex(e2).getStringAtRange([n2, n2 + 1]);
          }, c.prototype.getLength = function() {
            return this.blockList.getEndPosition();
          }, c.prototype.getBlocks = function() {
            return this.blockList.toArray();
          }, c.prototype.getBlockCount = function() {
            return this.blockList.length;
          }, c.prototype.getEditCount = function() {
            return this.editCount;
          }, c.prototype.eachBlock = function(t3) {
            return this.blockList.eachObject(t3);
          }, c.prototype.eachBlockAtRange = function(t3, e2) {
            var n2, o2, r2, s3, a2, u2, c2, l2, h, p, d, f;
            if (u2 = t3 = i(t3), d = u2[0], r2 = u2[1], p = this.locationFromPosition(d), o2 = this.locationFromPosition(r2), p.index === o2.index)
              return n2 = this.getBlockAtIndex(p.index), f = [p.offset, o2.offset], e2(n2, f, p.index);
            for (h = [], a2 = s3 = c2 = p.index, l2 = o2.index; l2 >= c2 ? l2 >= s3 : s3 >= l2; a2 = l2 >= c2 ? ++s3 : --s3)
              (n2 = this.getBlockAtIndex(a2)) ? (f = function() {
                switch (a2) {
                  case p.index:
                    return [p.offset, n2.text.getLength()];
                  case o2.index:
                    return [0, o2.offset];
                  default:
                    return [0, n2.text.getLength()];
                }
              }(), h.push(e2(n2, f, a2))) : h.push(void 0);
            return h;
          }, c.prototype.getCommonAttributesAtRange = function(t3) {
            var n2, r2, s3;
            return r2 = (t3 = i(t3))[0], o(t3) ? this.getCommonAttributesAtPosition(r2) : (s3 = [], n2 = [], this.eachBlockAtRange(t3, function(t4, e2) {
              return e2[0] !== e2[1] ? (s3.push(t4.text.getCommonAttributesAtRange(e2)), n2.push(l(t4))) : void 0;
            }), e.Hash.fromCommonAttributesOfObjects(s3).merge(e.Hash.fromCommonAttributesOfObjects(n2)).toObject());
          }, c.prototype.getCommonAttributesAtPosition = function(t3) {
            var n2, i2, o2, r2, s3, a2, c2, h, p, d;
            if (p = this.locationFromPosition(t3), s3 = p.index, h = p.offset, o2 = this.getBlockAtIndex(s3), !o2)
              return {};
            r2 = l(o2), n2 = o2.text.getAttributesAtPosition(h), i2 = o2.text.getAttributesAtPosition(h - 1), a2 = function() {
              var t4, n3;
              t4 = e.config.textAttributes, n3 = [];
              for (c2 in t4)
                d = t4[c2], d.inheritable && n3.push(c2);
              return n3;
            }();
            for (c2 in i2)
              d = i2[c2], (d === n2[c2] || u.call(a2, c2) >= 0) && (r2[c2] = d);
            return r2;
          }, c.prototype.getRangeOfCommonAttributeAtPosition = function(t3, e2) {
            var n2, o2, r2, s3, a2, u2, c2, l2, h;
            return a2 = this.locationFromPosition(e2), r2 = a2.index, s3 = a2.offset, h = this.getTextAtIndex(r2), u2 = h.getExpandedRangeForAttributeAtOffset(t3, s3), l2 = u2[0], o2 = u2[1], c2 = this.positionFromLocation({index: r2, offset: l2}), n2 = this.positionFromLocation({index: r2, offset: o2}), i([c2, n2]);
          }, c.prototype.getBaseBlockAttributes = function() {
            var t3, e2, n2, i2, o2, r2, s3;
            for (t3 = this.getBlockAtIndex(0).getAttributes(), n2 = i2 = 1, s3 = this.getBlockCount(); s3 >= 1 ? s3 > i2 : i2 > s3; n2 = s3 >= 1 ? ++i2 : --i2)
              e2 = this.getBlockAtIndex(n2).getAttributes(), r2 = Math.min(t3.length, e2.length), t3 = function() {
                var n3, i3, s4;
                for (s4 = [], o2 = n3 = 0, i3 = r2; (i3 >= 0 ? i3 > n3 : n3 > i3) && e2[o2] === t3[o2]; o2 = i3 >= 0 ? ++n3 : --n3)
                  s4.push(e2[o2]);
                return s4;
              }();
            return t3;
          }, l = function(t3) {
            var e2, n2;
            return n2 = {}, (e2 = t3.getLastAttribute()) && (n2[e2] = true), n2;
          }, c.prototype.getAttachmentById = function(t3) {
            var e2, n2, i2, o2;
            for (o2 = this.getAttachments(), n2 = 0, i2 = o2.length; i2 > n2; n2++)
              if (e2 = o2[n2], e2.id === t3)
                return e2;
          }, c.prototype.getAttachmentPieces = function() {
            var t3;
            return t3 = [], this.blockList.eachObject(function(e2) {
              var n2;
              return n2 = e2.text, t3 = t3.concat(n2.getAttachmentPieces());
            }), t3;
          }, c.prototype.getAttachments = function() {
            var t3, e2, n2, i2, o2;
            for (i2 = this.getAttachmentPieces(), o2 = [], t3 = 0, e2 = i2.length; e2 > t3; t3++)
              n2 = i2[t3], o2.push(n2.attachment);
            return o2;
          }, c.prototype.getRangeOfAttachment = function(t3) {
            var e2, n2, o2, r2, s3, a2, u2;
            for (r2 = 0, s3 = this.blockList.toArray(), n2 = e2 = 0, o2 = s3.length; o2 > e2; n2 = ++e2) {
              if (a2 = s3[n2].text, u2 = a2.getRangeOfAttachment(t3))
                return i([r2 + u2[0], r2 + u2[1]]);
              r2 += a2.getLength();
            }
          }, c.prototype.getLocationRangeOfAttachment = function(t3) {
            var e2;
            return e2 = this.getRangeOfAttachment(t3), this.locationRangeFromRange(e2);
          }, c.prototype.getAttachmentPieceForAttachment = function(t3) {
            var e2, n2, i2, o2;
            for (o2 = this.getAttachmentPieces(), e2 = 0, n2 = o2.length; n2 > e2; e2++)
              if (i2 = o2[e2], i2.attachment === t3)
                return i2;
          }, c.prototype.findRangesForBlockAttribute = function(t3) {
            var e2, n2, i2, o2, r2, s3, a2;
            for (r2 = 0, s3 = [], a2 = this.getBlocks(), n2 = 0, i2 = a2.length; i2 > n2; n2++)
              e2 = a2[n2], o2 = e2.getLength(), e2.hasAttribute(t3) && s3.push([r2, r2 + o2]), r2 += o2;
            return s3;
          }, c.prototype.findRangesForTextAttribute = function(t3, e2) {
            var n2, i2, o2, r2, s3, a2, u2, c2, l2, h;
            for (h = (e2 != null ? e2 : {}).withValue, a2 = 0, u2 = [], c2 = [], r2 = function(e3) {
              return h != null ? e3.getAttribute(t3) === h : e3.hasAttribute(t3);
            }, l2 = this.getPieces(), n2 = 0, i2 = l2.length; i2 > n2; n2++)
              s3 = l2[n2], o2 = s3.getLength(), r2(s3) && (u2[1] === a2 ? u2[1] = a2 + o2 : c2.push(u2 = [a2, a2 + o2])), a2 += o2;
            return c2;
          }, c.prototype.locationFromPosition = function(t3) {
            var e2, n2;
            return n2 = this.blockList.findIndexAndOffsetAtPosition(Math.max(0, t3)), n2.index != null ? n2 : (e2 = this.getBlocks(), {index: e2.length - 1, offset: e2[e2.length - 1].getLength()});
          }, c.prototype.positionFromLocation = function(t3) {
            return this.blockList.findPositionAtIndexAndOffset(t3.index, t3.offset);
          }, c.prototype.locationRangeFromPosition = function(t3) {
            return i(this.locationFromPosition(t3));
          }, c.prototype.locationRangeFromRange = function(t3) {
            var e2, n2, o2, r2;
            if (t3 = i(t3))
              return r2 = t3[0], n2 = t3[1], o2 = this.locationFromPosition(r2), e2 = this.locationFromPosition(n2), i([o2, e2]);
          }, c.prototype.rangeFromLocationRange = function(t3) {
            var e2, n2;
            return t3 = i(t3), e2 = this.positionFromLocation(t3[0]), o(t3) || (n2 = this.positionFromLocation(t3[1])), i([e2, n2]);
          }, c.prototype.isEqualTo = function(t3) {
            return this.blockList.isEqualTo(t3 != null ? t3.blockList : void 0);
          }, c.prototype.getTexts = function() {
            var t3, e2, n2, i2, o2;
            for (i2 = this.getBlocks(), o2 = [], e2 = 0, n2 = i2.length; n2 > e2; e2++)
              t3 = i2[e2], o2.push(t3.text);
            return o2;
          }, c.prototype.getPieces = function() {
            var t3, e2, n2, i2, o2;
            for (n2 = [], i2 = this.getTexts(), t3 = 0, e2 = i2.length; e2 > t3; t3++)
              o2 = i2[t3], n2.push.apply(n2, o2.getPieces());
            return n2;
          }, c.prototype.getObjects = function() {
            return this.getBlocks().concat(this.getTexts()).concat(this.getPieces());
          }, c.prototype.toSerializableDocument = function() {
            var t3;
            return t3 = [], this.blockList.eachObject(function(e2) {
              return t3.push(e2.copyWithText(e2.text.toSerializableText()));
            }), new this.constructor(t3);
          }, c.prototype.toString = function() {
            return this.blockList.toString();
          }, c.prototype.toJSON = function() {
            return this.blockList.toJSON();
          }, c.prototype.toConsole = function() {
            var t3;
            return JSON.stringify(function() {
              var e2, n2, i2, o2;
              for (i2 = this.blockList.toArray(), o2 = [], e2 = 0, n2 = i2.length; n2 > e2; e2++)
                t3 = i2[e2], o2.push(JSON.parse(t3.text.toConsole()));
              return o2;
            }.call(this));
          }, c;
        }(e.Object);
      }.call(this), function() {
        e.LineBreakInsertion = function() {
          function t2(t3) {
            var e2;
            this.composition = t3, this.document = this.composition.document, e2 = this.composition.getSelectedRange(), this.startPosition = e2[0], this.endPosition = e2[1], this.startLocation = this.document.locationFromPosition(this.startPosition), this.endLocation = this.document.locationFromPosition(this.endPosition), this.block = this.document.getBlockAtIndex(this.endLocation.index), this.breaksOnReturn = this.block.breaksOnReturn(), this.previousCharacter = this.block.text.getStringAtPosition(this.endLocation.offset - 1), this.nextCharacter = this.block.text.getStringAtPosition(this.endLocation.offset);
          }
          return t2.prototype.shouldInsertBlockBreak = function() {
            return this.block.hasAttributes() && this.block.isListItem() && !this.block.isEmpty() ? this.startLocation.offset !== 0 : this.breaksOnReturn && this.nextCharacter !== "\n";
          }, t2.prototype.shouldBreakFormattedBlock = function() {
            return this.block.hasAttributes() && !this.block.isListItem() && (this.breaksOnReturn && this.nextCharacter === "\n" || this.previousCharacter === "\n");
          }, t2.prototype.shouldDecreaseListLevel = function() {
            return this.block.hasAttributes() && this.block.isListItem() && this.block.isEmpty();
          }, t2.prototype.shouldPrependListItem = function() {
            return this.block.isListItem() && this.startLocation.offset === 0 && !this.block.isEmpty();
          }, t2.prototype.shouldRemoveLastBlockAttribute = function() {
            return this.block.hasAttributes() && !this.block.isListItem() && this.block.isEmpty();
          }, t2;
        }();
      }.call(this), function() {
        var t2, n, i, o, r, s, a, u, c, l, h = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            p.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, p = {}.hasOwnProperty;
        s = e.normalizeRange, c = e.rangesAreEqual, u = e.rangeIsCollapsed, a = e.objectsAreEqual, t2 = e.arrayStartsWith, l = e.summarizeArrayChange, i = e.getAllAttributeNames, o = e.getBlockConfig, r = e.getTextConfig, n = e.extend, e.Composition = function(p2) {
          function d() {
            this.document = new e.Document(), this.attachments = [], this.currentAttributes = {}, this.revision = 0;
          }
          var f;
          return h(d, p2), d.prototype.setDocument = function(t3) {
            var e2;
            return t3.isEqualTo(this.document) ? void 0 : (this.document = t3, this.refreshAttachments(), this.revision++, (e2 = this.delegate) != null && typeof e2.compositionDidChangeDocument == "function" ? e2.compositionDidChangeDocument(t3) : void 0);
          }, d.prototype.getSnapshot = function() {
            return {document: this.document, selectedRange: this.getSelectedRange()};
          }, d.prototype.loadSnapshot = function(t3) {
            var n2, i2, o2, r2;
            return n2 = t3.document, r2 = t3.selectedRange, (i2 = this.delegate) != null && typeof i2.compositionWillLoadSnapshot == "function" && i2.compositionWillLoadSnapshot(), this.setDocument(n2 != null ? n2 : new e.Document()), this.setSelection(r2 != null ? r2 : [0, 0]), (o2 = this.delegate) != null && typeof o2.compositionDidLoadSnapshot == "function" ? o2.compositionDidLoadSnapshot() : void 0;
          }, d.prototype.insertText = function(t3, e2) {
            var n2, i2, o2, r2;
            return r2 = (e2 != null ? e2 : {updatePosition: true}).updatePosition, i2 = this.getSelectedRange(), this.setDocument(this.document.insertTextAtRange(t3, i2)), o2 = i2[0], n2 = o2 + t3.getLength(), r2 && this.setSelection(n2), this.notifyDelegateOfInsertionAtRange([o2, n2]);
          }, d.prototype.insertBlock = function(t3) {
            var n2;
            return t3 == null && (t3 = new e.Block()), n2 = new e.Document([t3]), this.insertDocument(n2);
          }, d.prototype.insertDocument = function(t3) {
            var n2, i2, o2;
            return t3 == null && (t3 = new e.Document()), i2 = this.getSelectedRange(), this.setDocument(this.document.insertDocumentAtRange(t3, i2)), o2 = i2[0], n2 = o2 + t3.getLength(), this.setSelection(n2), this.notifyDelegateOfInsertionAtRange([o2, n2]);
          }, d.prototype.insertString = function(t3, n2) {
            var i2, o2;
            return i2 = this.getCurrentTextAttributes(), o2 = e.Text.textForStringWithAttributes(t3, i2), this.insertText(o2, n2);
          }, d.prototype.insertBlockBreak = function() {
            var t3, e2, n2;
            return e2 = this.getSelectedRange(), this.setDocument(this.document.insertBlockBreakAtRange(e2)), n2 = e2[0], t3 = n2 + 1, this.setSelection(t3), this.notifyDelegateOfInsertionAtRange([n2, t3]);
          }, d.prototype.insertLineBreak = function() {
            var t3, n2;
            return n2 = new e.LineBreakInsertion(this), n2.shouldDecreaseListLevel() ? (this.decreaseListLevel(), this.setSelection(n2.startPosition)) : n2.shouldPrependListItem() ? (t3 = new e.Document([n2.block.copyWithoutText()]), this.insertDocument(t3)) : n2.shouldInsertBlockBreak() ? this.insertBlockBreak() : n2.shouldRemoveLastBlockAttribute() ? this.removeLastBlockAttribute() : n2.shouldBreakFormattedBlock() ? this.breakFormattedBlock(n2) : this.insertString("\n");
          }, d.prototype.insertHTML = function(t3) {
            var n2, i2, o2, r2;
            return n2 = e.Document.fromHTML(t3), o2 = this.getSelectedRange(), this.setDocument(this.document.mergeDocumentAtRange(n2, o2)), r2 = o2[0], i2 = r2 + n2.getLength() - 1, this.setSelection(i2), this.notifyDelegateOfInsertionAtRange([r2, i2]);
          }, d.prototype.replaceHTML = function(t3) {
            var n2, i2, o2;
            return n2 = e.Document.fromHTML(t3).copyUsingObjectsFromDocument(this.document), i2 = this.getLocationRange({strict: false}), o2 = this.document.rangeFromLocationRange(i2), this.setDocument(n2), this.setSelection(o2);
          }, d.prototype.insertFile = function(t3) {
            return this.insertFiles([t3]);
          }, d.prototype.insertFiles = function(t3) {
            var n2, i2, o2, r2, s2, a2;
            for (i2 = [], r2 = 0, s2 = t3.length; s2 > r2; r2++)
              o2 = t3[r2], ((a2 = this.delegate) != null ? a2.compositionShouldAcceptFile(o2) : void 0) && (n2 = e.Attachment.attachmentForFile(o2), i2.push(n2));
            return this.insertAttachments(i2);
          }, d.prototype.insertAttachment = function(t3) {
            return this.insertAttachments([t3]);
          }, d.prototype.insertAttachments = function(t3) {
            var n2, i2, o2, r2, s2, a2, u2, c2, l2;
            for (c2 = new e.Text(), r2 = 0, s2 = t3.length; s2 > r2; r2++)
              n2 = t3[r2], l2 = n2.getType(), a2 = (u2 = e.config.attachments[l2]) != null ? u2.presentation : void 0, o2 = this.getCurrentTextAttributes(), a2 && (o2.presentation = a2), i2 = e.Text.textForAttachmentWithAttributes(n2, o2), c2 = c2.appendText(i2);
            return this.insertText(c2);
          }, d.prototype.shouldManageDeletingInDirection = function(t3) {
            var e2;
            if (e2 = this.getLocationRange(), u(e2)) {
              if (t3 === "backward" && e2[0].offset === 0)
                return true;
              if (this.shouldManageMovingCursorInDirection(t3))
                return true;
            } else if (e2[0].index !== e2[1].index)
              return true;
            return false;
          }, d.prototype.deleteInDirection = function(t3, e2) {
            var n2, i2, o2, r2, s2, a2, c2, l2;
            return r2 = (e2 != null ? e2 : {}).length, s2 = this.getLocationRange(), a2 = this.getSelectedRange(), c2 = u(a2), c2 ? o2 = t3 === "backward" && s2[0].offset === 0 : l2 = s2[0].index !== s2[1].index, o2 && this.canDecreaseBlockAttributeLevel() && (i2 = this.getBlock(), i2.isListItem() ? this.decreaseListLevel() : this.decreaseBlockAttributeLevel(), this.setSelection(a2[0]), i2.isEmpty()) ? false : (c2 && (a2 = this.getExpandedRangeInDirection(t3, {length: r2}), t3 === "backward" && (n2 = this.getAttachmentAtRange(a2))), n2 ? (this.editAttachment(n2), false) : (this.setDocument(this.document.removeTextAtRange(a2)), this.setSelection(a2[0]), o2 || l2 ? false : void 0));
          }, d.prototype.moveTextFromRange = function(t3) {
            var e2;
            return e2 = this.getSelectedRange()[0], this.setDocument(this.document.moveTextFromRangeToPosition(t3, e2)), this.setSelection(e2);
          }, d.prototype.removeAttachment = function(t3) {
            var e2;
            return (e2 = this.document.getRangeOfAttachment(t3)) ? (this.stopEditingAttachment(), this.setDocument(this.document.removeTextAtRange(e2)), this.setSelection(e2[0])) : void 0;
          }, d.prototype.removeLastBlockAttribute = function() {
            var t3, e2, n2, i2;
            return n2 = this.getSelectedRange(), i2 = n2[0], e2 = n2[1], t3 = this.document.getBlockAtPosition(e2), this.removeCurrentAttribute(t3.getLastAttribute()), this.setSelection(i2);
          }, f = " ", d.prototype.insertPlaceholder = function() {
            return this.placeholderPosition = this.getPosition(), this.insertString(f);
          }, d.prototype.selectPlaceholder = function() {
            return this.placeholderPosition != null ? (this.setSelectedRange([this.placeholderPosition, this.placeholderPosition + f.length]), this.getSelectedRange()) : void 0;
          }, d.prototype.forgetPlaceholder = function() {
            return this.placeholderPosition = null;
          }, d.prototype.hasCurrentAttribute = function(t3) {
            var e2;
            return e2 = this.currentAttributes[t3], e2 != null && e2 !== false;
          }, d.prototype.toggleCurrentAttribute = function(t3) {
            var e2;
            return (e2 = !this.currentAttributes[t3]) ? this.setCurrentAttribute(t3, e2) : this.removeCurrentAttribute(t3);
          }, d.prototype.canSetCurrentAttribute = function(t3) {
            return o(t3) ? this.canSetCurrentBlockAttribute(t3) : this.canSetCurrentTextAttribute(t3);
          }, d.prototype.canSetCurrentTextAttribute = function() {
            var t3, e2, n2, i2, o2;
            if (e2 = this.getSelectedDocument()) {
              for (o2 = e2.getAttachments(), n2 = 0, i2 = o2.length; i2 > n2; n2++)
                if (t3 = o2[n2], !t3.hasContent())
                  return false;
              return true;
            }
          }, d.prototype.canSetCurrentBlockAttribute = function() {
            var t3;
            if (t3 = this.getBlock())
              return !t3.isTerminalBlock();
          }, d.prototype.setCurrentAttribute = function(t3, e2) {
            return o(t3) ? this.setBlockAttribute(t3, e2) : (this.setTextAttribute(t3, e2), this.currentAttributes[t3] = e2, this.notifyDelegateOfCurrentAttributesChange());
          }, d.prototype.setTextAttribute = function(t3, n2) {
            var i2, o2, r2, s2;
            if (o2 = this.getSelectedRange())
              return r2 = o2[0], i2 = o2[1], r2 !== i2 ? this.setDocument(this.document.addAttributeAtRange(t3, n2, o2)) : t3 === "href" ? (s2 = e.Text.textForStringWithAttributes(n2, {href: n2}), this.insertText(s2)) : void 0;
          }, d.prototype.setBlockAttribute = function(t3, e2) {
            var n2, i2;
            if (i2 = this.getSelectedRange())
              return this.canSetCurrentAttribute(t3) ? (n2 = this.getBlock(), this.setDocument(this.document.applyBlockAttributeAtRange(t3, e2, i2)), this.setSelection(i2)) : void 0;
          }, d.prototype.removeCurrentAttribute = function(t3) {
            return o(t3) ? (this.removeBlockAttribute(t3), this.updateCurrentAttributes()) : (this.removeTextAttribute(t3), delete this.currentAttributes[t3], this.notifyDelegateOfCurrentAttributesChange());
          }, d.prototype.removeTextAttribute = function(t3) {
            var e2;
            if (e2 = this.getSelectedRange())
              return this.setDocument(this.document.removeAttributeAtRange(t3, e2));
          }, d.prototype.removeBlockAttribute = function(t3) {
            var e2;
            if (e2 = this.getSelectedRange())
              return this.setDocument(this.document.removeAttributeAtRange(t3, e2));
          }, d.prototype.canDecreaseNestingLevel = function() {
            var t3;
            return ((t3 = this.getBlock()) != null ? t3.getNestingLevel() : void 0) > 0;
          }, d.prototype.canIncreaseNestingLevel = function() {
            var e2, n2, i2;
            if (e2 = this.getBlock())
              return ((i2 = o(e2.getLastNestableAttribute())) != null ? i2.listAttribute : 0) ? (n2 = this.getPreviousBlock()) ? t2(n2.getListItemAttributes(), e2.getListItemAttributes()) : void 0 : e2.getNestingLevel() > 0;
          }, d.prototype.decreaseNestingLevel = function() {
            var t3;
            if (t3 = this.getBlock())
              return this.setDocument(this.document.replaceBlock(t3, t3.decreaseNestingLevel()));
          }, d.prototype.increaseNestingLevel = function() {
            var t3;
            if (t3 = this.getBlock())
              return this.setDocument(this.document.replaceBlock(t3, t3.increaseNestingLevel()));
          }, d.prototype.canDecreaseBlockAttributeLevel = function() {
            var t3;
            return ((t3 = this.getBlock()) != null ? t3.getAttributeLevel() : void 0) > 0;
          }, d.prototype.decreaseBlockAttributeLevel = function() {
            var t3, e2;
            return (t3 = (e2 = this.getBlock()) != null ? e2.getLastAttribute() : void 0) ? this.removeCurrentAttribute(t3) : void 0;
          }, d.prototype.decreaseListLevel = function() {
            var t3, e2, n2, i2, o2, r2;
            for (r2 = this.getSelectedRange()[0], o2 = this.document.locationFromPosition(r2).index, n2 = o2, t3 = this.getBlock().getAttributeLevel(); (e2 = this.document.getBlockAtIndex(n2 + 1)) && e2.isListItem() && e2.getAttributeLevel() > t3; )
              n2++;
            return r2 = this.document.positionFromLocation({index: o2, offset: 0}), i2 = this.document.positionFromLocation({index: n2, offset: 0}), this.setDocument(this.document.removeLastListAttributeAtRange([r2, i2]));
          }, d.prototype.updateCurrentAttributes = function() {
            var t3, e2, n2, o2, r2, s2;
            if (s2 = this.getSelectedRange({ignoreLock: true})) {
              for (e2 = this.document.getCommonAttributesAtRange(s2), r2 = i(), n2 = 0, o2 = r2.length; o2 > n2; n2++)
                t3 = r2[n2], e2[t3] || this.canSetCurrentAttribute(t3) || (e2[t3] = false);
              if (!a(e2, this.currentAttributes))
                return this.currentAttributes = e2, this.notifyDelegateOfCurrentAttributesChange();
            }
          }, d.prototype.getCurrentAttributes = function() {
            return n.call({}, this.currentAttributes);
          }, d.prototype.getCurrentTextAttributes = function() {
            var t3, e2, n2, i2;
            t3 = {}, n2 = this.currentAttributes;
            for (e2 in n2)
              i2 = n2[e2], i2 !== false && r(e2) && (t3[e2] = i2);
            return t3;
          }, d.prototype.freezeSelection = function() {
            return this.setCurrentAttribute("frozen", true);
          }, d.prototype.thawSelection = function() {
            return this.removeCurrentAttribute("frozen");
          }, d.prototype.hasFrozenSelection = function() {
            return this.hasCurrentAttribute("frozen");
          }, d.proxyMethod("getSelectionManager().getPointRange"), d.proxyMethod("getSelectionManager().setLocationRangeFromPointRange"), d.proxyMethod("getSelectionManager().createLocationRangeFromDOMRange"), d.proxyMethod("getSelectionManager().locationIsCursorTarget"), d.proxyMethod("getSelectionManager().selectionIsExpanded"), d.proxyMethod("delegate?.getSelectionManager"), d.prototype.setSelection = function(t3) {
            var e2, n2;
            return e2 = this.document.locationRangeFromRange(t3), (n2 = this.delegate) != null ? n2.compositionDidRequestChangingSelectionToLocationRange(e2) : void 0;
          }, d.prototype.getSelectedRange = function() {
            var t3;
            return (t3 = this.getLocationRange()) ? this.document.rangeFromLocationRange(t3) : void 0;
          }, d.prototype.setSelectedRange = function(t3) {
            var e2;
            return e2 = this.document.locationRangeFromRange(t3), this.getSelectionManager().setLocationRange(e2);
          }, d.prototype.getPosition = function() {
            var t3;
            return (t3 = this.getLocationRange()) ? this.document.positionFromLocation(t3[0]) : void 0;
          }, d.prototype.getLocationRange = function(t3) {
            var e2, n2;
            return (e2 = (n2 = this.targetLocationRange) != null ? n2 : this.getSelectionManager().getLocationRange(t3)) != null ? e2 : s({index: 0, offset: 0});
          }, d.prototype.withTargetLocationRange = function(t3, e2) {
            var n2;
            this.targetLocationRange = t3;
            try {
              n2 = e2();
            } finally {
              this.targetLocationRange = null;
            }
            return n2;
          }, d.prototype.withTargetRange = function(t3, e2) {
            var n2;
            return n2 = this.document.locationRangeFromRange(t3), this.withTargetLocationRange(n2, e2);
          }, d.prototype.withTargetDOMRange = function(t3, e2) {
            var n2;
            return n2 = this.createLocationRangeFromDOMRange(t3, {strict: false}), this.withTargetLocationRange(n2, e2);
          }, d.prototype.getExpandedRangeInDirection = function(t3, e2) {
            var n2, i2, o2, r2;
            return i2 = (e2 != null ? e2 : {}).length, o2 = this.getSelectedRange(), r2 = o2[0], n2 = o2[1], t3 === "backward" ? i2 ? r2 -= i2 : r2 = this.translateUTF16PositionFromOffset(r2, -1) : i2 ? n2 += i2 : n2 = this.translateUTF16PositionFromOffset(n2, 1), s([r2, n2]);
          }, d.prototype.shouldManageMovingCursorInDirection = function(t3) {
            var e2;
            return this.editingAttachment ? true : (e2 = this.getExpandedRangeInDirection(t3), this.getAttachmentAtRange(e2) != null);
          }, d.prototype.moveCursorInDirection = function(t3) {
            var e2, n2, i2, o2;
            return this.editingAttachment ? i2 = this.document.getRangeOfAttachment(this.editingAttachment) : (o2 = this.getSelectedRange(), i2 = this.getExpandedRangeInDirection(t3), n2 = !c(o2, i2)), this.setSelectedRange(t3 === "backward" ? i2[0] : i2[1]), n2 && (e2 = this.getAttachmentAtRange(i2)) ? this.editAttachment(e2) : void 0;
          }, d.prototype.expandSelectionInDirection = function(t3, e2) {
            var n2, i2;
            return n2 = (e2 != null ? e2 : {}).length, i2 = this.getExpandedRangeInDirection(t3, {length: n2}), this.setSelectedRange(i2);
          }, d.prototype.expandSelectionForEditing = function() {
            return this.hasCurrentAttribute("href") ? this.expandSelectionAroundCommonAttribute("href") : void 0;
          }, d.prototype.expandSelectionAroundCommonAttribute = function(t3) {
            var e2, n2;
            return e2 = this.getPosition(), n2 = this.document.getRangeOfCommonAttributeAtPosition(t3, e2), this.setSelectedRange(n2);
          }, d.prototype.selectionContainsAttachments = function() {
            var t3;
            return ((t3 = this.getSelectedAttachments()) != null ? t3.length : void 0) > 0;
          }, d.prototype.selectionIsInCursorTarget = function() {
            return this.editingAttachment || this.positionIsCursorTarget(this.getPosition());
          }, d.prototype.positionIsCursorTarget = function(t3) {
            var e2;
            return (e2 = this.document.locationFromPosition(t3)) ? this.locationIsCursorTarget(e2) : void 0;
          }, d.prototype.positionIsBlockBreak = function(t3) {
            var e2;
            return (e2 = this.document.getPieceAtPosition(t3)) != null ? e2.isBlockBreak() : void 0;
          }, d.prototype.getSelectedDocument = function() {
            var t3;
            return (t3 = this.getSelectedRange()) ? this.document.getDocumentAtRange(t3) : void 0;
          }, d.prototype.getSelectedAttachments = function() {
            var t3;
            return (t3 = this.getSelectedDocument()) != null ? t3.getAttachments() : void 0;
          }, d.prototype.getAttachments = function() {
            return this.attachments.slice(0);
          }, d.prototype.refreshAttachments = function() {
            var t3, e2, n2, i2, o2, r2, s2, a2, u2, c2, h2, p3;
            for (n2 = this.document.getAttachments(), a2 = l(this.attachments, n2), t3 = a2.added, h2 = a2.removed, this.attachments = n2, i2 = 0, r2 = h2.length; r2 > i2; i2++)
              e2 = h2[i2], e2.delegate = null, (u2 = this.delegate) != null && typeof u2.compositionDidRemoveAttachment == "function" && u2.compositionDidRemoveAttachment(e2);
            for (p3 = [], o2 = 0, s2 = t3.length; s2 > o2; o2++)
              e2 = t3[o2], e2.delegate = this, p3.push((c2 = this.delegate) != null && typeof c2.compositionDidAddAttachment == "function" ? c2.compositionDidAddAttachment(e2) : void 0);
            return p3;
          }, d.prototype.attachmentDidChangeAttributes = function(t3) {
            var e2;
            return this.revision++, (e2 = this.delegate) != null && typeof e2.compositionDidEditAttachment == "function" ? e2.compositionDidEditAttachment(t3) : void 0;
          }, d.prototype.attachmentDidChangePreviewURL = function(t3) {
            var e2;
            return this.revision++, (e2 = this.delegate) != null && typeof e2.compositionDidChangeAttachmentPreviewURL == "function" ? e2.compositionDidChangeAttachmentPreviewURL(t3) : void 0;
          }, d.prototype.editAttachment = function(t3, e2) {
            var n2;
            if (t3 !== this.editingAttachment)
              return this.stopEditingAttachment(), this.editingAttachment = t3, (n2 = this.delegate) != null && typeof n2.compositionDidStartEditingAttachment == "function" ? n2.compositionDidStartEditingAttachment(this.editingAttachment, e2) : void 0;
          }, d.prototype.stopEditingAttachment = function() {
            var t3;
            if (this.editingAttachment)
              return (t3 = this.delegate) != null && typeof t3.compositionDidStopEditingAttachment == "function" && t3.compositionDidStopEditingAttachment(this.editingAttachment), this.editingAttachment = null;
          }, d.prototype.updateAttributesForAttachment = function(t3, e2) {
            return this.setDocument(this.document.updateAttributesForAttachment(t3, e2));
          }, d.prototype.removeAttributeForAttachment = function(t3, e2) {
            return this.setDocument(this.document.removeAttributeForAttachment(t3, e2));
          }, d.prototype.breakFormattedBlock = function(t3) {
            var n2, i2, o2, r2, s2;
            return i2 = t3.document, n2 = t3.block, r2 = t3.startPosition, s2 = [r2 - 1, r2], n2.getBlockBreakPosition() === t3.startLocation.offset ? (n2.breaksOnReturn() && t3.nextCharacter === "\n" ? r2 += 1 : i2 = i2.removeTextAtRange(s2), s2 = [r2, r2]) : t3.nextCharacter === "\n" ? t3.previousCharacter === "\n" ? s2 = [r2 - 1, r2 + 1] : (s2 = [r2, r2 + 1], r2 += 1) : t3.startLocation.offset - 1 !== 0 && (r2 += 1), o2 = new e.Document([n2.removeLastAttribute().copyWithoutText()]), this.setDocument(i2.insertDocumentAtRange(o2, s2)), this.setSelection(r2);
          }, d.prototype.getPreviousBlock = function() {
            var t3, e2;
            return (e2 = this.getLocationRange()) && (t3 = e2[0].index, t3 > 0) ? this.document.getBlockAtIndex(t3 - 1) : void 0;
          }, d.prototype.getBlock = function() {
            var t3;
            return (t3 = this.getLocationRange()) ? this.document.getBlockAtIndex(t3[0].index) : void 0;
          }, d.prototype.getAttachmentAtRange = function(t3) {
            var n2;
            return n2 = this.document.getDocumentAtRange(t3), n2.toString() === e.OBJECT_REPLACEMENT_CHARACTER + "\n" ? n2.getAttachments()[0] : void 0;
          }, d.prototype.notifyDelegateOfCurrentAttributesChange = function() {
            var t3;
            return (t3 = this.delegate) != null && typeof t3.compositionDidChangeCurrentAttributes == "function" ? t3.compositionDidChangeCurrentAttributes(this.currentAttributes) : void 0;
          }, d.prototype.notifyDelegateOfInsertionAtRange = function(t3) {
            var e2;
            return (e2 = this.delegate) != null && typeof e2.compositionDidPerformInsertionAtRange == "function" ? e2.compositionDidPerformInsertionAtRange(t3) : void 0;
          }, d.prototype.translateUTF16PositionFromOffset = function(t3, e2) {
            var n2, i2;
            return i2 = this.document.toUTF16String(), n2 = i2.offsetFromUCS2Offset(t3), i2.offsetToUCS2Offset(n2 + e2);
          }, d;
        }(e.BasicObject);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.UndoManager = function(e2) {
          function n2(t3) {
            this.composition = t3, this.undoEntries = [], this.redoEntries = [];
          }
          var i;
          return t2(n2, e2), n2.prototype.recordUndoEntry = function(t3, e3) {
            var n3, o, r, s, a;
            return s = e3 != null ? e3 : {}, o = s.context, n3 = s.consolidatable, r = this.undoEntries.slice(-1)[0], n3 && i(r, t3, o) ? void 0 : (a = this.createEntry({description: t3, context: o}), this.undoEntries.push(a), this.redoEntries = []);
          }, n2.prototype.undo = function() {
            var t3, e3;
            return (e3 = this.undoEntries.pop()) ? (t3 = this.createEntry(e3), this.redoEntries.push(t3), this.composition.loadSnapshot(e3.snapshot)) : void 0;
          }, n2.prototype.redo = function() {
            var t3, e3;
            return (t3 = this.redoEntries.pop()) ? (e3 = this.createEntry(t3), this.undoEntries.push(e3), this.composition.loadSnapshot(t3.snapshot)) : void 0;
          }, n2.prototype.canUndo = function() {
            return this.undoEntries.length > 0;
          }, n2.prototype.canRedo = function() {
            return this.redoEntries.length > 0;
          }, n2.prototype.createEntry = function(t3) {
            var e3, n3, i2;
            return i2 = t3 != null ? t3 : {}, n3 = i2.description, e3 = i2.context, {description: n3 != null ? n3.toString() : void 0, context: JSON.stringify(e3), snapshot: this.composition.getSnapshot()};
          }, i = function(t3, e3, n3) {
            return (t3 != null ? t3.description : void 0) === (e3 != null ? e3.toString() : void 0) && (t3 != null ? t3.context : void 0) === JSON.stringify(n3);
          }, n2;
        }(e.BasicObject);
      }.call(this), function() {
        var t2;
        e.attachmentGalleryFilter = function(e2) {
          var n;
          return n = new t2(e2), n.perform(), n.getSnapshot();
        }, t2 = function() {
          function t3(t4) {
            this.document = t4.document, this.selectedRange = t4.selectedRange;
          }
          var e2, n, i;
          return e2 = "attachmentGallery", n = "presentation", i = "gallery", t3.prototype.perform = function() {
            return this.removeBlockAttribute(), this.applyBlockAttribute();
          }, t3.prototype.getSnapshot = function() {
            return {document: this.document, selectedRange: this.selectedRange};
          }, t3.prototype.removeBlockAttribute = function() {
            var t4, n2, i2, o, r;
            for (o = this.findRangesOfBlocks(), r = [], t4 = 0, n2 = o.length; n2 > t4; t4++)
              i2 = o[t4], r.push(this.document = this.document.removeAttributeAtRange(e2, i2));
            return r;
          }, t3.prototype.applyBlockAttribute = function() {
            var t4, n2, i2, o, r, s;
            for (i2 = 0, r = this.findRangesOfPieces(), s = [], t4 = 0, n2 = r.length; n2 > t4; t4++)
              o = r[t4], o[1] - o[0] > 1 && (o[0] += i2, o[1] += i2, this.document.getCharacterAtPosition(o[1]) !== "\n" && (this.document = this.document.insertBlockBreakAtRange(o[1]), o[1] < this.selectedRange[1] && this.moveSelectedRangeForward(), o[1]++, i2++), o[0] !== 0 && this.document.getCharacterAtPosition(o[0] - 1) !== "\n" && (this.document = this.document.insertBlockBreakAtRange(o[0]), o[0] < this.selectedRange[0] && this.moveSelectedRangeForward(), o[0]++, i2++), s.push(this.document = this.document.applyBlockAttributeAtRange(e2, true, o)));
            return s;
          }, t3.prototype.findRangesOfBlocks = function() {
            return this.document.findRangesForBlockAttribute(e2);
          }, t3.prototype.findRangesOfPieces = function() {
            return this.document.findRangesForTextAttribute(n, {withValue: i});
          }, t3.prototype.moveSelectedRangeForward = function() {
            return this.selectedRange[0] += 1, this.selectedRange[1] += 1;
          }, t3;
        }();
      }.call(this), function() {
        var t2 = function(t3, e2) {
          return function() {
            return t3.apply(e2, arguments);
          };
        };
        e.Editor = function() {
          function n(n2, o, r) {
            this.composition = n2, this.selectionManager = o, this.element = r, this.insertFiles = t2(this.insertFiles, this), this.undoManager = new e.UndoManager(this.composition), this.filters = i.slice(0);
          }
          var i;
          return i = [e.attachmentGalleryFilter], n.prototype.loadDocument = function(t3) {
            return this.loadSnapshot({document: t3, selectedRange: [0, 0]});
          }, n.prototype.loadHTML = function(t3) {
            return t3 == null && (t3 = ""), this.loadDocument(e.Document.fromHTML(t3, {referenceElement: this.element}));
          }, n.prototype.loadJSON = function(t3) {
            var n2, i2;
            return n2 = t3.document, i2 = t3.selectedRange, n2 = e.Document.fromJSON(n2), this.loadSnapshot({document: n2, selectedRange: i2});
          }, n.prototype.loadSnapshot = function(t3) {
            return this.undoManager = new e.UndoManager(this.composition), this.composition.loadSnapshot(t3);
          }, n.prototype.getDocument = function() {
            return this.composition.document;
          }, n.prototype.getSelectedDocument = function() {
            return this.composition.getSelectedDocument();
          }, n.prototype.getSnapshot = function() {
            return this.composition.getSnapshot();
          }, n.prototype.toJSON = function() {
            return this.getSnapshot();
          }, n.prototype.deleteInDirection = function(t3) {
            return this.composition.deleteInDirection(t3);
          }, n.prototype.insertAttachment = function(t3) {
            return this.composition.insertAttachment(t3);
          }, n.prototype.insertAttachments = function(t3) {
            return this.composition.insertAttachments(t3);
          }, n.prototype.insertDocument = function(t3) {
            return this.composition.insertDocument(t3);
          }, n.prototype.insertFile = function(t3) {
            return this.composition.insertFile(t3);
          }, n.prototype.insertFiles = function(t3) {
            return this.composition.insertFiles(t3);
          }, n.prototype.insertHTML = function(t3) {
            return this.composition.insertHTML(t3);
          }, n.prototype.insertString = function(t3) {
            return this.composition.insertString(t3);
          }, n.prototype.insertText = function(t3) {
            return this.composition.insertText(t3);
          }, n.prototype.insertLineBreak = function() {
            return this.composition.insertLineBreak();
          }, n.prototype.getSelectedRange = function() {
            return this.composition.getSelectedRange();
          }, n.prototype.getPosition = function() {
            return this.composition.getPosition();
          }, n.prototype.getClientRectAtPosition = function(t3) {
            var e2;
            return e2 = this.getDocument().locationRangeFromRange([t3, t3 + 1]), this.selectionManager.getClientRectAtLocationRange(e2);
          }, n.prototype.expandSelectionInDirection = function(t3) {
            return this.composition.expandSelectionInDirection(t3);
          }, n.prototype.moveCursorInDirection = function(t3) {
            return this.composition.moveCursorInDirection(t3);
          }, n.prototype.setSelectedRange = function(t3) {
            return this.composition.setSelectedRange(t3);
          }, n.prototype.activateAttribute = function(t3, e2) {
            return e2 == null && (e2 = true), this.composition.setCurrentAttribute(t3, e2);
          }, n.prototype.attributeIsActive = function(t3) {
            return this.composition.hasCurrentAttribute(t3);
          }, n.prototype.canActivateAttribute = function(t3) {
            return this.composition.canSetCurrentAttribute(t3);
          }, n.prototype.deactivateAttribute = function(t3) {
            return this.composition.removeCurrentAttribute(t3);
          }, n.prototype.canDecreaseNestingLevel = function() {
            return this.composition.canDecreaseNestingLevel();
          }, n.prototype.canIncreaseNestingLevel = function() {
            return this.composition.canIncreaseNestingLevel();
          }, n.prototype.decreaseNestingLevel = function() {
            return this.canDecreaseNestingLevel() ? this.composition.decreaseNestingLevel() : void 0;
          }, n.prototype.increaseNestingLevel = function() {
            return this.canIncreaseNestingLevel() ? this.composition.increaseNestingLevel() : void 0;
          }, n.prototype.canRedo = function() {
            return this.undoManager.canRedo();
          }, n.prototype.canUndo = function() {
            return this.undoManager.canUndo();
          }, n.prototype.recordUndoEntry = function(t3, e2) {
            var n2, i2, o;
            return o = e2 != null ? e2 : {}, i2 = o.context, n2 = o.consolidatable, this.undoManager.recordUndoEntry(t3, {context: i2, consolidatable: n2});
          }, n.prototype.redo = function() {
            return this.canRedo() ? this.undoManager.redo() : void 0;
          }, n.prototype.undo = function() {
            return this.canUndo() ? this.undoManager.undo() : void 0;
          }, n;
        }();
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.ManagedAttachment = function(e2) {
          function n2(t3, e3) {
            var n3;
            this.attachmentManager = t3, this.attachment = e3, n3 = this.attachment, this.id = n3.id, this.file = n3.file;
          }
          return t2(n2, e2), n2.prototype.remove = function() {
            return this.attachmentManager.requestRemovalOfAttachment(this.attachment);
          }, n2.proxyMethod("attachment.getAttribute"), n2.proxyMethod("attachment.hasAttribute"), n2.proxyMethod("attachment.setAttribute"), n2.proxyMethod("attachment.getAttributes"), n2.proxyMethod("attachment.setAttributes"), n2.proxyMethod("attachment.isPending"), n2.proxyMethod("attachment.isPreviewable"), n2.proxyMethod("attachment.getURL"), n2.proxyMethod("attachment.getHref"), n2.proxyMethod("attachment.getFilename"), n2.proxyMethod("attachment.getFilesize"), n2.proxyMethod("attachment.getFormattedFilesize"), n2.proxyMethod("attachment.getExtension"), n2.proxyMethod("attachment.getContentType"), n2.proxyMethod("attachment.getFile"), n2.proxyMethod("attachment.setFile"), n2.proxyMethod("attachment.releaseFile"), n2.proxyMethod("attachment.getUploadProgress"), n2.proxyMethod("attachment.setUploadProgress"), n2;
        }(e.BasicObject);
      }.call(this), function() {
        var t2 = function(t3, e2) {
          function i() {
            this.constructor = t3;
          }
          for (var o in e2)
            n.call(e2, o) && (t3[o] = e2[o]);
          return i.prototype = e2.prototype, t3.prototype = new i(), t3.__super__ = e2.prototype, t3;
        }, n = {}.hasOwnProperty;
        e.AttachmentManager = function(n2) {
          function i(t3) {
            var e2, n3, i2;
            for (t3 == null && (t3 = []), this.managedAttachments = {}, n3 = 0, i2 = t3.length; i2 > n3; n3++)
              e2 = t3[n3], this.manageAttachment(e2);
          }
          return t2(i, n2), i.prototype.getAttachments = function() {
            var t3, e2, n3, i2;
            n3 = this.managedAttachments, i2 = [];
            for (e2 in n3)
              t3 = n3[e2], i2.push(t3);
            return i2;
          }, i.prototype.manageAttachment = function(t3) {
            var n3, i2;
            return (n3 = this.managedAttachments)[i2 = t3.id] != null ? n3[i2] : n3[i2] = new e.ManagedAttachment(this, t3);
          }, i.prototype.attachmentIsManaged = function(t3) {
            return t3.id in this.managedAttachments;
          }, i.prototype.requestRemovalOfAttachment = function(t3) {
            var e2;
            return this.attachmentIsManaged(t3) && (e2 = this.delegate) != null && typeof e2.attachmentManagerDidRequestRemovalOfAttachment == "function" ? e2.attachmentManagerDidRequestRemovalOfAttachment(t3) : void 0;
          }, i.prototype.unmanageAttachment = function(t3) {
            var e2;
            return e2 = this.managedAttachments[t3.id], delete this.managedAttachments[t3.id], e2;
          }, i;
        }(e.BasicObject);
      }.call(this), function() {
        var t2, n, i, o, r, s, a, u, c, l, h;
        t2 = e.elementContainsNode, n = e.findChildIndexOfNode, r = e.nodeIsBlockStart, s = e.nodeIsBlockStartComment, o = e.nodeIsBlockContainer, a = e.nodeIsCursorTarget, u = e.nodeIsEmptyTextNode, c = e.nodeIsTextNode, i = e.nodeIsAttachmentElement, l = e.tagName, h = e.walkTree, e.LocationMapper = function() {
          function e2(t3) {
            this.element = t3;
          }
          var p, d, f, g;
          return e2.prototype.findLocationFromContainerAndOffset = function(e3, i2, o2) {
            var s2, u2, l2, p2, g2, m, v;
            for (m = (o2 != null ? o2 : {strict: true}).strict, u2 = 0, l2 = false, p2 = {index: 0, offset: 0}, (s2 = this.findAttachmentElementParentForNode(e3)) && (e3 = s2.parentNode, i2 = n(s2)), v = h(this.element, {usingFilter: f}); v.nextNode(); ) {
              if (g2 = v.currentNode, g2 === e3 && c(e3)) {
                a(g2) || (p2.offset += i2);
                break;
              }
              if (g2.parentNode === e3) {
                if (u2++ === i2)
                  break;
              } else if (!t2(e3, g2) && u2 > 0)
                break;
              r(g2, {strict: m}) ? (l2 && p2.index++, p2.offset = 0, l2 = true) : p2.offset += d(g2);
            }
            return p2;
          }, e2.prototype.findContainerAndOffsetFromLocation = function(t3) {
            var e3, i2, s2, u2, l2;
            if (t3.index === 0 && t3.offset === 0) {
              for (e3 = this.element, u2 = 0; e3.firstChild; )
                if (e3 = e3.firstChild, o(e3)) {
                  u2 = 1;
                  break;
                }
              return [e3, u2];
            }
            if (l2 = this.findNodeAndOffsetFromLocation(t3), i2 = l2[0], s2 = l2[1], i2) {
              if (c(i2))
                d(i2) === 0 ? (e3 = i2.parentNode.parentNode, u2 = n(i2.parentNode), a(i2, {name: "right"}) && u2++) : (e3 = i2, u2 = t3.offset - s2);
              else {
                if (e3 = i2.parentNode, !r(i2.previousSibling) && !o(e3))
                  for (; i2 === e3.lastChild && (i2 = e3, e3 = e3.parentNode, !o(e3)); )
                    ;
                u2 = n(i2), t3.offset !== 0 && u2++;
              }
              return [e3, u2];
            }
          }, e2.prototype.findNodeAndOffsetFromLocation = function(t3) {
            var e3, n2, i2, o2, r2, s2, u2, l2;
            for (u2 = 0, l2 = this.getSignificantNodesForIndex(t3.index), n2 = 0, i2 = l2.length; i2 > n2; n2++) {
              if (e3 = l2[n2], o2 = d(e3), t3.offset <= u2 + o2)
                if (c(e3)) {
                  if (r2 = e3, s2 = u2, t3.offset === s2 && a(r2))
                    break;
                } else
                  r2 || (r2 = e3, s2 = u2);
              if (u2 += o2, u2 > t3.offset)
                break;
            }
            return [r2, s2];
          }, e2.prototype.findAttachmentElementParentForNode = function(t3) {
            for (; t3 && t3 !== this.element; ) {
              if (i(t3))
                return t3;
              t3 = t3.parentNode;
            }
          }, e2.prototype.getSignificantNodesForIndex = function(t3) {
            var e3, n2, i2, o2, r2;
            for (i2 = [], r2 = h(this.element, {usingFilter: p}), o2 = false; r2.nextNode(); )
              if (n2 = r2.currentNode, s(n2)) {
                if (typeof e3 != "undefined" && e3 !== null ? e3++ : e3 = 0, e3 === t3)
                  o2 = true;
                else if (o2)
                  break;
              } else
                o2 && i2.push(n2);
            return i2;
          }, d = function(t3) {
            var e3;
            return t3.nodeType === Node.TEXT_NODE ? a(t3) ? 0 : (e3 = t3.textContent, e3.length) : l(t3) === "br" || i(t3) ? 1 : 0;
          }, p = function(t3) {
            return g(t3) === NodeFilter.FILTER_ACCEPT ? f(t3) : NodeFilter.FILTER_REJECT;
          }, g = function(t3) {
            return u(t3) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
          }, f = function(t3) {
            return i(t3.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
          }, e2;
        }();
      }.call(this), function() {
        var t2, n, i = [].slice;
        t2 = e.getDOMRange, n = e.setDOMRange, e.PointMapper = function() {
          function e2() {
          }
          return e2.prototype.createDOMRangeFromPoint = function(e3) {
            var i2, o, r, s, a, u, c, l;
            if (c = e3.x, l = e3.y, document.caretPositionFromPoint)
              return a = document.caretPositionFromPoint(c, l), r = a.offsetNode, o = a.offset, i2 = document.createRange(), i2.setStart(r, o), i2;
            if (document.caretRangeFromPoint)
              return document.caretRangeFromPoint(c, l);
            if (document.body.createTextRange) {
              s = t2();
              try {
                u = document.body.createTextRange(), u.moveToPoint(c, l), u.select();
              } catch (h) {
              }
              return i2 = t2(), n(s), i2;
            }
          }, e2.prototype.getClientRectsForDOMRange = function(t3) {
            var e3, n2, o;
            return n2 = i.call(t3.getClientRects()), o = n2[0], e3 = n2[n2.length - 1], [o, e3];
          }, e2;
        }();
      }.call(this), function() {
        var t2, n = function(t3, e2) {
          return function() {
            return t3.apply(e2, arguments);
          };
        }, i = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            o.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, o = {}.hasOwnProperty, r = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        };
        t2 = e.getDOMRange, e.SelectionChangeObserver = function(e2) {
          function o2() {
            this.run = n(this.run, this), this.update = n(this.update, this), this.selectionManagers = [];
          }
          var s;
          return i(o2, e2), o2.prototype.start = function() {
            return this.started ? void 0 : (this.started = true, "onselectionchange" in document ? document.addEventListener("selectionchange", this.update, true) : this.run());
          }, o2.prototype.stop = function() {
            return this.started ? (this.started = false, document.removeEventListener("selectionchange", this.update, true)) : void 0;
          }, o2.prototype.registerSelectionManager = function(t3) {
            return r.call(this.selectionManagers, t3) < 0 ? (this.selectionManagers.push(t3), this.start()) : void 0;
          }, o2.prototype.unregisterSelectionManager = function(t3) {
            var e3;
            return this.selectionManagers = function() {
              var n2, i2, o3, r2;
              for (o3 = this.selectionManagers, r2 = [], n2 = 0, i2 = o3.length; i2 > n2; n2++)
                e3 = o3[n2], e3 !== t3 && r2.push(e3);
              return r2;
            }.call(this), this.selectionManagers.length === 0 ? this.stop() : void 0;
          }, o2.prototype.notifySelectionManagersOfSelectionChange = function() {
            var t3, e3, n2, i2, o3;
            for (n2 = this.selectionManagers, i2 = [], t3 = 0, e3 = n2.length; e3 > t3; t3++)
              o3 = n2[t3], i2.push(o3.selectionDidChange());
            return i2;
          }, o2.prototype.update = function() {
            var e3;
            return e3 = t2(), s(e3, this.domRange) ? void 0 : (this.domRange = e3, this.notifySelectionManagersOfSelectionChange());
          }, o2.prototype.reset = function() {
            return this.domRange = null, this.update();
          }, o2.prototype.run = function() {
            return this.started ? (this.update(), requestAnimationFrame(this.run)) : void 0;
          }, s = function(t3, e3) {
            return (t3 != null ? t3.startContainer : void 0) === (e3 != null ? e3.startContainer : void 0) && (t3 != null ? t3.startOffset : void 0) === (e3 != null ? e3.startOffset : void 0) && (t3 != null ? t3.endContainer : void 0) === (e3 != null ? e3.endContainer : void 0) && (t3 != null ? t3.endOffset : void 0) === (e3 != null ? e3.endOffset : void 0);
          }, o2;
        }(e.BasicObject), e.selectionChangeObserver == null && (e.selectionChangeObserver = new e.SelectionChangeObserver());
      }.call(this), function() {
        var t2, n, i, o, r, s, a, u, c, l, h = function(t3, e2) {
          return function() {
            return t3.apply(e2, arguments);
          };
        }, p = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            d.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, d = {}.hasOwnProperty;
        i = e.getDOMSelection, n = e.getDOMRange, l = e.setDOMRange, t2 = e.elementContainsNode, s = e.nodeIsCursorTarget, r = e.innerElementIsActive, o = e.handleEvent, a = e.normalizeRange, u = e.rangeIsCollapsed, c = e.rangesAreEqual, e.SelectionManager = function(d2) {
          function f(t3) {
            this.element = t3, this.selectionDidChange = h(this.selectionDidChange, this), this.didMouseDown = h(this.didMouseDown, this), this.locationMapper = new e.LocationMapper(this.element), this.pointMapper = new e.PointMapper(), this.lockCount = 0, o("mousedown", {onElement: this.element, withCallback: this.didMouseDown});
          }
          return p(f, d2), f.prototype.getLocationRange = function(t3) {
            var e2, i2;
            return t3 == null && (t3 = {}), e2 = t3.strict === false ? this.createLocationRangeFromDOMRange(n(), {strict: false}) : t3.ignoreLock ? this.currentLocationRange : (i2 = this.lockedLocationRange) != null ? i2 : this.currentLocationRange;
          }, f.prototype.setLocationRange = function(t3) {
            var e2;
            if (!this.lockedLocationRange)
              return t3 = a(t3), (e2 = this.createDOMRangeFromLocationRange(t3)) ? (l(e2), this.updateCurrentLocationRange(t3)) : void 0;
          }, f.prototype.setLocationRangeFromPointRange = function(t3) {
            var e2, n2;
            return t3 = a(t3), n2 = this.getLocationAtPoint(t3[0]), e2 = this.getLocationAtPoint(t3[1]), this.setLocationRange([n2, e2]);
          }, f.prototype.getClientRectAtLocationRange = function(t3) {
            var e2;
            return (e2 = this.createDOMRangeFromLocationRange(t3)) ? this.getClientRectsForDOMRange(e2)[1] : void 0;
          }, f.prototype.locationIsCursorTarget = function(t3) {
            var e2, n2, i2;
            return i2 = this.findNodeAndOffsetFromLocation(t3), e2 = i2[0], n2 = i2[1], s(e2);
          }, f.prototype.lock = function() {
            return this.lockCount++ === 0 ? (this.updateCurrentLocationRange(), this.lockedLocationRange = this.getLocationRange()) : void 0;
          }, f.prototype.unlock = function() {
            var t3;
            return --this.lockCount === 0 && (t3 = this.lockedLocationRange, this.lockedLocationRange = null, t3 != null) ? this.setLocationRange(t3) : void 0;
          }, f.prototype.clearSelection = function() {
            var t3;
            return (t3 = i()) != null ? t3.removeAllRanges() : void 0;
          }, f.prototype.selectionIsCollapsed = function() {
            var t3;
            return ((t3 = n()) != null ? t3.collapsed : void 0) === true;
          }, f.prototype.selectionIsExpanded = function() {
            return !this.selectionIsCollapsed();
          }, f.prototype.createLocationRangeFromDOMRange = function(t3, e2) {
            var n2, i2;
            if (t3 != null && this.domRangeWithinElement(t3) && (i2 = this.findLocationFromContainerAndOffset(t3.startContainer, t3.startOffset, e2)))
              return t3.collapsed || (n2 = this.findLocationFromContainerAndOffset(t3.endContainer, t3.endOffset, e2)), a([i2, n2]);
          }, f.proxyMethod("locationMapper.findLocationFromContainerAndOffset"), f.proxyMethod("locationMapper.findContainerAndOffsetFromLocation"), f.proxyMethod("locationMapper.findNodeAndOffsetFromLocation"), f.proxyMethod("pointMapper.createDOMRangeFromPoint"), f.proxyMethod("pointMapper.getClientRectsForDOMRange"), f.prototype.didMouseDown = function() {
            return this.pauseTemporarily();
          }, f.prototype.pauseTemporarily = function() {
            var e2, n2, i2, r2;
            return this.paused = true, n2 = function(e3) {
              return function() {
                var n3, o2, s2;
                for (e3.paused = false, clearTimeout(r2), o2 = 0, s2 = i2.length; s2 > o2; o2++)
                  n3 = i2[o2], n3.destroy();
                return t2(document, e3.element) ? e3.selectionDidChange() : void 0;
              };
            }(this), r2 = setTimeout(n2, 200), i2 = function() {
              var t3, i3, r3, s2;
              for (r3 = ["mousemove", "keydown"], s2 = [], t3 = 0, i3 = r3.length; i3 > t3; t3++)
                e2 = r3[t3], s2.push(o(e2, {onElement: document, withCallback: n2}));
              return s2;
            }();
          }, f.prototype.selectionDidChange = function() {
            return this.paused || r(this.element) ? void 0 : this.updateCurrentLocationRange();
          }, f.prototype.updateCurrentLocationRange = function(t3) {
            var e2;
            return (t3 != null ? t3 : t3 = this.createLocationRangeFromDOMRange(n())) && !c(t3, this.currentLocationRange) ? (this.currentLocationRange = t3, (e2 = this.delegate) != null && typeof e2.locationRangeDidChange == "function" ? e2.locationRangeDidChange(this.currentLocationRange.slice(0)) : void 0) : void 0;
          }, f.prototype.createDOMRangeFromLocationRange = function(t3) {
            var e2, n2, i2, o2;
            return i2 = this.findContainerAndOffsetFromLocation(t3[0]), n2 = u(t3) ? i2 : (o2 = this.findContainerAndOffsetFromLocation(t3[1])) != null ? o2 : i2, i2 != null && n2 != null ? (e2 = document.createRange(), e2.setStart.apply(e2, i2), e2.setEnd.apply(e2, n2), e2) : void 0;
          }, f.prototype.getLocationAtPoint = function(t3) {
            var e2, n2;
            return (e2 = this.createDOMRangeFromPoint(t3)) && (n2 = this.createLocationRangeFromDOMRange(e2)) != null ? n2[0] : void 0;
          }, f.prototype.domRangeWithinElement = function(e2) {
            return e2.collapsed ? t2(this.element, e2.startContainer) : t2(this.element, e2.startContainer) && t2(this.element, e2.endContainer);
          }, f;
        }(e.BasicObject);
      }.call(this), function() {
        var t2, n, i, o, r = function(t3, e2) {
          function n2() {
            this.constructor = t3;
          }
          for (var i2 in e2)
            s.call(e2, i2) && (t3[i2] = e2[i2]);
          return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
        }, s = {}.hasOwnProperty, a = [].slice;
        i = e.rangeIsCollapsed, o = e.rangesAreEqual, n = e.objectsAreEqual, t2 = e.getBlockConfig, e.EditorController = function(s2) {
          function u(t3) {
            var n2, i2;
            this.editorElement = t3.editorElement, n2 = t3.document, i2 = t3.html, this.selectionManager = new e.SelectionManager(this.editorElement), this.selectionManager.delegate = this, this.composition = new e.Composition(), this.composition.delegate = this, this.attachmentManager = new e.AttachmentManager(this.composition.getAttachments()), this.attachmentManager.delegate = this, this.inputController = new e["Level" + e.config.input.getLevel() + "InputController"](this.editorElement), this.inputController.delegate = this, this.inputController.responder = this.composition, this.compositionController = new e.CompositionController(this.editorElement, this.composition), this.compositionController.delegate = this, this.toolbarController = new e.ToolbarController(this.editorElement.toolbarElement), this.toolbarController.delegate = this, this.editor = new e.Editor(this.composition, this.selectionManager, this.editorElement), n2 != null ? this.editor.loadDocument(n2) : this.editor.loadHTML(i2);
          }
          var c;
          return r(u, s2), u.prototype.registerSelectionManager = function() {
            return e.selectionChangeObserver.registerSelectionManager(this.selectionManager);
          }, u.prototype.unregisterSelectionManager = function() {
            return e.selectionChangeObserver.unregisterSelectionManager(this.selectionManager);
          }, u.prototype.render = function() {
            return this.compositionController.render();
          }, u.prototype.reparse = function() {
            return this.composition.replaceHTML(this.editorElement.innerHTML);
          }, u.prototype.compositionDidChangeDocument = function() {
            return this.notifyEditorElement("document-change"), this.handlingInput ? void 0 : this.render();
          }, u.prototype.compositionDidChangeCurrentAttributes = function(t3) {
            return this.currentAttributes = t3, this.toolbarController.updateAttributes(this.currentAttributes), this.updateCurrentActions(), this.notifyEditorElement("attributes-change", {attributes: this.currentAttributes});
          }, u.prototype.compositionDidPerformInsertionAtRange = function(t3) {
            return this.pasting ? this.pastedRange = t3 : void 0;
          }, u.prototype.compositionShouldAcceptFile = function(t3) {
            return this.notifyEditorElement("file-accept", {file: t3});
          }, u.prototype.compositionDidAddAttachment = function(t3) {
            var e2;
            return e2 = this.attachmentManager.manageAttachment(t3), this.notifyEditorElement("attachment-add", {attachment: e2});
          }, u.prototype.compositionDidEditAttachment = function(t3) {
            var e2;
            return this.compositionController.rerenderViewForObject(t3), e2 = this.attachmentManager.manageAttachment(t3), this.notifyEditorElement("attachment-edit", {attachment: e2}), this.notifyEditorElement("change");
          }, u.prototype.compositionDidChangeAttachmentPreviewURL = function(t3) {
            return this.compositionController.invalidateViewForObject(t3), this.notifyEditorElement("change");
          }, u.prototype.compositionDidRemoveAttachment = function(t3) {
            var e2;
            return e2 = this.attachmentManager.unmanageAttachment(t3), this.notifyEditorElement("attachment-remove", {attachment: e2});
          }, u.prototype.compositionDidStartEditingAttachment = function(t3, e2) {
            return this.attachmentLocationRange = this.composition.document.getLocationRangeOfAttachment(t3), this.compositionController.installAttachmentEditorForAttachment(t3, e2), this.selectionManager.setLocationRange(this.attachmentLocationRange);
          }, u.prototype.compositionDidStopEditingAttachment = function() {
            return this.compositionController.uninstallAttachmentEditor(), this.attachmentLocationRange = null;
          }, u.prototype.compositionDidRequestChangingSelectionToLocationRange = function(t3) {
            return !this.loadingSnapshot || this.isFocused() ? (this.requestedLocationRange = t3, this.compositionRevisionWhenLocationRangeRequested = this.composition.revision, this.handlingInput ? void 0 : this.render()) : void 0;
          }, u.prototype.compositionWillLoadSnapshot = function() {
            return this.loadingSnapshot = true;
          }, u.prototype.compositionDidLoadSnapshot = function() {
            return this.compositionController.refreshViewCache(), this.render(), this.loadingSnapshot = false;
          }, u.prototype.getSelectionManager = function() {
            return this.selectionManager;
          }, u.proxyMethod("getSelectionManager().setLocationRange"), u.proxyMethod("getSelectionManager().getLocationRange"), u.prototype.attachmentManagerDidRequestRemovalOfAttachment = function(t3) {
            return this.removeAttachment(t3);
          }, u.prototype.compositionControllerWillSyncDocumentView = function() {
            return this.inputController.editorWillSyncDocumentView(), this.selectionManager.lock(), this.selectionManager.clearSelection();
          }, u.prototype.compositionControllerDidSyncDocumentView = function() {
            return this.inputController.editorDidSyncDocumentView(), this.selectionManager.unlock(), this.updateCurrentActions(), this.notifyEditorElement("sync");
          }, u.prototype.compositionControllerDidRender = function() {
            return this.requestedLocationRange != null && (this.compositionRevisionWhenLocationRangeRequested === this.composition.revision && this.selectionManager.setLocationRange(this.requestedLocationRange), this.requestedLocationRange = null, this.compositionRevisionWhenLocationRangeRequested = null), this.renderedCompositionRevision !== this.composition.revision && (this.runEditorFilters(), this.composition.updateCurrentAttributes(), this.notifyEditorElement("render")), this.renderedCompositionRevision = this.composition.revision;
          }, u.prototype.compositionControllerDidFocus = function() {
            return this.isFocusedInvisibly() && this.setLocationRange({index: 0, offset: 0}), this.toolbarController.hideDialog(), this.notifyEditorElement("focus");
          }, u.prototype.compositionControllerDidBlur = function() {
            return this.notifyEditorElement("blur");
          }, u.prototype.compositionControllerDidSelectAttachment = function(t3, e2) {
            return this.toolbarController.hideDialog(), this.composition.editAttachment(t3, e2);
          }, u.prototype.compositionControllerDidRequestDeselectingAttachment = function(t3) {
            var e2, n2;
            return e2 = (n2 = this.attachmentLocationRange) != null ? n2 : this.composition.document.getLocationRangeOfAttachment(t3), this.selectionManager.setLocationRange(e2[1]);
          }, u.prototype.compositionControllerWillUpdateAttachment = function(t3) {
            return this.editor.recordUndoEntry("Edit Attachment", {context: t3.id, consolidatable: true});
          }, u.prototype.compositionControllerDidRequestRemovalOfAttachment = function(t3) {
            return this.removeAttachment(t3);
          }, u.prototype.inputControllerWillHandleInput = function() {
            return this.handlingInput = true, this.requestedRender = false;
          }, u.prototype.inputControllerDidRequestRender = function() {
            return this.requestedRender = true;
          }, u.prototype.inputControllerDidHandleInput = function() {
            return this.handlingInput = false, this.requestedRender ? (this.requestedRender = false, this.render()) : void 0;
          }, u.prototype.inputControllerDidAllowUnhandledInput = function() {
            return this.notifyEditorElement("change");
          }, u.prototype.inputControllerDidRequestReparse = function() {
            return this.reparse();
          }, u.prototype.inputControllerWillPerformTyping = function() {
            return this.recordTypingUndoEntry();
          }, u.prototype.inputControllerWillPerformFormatting = function(t3) {
            return this.recordFormattingUndoEntry(t3);
          }, u.prototype.inputControllerWillCutText = function() {
            return this.editor.recordUndoEntry("Cut");
          }, u.prototype.inputControllerWillPaste = function(t3) {
            return this.editor.recordUndoEntry("Paste"), this.pasting = true, this.notifyEditorElement("before-paste", {paste: t3});
          }, u.prototype.inputControllerDidPaste = function(t3) {
            return t3.range = this.pastedRange, this.pastedRange = null, this.pasting = null, this.notifyEditorElement("paste", {paste: t3});
          }, u.prototype.inputControllerWillMoveText = function() {
            return this.editor.recordUndoEntry("Move");
          }, u.prototype.inputControllerWillAttachFiles = function() {
            return this.editor.recordUndoEntry("Drop Files");
          }, u.prototype.inputControllerWillPerformUndo = function() {
            return this.editor.undo();
          }, u.prototype.inputControllerWillPerformRedo = function() {
            return this.editor.redo();
          }, u.prototype.inputControllerDidReceiveKeyboardCommand = function(t3) {
            return this.toolbarController.applyKeyboardCommand(t3);
          }, u.prototype.inputControllerDidStartDrag = function() {
            return this.locationRangeBeforeDrag = this.selectionManager.getLocationRange();
          }, u.prototype.inputControllerDidReceiveDragOverPoint = function(t3) {
            return this.selectionManager.setLocationRangeFromPointRange(t3);
          }, u.prototype.inputControllerDidCancelDrag = function() {
            return this.selectionManager.setLocationRange(this.locationRangeBeforeDrag), this.locationRangeBeforeDrag = null;
          }, u.prototype.locationRangeDidChange = function(t3) {
            return this.composition.updateCurrentAttributes(), this.updateCurrentActions(), this.attachmentLocationRange && !o(this.attachmentLocationRange, t3) && this.composition.stopEditingAttachment(), this.notifyEditorElement("selection-change");
          }, u.prototype.toolbarDidClickButton = function() {
            return this.getLocationRange() ? void 0 : this.setLocationRange({index: 0, offset: 0});
          }, u.prototype.toolbarDidInvokeAction = function(t3) {
            return this.invokeAction(t3);
          }, u.prototype.toolbarDidToggleAttribute = function(t3) {
            return this.recordFormattingUndoEntry(t3), this.composition.toggleCurrentAttribute(t3), this.render(), this.selectionFrozen ? void 0 : this.editorElement.focus();
          }, u.prototype.toolbarDidUpdateAttribute = function(t3, e2) {
            return this.recordFormattingUndoEntry(t3), this.composition.setCurrentAttribute(t3, e2), this.render(), this.selectionFrozen ? void 0 : this.editorElement.focus();
          }, u.prototype.toolbarDidRemoveAttribute = function(t3) {
            return this.recordFormattingUndoEntry(t3), this.composition.removeCurrentAttribute(t3), this.render(), this.selectionFrozen ? void 0 : this.editorElement.focus();
          }, u.prototype.toolbarWillShowDialog = function() {
            return this.composition.expandSelectionForEditing(), this.freezeSelection();
          }, u.prototype.toolbarDidShowDialog = function(t3) {
            return this.notifyEditorElement("toolbar-dialog-show", {dialogName: t3});
          }, u.prototype.toolbarDidHideDialog = function(t3) {
            return this.thawSelection(), this.editorElement.focus(), this.notifyEditorElement("toolbar-dialog-hide", {dialogName: t3});
          }, u.prototype.freezeSelection = function() {
            return this.selectionFrozen ? void 0 : (this.selectionManager.lock(), this.composition.freezeSelection(), this.selectionFrozen = true, this.render());
          }, u.prototype.thawSelection = function() {
            return this.selectionFrozen ? (this.composition.thawSelection(), this.selectionManager.unlock(), this.selectionFrozen = false, this.render()) : void 0;
          }, u.prototype.actions = {undo: {test: function() {
            return this.editor.canUndo();
          }, perform: function() {
            return this.editor.undo();
          }}, redo: {test: function() {
            return this.editor.canRedo();
          }, perform: function() {
            return this.editor.redo();
          }}, link: {test: function() {
            return this.editor.canActivateAttribute("href");
          }}, increaseNestingLevel: {test: function() {
            return this.editor.canIncreaseNestingLevel();
          }, perform: function() {
            return this.editor.increaseNestingLevel() && this.render();
          }}, decreaseNestingLevel: {test: function() {
            return this.editor.canDecreaseNestingLevel();
          }, perform: function() {
            return this.editor.decreaseNestingLevel() && this.render();
          }}, attachFiles: {test: function() {
            return true;
          }, perform: function() {
            return e.config.input.pickFiles(this.editor.insertFiles);
          }}}, u.prototype.canInvokeAction = function(t3) {
            var e2, n2;
            return this.actionIsExternal(t3) ? true : !!((e2 = this.actions[t3]) != null && (n2 = e2.test) != null ? n2.call(this) : void 0);
          }, u.prototype.invokeAction = function(t3) {
            var e2, n2;
            return this.actionIsExternal(t3) ? this.notifyEditorElement("action-invoke", {actionName: t3}) : (e2 = this.actions[t3]) != null && (n2 = e2.perform) != null ? n2.call(this) : void 0;
          }, u.prototype.actionIsExternal = function(t3) {
            return /^x-./.test(t3);
          }, u.prototype.getCurrentActions = function() {
            var t3, e2;
            e2 = {};
            for (t3 in this.actions)
              e2[t3] = this.canInvokeAction(t3);
            return e2;
          }, u.prototype.updateCurrentActions = function() {
            var t3;
            return t3 = this.getCurrentActions(), n(t3, this.currentActions) ? void 0 : (this.currentActions = t3, this.toolbarController.updateActions(this.currentActions), this.notifyEditorElement("actions-change", {actions: this.currentActions}));
          }, u.prototype.runEditorFilters = function() {
            var t3, e2, n2, i2, o2, r2, s3, a2;
            for (a2 = this.composition.getSnapshot(), o2 = this.editor.filters, n2 = 0, i2 = o2.length; i2 > n2; n2++)
              e2 = o2[n2], t3 = a2.document, s3 = a2.selectedRange, a2 = (r2 = e2.call(this.editor, a2)) != null ? r2 : {}, a2.document == null && (a2.document = t3), a2.selectedRange == null && (a2.selectedRange = s3);
            return c(a2, this.composition.getSnapshot()) ? void 0 : this.composition.loadSnapshot(a2);
          }, c = function(t3, e2) {
            return o(t3.selectedRange, e2.selectedRange) && t3.document.isEqualTo(e2.document);
          }, u.prototype.updateInputElement = function() {
            var t3, n2;
            return t3 = this.compositionController.getSerializableElement(), n2 = e.serializeToContentType(t3, "text/html"), this.editorElement.setInputElementValue(n2);
          }, u.prototype.notifyEditorElement = function(t3, e2) {
            switch (t3) {
              case "document-change":
                this.documentChangedSinceLastRender = true;
                break;
              case "render":
                this.documentChangedSinceLastRender && (this.documentChangedSinceLastRender = false, this.notifyEditorElement("change"));
                break;
              case "change":
              case "attachment-add":
              case "attachment-edit":
              case "attachment-remove":
                this.updateInputElement();
            }
            return this.editorElement.notify(t3, e2);
          }, u.prototype.removeAttachment = function(t3) {
            return this.editor.recordUndoEntry("Delete Attachment"), this.composition.removeAttachment(t3), this.render();
          }, u.prototype.recordFormattingUndoEntry = function(e2) {
            var n2, o2;
            return n2 = t2(e2), o2 = this.selectionManager.getLocationRange(), n2 || !i(o2) ? this.editor.recordUndoEntry("Formatting", {context: this.getUndoContext(), consolidatable: true}) : void 0;
          }, u.prototype.recordTypingUndoEntry = function() {
            return this.editor.recordUndoEntry("Typing", {context: this.getUndoContext(this.currentAttributes), consolidatable: true});
          }, u.prototype.getUndoContext = function() {
            var t3;
            return t3 = 1 <= arguments.length ? a.call(arguments, 0) : [], [this.getLocationContext(), this.getTimeContext()].concat(a.call(t3));
          }, u.prototype.getLocationContext = function() {
            var t3;
            return t3 = this.selectionManager.getLocationRange(), i(t3) ? t3[0].index : t3;
          }, u.prototype.getTimeContext = function() {
            return e.config.undoInterval > 0 ? Math.floor(new Date().getTime() / e.config.undoInterval) : 0;
          }, u.prototype.isFocused = function() {
            var t3;
            return this.editorElement === ((t3 = this.editorElement.ownerDocument) != null ? t3.activeElement : void 0);
          }, u.prototype.isFocusedInvisibly = function() {
            return this.isFocused() && !this.getLocationRange();
          }, u;
        }(e.Controller);
      }.call(this), function() {
        var t2, n, i, o, r, s, a, u = [].indexOf || function(t3) {
          for (var e2 = 0, n2 = this.length; n2 > e2; e2++)
            if (e2 in this && this[e2] === t3)
              return e2;
          return -1;
        };
        n = e.browser, s = e.makeElement, a = e.triggerEvent, o = e.handleEvent, r = e.handleEventOnce, i = e.findClosestElementFromNode, t2 = e.AttachmentView.attachmentSelector, e.registerElement("trix-editor", function() {
          var c, l, h, p, d, f, g, m, v;
          return g = 0, l = function(t3) {
            return !document.querySelector(":focus") && t3.hasAttribute("autofocus") && document.querySelector("[autofocus]") === t3 ? t3.focus() : void 0;
          }, m = function(t3) {
            return t3.hasAttribute("contenteditable") ? void 0 : (t3.setAttribute("contenteditable", ""), r("focus", {onElement: t3, withCallback: function() {
              return h(t3);
            }}));
          }, h = function(t3) {
            return d(t3), v(t3);
          }, d = function(t3) {
            return (typeof document.queryCommandSupported == "function" ? document.queryCommandSupported("enableObjectResizing") : void 0) ? (document.execCommand("enableObjectResizing", false, false), o("mscontrolselect", {onElement: t3, preventDefault: true})) : void 0;
          }, v = function() {
            var t3;
            return (typeof document.queryCommandSupported == "function" ? document.queryCommandSupported("DefaultParagraphSeparator") : void 0) && (t3 = e.config.blockAttributes["default"].tagName, t3 === "div" || t3 === "p") ? document.execCommand("DefaultParagraphSeparator", false, t3) : void 0;
          }, c = function(t3) {
            return t3.hasAttribute("role") ? void 0 : t3.setAttribute("role", "textbox");
          }, f = function(t3) {
            var e2;
            if (!t3.hasAttribute("aria-label") && !t3.hasAttribute("aria-labelledby"))
              return (e2 = function() {
                var e3, n2, i2;
                return i2 = function() {
                  var n3, i3, o2, r2;
                  for (o2 = t3.labels, r2 = [], n3 = 0, i3 = o2.length; i3 > n3; n3++)
                    e3 = o2[n3], e3.contains(t3) || r2.push(e3.textContent);
                  return r2;
                }(), (n2 = i2.join(" ")) ? t3.setAttribute("aria-label", n2) : t3.removeAttribute("aria-label");
              })(), o("focus", {onElement: t3, withCallback: e2});
          }, p = function() {
            return n.forcesObjectResizing ? {display: "inline", width: "auto"} : {display: "inline-block", width: "1px"};
          }(), {defaultCSS: "%t {\n  display: block;\n}\n\n%t:empty:not(:focus)::before {\n  content: attr(placeholder);\n  color: graytext;\n  cursor: text;\n  pointer-events: none;\n}\n\n%t a[contenteditable=false] {\n  cursor: text;\n}\n\n%t img {\n  max-width: 100%;\n  height: auto;\n}\n\n%t " + t2 + " figcaption textarea {\n  resize: none;\n}\n\n%t " + t2 + " figcaption textarea.trix-autoresize-clone {\n  position: absolute;\n  left: -9999px;\n  max-height: 0px;\n}\n\n%t " + t2 + " figcaption[data-trix-placeholder]:empty::before {\n  content: attr(data-trix-placeholder);\n  color: graytext;\n}\n\n%t [data-trix-cursor-target] {\n  display: " + p.display + " !important;\n  width: " + p.width + " !important;\n  padding: 0 !important;\n  margin: 0 !important;\n  border: none !important;\n}\n\n%t [data-trix-cursor-target=left] {\n  vertical-align: top !important;\n  margin-left: -1px !important;\n}\n\n%t [data-trix-cursor-target=right] {\n  vertical-align: bottom !important;\n  margin-right: -1px !important;\n}", trixId: {get: function() {
            return this.hasAttribute("trix-id") ? this.getAttribute("trix-id") : (this.setAttribute("trix-id", ++g), this.trixId);
          }}, labels: {get: function() {
            var t3, e2, n2;
            return e2 = [], this.id && this.ownerDocument && e2.push.apply(e2, this.ownerDocument.querySelectorAll("label[for='" + this.id + "']")), (t3 = i(this, {matchingSelector: "label"})) && ((n2 = t3.control) === this || n2 === null) && e2.push(t3), e2;
          }}, toolbarElement: {get: function() {
            var t3, e2, n2;
            return this.hasAttribute("toolbar") ? (e2 = this.ownerDocument) != null ? e2.getElementById(this.getAttribute("toolbar")) : void 0 : this.parentNode ? (n2 = "trix-toolbar-" + this.trixId, this.setAttribute("toolbar", n2), t3 = s("trix-toolbar", {id: n2}), this.parentNode.insertBefore(t3, this), t3) : void 0;
          }}, inputElement: {get: function() {
            var t3, e2, n2;
            return this.hasAttribute("input") ? (n2 = this.ownerDocument) != null ? n2.getElementById(this.getAttribute("input")) : void 0 : this.parentNode ? (e2 = "trix-input-" + this.trixId, this.setAttribute("input", e2), t3 = s("input", {type: "hidden", id: e2}), this.parentNode.insertBefore(t3, this.nextElementSibling), t3) : void 0;
          }}, editor: {get: function() {
            var t3;
            return (t3 = this.editorController) != null ? t3.editor : void 0;
          }}, name: {get: function() {
            var t3;
            return (t3 = this.inputElement) != null ? t3.name : void 0;
          }}, value: {get: function() {
            var t3;
            return (t3 = this.inputElement) != null ? t3.value : void 0;
          }, set: function(t3) {
            var e2;
            return this.defaultValue = t3, (e2 = this.editor) != null ? e2.loadHTML(this.defaultValue) : void 0;
          }}, notify: function(t3, e2) {
            return this.editorController ? a("trix-" + t3, {onElement: this, attributes: e2}) : void 0;
          }, setInputElementValue: function(t3) {
            var e2;
            return (e2 = this.inputElement) != null ? e2.value = t3 : void 0;
          }, initialize: function() {
            return this.hasAttribute("data-trix-internal") ? void 0 : (m(this), c(this), f(this));
          }, connect: function() {
            return this.hasAttribute("data-trix-internal") ? void 0 : (this.editorController || (a("trix-before-initialize", {onElement: this}), this.editorController = new e.EditorController({editorElement: this, html: this.defaultValue = this.value}), requestAnimationFrame(function(t3) {
              return function() {
                return a("trix-initialize", {onElement: t3});
              };
            }(this))), this.editorController.registerSelectionManager(), this.registerResetListener(), this.registerClickListener(), l(this));
          }, disconnect: function() {
            var t3;
            return (t3 = this.editorController) != null && t3.unregisterSelectionManager(), this.unregisterResetListener(), this.unregisterClickListener();
          }, registerResetListener: function() {
            return this.resetListener = this.resetBubbled.bind(this), window.addEventListener("reset", this.resetListener, false);
          }, unregisterResetListener: function() {
            return window.removeEventListener("reset", this.resetListener, false);
          }, registerClickListener: function() {
            return this.clickListener = this.clickBubbled.bind(this), window.addEventListener("click", this.clickListener, false);
          }, unregisterClickListener: function() {
            return window.removeEventListener("click", this.clickListener, false);
          }, resetBubbled: function(t3) {
            var e2;
            if (!t3.defaultPrevented && t3.target === ((e2 = this.inputElement) != null ? e2.form : void 0))
              return this.reset();
          }, clickBubbled: function(t3) {
            var e2;
            if (!(t3.defaultPrevented || this.contains(t3.target) || !(e2 = i(t3.target, {matchingSelector: "label"})) || u.call(this.labels, e2) < 0))
              return this.focus();
          }, reset: function() {
            return this.value = this.defaultValue;
          }};
        }());
      }.call(this), function() {
      }.call(this);
    }).call(this), typeof module == "object" && module.exports ? module.exports = e : typeof define == "function" && define.amd && define(e);
  }.call(exports);
});

// node_modules/choices.js/public/assets/scripts/choices.js
var require_choices = __commonJS((exports, module) => {
  /*! choices.js v10.1.0 |  2022 Josh Johnson | https://github.com/jshjohnson/Choices#readme */
  (function webpackUniversalModuleDefinition(root2, factory) {
    if (typeof exports === "object" && typeof module === "object")
      module.exports = factory();
    else if (typeof define === "function" && define.amd)
      define([], factory);
    else if (typeof exports === "object")
      exports["Choices"] = factory();
    else
      root2["Choices"] = factory();
  })(window, function() {
    return function() {
      "use strict";
      var __webpack_modules__ = {
        282: function(__unused_webpack_module, exports2, __webpack_require__2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.clearChoices = exports2.activateChoices = exports2.filterChoices = exports2.addChoice = void 0;
          var constants_1 = __webpack_require__2(883);
          var addChoice = function(_a) {
            var value = _a.value, label = _a.label, id = _a.id, groupId = _a.groupId, disabled = _a.disabled, elementId = _a.elementId, customProperties = _a.customProperties, placeholder = _a.placeholder, keyCode = _a.keyCode;
            return {
              type: constants_1.ACTION_TYPES.ADD_CHOICE,
              value,
              label,
              id,
              groupId,
              disabled,
              elementId,
              customProperties,
              placeholder,
              keyCode
            };
          };
          exports2.addChoice = addChoice;
          var filterChoices = function(results) {
            return {
              type: constants_1.ACTION_TYPES.FILTER_CHOICES,
              results
            };
          };
          exports2.filterChoices = filterChoices;
          var activateChoices = function(active) {
            if (active === void 0) {
              active = true;
            }
            return {
              type: constants_1.ACTION_TYPES.ACTIVATE_CHOICES,
              active
            };
          };
          exports2.activateChoices = activateChoices;
          var clearChoices = function() {
            return {
              type: constants_1.ACTION_TYPES.CLEAR_CHOICES
            };
          };
          exports2.clearChoices = clearChoices;
        },
        783: function(__unused_webpack_module, exports2, __webpack_require__2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.addGroup = void 0;
          var constants_1 = __webpack_require__2(883);
          var addGroup = function(_a) {
            var value = _a.value, id = _a.id, active = _a.active, disabled = _a.disabled;
            return {
              type: constants_1.ACTION_TYPES.ADD_GROUP,
              value,
              id,
              active,
              disabled
            };
          };
          exports2.addGroup = addGroup;
        },
        464: function(__unused_webpack_module, exports2, __webpack_require__2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.highlightItem = exports2.removeItem = exports2.addItem = void 0;
          var constants_1 = __webpack_require__2(883);
          var addItem = function(_a) {
            var value = _a.value, label = _a.label, id = _a.id, choiceId = _a.choiceId, groupId = _a.groupId, customProperties = _a.customProperties, placeholder = _a.placeholder, keyCode = _a.keyCode;
            return {
              type: constants_1.ACTION_TYPES.ADD_ITEM,
              value,
              label,
              id,
              choiceId,
              groupId,
              customProperties,
              placeholder,
              keyCode
            };
          };
          exports2.addItem = addItem;
          var removeItem = function(id, choiceId) {
            return {
              type: constants_1.ACTION_TYPES.REMOVE_ITEM,
              id,
              choiceId
            };
          };
          exports2.removeItem = removeItem;
          var highlightItem = function(id, highlighted) {
            return {
              type: constants_1.ACTION_TYPES.HIGHLIGHT_ITEM,
              id,
              highlighted
            };
          };
          exports2.highlightItem = highlightItem;
        },
        137: function(__unused_webpack_module, exports2, __webpack_require__2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.setIsLoading = exports2.resetTo = exports2.clearAll = void 0;
          var constants_1 = __webpack_require__2(883);
          var clearAll = function() {
            return {
              type: constants_1.ACTION_TYPES.CLEAR_ALL
            };
          };
          exports2.clearAll = clearAll;
          var resetTo = function(state2) {
            return {
              type: constants_1.ACTION_TYPES.RESET_TO,
              state: state2
            };
          };
          exports2.resetTo = resetTo;
          var setIsLoading = function(isLoading) {
            return {
              type: constants_1.ACTION_TYPES.SET_IS_LOADING,
              isLoading
            };
          };
          exports2.setIsLoading = setIsLoading;
        },
        373: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2)
              for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                  if (!ar)
                    ar = Array.prototype.slice.call(from, 0, i);
                  ar[i] = from[i];
                }
              }
            return to.concat(ar || Array.prototype.slice.call(from));
          };
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
              default: mod
            };
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var deepmerge_1 = __importDefault(__webpack_require__2(996));
          var fuse_js_1 = __importDefault(__webpack_require__2(221));
          var choices_1 = __webpack_require__2(282);
          var groups_1 = __webpack_require__2(783);
          var items_1 = __webpack_require__2(464);
          var misc_1 = __webpack_require__2(137);
          var components_1 = __webpack_require__2(520);
          var constants_1 = __webpack_require__2(883);
          var defaults_1 = __webpack_require__2(789);
          var utils_1 = __webpack_require__2(799);
          var reducers_1 = __webpack_require__2(655);
          var store_1 = __importDefault(__webpack_require__2(744));
          var templates_1 = __importDefault(__webpack_require__2(686));
          var IS_IE11 = "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style;
          var USER_DEFAULTS = {};
          var Choices2 = function() {
            function Choices3(element, userConfig) {
              var _this = this;
              if (element === void 0) {
                element = "[data-choice]";
              }
              if (userConfig === void 0) {
                userConfig = {};
              }
              if (userConfig.allowHTML === void 0) {
                console.warn("Deprecation warning: allowHTML will default to false in a future release. To render HTML in Choices, you will need to set it to true. Setting allowHTML will suppress this message.");
              }
              this.config = deepmerge_1.default.all([defaults_1.DEFAULT_CONFIG, Choices3.defaults.options, userConfig], {
                arrayMerge: function(_, sourceArray) {
                  return __spreadArray([], sourceArray, true);
                }
              });
              var invalidConfigOptions = (0, utils_1.diff)(this.config, defaults_1.DEFAULT_CONFIG);
              if (invalidConfigOptions.length) {
                console.warn("Unknown config option(s) passed", invalidConfigOptions.join(", "));
              }
              var passedElement = typeof element === "string" ? document.querySelector(element) : element;
              if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {
                throw TypeError("Expected one of the following types text|select-one|select-multiple");
              }
              this._isTextElement = passedElement.type === constants_1.TEXT_TYPE;
              this._isSelectOneElement = passedElement.type === constants_1.SELECT_ONE_TYPE;
              this._isSelectMultipleElement = passedElement.type === constants_1.SELECT_MULTIPLE_TYPE;
              this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;
              this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;
              if (!["auto", "always"].includes("".concat(this.config.renderSelectedChoices))) {
                this.config.renderSelectedChoices = "auto";
              }
              if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== "function") {
                var re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
                this.config.addItemFilter = re.test.bind(re);
              }
              if (this._isTextElement) {
                this.passedElement = new components_1.WrappedInput({
                  element: passedElement,
                  classNames: this.config.classNames,
                  delimiter: this.config.delimiter
                });
              } else {
                this.passedElement = new components_1.WrappedSelect({
                  element: passedElement,
                  classNames: this.config.classNames,
                  template: function(data3) {
                    return _this._templates.option(data3);
                  }
                });
              }
              this.initialised = false;
              this._store = new store_1.default();
              this._initialState = reducers_1.defaultState;
              this._currentState = reducers_1.defaultState;
              this._prevState = reducers_1.defaultState;
              this._currentValue = "";
              this._canSearch = !!this.config.searchEnabled;
              this._isScrollingOnIe = false;
              this._highlightPosition = 0;
              this._wasTap = true;
              this._placeholderValue = this._generatePlaceholderValue();
              this._baseId = (0, utils_1.generateId)(this.passedElement.element, "choices-");
              this._direction = this.passedElement.dir;
              if (!this._direction) {
                var elementDirection = window.getComputedStyle(this.passedElement.element).direction;
                var documentDirection = window.getComputedStyle(document.documentElement).direction;
                if (elementDirection !== documentDirection) {
                  this._direction = elementDirection;
                }
              }
              this._idNames = {
                itemChoice: "item-choice"
              };
              if (this._isSelectElement) {
                this._presetGroups = this.passedElement.optionGroups;
                this._presetOptions = this.passedElement.options;
              }
              this._presetChoices = this.config.choices;
              this._presetItems = this.config.items;
              if (this.passedElement.value && this._isTextElement) {
                var splitValues = this.passedElement.value.split(this.config.delimiter);
                this._presetItems = this._presetItems.concat(splitValues);
              }
              if (this.passedElement.options) {
                this.passedElement.options.forEach(function(option3) {
                  _this._presetChoices.push({
                    value: option3.value,
                    label: option3.innerHTML,
                    selected: !!option3.selected,
                    disabled: option3.disabled || option3.parentNode.disabled,
                    placeholder: option3.value === "" || option3.hasAttribute("placeholder"),
                    customProperties: option3.dataset["custom-properties"]
                  });
                });
              }
              this._render = this._render.bind(this);
              this._onFocus = this._onFocus.bind(this);
              this._onBlur = this._onBlur.bind(this);
              this._onKeyUp = this._onKeyUp.bind(this);
              this._onKeyDown = this._onKeyDown.bind(this);
              this._onClick = this._onClick.bind(this);
              this._onTouchMove = this._onTouchMove.bind(this);
              this._onTouchEnd = this._onTouchEnd.bind(this);
              this._onMouseDown = this._onMouseDown.bind(this);
              this._onMouseOver = this._onMouseOver.bind(this);
              this._onFormReset = this._onFormReset.bind(this);
              this._onSelectKey = this._onSelectKey.bind(this);
              this._onEnterKey = this._onEnterKey.bind(this);
              this._onEscapeKey = this._onEscapeKey.bind(this);
              this._onDirectionKey = this._onDirectionKey.bind(this);
              this._onDeleteKey = this._onDeleteKey.bind(this);
              if (this.passedElement.isActive) {
                if (!this.config.silent) {
                  console.warn("Trying to initialise Choices on element already initialised", {
                    element
                  });
                }
                this.initialised = true;
                return;
              }
              this.init();
            }
            Object.defineProperty(Choices3, "defaults", {
              get: function() {
                return Object.preventExtensions({
                  get options() {
                    return USER_DEFAULTS;
                  },
                  get templates() {
                    return templates_1.default;
                  }
                });
              },
              enumerable: false,
              configurable: true
            });
            Choices3.prototype.init = function() {
              if (this.initialised) {
                return;
              }
              this._createTemplates();
              this._createElements();
              this._createStructure();
              this._store.subscribe(this._render);
              this._render();
              this._addEventListeners();
              var shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute("disabled");
              if (shouldDisable) {
                this.disable();
              }
              this.initialised = true;
              var callbackOnInit = this.config.callbackOnInit;
              if (callbackOnInit && typeof callbackOnInit === "function") {
                callbackOnInit.call(this);
              }
            };
            Choices3.prototype.destroy = function() {
              if (!this.initialised) {
                return;
              }
              this._removeEventListeners();
              this.passedElement.reveal();
              this.containerOuter.unwrap(this.passedElement.element);
              this.clearStore();
              if (this._isSelectElement) {
                this.passedElement.options = this._presetOptions;
              }
              this._templates = templates_1.default;
              this.initialised = false;
            };
            Choices3.prototype.enable = function() {
              if (this.passedElement.isDisabled) {
                this.passedElement.enable();
              }
              if (this.containerOuter.isDisabled) {
                this._addEventListeners();
                this.input.enable();
                this.containerOuter.enable();
              }
              return this;
            };
            Choices3.prototype.disable = function() {
              if (!this.passedElement.isDisabled) {
                this.passedElement.disable();
              }
              if (!this.containerOuter.isDisabled) {
                this._removeEventListeners();
                this.input.disable();
                this.containerOuter.disable();
              }
              return this;
            };
            Choices3.prototype.highlightItem = function(item2, runEvent) {
              if (runEvent === void 0) {
                runEvent = true;
              }
              if (!item2 || !item2.id) {
                return this;
              }
              var id = item2.id, _a = item2.groupId, groupId = _a === void 0 ? -1 : _a, _b = item2.value, value = _b === void 0 ? "" : _b, _c = item2.label, label = _c === void 0 ? "" : _c;
              var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
              this._store.dispatch((0, items_1.highlightItem)(id, true));
              if (runEvent) {
                this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                  id,
                  value,
                  label,
                  groupValue: group && group.value ? group.value : null
                });
              }
              return this;
            };
            Choices3.prototype.unhighlightItem = function(item2) {
              if (!item2 || !item2.id) {
                return this;
              }
              var id = item2.id, _a = item2.groupId, groupId = _a === void 0 ? -1 : _a, _b = item2.value, value = _b === void 0 ? "" : _b, _c = item2.label, label = _c === void 0 ? "" : _c;
              var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
              this._store.dispatch((0, items_1.highlightItem)(id, false));
              this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                id,
                value,
                label,
                groupValue: group && group.value ? group.value : null
              });
              return this;
            };
            Choices3.prototype.highlightAll = function() {
              var _this = this;
              this._store.items.forEach(function(item2) {
                return _this.highlightItem(item2);
              });
              return this;
            };
            Choices3.prototype.unhighlightAll = function() {
              var _this = this;
              this._store.items.forEach(function(item2) {
                return _this.unhighlightItem(item2);
              });
              return this;
            };
            Choices3.prototype.removeActiveItemsByValue = function(value) {
              var _this = this;
              this._store.activeItems.filter(function(item2) {
                return item2.value === value;
              }).forEach(function(item2) {
                return _this._removeItem(item2);
              });
              return this;
            };
            Choices3.prototype.removeActiveItems = function(excludedId) {
              var _this = this;
              this._store.activeItems.filter(function(_a) {
                var id = _a.id;
                return id !== excludedId;
              }).forEach(function(item2) {
                return _this._removeItem(item2);
              });
              return this;
            };
            Choices3.prototype.removeHighlightedItems = function(runEvent) {
              var _this = this;
              if (runEvent === void 0) {
                runEvent = false;
              }
              this._store.highlightedActiveItems.forEach(function(item2) {
                _this._removeItem(item2);
                if (runEvent) {
                  _this._triggerChange(item2.value);
                }
              });
              return this;
            };
            Choices3.prototype.showDropdown = function(preventInputFocus) {
              var _this = this;
              if (this.dropdown.isActive) {
                return this;
              }
              requestAnimationFrame(function() {
                _this.dropdown.show();
                _this.containerOuter.open(_this.dropdown.distanceFromTopWindow);
                if (!preventInputFocus && _this._canSearch) {
                  _this.input.focus();
                }
                _this.passedElement.triggerEvent(constants_1.EVENTS.showDropdown, {});
              });
              return this;
            };
            Choices3.prototype.hideDropdown = function(preventInputBlur) {
              var _this = this;
              if (!this.dropdown.isActive) {
                return this;
              }
              requestAnimationFrame(function() {
                _this.dropdown.hide();
                _this.containerOuter.close();
                if (!preventInputBlur && _this._canSearch) {
                  _this.input.removeActiveDescendant();
                  _this.input.blur();
                }
                _this.passedElement.triggerEvent(constants_1.EVENTS.hideDropdown, {});
              });
              return this;
            };
            Choices3.prototype.getValue = function(valueOnly) {
              if (valueOnly === void 0) {
                valueOnly = false;
              }
              var values = this._store.activeItems.reduce(function(selectedItems, item2) {
                var itemValue = valueOnly ? item2.value : item2;
                selectedItems.push(itemValue);
                return selectedItems;
              }, []);
              return this._isSelectOneElement ? values[0] : values;
            };
            Choices3.prototype.setValue = function(items) {
              var _this = this;
              if (!this.initialised) {
                return this;
              }
              items.forEach(function(value) {
                return _this._setChoiceOrItem(value);
              });
              return this;
            };
            Choices3.prototype.setChoiceByValue = function(value) {
              var _this = this;
              if (!this.initialised || this._isTextElement) {
                return this;
              }
              var choiceValue = Array.isArray(value) ? value : [value];
              choiceValue.forEach(function(val) {
                return _this._findAndSelectChoiceByValue(val);
              });
              return this;
            };
            Choices3.prototype.setChoices = function(choicesArrayOrFetcher, value, label, replaceChoices) {
              var _this = this;
              if (choicesArrayOrFetcher === void 0) {
                choicesArrayOrFetcher = [];
              }
              if (value === void 0) {
                value = "value";
              }
              if (label === void 0) {
                label = "label";
              }
              if (replaceChoices === void 0) {
                replaceChoices = false;
              }
              if (!this.initialised) {
                throw new ReferenceError("setChoices was called on a non-initialized instance of Choices");
              }
              if (!this._isSelectElement) {
                throw new TypeError("setChoices can't be used with INPUT based Choices");
              }
              if (typeof value !== "string" || !value) {
                throw new TypeError("value parameter must be a name of 'value' field in passed objects");
              }
              if (replaceChoices) {
                this.clearChoices();
              }
              if (typeof choicesArrayOrFetcher === "function") {
                var fetcher_1 = choicesArrayOrFetcher(this);
                if (typeof Promise === "function" && fetcher_1 instanceof Promise) {
                  return new Promise(function(resolve) {
                    return requestAnimationFrame(resolve);
                  }).then(function() {
                    return _this._handleLoadingState(true);
                  }).then(function() {
                    return fetcher_1;
                  }).then(function(data3) {
                    return _this.setChoices(data3, value, label, replaceChoices);
                  }).catch(function(err) {
                    if (!_this.config.silent) {
                      console.error(err);
                    }
                  }).then(function() {
                    return _this._handleLoadingState(false);
                  }).then(function() {
                    return _this;
                  });
                }
                if (!Array.isArray(fetcher_1)) {
                  throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof fetcher_1));
                }
                return this.setChoices(fetcher_1, value, label, false);
              }
              if (!Array.isArray(choicesArrayOrFetcher)) {
                throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
              }
              this.containerOuter.removeLoadingState();
              this._startLoading();
              choicesArrayOrFetcher.forEach(function(groupOrChoice) {
                if (groupOrChoice.choices) {
                  _this._addGroup({
                    id: groupOrChoice.id ? parseInt("".concat(groupOrChoice.id), 10) : null,
                    group: groupOrChoice,
                    valueKey: value,
                    labelKey: label
                  });
                } else {
                  var choice = groupOrChoice;
                  _this._addChoice({
                    value: choice[value],
                    label: choice[label],
                    isSelected: !!choice.selected,
                    isDisabled: !!choice.disabled,
                    placeholder: !!choice.placeholder,
                    customProperties: choice.customProperties
                  });
                }
              });
              this._stopLoading();
              return this;
            };
            Choices3.prototype.clearChoices = function() {
              this._store.dispatch((0, choices_1.clearChoices)());
              return this;
            };
            Choices3.prototype.clearStore = function() {
              this._store.dispatch((0, misc_1.clearAll)());
              return this;
            };
            Choices3.prototype.clearInput = function() {
              var shouldSetInputWidth = !this._isSelectOneElement;
              this.input.clear(shouldSetInputWidth);
              if (!this._isTextElement && this._canSearch) {
                this._isSearching = false;
                this._store.dispatch((0, choices_1.activateChoices)(true));
              }
              return this;
            };
            Choices3.prototype._render = function() {
              if (this._store.isLoading()) {
                return;
              }
              this._currentState = this._store.state;
              var stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;
              var shouldRenderChoices = this._isSelectElement;
              var shouldRenderItems = this._currentState.items !== this._prevState.items;
              if (!stateChanged) {
                return;
              }
              if (shouldRenderChoices) {
                this._renderChoices();
              }
              if (shouldRenderItems) {
                this._renderItems();
              }
              this._prevState = this._currentState;
            };
            Choices3.prototype._renderChoices = function() {
              var _this = this;
              var _a = this._store, activeGroups = _a.activeGroups, activeChoices = _a.activeChoices;
              var choiceListFragment = document.createDocumentFragment();
              this.choiceList.clear();
              if (this.config.resetScrollPosition) {
                requestAnimationFrame(function() {
                  return _this.choiceList.scrollToTop();
                });
              }
              if (activeGroups.length >= 1 && !this._isSearching) {
                var activePlaceholders = activeChoices.filter(function(activeChoice) {
                  return activeChoice.placeholder === true && activeChoice.groupId === -1;
                });
                if (activePlaceholders.length >= 1) {
                  choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
                }
                choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
              } else if (activeChoices.length >= 1) {
                choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
              }
              if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
                var activeItems = this._store.activeItems;
                var canAddItem = this._canAddItem(activeItems, this.input.value);
                if (canAddItem.response) {
                  this.choiceList.append(choiceListFragment);
                  this._highlightChoice();
                } else {
                  var notice = this._getTemplate("notice", canAddItem.notice);
                  this.choiceList.append(notice);
                }
              } else {
                var dropdownItem = void 0;
                var notice = void 0;
                if (this._isSearching) {
                  notice = typeof this.config.noResultsText === "function" ? this.config.noResultsText() : this.config.noResultsText;
                  dropdownItem = this._getTemplate("notice", notice, "no-results");
                } else {
                  notice = typeof this.config.noChoicesText === "function" ? this.config.noChoicesText() : this.config.noChoicesText;
                  dropdownItem = this._getTemplate("notice", notice, "no-choices");
                }
                this.choiceList.append(dropdownItem);
              }
            };
            Choices3.prototype._renderItems = function() {
              var activeItems = this._store.activeItems || [];
              this.itemList.clear();
              var itemListFragment = this._createItemsFragment(activeItems);
              if (itemListFragment.childNodes) {
                this.itemList.append(itemListFragment);
              }
            };
            Choices3.prototype._createGroupsFragment = function(groups, choices, fragment) {
              var _this = this;
              if (fragment === void 0) {
                fragment = document.createDocumentFragment();
              }
              var getGroupChoices = function(group) {
                return choices.filter(function(choice) {
                  if (_this._isSelectOneElement) {
                    return choice.groupId === group.id;
                  }
                  return choice.groupId === group.id && (_this.config.renderSelectedChoices === "always" || !choice.selected);
                });
              };
              if (this.config.shouldSort) {
                groups.sort(this.config.sorter);
              }
              groups.forEach(function(group) {
                var groupChoices = getGroupChoices(group);
                if (groupChoices.length >= 1) {
                  var dropdownGroup = _this._getTemplate("choiceGroup", group);
                  fragment.appendChild(dropdownGroup);
                  _this._createChoicesFragment(groupChoices, fragment, true);
                }
              });
              return fragment;
            };
            Choices3.prototype._createChoicesFragment = function(choices, fragment, withinGroup) {
              var _this = this;
              if (fragment === void 0) {
                fragment = document.createDocumentFragment();
              }
              if (withinGroup === void 0) {
                withinGroup = false;
              }
              var _a = this.config, renderSelectedChoices = _a.renderSelectedChoices, searchResultLimit = _a.searchResultLimit, renderChoiceLimit = _a.renderChoiceLimit;
              var filter = this._isSearching ? utils_1.sortByScore : this.config.sorter;
              var appendChoice = function(choice) {
                var shouldRender = renderSelectedChoices === "auto" ? _this._isSelectOneElement || !choice.selected : true;
                if (shouldRender) {
                  var dropdownItem = _this._getTemplate("choice", choice, _this.config.itemSelectText);
                  fragment.appendChild(dropdownItem);
                }
              };
              var rendererableChoices = choices;
              if (renderSelectedChoices === "auto" && !this._isSelectOneElement) {
                rendererableChoices = choices.filter(function(choice) {
                  return !choice.selected;
                });
              }
              var _b = rendererableChoices.reduce(function(acc, choice) {
                if (choice.placeholder) {
                  acc.placeholderChoices.push(choice);
                } else {
                  acc.normalChoices.push(choice);
                }
                return acc;
              }, {
                placeholderChoices: [],
                normalChoices: []
              }), placeholderChoices = _b.placeholderChoices, normalChoices = _b.normalChoices;
              if (this.config.shouldSort || this._isSearching) {
                normalChoices.sort(filter);
              }
              var choiceLimit = rendererableChoices.length;
              var sortedChoices = this._isSelectOneElement ? __spreadArray(__spreadArray([], placeholderChoices, true), normalChoices, true) : normalChoices;
              if (this._isSearching) {
                choiceLimit = searchResultLimit;
              } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
                choiceLimit = renderChoiceLimit;
              }
              for (var i = 0; i < choiceLimit; i += 1) {
                if (sortedChoices[i]) {
                  appendChoice(sortedChoices[i]);
                }
              }
              return fragment;
            };
            Choices3.prototype._createItemsFragment = function(items, fragment) {
              var _this = this;
              if (fragment === void 0) {
                fragment = document.createDocumentFragment();
              }
              var _a = this.config, shouldSortItems = _a.shouldSortItems, sorter = _a.sorter, removeItemButton = _a.removeItemButton;
              if (shouldSortItems && !this._isSelectOneElement) {
                items.sort(sorter);
              }
              if (this._isTextElement) {
                this.passedElement.value = items.map(function(_a2) {
                  var value = _a2.value;
                  return value;
                }).join(this.config.delimiter);
              } else {
                this.passedElement.options = items;
              }
              var addItemToFragment = function(item2) {
                var listItem = _this._getTemplate("item", item2, removeItemButton);
                fragment.appendChild(listItem);
              };
              items.forEach(addItemToFragment);
              return fragment;
            };
            Choices3.prototype._triggerChange = function(value) {
              if (value === void 0 || value === null) {
                return;
              }
              this.passedElement.triggerEvent(constants_1.EVENTS.change, {
                value
              });
            };
            Choices3.prototype._selectPlaceholderChoice = function(placeholderChoice) {
              this._addItem({
                value: placeholderChoice.value,
                label: placeholderChoice.label,
                choiceId: placeholderChoice.id,
                groupId: placeholderChoice.groupId,
                placeholder: placeholderChoice.placeholder
              });
              this._triggerChange(placeholderChoice.value);
            };
            Choices3.prototype._handleButtonAction = function(activeItems, element) {
              if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {
                return;
              }
              var itemId = element.parentNode && element.parentNode.dataset.id;
              var itemToRemove = itemId && activeItems.find(function(item2) {
                return item2.id === parseInt(itemId, 10);
              });
              if (!itemToRemove) {
                return;
              }
              this._removeItem(itemToRemove);
              this._triggerChange(itemToRemove.value);
              if (this._isSelectOneElement && this._store.placeholderChoice) {
                this._selectPlaceholderChoice(this._store.placeholderChoice);
              }
            };
            Choices3.prototype._handleItemAction = function(activeItems, element, hasShiftKey) {
              var _this = this;
              if (hasShiftKey === void 0) {
                hasShiftKey = false;
              }
              if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {
                return;
              }
              var passedId = element.dataset.id;
              activeItems.forEach(function(item2) {
                if (item2.id === parseInt("".concat(passedId), 10) && !item2.highlighted) {
                  _this.highlightItem(item2);
                } else if (!hasShiftKey && item2.highlighted) {
                  _this.unhighlightItem(item2);
                }
              });
              this.input.focus();
            };
            Choices3.prototype._handleChoiceAction = function(activeItems, element) {
              if (!activeItems || !element) {
                return;
              }
              var id = element.dataset.id;
              var choice = id && this._store.getChoiceById(id);
              if (!choice) {
                return;
              }
              var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : void 0;
              var hasActiveDropdown = this.dropdown.isActive;
              choice.keyCode = passedKeyCode;
              this.passedElement.triggerEvent(constants_1.EVENTS.choice, {
                choice
              });
              if (!choice.selected && !choice.disabled) {
                var canAddItem = this._canAddItem(activeItems, choice.value);
                if (canAddItem.response) {
                  this._addItem({
                    value: choice.value,
                    label: choice.label,
                    choiceId: choice.id,
                    groupId: choice.groupId,
                    customProperties: choice.customProperties,
                    placeholder: choice.placeholder,
                    keyCode: choice.keyCode
                  });
                  this._triggerChange(choice.value);
                }
              }
              this.clearInput();
              if (hasActiveDropdown && this._isSelectOneElement) {
                this.hideDropdown(true);
                this.containerOuter.focus();
              }
            };
            Choices3.prototype._handleBackspace = function(activeItems) {
              if (!this.config.removeItems || !activeItems) {
                return;
              }
              var lastItem = activeItems[activeItems.length - 1];
              var hasHighlightedItems = activeItems.some(function(item2) {
                return item2.highlighted;
              });
              if (this.config.editItems && !hasHighlightedItems && lastItem) {
                this.input.value = lastItem.value;
                this.input.setWidth();
                this._removeItem(lastItem);
                this._triggerChange(lastItem.value);
              } else {
                if (!hasHighlightedItems) {
                  this.highlightItem(lastItem, false);
                }
                this.removeHighlightedItems(true);
              }
            };
            Choices3.prototype._startLoading = function() {
              this._store.dispatch((0, misc_1.setIsLoading)(true));
            };
            Choices3.prototype._stopLoading = function() {
              this._store.dispatch((0, misc_1.setIsLoading)(false));
            };
            Choices3.prototype._handleLoadingState = function(setLoading) {
              if (setLoading === void 0) {
                setLoading = true;
              }
              var placeholderItem = this.itemList.getChild(".".concat(this.config.classNames.placeholder));
              if (setLoading) {
                this.disable();
                this.containerOuter.addLoadingState();
                if (this._isSelectOneElement) {
                  if (!placeholderItem) {
                    placeholderItem = this._getTemplate("placeholder", this.config.loadingText);
                    if (placeholderItem) {
                      this.itemList.append(placeholderItem);
                    }
                  } else {
                    placeholderItem.innerHTML = this.config.loadingText;
                  }
                } else {
                  this.input.placeholder = this.config.loadingText;
                }
              } else {
                this.enable();
                this.containerOuter.removeLoadingState();
                if (this._isSelectOneElement) {
                  if (placeholderItem) {
                    placeholderItem.innerHTML = this._placeholderValue || "";
                  }
                } else {
                  this.input.placeholder = this._placeholderValue || "";
                }
              }
            };
            Choices3.prototype._handleSearch = function(value) {
              if (!this.input.isFocussed) {
                return;
              }
              var choices = this._store.choices;
              var _a = this.config, searchFloor = _a.searchFloor, searchChoices = _a.searchChoices;
              var hasUnactiveChoices = choices.some(function(option3) {
                return !option3.active;
              });
              if (value !== null && typeof value !== "undefined" && value.length >= searchFloor) {
                var resultCount = searchChoices ? this._searchChoices(value) : 0;
                this.passedElement.triggerEvent(constants_1.EVENTS.search, {
                  value,
                  resultCount
                });
              } else if (hasUnactiveChoices) {
                this._isSearching = false;
                this._store.dispatch((0, choices_1.activateChoices)(true));
              }
            };
            Choices3.prototype._canAddItem = function(activeItems, value) {
              var canAddItem = true;
              var notice = typeof this.config.addItemText === "function" ? this.config.addItemText(value) : this.config.addItemText;
              if (!this._isSelectOneElement) {
                var isDuplicateValue = (0, utils_1.existsInArray)(activeItems, value);
                if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
                  canAddItem = false;
                  notice = typeof this.config.maxItemText === "function" ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
                }
                if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {
                  canAddItem = false;
                  notice = typeof this.config.uniqueItemText === "function" ? this.config.uniqueItemText(value) : this.config.uniqueItemText;
                }
                if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === "function" && !this.config.addItemFilter(value)) {
                  canAddItem = false;
                  notice = typeof this.config.customAddItemText === "function" ? this.config.customAddItemText(value) : this.config.customAddItemText;
                }
              }
              return {
                response: canAddItem,
                notice
              };
            };
            Choices3.prototype._searchChoices = function(value) {
              var newValue = typeof value === "string" ? value.trim() : value;
              var currentValue = typeof this._currentValue === "string" ? this._currentValue.trim() : this._currentValue;
              if (newValue.length < 1 && newValue === "".concat(currentValue, " ")) {
                return 0;
              }
              var haystack = this._store.searchableChoices;
              var needle = newValue;
              var options = Object.assign(this.config.fuseOptions, {
                keys: __spreadArray([], this.config.searchFields, true),
                includeMatches: true
              });
              var fuse = new fuse_js_1.default(haystack, options);
              var results = fuse.search(needle);
              this._currentValue = newValue;
              this._highlightPosition = 0;
              this._isSearching = true;
              this._store.dispatch((0, choices_1.filterChoices)(results));
              return results.length;
            };
            Choices3.prototype._addEventListeners = function() {
              var documentElement = document.documentElement;
              documentElement.addEventListener("touchend", this._onTouchEnd, true);
              this.containerOuter.element.addEventListener("keydown", this._onKeyDown, true);
              this.containerOuter.element.addEventListener("mousedown", this._onMouseDown, true);
              documentElement.addEventListener("click", this._onClick, {
                passive: true
              });
              documentElement.addEventListener("touchmove", this._onTouchMove, {
                passive: true
              });
              this.dropdown.element.addEventListener("mouseover", this._onMouseOver, {
                passive: true
              });
              if (this._isSelectOneElement) {
                this.containerOuter.element.addEventListener("focus", this._onFocus, {
                  passive: true
                });
                this.containerOuter.element.addEventListener("blur", this._onBlur, {
                  passive: true
                });
              }
              this.input.element.addEventListener("keyup", this._onKeyUp, {
                passive: true
              });
              this.input.element.addEventListener("focus", this._onFocus, {
                passive: true
              });
              this.input.element.addEventListener("blur", this._onBlur, {
                passive: true
              });
              if (this.input.element.form) {
                this.input.element.form.addEventListener("reset", this._onFormReset, {
                  passive: true
                });
              }
              this.input.addEventListeners();
            };
            Choices3.prototype._removeEventListeners = function() {
              var documentElement = document.documentElement;
              documentElement.removeEventListener("touchend", this._onTouchEnd, true);
              this.containerOuter.element.removeEventListener("keydown", this._onKeyDown, true);
              this.containerOuter.element.removeEventListener("mousedown", this._onMouseDown, true);
              documentElement.removeEventListener("click", this._onClick);
              documentElement.removeEventListener("touchmove", this._onTouchMove);
              this.dropdown.element.removeEventListener("mouseover", this._onMouseOver);
              if (this._isSelectOneElement) {
                this.containerOuter.element.removeEventListener("focus", this._onFocus);
                this.containerOuter.element.removeEventListener("blur", this._onBlur);
              }
              this.input.element.removeEventListener("keyup", this._onKeyUp);
              this.input.element.removeEventListener("focus", this._onFocus);
              this.input.element.removeEventListener("blur", this._onBlur);
              if (this.input.element.form) {
                this.input.element.form.removeEventListener("reset", this._onFormReset);
              }
              this.input.removeEventListeners();
            };
            Choices3.prototype._onKeyDown = function(event) {
              var keyCode = event.keyCode;
              var activeItems = this._store.activeItems;
              var hasFocusedInput = this.input.isFocussed;
              var hasActiveDropdown = this.dropdown.isActive;
              var hasItems = this.itemList.hasChildren();
              var keyString = String.fromCharCode(keyCode);
              var wasAlphaNumericChar = /[a-zA-Z0-9-_ ]/.test(keyString);
              var BACK_KEY = constants_1.KEY_CODES.BACK_KEY, DELETE_KEY = constants_1.KEY_CODES.DELETE_KEY, ENTER_KEY = constants_1.KEY_CODES.ENTER_KEY, A_KEY = constants_1.KEY_CODES.A_KEY, ESC_KEY = constants_1.KEY_CODES.ESC_KEY, UP_KEY = constants_1.KEY_CODES.UP_KEY, DOWN_KEY = constants_1.KEY_CODES.DOWN_KEY, PAGE_UP_KEY = constants_1.KEY_CODES.PAGE_UP_KEY, PAGE_DOWN_KEY = constants_1.KEY_CODES.PAGE_DOWN_KEY;
              if (!this._isTextElement && !hasActiveDropdown && wasAlphaNumericChar) {
                this.showDropdown();
                if (!this.input.isFocussed) {
                  this.input.value += keyString.toLowerCase();
                }
              }
              switch (keyCode) {
                case A_KEY:
                  return this._onSelectKey(event, hasItems);
                case ENTER_KEY:
                  return this._onEnterKey(event, activeItems, hasActiveDropdown);
                case ESC_KEY:
                  return this._onEscapeKey(hasActiveDropdown);
                case UP_KEY:
                case PAGE_UP_KEY:
                case DOWN_KEY:
                case PAGE_DOWN_KEY:
                  return this._onDirectionKey(event, hasActiveDropdown);
                case DELETE_KEY:
                case BACK_KEY:
                  return this._onDeleteKey(event, activeItems, hasFocusedInput);
                default:
              }
            };
            Choices3.prototype._onKeyUp = function(_a) {
              var target = _a.target, keyCode = _a.keyCode;
              var value = this.input.value;
              var activeItems = this._store.activeItems;
              var canAddItem = this._canAddItem(activeItems, value);
              var backKey = constants_1.KEY_CODES.BACK_KEY, deleteKey = constants_1.KEY_CODES.DELETE_KEY;
              if (this._isTextElement) {
                var canShowDropdownNotice = canAddItem.notice && value;
                if (canShowDropdownNotice) {
                  var dropdownItem = this._getTemplate("notice", canAddItem.notice);
                  this.dropdown.element.innerHTML = dropdownItem.outerHTML;
                  this.showDropdown(true);
                } else {
                  this.hideDropdown(true);
                }
              } else {
                var wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey;
                var userHasRemovedValue = wasRemovalKeyCode && target && !target.value;
                var canReactivateChoices = !this._isTextElement && this._isSearching;
                var canSearch = this._canSearch && canAddItem.response;
                if (userHasRemovedValue && canReactivateChoices) {
                  this._isSearching = false;
                  this._store.dispatch((0, choices_1.activateChoices)(true));
                } else if (canSearch) {
                  this._handleSearch(this.input.rawValue);
                }
              }
              this._canSearch = this.config.searchEnabled;
            };
            Choices3.prototype._onSelectKey = function(event, hasItems) {
              var ctrlKey = event.ctrlKey, metaKey = event.metaKey;
              var hasCtrlDownKeyPressed = ctrlKey || metaKey;
              if (hasCtrlDownKeyPressed && hasItems) {
                this._canSearch = false;
                var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;
                if (shouldHightlightAll) {
                  this.highlightAll();
                }
              }
            };
            Choices3.prototype._onEnterKey = function(event, activeItems, hasActiveDropdown) {
              var target = event.target;
              var enterKey = constants_1.KEY_CODES.ENTER_KEY;
              var targetWasButton = target && target.hasAttribute("data-button");
              if (this._isTextElement && target && target.value) {
                var value = this.input.value;
                var canAddItem = this._canAddItem(activeItems, value);
                if (canAddItem.response) {
                  this.hideDropdown(true);
                  this._addItem({
                    value
                  });
                  this._triggerChange(value);
                  this.clearInput();
                }
              }
              if (targetWasButton) {
                this._handleButtonAction(activeItems, target);
                event.preventDefault();
              }
              if (hasActiveDropdown) {
                var highlightedChoice = this.dropdown.getChild(".".concat(this.config.classNames.highlightedState));
                if (highlightedChoice) {
                  if (activeItems[0]) {
                    activeItems[0].keyCode = enterKey;
                  }
                  this._handleChoiceAction(activeItems, highlightedChoice);
                }
                event.preventDefault();
              } else if (this._isSelectOneElement) {
                this.showDropdown();
                event.preventDefault();
              }
            };
            Choices3.prototype._onEscapeKey = function(hasActiveDropdown) {
              if (hasActiveDropdown) {
                this.hideDropdown(true);
                this.containerOuter.focus();
              }
            };
            Choices3.prototype._onDirectionKey = function(event, hasActiveDropdown) {
              var keyCode = event.keyCode, metaKey = event.metaKey;
              var downKey = constants_1.KEY_CODES.DOWN_KEY, pageUpKey = constants_1.KEY_CODES.PAGE_UP_KEY, pageDownKey = constants_1.KEY_CODES.PAGE_DOWN_KEY;
              if (hasActiveDropdown || this._isSelectOneElement) {
                this.showDropdown();
                this._canSearch = false;
                var directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
                var skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
                var selectableChoiceIdentifier = "[data-choice-selectable]";
                var nextEl2 = void 0;
                if (skipKey) {
                  if (directionInt > 0) {
                    nextEl2 = this.dropdown.element.querySelector("".concat(selectableChoiceIdentifier, ":last-of-type"));
                  } else {
                    nextEl2 = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                  }
                } else {
                  var currentEl = this.dropdown.element.querySelector(".".concat(this.config.classNames.highlightedState));
                  if (currentEl) {
                    nextEl2 = (0, utils_1.getAdjacentEl)(currentEl, selectableChoiceIdentifier, directionInt);
                  } else {
                    nextEl2 = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                  }
                }
                if (nextEl2) {
                  if (!(0, utils_1.isScrolledIntoView)(nextEl2, this.choiceList.element, directionInt)) {
                    this.choiceList.scrollToChildElement(nextEl2, directionInt);
                  }
                  this._highlightChoice(nextEl2);
                }
                event.preventDefault();
              }
            };
            Choices3.prototype._onDeleteKey = function(event, activeItems, hasFocusedInput) {
              var target = event.target;
              if (!this._isSelectOneElement && !target.value && hasFocusedInput) {
                this._handleBackspace(activeItems);
                event.preventDefault();
              }
            };
            Choices3.prototype._onTouchMove = function() {
              if (this._wasTap) {
                this._wasTap = false;
              }
            };
            Choices3.prototype._onTouchEnd = function(event) {
              var target = (event || event.touches[0]).target;
              var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);
              if (touchWasWithinContainer) {
                var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;
                if (containerWasExactTarget) {
                  if (this._isTextElement) {
                    this.input.focus();
                  } else if (this._isSelectMultipleElement) {
                    this.showDropdown();
                  }
                }
                event.stopPropagation();
              }
              this._wasTap = true;
            };
            Choices3.prototype._onMouseDown = function(event) {
              var target = event.target;
              if (!(target instanceof HTMLElement)) {
                return;
              }
              if (IS_IE11 && this.choiceList.element.contains(target)) {
                var firstChoice = this.choiceList.element.firstElementChild;
                var isOnScrollbar = this._direction === "ltr" ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;
                this._isScrollingOnIe = isOnScrollbar;
              }
              if (target === this.input.element) {
                return;
              }
              var item2 = target.closest("[data-button],[data-item],[data-choice]");
              if (item2 instanceof HTMLElement) {
                var hasShiftKey = event.shiftKey;
                var activeItems = this._store.activeItems;
                var dataset = item2.dataset;
                if ("button" in dataset) {
                  this._handleButtonAction(activeItems, item2);
                } else if ("item" in dataset) {
                  this._handleItemAction(activeItems, item2, hasShiftKey);
                } else if ("choice" in dataset) {
                  this._handleChoiceAction(activeItems, item2);
                }
              }
              event.preventDefault();
            };
            Choices3.prototype._onMouseOver = function(_a) {
              var target = _a.target;
              if (target instanceof HTMLElement && "choice" in target.dataset) {
                this._highlightChoice(target);
              }
            };
            Choices3.prototype._onClick = function(_a) {
              var target = _a.target;
              var clickWasWithinContainer = this.containerOuter.element.contains(target);
              if (clickWasWithinContainer) {
                if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
                  if (this._isTextElement) {
                    if (document.activeElement !== this.input.element) {
                      this.input.focus();
                    }
                  } else {
                    this.showDropdown();
                    this.containerOuter.focus();
                  }
                } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {
                  this.hideDropdown();
                }
              } else {
                var hasHighlightedItems = this._store.highlightedActiveItems.length > 0;
                if (hasHighlightedItems) {
                  this.unhighlightAll();
                }
                this.containerOuter.removeFocusState();
                this.hideDropdown(true);
              }
            };
            Choices3.prototype._onFocus = function(_a) {
              var _b;
              var _this = this;
              var target = _a.target;
              var focusWasWithinContainer = target && this.containerOuter.element.contains(target);
              if (!focusWasWithinContainer) {
                return;
              }
              var focusActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function() {
                if (target === _this.input.element) {
                  _this.containerOuter.addFocusState();
                }
              }, _b[constants_1.SELECT_ONE_TYPE] = function() {
                _this.containerOuter.addFocusState();
                if (target === _this.input.element) {
                  _this.showDropdown(true);
                }
              }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function() {
                if (target === _this.input.element) {
                  _this.showDropdown(true);
                  _this.containerOuter.addFocusState();
                }
              }, _b);
              focusActions[this.passedElement.element.type]();
            };
            Choices3.prototype._onBlur = function(_a) {
              var _b;
              var _this = this;
              var target = _a.target;
              var blurWasWithinContainer = target && this.containerOuter.element.contains(target);
              if (blurWasWithinContainer && !this._isScrollingOnIe) {
                var activeItems = this._store.activeItems;
                var hasHighlightedItems_1 = activeItems.some(function(item2) {
                  return item2.highlighted;
                });
                var blurActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function() {
                  if (target === _this.input.element) {
                    _this.containerOuter.removeFocusState();
                    if (hasHighlightedItems_1) {
                      _this.unhighlightAll();
                    }
                    _this.hideDropdown(true);
                  }
                }, _b[constants_1.SELECT_ONE_TYPE] = function() {
                  _this.containerOuter.removeFocusState();
                  if (target === _this.input.element || target === _this.containerOuter.element && !_this._canSearch) {
                    _this.hideDropdown(true);
                  }
                }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function() {
                  if (target === _this.input.element) {
                    _this.containerOuter.removeFocusState();
                    _this.hideDropdown(true);
                    if (hasHighlightedItems_1) {
                      _this.unhighlightAll();
                    }
                  }
                }, _b);
                blurActions[this.passedElement.element.type]();
              } else {
                this._isScrollingOnIe = false;
                this.input.element.focus();
              }
            };
            Choices3.prototype._onFormReset = function() {
              this._store.dispatch((0, misc_1.resetTo)(this._initialState));
            };
            Choices3.prototype._highlightChoice = function(el) {
              var _this = this;
              if (el === void 0) {
                el = null;
              }
              var choices = Array.from(this.dropdown.element.querySelectorAll("[data-choice-selectable]"));
              if (!choices.length) {
                return;
              }
              var passedEl = el;
              var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(".".concat(this.config.classNames.highlightedState)));
              highlightedChoices.forEach(function(choice) {
                choice.classList.remove(_this.config.classNames.highlightedState);
                choice.setAttribute("aria-selected", "false");
              });
              if (passedEl) {
                this._highlightPosition = choices.indexOf(passedEl);
              } else {
                if (choices.length > this._highlightPosition) {
                  passedEl = choices[this._highlightPosition];
                } else {
                  passedEl = choices[choices.length - 1];
                }
                if (!passedEl) {
                  passedEl = choices[0];
                }
              }
              passedEl.classList.add(this.config.classNames.highlightedState);
              passedEl.setAttribute("aria-selected", "true");
              this.passedElement.triggerEvent(constants_1.EVENTS.highlightChoice, {
                el: passedEl
              });
              if (this.dropdown.isActive) {
                this.input.setActiveDescendant(passedEl.id);
                this.containerOuter.setActiveDescendant(passedEl.id);
              }
            };
            Choices3.prototype._addItem = function(_a) {
              var value = _a.value, _b = _a.label, label = _b === void 0 ? null : _b, _c = _a.choiceId, choiceId = _c === void 0 ? -1 : _c, _d = _a.groupId, groupId = _d === void 0 ? -1 : _d, _e = _a.customProperties, customProperties = _e === void 0 ? {} : _e, _f = _a.placeholder, placeholder = _f === void 0 ? false : _f, _g = _a.keyCode, keyCode = _g === void 0 ? -1 : _g;
              var passedValue = typeof value === "string" ? value.trim() : value;
              var items = this._store.items;
              var passedLabel = label || passedValue;
              var passedOptionId = choiceId || -1;
              var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
              var id = items ? items.length + 1 : 1;
              if (this.config.prependValue) {
                passedValue = this.config.prependValue + passedValue.toString();
              }
              if (this.config.appendValue) {
                passedValue += this.config.appendValue.toString();
              }
              this._store.dispatch((0, items_1.addItem)({
                value: passedValue,
                label: passedLabel,
                id,
                choiceId: passedOptionId,
                groupId,
                customProperties,
                placeholder,
                keyCode
              }));
              if (this._isSelectOneElement) {
                this.removeActiveItems(id);
              }
              this.passedElement.triggerEvent(constants_1.EVENTS.addItem, {
                id,
                value: passedValue,
                label: passedLabel,
                customProperties,
                groupValue: group && group.value ? group.value : null,
                keyCode
              });
            };
            Choices3.prototype._removeItem = function(item2) {
              var id = item2.id, value = item2.value, label = item2.label, customProperties = item2.customProperties, choiceId = item2.choiceId, groupId = item2.groupId;
              var group = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;
              if (!id || !choiceId) {
                return;
              }
              this._store.dispatch((0, items_1.removeItem)(id, choiceId));
              this.passedElement.triggerEvent(constants_1.EVENTS.removeItem, {
                id,
                value,
                label,
                customProperties,
                groupValue: group && group.value ? group.value : null
              });
            };
            Choices3.prototype._addChoice = function(_a) {
              var value = _a.value, _b = _a.label, label = _b === void 0 ? null : _b, _c = _a.isSelected, isSelected = _c === void 0 ? false : _c, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = _a.groupId, groupId = _e === void 0 ? -1 : _e, _f = _a.customProperties, customProperties = _f === void 0 ? {} : _f, _g = _a.placeholder, placeholder = _g === void 0 ? false : _g, _h = _a.keyCode, keyCode = _h === void 0 ? -1 : _h;
              if (typeof value === "undefined" || value === null) {
                return;
              }
              var choices = this._store.choices;
              var choiceLabel = label || value;
              var choiceId = choices ? choices.length + 1 : 1;
              var choiceElementId = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(choiceId);
              this._store.dispatch((0, choices_1.addChoice)({
                id: choiceId,
                groupId,
                elementId: choiceElementId,
                value,
                label: choiceLabel,
                disabled: isDisabled,
                customProperties,
                placeholder,
                keyCode
              }));
              if (isSelected) {
                this._addItem({
                  value,
                  label: choiceLabel,
                  choiceId,
                  customProperties,
                  placeholder,
                  keyCode
                });
              }
            };
            Choices3.prototype._addGroup = function(_a) {
              var _this = this;
              var group = _a.group, id = _a.id, _b = _a.valueKey, valueKey = _b === void 0 ? "value" : _b, _c = _a.labelKey, labelKey = _c === void 0 ? "label" : _c;
              var groupChoices = (0, utils_1.isType)("Object", group) ? group.choices : Array.from(group.getElementsByTagName("OPTION"));
              var groupId = id || Math.floor(new Date().valueOf() * Math.random());
              var isDisabled = group.disabled ? group.disabled : false;
              if (groupChoices) {
                this._store.dispatch((0, groups_1.addGroup)({
                  value: group.label,
                  id: groupId,
                  active: true,
                  disabled: isDisabled
                }));
                var addGroupChoices = function(choice) {
                  var isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;
                  _this._addChoice({
                    value: choice[valueKey],
                    label: (0, utils_1.isType)("Object", choice) ? choice[labelKey] : choice.innerHTML,
                    isSelected: choice.selected,
                    isDisabled: isOptDisabled,
                    groupId,
                    customProperties: choice.customProperties,
                    placeholder: choice.placeholder
                  });
                };
                groupChoices.forEach(addGroupChoices);
              } else {
                this._store.dispatch((0, groups_1.addGroup)({
                  value: group.label,
                  id: group.id,
                  active: false,
                  disabled: group.disabled
                }));
              }
            };
            Choices3.prototype._getTemplate = function(template) {
              var _a;
              var args = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
              }
              return (_a = this._templates[template]).call.apply(_a, __spreadArray([this, this.config], args, false));
            };
            Choices3.prototype._createTemplates = function() {
              var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;
              var userTemplates = {};
              if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === "function") {
                userTemplates = callbackOnCreateTemplates.call(this, utils_1.strToEl);
              }
              this._templates = (0, deepmerge_1.default)(templates_1.default, userTemplates);
            };
            Choices3.prototype._createElements = function() {
              this.containerOuter = new components_1.Container({
                element: this._getTemplate("containerOuter", this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type, this.config.labelId),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
                position: this.config.position
              });
              this.containerInner = new components_1.Container({
                element: this._getTemplate("containerInner"),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
                position: this.config.position
              });
              this.input = new components_1.Input({
                element: this._getTemplate("input", this._placeholderValue),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
                preventPaste: !this.config.paste
              });
              this.choiceList = new components_1.List({
                element: this._getTemplate("choiceList", this._isSelectOneElement)
              });
              this.itemList = new components_1.List({
                element: this._getTemplate("itemList", this._isSelectOneElement)
              });
              this.dropdown = new components_1.Dropdown({
                element: this._getTemplate("dropdown"),
                classNames: this.config.classNames,
                type: this.passedElement.element.type
              });
            };
            Choices3.prototype._createStructure = function() {
              this.passedElement.conceal();
              this.containerInner.wrap(this.passedElement.element);
              this.containerOuter.wrap(this.containerInner.element);
              if (this._isSelectOneElement) {
                this.input.placeholder = this.config.searchPlaceholderValue || "";
              } else if (this._placeholderValue) {
                this.input.placeholder = this._placeholderValue;
                this.input.setWidth();
              }
              this.containerOuter.element.appendChild(this.containerInner.element);
              this.containerOuter.element.appendChild(this.dropdown.element);
              this.containerInner.element.appendChild(this.itemList.element);
              if (!this._isTextElement) {
                this.dropdown.element.appendChild(this.choiceList.element);
              }
              if (!this._isSelectOneElement) {
                this.containerInner.element.appendChild(this.input.element);
              } else if (this.config.searchEnabled) {
                this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
              }
              if (this._isSelectElement) {
                this._highlightPosition = 0;
                this._isSearching = false;
                this._startLoading();
                if (this._presetGroups.length) {
                  this._addPredefinedGroups(this._presetGroups);
                } else {
                  this._addPredefinedChoices(this._presetChoices);
                }
                this._stopLoading();
              }
              if (this._isTextElement) {
                this._addPredefinedItems(this._presetItems);
              }
            };
            Choices3.prototype._addPredefinedGroups = function(groups) {
              var _this = this;
              var placeholderChoice = this.passedElement.placeholderOption;
              if (placeholderChoice && placeholderChoice.parentNode && placeholderChoice.parentNode.tagName === "SELECT") {
                this._addChoice({
                  value: placeholderChoice.value,
                  label: placeholderChoice.innerHTML,
                  isSelected: placeholderChoice.selected,
                  isDisabled: placeholderChoice.disabled,
                  placeholder: true
                });
              }
              groups.forEach(function(group) {
                return _this._addGroup({
                  group,
                  id: group.id || null
                });
              });
            };
            Choices3.prototype._addPredefinedChoices = function(choices) {
              var _this = this;
              if (this.config.shouldSort) {
                choices.sort(this.config.sorter);
              }
              var hasSelectedChoice = choices.some(function(choice) {
                return choice.selected;
              });
              var firstEnabledChoiceIndex = choices.findIndex(function(choice) {
                return choice.disabled === void 0 || !choice.disabled;
              });
              choices.forEach(function(choice, index2) {
                var _a = choice.value, value = _a === void 0 ? "" : _a, label = choice.label, customProperties = choice.customProperties, placeholder = choice.placeholder;
                if (_this._isSelectElement) {
                  if (choice.choices) {
                    _this._addGroup({
                      group: choice,
                      id: choice.id || null
                    });
                  } else {
                    var shouldPreselect = _this._isSelectOneElement && !hasSelectedChoice && index2 === firstEnabledChoiceIndex;
                    var isSelected = shouldPreselect ? true : choice.selected;
                    var isDisabled = choice.disabled;
                    _this._addChoice({
                      value,
                      label,
                      isSelected: !!isSelected,
                      isDisabled: !!isDisabled,
                      placeholder: !!placeholder,
                      customProperties
                    });
                  }
                } else {
                  _this._addChoice({
                    value,
                    label,
                    isSelected: !!choice.selected,
                    isDisabled: !!choice.disabled,
                    placeholder: !!choice.placeholder,
                    customProperties
                  });
                }
              });
            };
            Choices3.prototype._addPredefinedItems = function(items) {
              var _this = this;
              items.forEach(function(item2) {
                if (typeof item2 === "object" && item2.value) {
                  _this._addItem({
                    value: item2.value,
                    label: item2.label,
                    choiceId: item2.id,
                    customProperties: item2.customProperties,
                    placeholder: item2.placeholder
                  });
                }
                if (typeof item2 === "string") {
                  _this._addItem({
                    value: item2
                  });
                }
              });
            };
            Choices3.prototype._setChoiceOrItem = function(item2) {
              var _this = this;
              var itemType = (0, utils_1.getType)(item2).toLowerCase();
              var handleType = {
                object: function() {
                  if (!item2.value) {
                    return;
                  }
                  if (!_this._isTextElement) {
                    _this._addChoice({
                      value: item2.value,
                      label: item2.label,
                      isSelected: true,
                      isDisabled: false,
                      customProperties: item2.customProperties,
                      placeholder: item2.placeholder
                    });
                  } else {
                    _this._addItem({
                      value: item2.value,
                      label: item2.label,
                      choiceId: item2.id,
                      customProperties: item2.customProperties,
                      placeholder: item2.placeholder
                    });
                  }
                },
                string: function() {
                  if (!_this._isTextElement) {
                    _this._addChoice({
                      value: item2,
                      label: item2,
                      isSelected: true,
                      isDisabled: false
                    });
                  } else {
                    _this._addItem({
                      value: item2
                    });
                  }
                }
              };
              handleType[itemType]();
            };
            Choices3.prototype._findAndSelectChoiceByValue = function(value) {
              var _this = this;
              var choices = this._store.choices;
              var foundChoice = choices.find(function(choice) {
                return _this.config.valueComparer(choice.value, value);
              });
              if (foundChoice && !foundChoice.selected) {
                this._addItem({
                  value: foundChoice.value,
                  label: foundChoice.label,
                  choiceId: foundChoice.id,
                  groupId: foundChoice.groupId,
                  customProperties: foundChoice.customProperties,
                  placeholder: foundChoice.placeholder,
                  keyCode: foundChoice.keyCode
                });
              }
            };
            Choices3.prototype._generatePlaceholderValue = function() {
              if (this._isSelectElement && this.passedElement.placeholderOption) {
                var placeholderOption = this.passedElement.placeholderOption;
                return placeholderOption ? placeholderOption.text : null;
              }
              var _a = this.config, placeholder = _a.placeholder, placeholderValue = _a.placeholderValue;
              var dataset = this.passedElement.element.dataset;
              if (placeholder) {
                if (placeholderValue) {
                  return placeholderValue;
                }
                if (dataset.placeholder) {
                  return dataset.placeholder;
                }
              }
              return null;
            };
            return Choices3;
          }();
          exports2["default"] = Choices2;
        },
        613: function(__unused_webpack_module, exports2, __webpack_require__2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var utils_1 = __webpack_require__2(799);
          var constants_1 = __webpack_require__2(883);
          var Container = function() {
            function Container2(_a) {
              var element = _a.element, type = _a.type, classNames = _a.classNames, position = _a.position;
              this.element = element;
              this.classNames = classNames;
              this.type = type;
              this.position = position;
              this.isOpen = false;
              this.isFlipped = false;
              this.isFocussed = false;
              this.isDisabled = false;
              this.isLoading = false;
              this._onFocus = this._onFocus.bind(this);
              this._onBlur = this._onBlur.bind(this);
            }
            Container2.prototype.addEventListeners = function() {
              this.element.addEventListener("focus", this._onFocus);
              this.element.addEventListener("blur", this._onBlur);
            };
            Container2.prototype.removeEventListeners = function() {
              this.element.removeEventListener("focus", this._onFocus);
              this.element.removeEventListener("blur", this._onBlur);
            };
            Container2.prototype.shouldFlip = function(dropdownPos) {
              if (typeof dropdownPos !== "number") {
                return false;
              }
              var shouldFlip = false;
              if (this.position === "auto") {
                shouldFlip = !window.matchMedia("(min-height: ".concat(dropdownPos + 1, "px)")).matches;
              } else if (this.position === "top") {
                shouldFlip = true;
              }
              return shouldFlip;
            };
            Container2.prototype.setActiveDescendant = function(activeDescendantID) {
              this.element.setAttribute("aria-activedescendant", activeDescendantID);
            };
            Container2.prototype.removeActiveDescendant = function() {
              this.element.removeAttribute("aria-activedescendant");
            };
            Container2.prototype.open = function(dropdownPos) {
              this.element.classList.add(this.classNames.openState);
              this.element.setAttribute("aria-expanded", "true");
              this.isOpen = true;
              if (this.shouldFlip(dropdownPos)) {
                this.element.classList.add(this.classNames.flippedState);
                this.isFlipped = true;
              }
            };
            Container2.prototype.close = function() {
              this.element.classList.remove(this.classNames.openState);
              this.element.setAttribute("aria-expanded", "false");
              this.removeActiveDescendant();
              this.isOpen = false;
              if (this.isFlipped) {
                this.element.classList.remove(this.classNames.flippedState);
                this.isFlipped = false;
              }
            };
            Container2.prototype.focus = function() {
              if (!this.isFocussed) {
                this.element.focus();
              }
            };
            Container2.prototype.addFocusState = function() {
              this.element.classList.add(this.classNames.focusState);
            };
            Container2.prototype.removeFocusState = function() {
              this.element.classList.remove(this.classNames.focusState);
            };
            Container2.prototype.enable = function() {
              this.element.classList.remove(this.classNames.disabledState);
              this.element.removeAttribute("aria-disabled");
              if (this.type === constants_1.SELECT_ONE_TYPE) {
                this.element.setAttribute("tabindex", "0");
              }
              this.isDisabled = false;
            };
            Container2.prototype.disable = function() {
              this.element.classList.add(this.classNames.disabledState);
              this.element.setAttribute("aria-disabled", "true");
              if (this.type === constants_1.SELECT_ONE_TYPE) {
                this.element.setAttribute("tabindex", "-1");
              }
              this.isDisabled = true;
            };
            Container2.prototype.wrap = function(element) {
              (0, utils_1.wrap)(element, this.element);
            };
            Container2.prototype.unwrap = function(element) {
              if (this.element.parentNode) {
                this.element.parentNode.insertBefore(element, this.element);
                this.element.parentNode.removeChild(this.element);
              }
            };
            Container2.prototype.addLoadingState = function() {
              this.element.classList.add(this.classNames.loadingState);
              this.element.setAttribute("aria-busy", "true");
              this.isLoading = true;
            };
            Container2.prototype.removeLoadingState = function() {
              this.element.classList.remove(this.classNames.loadingState);
              this.element.removeAttribute("aria-busy");
              this.isLoading = false;
            };
            Container2.prototype._onFocus = function() {
              this.isFocussed = true;
            };
            Container2.prototype._onBlur = function() {
              this.isFocussed = false;
            };
            return Container2;
          }();
          exports2["default"] = Container;
        },
        217: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var Dropdown = function() {
            function Dropdown2(_a) {
              var element = _a.element, type = _a.type, classNames = _a.classNames;
              this.element = element;
              this.classNames = classNames;
              this.type = type;
              this.isActive = false;
            }
            Object.defineProperty(Dropdown2.prototype, "distanceFromTopWindow", {
              get: function() {
                return this.element.getBoundingClientRect().bottom;
              },
              enumerable: false,
              configurable: true
            });
            Dropdown2.prototype.getChild = function(selector) {
              return this.element.querySelector(selector);
            };
            Dropdown2.prototype.show = function() {
              this.element.classList.add(this.classNames.activeState);
              this.element.setAttribute("aria-expanded", "true");
              this.isActive = true;
              return this;
            };
            Dropdown2.prototype.hide = function() {
              this.element.classList.remove(this.classNames.activeState);
              this.element.setAttribute("aria-expanded", "false");
              this.isActive = false;
              return this;
            };
            return Dropdown2;
          }();
          exports2["default"] = Dropdown;
        },
        520: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
              default: mod
            };
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.WrappedSelect = exports2.WrappedInput = exports2.List = exports2.Input = exports2.Container = exports2.Dropdown = void 0;
          var dropdown_1 = __importDefault(__webpack_require__2(217));
          exports2.Dropdown = dropdown_1.default;
          var container_1 = __importDefault(__webpack_require__2(613));
          exports2.Container = container_1.default;
          var input_1 = __importDefault(__webpack_require__2(11));
          exports2.Input = input_1.default;
          var list_1 = __importDefault(__webpack_require__2(624));
          exports2.List = list_1.default;
          var wrapped_input_1 = __importDefault(__webpack_require__2(541));
          exports2.WrappedInput = wrapped_input_1.default;
          var wrapped_select_1 = __importDefault(__webpack_require__2(982));
          exports2.WrappedSelect = wrapped_select_1.default;
        },
        11: function(__unused_webpack_module, exports2, __webpack_require__2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var utils_1 = __webpack_require__2(799);
          var constants_1 = __webpack_require__2(883);
          var Input = function() {
            function Input2(_a) {
              var element = _a.element, type = _a.type, classNames = _a.classNames, preventPaste = _a.preventPaste;
              this.element = element;
              this.type = type;
              this.classNames = classNames;
              this.preventPaste = preventPaste;
              this.isFocussed = this.element.isEqualNode(document.activeElement);
              this.isDisabled = element.disabled;
              this._onPaste = this._onPaste.bind(this);
              this._onInput = this._onInput.bind(this);
              this._onFocus = this._onFocus.bind(this);
              this._onBlur = this._onBlur.bind(this);
            }
            Object.defineProperty(Input2.prototype, "placeholder", {
              set: function(placeholder) {
                this.element.placeholder = placeholder;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Input2.prototype, "value", {
              get: function() {
                return (0, utils_1.sanitise)(this.element.value);
              },
              set: function(value) {
                this.element.value = value;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Input2.prototype, "rawValue", {
              get: function() {
                return this.element.value;
              },
              enumerable: false,
              configurable: true
            });
            Input2.prototype.addEventListeners = function() {
              this.element.addEventListener("paste", this._onPaste);
              this.element.addEventListener("input", this._onInput, {
                passive: true
              });
              this.element.addEventListener("focus", this._onFocus, {
                passive: true
              });
              this.element.addEventListener("blur", this._onBlur, {
                passive: true
              });
            };
            Input2.prototype.removeEventListeners = function() {
              this.element.removeEventListener("input", this._onInput);
              this.element.removeEventListener("paste", this._onPaste);
              this.element.removeEventListener("focus", this._onFocus);
              this.element.removeEventListener("blur", this._onBlur);
            };
            Input2.prototype.enable = function() {
              this.element.removeAttribute("disabled");
              this.isDisabled = false;
            };
            Input2.prototype.disable = function() {
              this.element.setAttribute("disabled", "");
              this.isDisabled = true;
            };
            Input2.prototype.focus = function() {
              if (!this.isFocussed) {
                this.element.focus();
              }
            };
            Input2.prototype.blur = function() {
              if (this.isFocussed) {
                this.element.blur();
              }
            };
            Input2.prototype.clear = function(setWidth) {
              if (setWidth === void 0) {
                setWidth = true;
              }
              if (this.element.value) {
                this.element.value = "";
              }
              if (setWidth) {
                this.setWidth();
              }
              return this;
            };
            Input2.prototype.setWidth = function() {
              var _a = this.element, style = _a.style, value = _a.value, placeholder = _a.placeholder;
              style.minWidth = "".concat(placeholder.length + 1, "ch");
              style.width = "".concat(value.length + 1, "ch");
            };
            Input2.prototype.setActiveDescendant = function(activeDescendantID) {
              this.element.setAttribute("aria-activedescendant", activeDescendantID);
            };
            Input2.prototype.removeActiveDescendant = function() {
              this.element.removeAttribute("aria-activedescendant");
            };
            Input2.prototype._onInput = function() {
              if (this.type !== constants_1.SELECT_ONE_TYPE) {
                this.setWidth();
              }
            };
            Input2.prototype._onPaste = function(event) {
              if (this.preventPaste) {
                event.preventDefault();
              }
            };
            Input2.prototype._onFocus = function() {
              this.isFocussed = true;
            };
            Input2.prototype._onBlur = function() {
              this.isFocussed = false;
            };
            return Input2;
          }();
          exports2["default"] = Input;
        },
        624: function(__unused_webpack_module, exports2, __webpack_require__2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var constants_1 = __webpack_require__2(883);
          var List = function() {
            function List2(_a) {
              var element = _a.element;
              this.element = element;
              this.scrollPos = this.element.scrollTop;
              this.height = this.element.offsetHeight;
            }
            List2.prototype.clear = function() {
              this.element.innerHTML = "";
            };
            List2.prototype.append = function(node) {
              this.element.appendChild(node);
            };
            List2.prototype.getChild = function(selector) {
              return this.element.querySelector(selector);
            };
            List2.prototype.hasChildren = function() {
              return this.element.hasChildNodes();
            };
            List2.prototype.scrollToTop = function() {
              this.element.scrollTop = 0;
            };
            List2.prototype.scrollToChildElement = function(element, direction) {
              var _this = this;
              if (!element) {
                return;
              }
              var listHeight = this.element.offsetHeight;
              var listScrollPosition = this.element.scrollTop + listHeight;
              var elementHeight = element.offsetHeight;
              var elementPos = element.offsetTop + elementHeight;
              var destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
              requestAnimationFrame(function() {
                _this._animateScroll(destination, direction);
              });
            };
            List2.prototype._scrollDown = function(scrollPos, strength, destination) {
              var easing = (destination - scrollPos) / strength;
              var distance = easing > 1 ? easing : 1;
              this.element.scrollTop = scrollPos + distance;
            };
            List2.prototype._scrollUp = function(scrollPos, strength, destination) {
              var easing = (scrollPos - destination) / strength;
              var distance = easing > 1 ? easing : 1;
              this.element.scrollTop = scrollPos - distance;
            };
            List2.prototype._animateScroll = function(destination, direction) {
              var _this = this;
              var strength = constants_1.SCROLLING_SPEED;
              var choiceListScrollTop = this.element.scrollTop;
              var continueAnimation = false;
              if (direction > 0) {
                this._scrollDown(choiceListScrollTop, strength, destination);
                if (choiceListScrollTop < destination) {
                  continueAnimation = true;
                }
              } else {
                this._scrollUp(choiceListScrollTop, strength, destination);
                if (choiceListScrollTop > destination) {
                  continueAnimation = true;
                }
              }
              if (continueAnimation) {
                requestAnimationFrame(function() {
                  _this._animateScroll(destination, direction);
                });
              }
            };
            return List2;
          }();
          exports2["default"] = List;
        },
        730: function(__unused_webpack_module, exports2, __webpack_require__2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var utils_1 = __webpack_require__2(799);
          var WrappedElement = function() {
            function WrappedElement2(_a) {
              var element = _a.element, classNames = _a.classNames;
              this.element = element;
              this.classNames = classNames;
              if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {
                throw new TypeError("Invalid element passed");
              }
              this.isDisabled = false;
            }
            Object.defineProperty(WrappedElement2.prototype, "isActive", {
              get: function() {
                return this.element.dataset.choice === "active";
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(WrappedElement2.prototype, "dir", {
              get: function() {
                return this.element.dir;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(WrappedElement2.prototype, "value", {
              get: function() {
                return this.element.value;
              },
              set: function(value) {
                this.element.value = value;
              },
              enumerable: false,
              configurable: true
            });
            WrappedElement2.prototype.conceal = function() {
              this.element.classList.add(this.classNames.input);
              this.element.hidden = true;
              this.element.tabIndex = -1;
              var origStyle = this.element.getAttribute("style");
              if (origStyle) {
                this.element.setAttribute("data-choice-orig-style", origStyle);
              }
              this.element.setAttribute("data-choice", "active");
            };
            WrappedElement2.prototype.reveal = function() {
              this.element.classList.remove(this.classNames.input);
              this.element.hidden = false;
              this.element.removeAttribute("tabindex");
              var origStyle = this.element.getAttribute("data-choice-orig-style");
              if (origStyle) {
                this.element.removeAttribute("data-choice-orig-style");
                this.element.setAttribute("style", origStyle);
              } else {
                this.element.removeAttribute("style");
              }
              this.element.removeAttribute("data-choice");
              this.element.value = this.element.value;
            };
            WrappedElement2.prototype.enable = function() {
              this.element.removeAttribute("disabled");
              this.element.disabled = false;
              this.isDisabled = false;
            };
            WrappedElement2.prototype.disable = function() {
              this.element.setAttribute("disabled", "");
              this.element.disabled = true;
              this.isDisabled = true;
            };
            WrappedElement2.prototype.triggerEvent = function(eventType, data3) {
              (0, utils_1.dispatchEvent)(this.element, eventType, data3);
            };
            return WrappedElement2;
          }();
          exports2["default"] = WrappedElement;
        },
        541: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (Object.prototype.hasOwnProperty.call(b2, p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
              default: mod
            };
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var wrapped_element_1 = __importDefault(__webpack_require__2(730));
          var WrappedInput = function(_super) {
            __extends(WrappedInput2, _super);
            function WrappedInput2(_a) {
              var element = _a.element, classNames = _a.classNames, delimiter = _a.delimiter;
              var _this = _super.call(this, {
                element,
                classNames
              }) || this;
              _this.delimiter = delimiter;
              return _this;
            }
            Object.defineProperty(WrappedInput2.prototype, "value", {
              get: function() {
                return this.element.value;
              },
              set: function(value) {
                this.element.setAttribute("value", value);
                this.element.value = value;
              },
              enumerable: false,
              configurable: true
            });
            return WrappedInput2;
          }(wrapped_element_1.default);
          exports2["default"] = WrappedInput;
        },
        982: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (Object.prototype.hasOwnProperty.call(b2, p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
              default: mod
            };
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var wrapped_element_1 = __importDefault(__webpack_require__2(730));
          var WrappedSelect = function(_super) {
            __extends(WrappedSelect2, _super);
            function WrappedSelect2(_a) {
              var element = _a.element, classNames = _a.classNames, template = _a.template;
              var _this = _super.call(this, {
                element,
                classNames
              }) || this;
              _this.template = template;
              return _this;
            }
            Object.defineProperty(WrappedSelect2.prototype, "placeholderOption", {
              get: function() {
                return this.element.querySelector('option[value=""]') || this.element.querySelector("option[placeholder]");
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(WrappedSelect2.prototype, "optionGroups", {
              get: function() {
                return Array.from(this.element.getElementsByTagName("OPTGROUP"));
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(WrappedSelect2.prototype, "options", {
              get: function() {
                return Array.from(this.element.options);
              },
              set: function(options) {
                var _this = this;
                var fragment = document.createDocumentFragment();
                var addOptionToFragment = function(data3) {
                  var option3 = _this.template(data3);
                  fragment.appendChild(option3);
                };
                options.forEach(function(optionData) {
                  return addOptionToFragment(optionData);
                });
                this.appendDocFragment(fragment);
              },
              enumerable: false,
              configurable: true
            });
            WrappedSelect2.prototype.appendDocFragment = function(fragment) {
              this.element.innerHTML = "";
              this.element.appendChild(fragment);
            };
            return WrappedSelect2;
          }(wrapped_element_1.default);
          exports2["default"] = WrappedSelect;
        },
        883: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.SCROLLING_SPEED = exports2.SELECT_MULTIPLE_TYPE = exports2.SELECT_ONE_TYPE = exports2.TEXT_TYPE = exports2.KEY_CODES = exports2.ACTION_TYPES = exports2.EVENTS = void 0;
          exports2.EVENTS = {
            showDropdown: "showDropdown",
            hideDropdown: "hideDropdown",
            change: "change",
            choice: "choice",
            search: "search",
            addItem: "addItem",
            removeItem: "removeItem",
            highlightItem: "highlightItem",
            highlightChoice: "highlightChoice",
            unhighlightItem: "unhighlightItem"
          };
          exports2.ACTION_TYPES = {
            ADD_CHOICE: "ADD_CHOICE",
            FILTER_CHOICES: "FILTER_CHOICES",
            ACTIVATE_CHOICES: "ACTIVATE_CHOICES",
            CLEAR_CHOICES: "CLEAR_CHOICES",
            ADD_GROUP: "ADD_GROUP",
            ADD_ITEM: "ADD_ITEM",
            REMOVE_ITEM: "REMOVE_ITEM",
            HIGHLIGHT_ITEM: "HIGHLIGHT_ITEM",
            CLEAR_ALL: "CLEAR_ALL",
            RESET_TO: "RESET_TO",
            SET_IS_LOADING: "SET_IS_LOADING"
          };
          exports2.KEY_CODES = {
            BACK_KEY: 46,
            DELETE_KEY: 8,
            ENTER_KEY: 13,
            A_KEY: 65,
            ESC_KEY: 27,
            UP_KEY: 38,
            DOWN_KEY: 40,
            PAGE_UP_KEY: 33,
            PAGE_DOWN_KEY: 34
          };
          exports2.TEXT_TYPE = "text";
          exports2.SELECT_ONE_TYPE = "select-one";
          exports2.SELECT_MULTIPLE_TYPE = "select-multiple";
          exports2.SCROLLING_SPEED = 4;
        },
        789: function(__unused_webpack_module, exports2, __webpack_require__2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.DEFAULT_CONFIG = exports2.DEFAULT_CLASSNAMES = void 0;
          var utils_1 = __webpack_require__2(799);
          exports2.DEFAULT_CLASSNAMES = {
            containerOuter: "choices",
            containerInner: "choices__inner",
            input: "choices__input",
            inputCloned: "choices__input--cloned",
            list: "choices__list",
            listItems: "choices__list--multiple",
            listSingle: "choices__list--single",
            listDropdown: "choices__list--dropdown",
            item: "choices__item",
            itemSelectable: "choices__item--selectable",
            itemDisabled: "choices__item--disabled",
            itemChoice: "choices__item--choice",
            placeholder: "choices__placeholder",
            group: "choices__group",
            groupHeading: "choices__heading",
            button: "choices__button",
            activeState: "is-active",
            focusState: "is-focused",
            openState: "is-open",
            disabledState: "is-disabled",
            highlightedState: "is-highlighted",
            selectedState: "is-selected",
            flippedState: "is-flipped",
            loadingState: "is-loading",
            noResults: "has-no-results",
            noChoices: "has-no-choices"
          };
          exports2.DEFAULT_CONFIG = {
            items: [],
            choices: [],
            silent: false,
            renderChoiceLimit: -1,
            maxItemCount: -1,
            addItems: true,
            addItemFilter: null,
            removeItems: true,
            removeItemButton: false,
            editItems: false,
            allowHTML: true,
            duplicateItemsAllowed: true,
            delimiter: ",",
            paste: true,
            searchEnabled: true,
            searchChoices: true,
            searchFloor: 1,
            searchResultLimit: 4,
            searchFields: ["label", "value"],
            position: "auto",
            resetScrollPosition: true,
            shouldSort: true,
            shouldSortItems: false,
            sorter: utils_1.sortByAlpha,
            placeholder: true,
            placeholderValue: null,
            searchPlaceholderValue: null,
            prependValue: null,
            appendValue: null,
            renderSelectedChoices: "auto",
            loadingText: "Loading...",
            noResultsText: "No results found",
            noChoicesText: "No choices to choose from",
            itemSelectText: "Press to select",
            uniqueItemText: "Only unique values can be added",
            customAddItemText: "Only values matching specific conditions can be added",
            addItemText: function(value) {
              return 'Press Enter to add <b>"'.concat((0, utils_1.sanitise)(value), '"</b>');
            },
            maxItemText: function(maxItemCount) {
              return "Only ".concat(maxItemCount, " values can be added");
            },
            valueComparer: function(value1, value2) {
              return value1 === value2;
            },
            fuseOptions: {
              includeScore: true
            },
            labelId: "",
            callbackOnInit: null,
            callbackOnCreateTemplates: null,
            classNames: exports2.DEFAULT_CLASSNAMES
          };
        },
        18: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        978: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        948: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        359: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        285: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        533: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        187: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            Object.defineProperty(o, k2, {
              enumerable: true,
              get: function() {
                return m[k];
              }
            });
          } : function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            o[k2] = m[k];
          });
          var __exportStar2 = this && this.__exportStar || function(m, exports3) {
            for (var p in m)
              if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                __createBinding(exports3, m, p);
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          __exportStar2(__webpack_require__2(18), exports2);
          __exportStar2(__webpack_require__2(978), exports2);
          __exportStar2(__webpack_require__2(948), exports2);
          __exportStar2(__webpack_require__2(359), exports2);
          __exportStar2(__webpack_require__2(285), exports2);
          __exportStar2(__webpack_require__2(533), exports2);
          __exportStar2(__webpack_require__2(287), exports2);
          __exportStar2(__webpack_require__2(132), exports2);
          __exportStar2(__webpack_require__2(837), exports2);
          __exportStar2(__webpack_require__2(598), exports2);
          __exportStar2(__webpack_require__2(369), exports2);
          __exportStar2(__webpack_require__2(37), exports2);
          __exportStar2(__webpack_require__2(47), exports2);
          __exportStar2(__webpack_require__2(923), exports2);
          __exportStar2(__webpack_require__2(876), exports2);
        },
        287: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        132: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        837: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        598: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        37: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        369: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        47: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        923: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        876: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
        },
        799: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.diff = exports2.cloneObject = exports2.existsInArray = exports2.dispatchEvent = exports2.sortByScore = exports2.sortByAlpha = exports2.strToEl = exports2.sanitise = exports2.isScrolledIntoView = exports2.getAdjacentEl = exports2.wrap = exports2.isType = exports2.getType = exports2.generateId = exports2.generateChars = exports2.getRandomNumber = void 0;
          var getRandomNumber2 = function(min, max) {
            return Math.floor(Math.random() * (max - min) + min);
          };
          exports2.getRandomNumber = getRandomNumber2;
          var generateChars = function(length) {
            return Array.from({
              length
            }, function() {
              return (0, exports2.getRandomNumber)(0, 36).toString(36);
            }).join("");
          };
          exports2.generateChars = generateChars;
          var generateId = function(element, prefix) {
            var id = element.id || element.name && "".concat(element.name, "-").concat((0, exports2.generateChars)(2)) || (0, exports2.generateChars)(4);
            id = id.replace(/(:|\.|\[|\]|,)/g, "");
            id = "".concat(prefix, "-").concat(id);
            return id;
          };
          exports2.generateId = generateId;
          var getType2 = function(obj) {
            return Object.prototype.toString.call(obj).slice(8, -1);
          };
          exports2.getType = getType2;
          var isType = function(type, obj) {
            return obj !== void 0 && obj !== null && (0, exports2.getType)(obj) === type;
          };
          exports2.isType = isType;
          var wrap2 = function(element, wrapper3) {
            if (wrapper3 === void 0) {
              wrapper3 = document.createElement("div");
            }
            if (element.parentNode) {
              if (element.nextSibling) {
                element.parentNode.insertBefore(wrapper3, element.nextSibling);
              } else {
                element.parentNode.appendChild(wrapper3);
              }
            }
            return wrapper3.appendChild(element);
          };
          exports2.wrap = wrap2;
          var getAdjacentEl = function(startEl, selector, direction) {
            if (direction === void 0) {
              direction = 1;
            }
            var prop = "".concat(direction > 0 ? "next" : "previous", "ElementSibling");
            var sibling = startEl[prop];
            while (sibling) {
              if (sibling.matches(selector)) {
                return sibling;
              }
              sibling = sibling[prop];
            }
            return sibling;
          };
          exports2.getAdjacentEl = getAdjacentEl;
          var isScrolledIntoView = function(element, parent, direction) {
            if (direction === void 0) {
              direction = 1;
            }
            if (!element) {
              return false;
            }
            var isVisible;
            if (direction > 0) {
              isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
            } else {
              isVisible = element.offsetTop >= parent.scrollTop;
            }
            return isVisible;
          };
          exports2.isScrolledIntoView = isScrolledIntoView;
          var sanitise = function(value) {
            if (typeof value !== "string") {
              return value;
            }
            return value.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
          };
          exports2.sanitise = sanitise;
          exports2.strToEl = function() {
            var tmpEl = document.createElement("div");
            return function(str) {
              var cleanedInput = str.trim();
              tmpEl.innerHTML = cleanedInput;
              var firldChild = tmpEl.children[0];
              while (tmpEl.firstChild) {
                tmpEl.removeChild(tmpEl.firstChild);
              }
              return firldChild;
            };
          }();
          var sortByAlpha = function(_a, _b) {
            var value = _a.value, _c = _a.label, label = _c === void 0 ? value : _c;
            var value2 = _b.value, _d = _b.label, label2 = _d === void 0 ? value2 : _d;
            return label.localeCompare(label2, [], {
              sensitivity: "base",
              ignorePunctuation: true,
              numeric: true
            });
          };
          exports2.sortByAlpha = sortByAlpha;
          var sortByScore = function(a, b) {
            var _a = a.score, scoreA = _a === void 0 ? 0 : _a;
            var _b = b.score, scoreB = _b === void 0 ? 0 : _b;
            return scoreA - scoreB;
          };
          exports2.sortByScore = sortByScore;
          var dispatchEvent2 = function(element, type, customArgs) {
            if (customArgs === void 0) {
              customArgs = null;
            }
            var event = new CustomEvent(type, {
              detail: customArgs,
              bubbles: true,
              cancelable: true
            });
            return element.dispatchEvent(event);
          };
          exports2.dispatchEvent = dispatchEvent2;
          var existsInArray = function(array, value, key) {
            if (key === void 0) {
              key = "value";
            }
            return array.some(function(item2) {
              if (typeof value === "string") {
                return item2[key] === value.trim();
              }
              return item2[key] === value;
            });
          };
          exports2.existsInArray = existsInArray;
          var cloneObject = function(obj) {
            return JSON.parse(JSON.stringify(obj));
          };
          exports2.cloneObject = cloneObject;
          var diff = function(a, b) {
            var aKeys = Object.keys(a).sort();
            var bKeys = Object.keys(b).sort();
            return aKeys.filter(function(i) {
              return bKeys.indexOf(i) < 0;
            });
          };
          exports2.diff = diff;
        },
        273: function(__unused_webpack_module, exports2) {
          var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2)
              for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                  if (!ar)
                    ar = Array.prototype.slice.call(from, 0, i);
                  ar[i] = from[i];
                }
              }
            return to.concat(ar || Array.prototype.slice.call(from));
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultState = void 0;
          exports2.defaultState = [];
          function choices(state2, action) {
            if (state2 === void 0) {
              state2 = exports2.defaultState;
            }
            if (action === void 0) {
              action = {};
            }
            switch (action.type) {
              case "ADD_CHOICE": {
                var addChoiceAction = action;
                var choice = {
                  id: addChoiceAction.id,
                  elementId: addChoiceAction.elementId,
                  groupId: addChoiceAction.groupId,
                  value: addChoiceAction.value,
                  label: addChoiceAction.label || addChoiceAction.value,
                  disabled: addChoiceAction.disabled || false,
                  selected: false,
                  active: true,
                  score: 9999,
                  customProperties: addChoiceAction.customProperties,
                  placeholder: addChoiceAction.placeholder || false
                };
                return __spreadArray(__spreadArray([], state2, true), [choice], false);
              }
              case "ADD_ITEM": {
                var addItemAction_1 = action;
                if (addItemAction_1.choiceId > -1) {
                  return state2.map(function(obj) {
                    var choice2 = obj;
                    if (choice2.id === parseInt("".concat(addItemAction_1.choiceId), 10)) {
                      choice2.selected = true;
                    }
                    return choice2;
                  });
                }
                return state2;
              }
              case "REMOVE_ITEM": {
                var removeItemAction_1 = action;
                if (removeItemAction_1.choiceId && removeItemAction_1.choiceId > -1) {
                  return state2.map(function(obj) {
                    var choice2 = obj;
                    if (choice2.id === parseInt("".concat(removeItemAction_1.choiceId), 10)) {
                      choice2.selected = false;
                    }
                    return choice2;
                  });
                }
                return state2;
              }
              case "FILTER_CHOICES": {
                var filterChoicesAction_1 = action;
                return state2.map(function(obj) {
                  var choice2 = obj;
                  choice2.active = filterChoicesAction_1.results.some(function(_a) {
                    var item2 = _a.item, score = _a.score;
                    if (item2.id === choice2.id) {
                      choice2.score = score;
                      return true;
                    }
                    return false;
                  });
                  return choice2;
                });
              }
              case "ACTIVATE_CHOICES": {
                var activateChoicesAction_1 = action;
                return state2.map(function(obj) {
                  var choice2 = obj;
                  choice2.active = activateChoicesAction_1.active;
                  return choice2;
                });
              }
              case "CLEAR_CHOICES": {
                return exports2.defaultState;
              }
              default: {
                return state2;
              }
            }
          }
          exports2["default"] = choices;
        },
        871: function(__unused_webpack_module, exports2) {
          var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2)
              for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                  if (!ar)
                    ar = Array.prototype.slice.call(from, 0, i);
                  ar[i] = from[i];
                }
              }
            return to.concat(ar || Array.prototype.slice.call(from));
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultState = void 0;
          exports2.defaultState = [];
          function groups(state2, action) {
            if (state2 === void 0) {
              state2 = exports2.defaultState;
            }
            if (action === void 0) {
              action = {};
            }
            switch (action.type) {
              case "ADD_GROUP": {
                var addGroupAction = action;
                return __spreadArray(__spreadArray([], state2, true), [{
                  id: addGroupAction.id,
                  value: addGroupAction.value,
                  active: addGroupAction.active,
                  disabled: addGroupAction.disabled
                }], false);
              }
              case "CLEAR_CHOICES": {
                return [];
              }
              default: {
                return state2;
              }
            }
          }
          exports2["default"] = groups;
        },
        655: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
              default: mod
            };
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultState = void 0;
          var redux_1 = __webpack_require__2(857);
          var items_1 = __importDefault(__webpack_require__2(52));
          var groups_1 = __importDefault(__webpack_require__2(871));
          var choices_1 = __importDefault(__webpack_require__2(273));
          var loading_1 = __importDefault(__webpack_require__2(502));
          var utils_1 = __webpack_require__2(799);
          exports2.defaultState = {
            groups: [],
            items: [],
            choices: [],
            loading: false
          };
          var appReducer = (0, redux_1.combineReducers)({
            items: items_1.default,
            groups: groups_1.default,
            choices: choices_1.default,
            loading: loading_1.default
          });
          var rootReducer = function(passedState, action) {
            var state2 = passedState;
            if (action.type === "CLEAR_ALL") {
              state2 = exports2.defaultState;
            } else if (action.type === "RESET_TO") {
              return (0, utils_1.cloneObject)(action.state);
            }
            return appReducer(state2, action);
          };
          exports2["default"] = rootReducer;
        },
        52: function(__unused_webpack_module, exports2) {
          var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2)
              for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                  if (!ar)
                    ar = Array.prototype.slice.call(from, 0, i);
                  ar[i] = from[i];
                }
              }
            return to.concat(ar || Array.prototype.slice.call(from));
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultState = void 0;
          exports2.defaultState = [];
          function items(state2, action) {
            if (state2 === void 0) {
              state2 = exports2.defaultState;
            }
            if (action === void 0) {
              action = {};
            }
            switch (action.type) {
              case "ADD_ITEM": {
                var addItemAction = action;
                var newState = __spreadArray(__spreadArray([], state2, true), [{
                  id: addItemAction.id,
                  choiceId: addItemAction.choiceId,
                  groupId: addItemAction.groupId,
                  value: addItemAction.value,
                  label: addItemAction.label,
                  active: true,
                  highlighted: false,
                  customProperties: addItemAction.customProperties,
                  placeholder: addItemAction.placeholder || false,
                  keyCode: null
                }], false);
                return newState.map(function(obj) {
                  var item2 = obj;
                  item2.highlighted = false;
                  return item2;
                });
              }
              case "REMOVE_ITEM": {
                return state2.map(function(obj) {
                  var item2 = obj;
                  if (item2.id === action.id) {
                    item2.active = false;
                  }
                  return item2;
                });
              }
              case "HIGHLIGHT_ITEM": {
                var highlightItemAction_1 = action;
                return state2.map(function(obj) {
                  var item2 = obj;
                  if (item2.id === highlightItemAction_1.id) {
                    item2.highlighted = highlightItemAction_1.highlighted;
                  }
                  return item2;
                });
              }
              default: {
                return state2;
              }
            }
          }
          exports2["default"] = items;
        },
        502: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.defaultState = void 0;
          exports2.defaultState = false;
          var general = function(state2, action) {
            if (state2 === void 0) {
              state2 = exports2.defaultState;
            }
            if (action === void 0) {
              action = {};
            }
            switch (action.type) {
              case "SET_IS_LOADING": {
                return action.isLoading;
              }
              default: {
                return state2;
              }
            }
          };
          exports2["default"] = general;
        },
        744: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2)
              for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                  if (!ar)
                    ar = Array.prototype.slice.call(from, 0, i);
                  ar[i] = from[i];
                }
              }
            return to.concat(ar || Array.prototype.slice.call(from));
          };
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
              default: mod
            };
          };
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var redux_1 = __webpack_require__2(857);
          var index_1 = __importDefault(__webpack_require__2(655));
          var Store = function() {
            function Store2() {
              this._store = (0, redux_1.createStore)(index_1.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
            }
            Store2.prototype.subscribe = function(onChange) {
              this._store.subscribe(onChange);
            };
            Store2.prototype.dispatch = function(action) {
              this._store.dispatch(action);
            };
            Object.defineProperty(Store2.prototype, "state", {
              get: function() {
                return this._store.getState();
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Store2.prototype, "items", {
              get: function() {
                return this.state.items;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Store2.prototype, "activeItems", {
              get: function() {
                return this.items.filter(function(item2) {
                  return item2.active === true;
                });
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Store2.prototype, "highlightedActiveItems", {
              get: function() {
                return this.items.filter(function(item2) {
                  return item2.active && item2.highlighted;
                });
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Store2.prototype, "choices", {
              get: function() {
                return this.state.choices;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Store2.prototype, "activeChoices", {
              get: function() {
                return this.choices.filter(function(choice) {
                  return choice.active === true;
                });
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Store2.prototype, "selectableChoices", {
              get: function() {
                return this.choices.filter(function(choice) {
                  return choice.disabled !== true;
                });
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Store2.prototype, "searchableChoices", {
              get: function() {
                return this.selectableChoices.filter(function(choice) {
                  return choice.placeholder !== true;
                });
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Store2.prototype, "placeholderChoice", {
              get: function() {
                return __spreadArray([], this.choices, true).reverse().find(function(choice) {
                  return choice.placeholder === true;
                });
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Store2.prototype, "groups", {
              get: function() {
                return this.state.groups;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(Store2.prototype, "activeGroups", {
              get: function() {
                var _a = this, groups = _a.groups, choices = _a.choices;
                return groups.filter(function(group) {
                  var isActive = group.active === true && group.disabled === false;
                  var hasActiveOptions = choices.some(function(choice) {
                    return choice.active === true && choice.disabled === false;
                  });
                  return isActive && hasActiveOptions;
                }, []);
              },
              enumerable: false,
              configurable: true
            });
            Store2.prototype.isLoading = function() {
              return this.state.loading;
            };
            Store2.prototype.getChoiceById = function(id) {
              return this.activeChoices.find(function(choice) {
                return choice.id === parseInt(id, 10);
              });
            };
            Store2.prototype.getGroupById = function(id) {
              return this.groups.find(function(group) {
                return group.id === id;
              });
            };
            return Store2;
          }();
          exports2["default"] = Store;
        },
        686: function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var templates = {
            containerOuter: function(_a, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {
              var containerOuter = _a.classNames.containerOuter;
              var div = Object.assign(document.createElement("div"), {
                className: containerOuter
              });
              div.dataset.type = passedElementType;
              if (dir) {
                div.dir = dir;
              }
              if (isSelectOneElement) {
                div.tabIndex = 0;
              }
              if (isSelectElement) {
                div.setAttribute("role", searchEnabled ? "combobox" : "listbox");
                if (searchEnabled) {
                  div.setAttribute("aria-autocomplete", "list");
                }
              }
              div.setAttribute("aria-haspopup", "true");
              div.setAttribute("aria-expanded", "false");
              if (labelId) {
                div.setAttribute("aria-labeledby", labelId);
              }
              return div;
            },
            containerInner: function(_a) {
              var containerInner = _a.classNames.containerInner;
              return Object.assign(document.createElement("div"), {
                className: containerInner
              });
            },
            itemList: function(_a, isSelectOneElement) {
              var _b = _a.classNames, list2 = _b.list, listSingle = _b.listSingle, listItems = _b.listItems;
              return Object.assign(document.createElement("div"), {
                className: "".concat(list2, " ").concat(isSelectOneElement ? listSingle : listItems)
              });
            },
            placeholder: function(_a, value) {
              var _b;
              var allowHTML = _a.allowHTML, placeholder = _a.classNames.placeholder;
              return Object.assign(document.createElement("div"), (_b = {
                className: placeholder
              }, _b[allowHTML ? "innerHTML" : "innerText"] = value, _b));
            },
            item: function(_a, _b, removeItemButton) {
              var _c, _d;
              var allowHTML = _a.allowHTML, _e = _a.classNames, item2 = _e.item, button = _e.button, highlightedState = _e.highlightedState, itemSelectable = _e.itemSelectable, placeholder = _e.placeholder;
              var id = _b.id, value = _b.value, label = _b.label, customProperties = _b.customProperties, active = _b.active, disabled = _b.disabled, highlighted = _b.highlighted, isPlaceholder = _b.placeholder;
              var div = Object.assign(document.createElement("div"), (_c = {
                className: item2
              }, _c[allowHTML ? "innerHTML" : "innerText"] = label, _c));
              Object.assign(div.dataset, {
                item: "",
                id,
                value,
                customProperties
              });
              if (active) {
                div.setAttribute("aria-selected", "true");
              }
              if (disabled) {
                div.setAttribute("aria-disabled", "true");
              }
              if (isPlaceholder) {
                div.classList.add(placeholder);
              }
              div.classList.add(highlighted ? highlightedState : itemSelectable);
              if (removeItemButton) {
                if (disabled) {
                  div.classList.remove(itemSelectable);
                }
                div.dataset.deletable = "";
                var REMOVE_ITEM_TEXT = "Remove item";
                var removeButton = Object.assign(document.createElement("button"), (_d = {
                  type: "button",
                  className: button
                }, _d[allowHTML ? "innerHTML" : "innerText"] = REMOVE_ITEM_TEXT, _d));
                removeButton.setAttribute("aria-label", "".concat(REMOVE_ITEM_TEXT, ": '").concat(value, "'"));
                removeButton.dataset.button = "";
                div.appendChild(removeButton);
              }
              return div;
            },
            choiceList: function(_a, isSelectOneElement) {
              var list2 = _a.classNames.list;
              var div = Object.assign(document.createElement("div"), {
                className: list2
              });
              if (!isSelectOneElement) {
                div.setAttribute("aria-multiselectable", "true");
              }
              div.setAttribute("role", "listbox");
              return div;
            },
            choiceGroup: function(_a, _b) {
              var _c;
              var allowHTML = _a.allowHTML, _d = _a.classNames, group = _d.group, groupHeading = _d.groupHeading, itemDisabled = _d.itemDisabled;
              var id = _b.id, value = _b.value, disabled = _b.disabled;
              var div = Object.assign(document.createElement("div"), {
                className: "".concat(group, " ").concat(disabled ? itemDisabled : "")
              });
              div.setAttribute("role", "group");
              Object.assign(div.dataset, {
                group: "",
                id,
                value
              });
              if (disabled) {
                div.setAttribute("aria-disabled", "true");
              }
              div.appendChild(Object.assign(document.createElement("div"), (_c = {
                className: groupHeading
              }, _c[allowHTML ? "innerHTML" : "innerText"] = value, _c)));
              return div;
            },
            choice: function(_a, _b, selectText) {
              var _c;
              var allowHTML = _a.allowHTML, _d = _a.classNames, item2 = _d.item, itemChoice = _d.itemChoice, itemSelectable = _d.itemSelectable, selectedState = _d.selectedState, itemDisabled = _d.itemDisabled, placeholder = _d.placeholder;
              var id = _b.id, value = _b.value, label = _b.label, groupId = _b.groupId, elementId = _b.elementId, isDisabled = _b.disabled, isSelected = _b.selected, isPlaceholder = _b.placeholder;
              var div = Object.assign(document.createElement("div"), (_c = {
                id: elementId
              }, _c[allowHTML ? "innerHTML" : "innerText"] = label, _c.className = "".concat(item2, " ").concat(itemChoice), _c));
              if (isSelected) {
                div.classList.add(selectedState);
              }
              if (isPlaceholder) {
                div.classList.add(placeholder);
              }
              div.setAttribute("role", groupId && groupId > 0 ? "treeitem" : "option");
              Object.assign(div.dataset, {
                choice: "",
                id,
                value,
                selectText
              });
              if (isDisabled) {
                div.classList.add(itemDisabled);
                div.dataset.choiceDisabled = "";
                div.setAttribute("aria-disabled", "true");
              } else {
                div.classList.add(itemSelectable);
                div.dataset.choiceSelectable = "";
              }
              return div;
            },
            input: function(_a, placeholderValue) {
              var _b = _a.classNames, input = _b.input, inputCloned = _b.inputCloned;
              var inp = Object.assign(document.createElement("input"), {
                type: "search",
                name: "search_terms",
                className: "".concat(input, " ").concat(inputCloned),
                autocomplete: "off",
                autocapitalize: "off",
                spellcheck: false
              });
              inp.setAttribute("role", "textbox");
              inp.setAttribute("aria-autocomplete", "list");
              inp.setAttribute("aria-label", placeholderValue);
              return inp;
            },
            dropdown: function(_a) {
              var _b = _a.classNames, list2 = _b.list, listDropdown = _b.listDropdown;
              var div = document.createElement("div");
              div.classList.add(list2, listDropdown);
              div.setAttribute("aria-expanded", "false");
              return div;
            },
            notice: function(_a, innerText, type) {
              var _b;
              var allowHTML = _a.allowHTML, _c = _a.classNames, item2 = _c.item, itemChoice = _c.itemChoice, noResults = _c.noResults, noChoices = _c.noChoices;
              if (type === void 0) {
                type = "";
              }
              var classes = [item2, itemChoice];
              if (type === "no-choices") {
                classes.push(noChoices);
              } else if (type === "no-results") {
                classes.push(noResults);
              }
              return Object.assign(document.createElement("div"), (_b = {}, _b[allowHTML ? "innerHTML" : "innerText"] = innerText, _b.className = classes.join(" "), _b));
            },
            option: function(_a) {
              var label = _a.label, value = _a.value, customProperties = _a.customProperties, active = _a.active, disabled = _a.disabled;
              var opt = new Option(label, value, false, active);
              if (customProperties) {
                opt.dataset.customProperties = "".concat(customProperties);
              }
              opt.disabled = !!disabled;
              return opt;
            }
          };
          exports2["default"] = templates;
        },
        996: function(module2) {
          var isMergeableObject = function isMergeableObject2(value) {
            return isNonNullObject(value) && !isSpecial(value);
          };
          function isNonNullObject(value) {
            return !!value && typeof value === "object";
          }
          function isSpecial(value) {
            var stringValue = Object.prototype.toString.call(value);
            return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
          }
          var canUseSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
          function isReactElement(value) {
            return value.$$typeof === REACT_ELEMENT_TYPE;
          }
          function emptyTarget(val) {
            return Array.isArray(val) ? [] : {};
          }
          function cloneUnlessOtherwiseSpecified(value, options) {
            return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
          }
          function defaultArrayMerge(target, source, options) {
            return target.concat(source).map(function(element) {
              return cloneUnlessOtherwiseSpecified(element, options);
            });
          }
          function getMergeFunction(key, options) {
            if (!options.customMerge) {
              return deepmerge;
            }
            var customMerge = options.customMerge(key);
            return typeof customMerge === "function" ? customMerge : deepmerge;
          }
          function getEnumerableOwnPropertySymbols(target) {
            return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
              return target.propertyIsEnumerable(symbol);
            }) : [];
          }
          function getKeys(target) {
            return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
          }
          function propertyIsOnObject(object, property) {
            try {
              return property in object;
            } catch (_) {
              return false;
            }
          }
          function propertyIsUnsafe(target, key) {
            return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
          }
          function mergeObject(target, source, options) {
            var destination = {};
            if (options.isMergeableObject(target)) {
              getKeys(target).forEach(function(key) {
                destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
              });
            }
            getKeys(source).forEach(function(key) {
              if (propertyIsUnsafe(target, key)) {
                return;
              }
              if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
                destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
              } else {
                destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
              }
            });
            return destination;
          }
          function deepmerge(target, source, options) {
            options = options || {};
            options.arrayMerge = options.arrayMerge || defaultArrayMerge;
            options.isMergeableObject = options.isMergeableObject || isMergeableObject;
            options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
            var sourceIsArray = Array.isArray(source);
            var targetIsArray = Array.isArray(target);
            var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
            if (!sourceAndTargetTypesMatch) {
              return cloneUnlessOtherwiseSpecified(source, options);
            } else if (sourceIsArray) {
              return options.arrayMerge(target, source, options);
            } else {
              return mergeObject(target, source, options);
            }
          }
          deepmerge.all = function deepmergeAll(array, options) {
            if (!Array.isArray(array)) {
              throw new Error("first argument should be an array");
            }
            return array.reduce(function(prev, next) {
              return deepmerge(prev, next, options);
            }, {});
          };
          var deepmerge_1 = deepmerge;
          module2.exports = deepmerge_1;
        },
        221: function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
          __webpack_require__2.r(__webpack_exports__2);
          __webpack_require__2.d(__webpack_exports__2, {
            default: function() {
              return Fuse;
            }
          });
          function isArray2(value) {
            return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
          }
          const INFINITY = 1 / 0;
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            let result = value + "";
            return result == "0" && 1 / value == -INFINITY ? "-0" : result;
          }
          function toString2(value) {
            return value == null ? "" : baseToString(value);
          }
          function isString3(value) {
            return typeof value === "string";
          }
          function isNumber2(value) {
            return typeof value === "number";
          }
          function isBoolean2(value) {
            return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
          }
          function isObject2(value) {
            return typeof value === "object";
          }
          function isObjectLike(value) {
            return isObject2(value) && value !== null;
          }
          function isDefined4(value) {
            return value !== void 0 && value !== null;
          }
          function isBlank(value) {
            return !value.trim().length;
          }
          function getTag(value) {
            return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
          }
          const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
          const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
          const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
          const PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
          const MISSING_KEY_PROPERTY = (name2) => `Missing ${name2} property in key`;
          const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
          const hasOwn = Object.prototype.hasOwnProperty;
          class KeyStore {
            constructor(keys) {
              this._keys = [];
              this._keyMap = {};
              let totalWeight = 0;
              keys.forEach((key) => {
                let obj = createKey(key);
                totalWeight += obj.weight;
                this._keys.push(obj);
                this._keyMap[obj.id] = obj;
                totalWeight += obj.weight;
              });
              this._keys.forEach((key) => {
                key.weight /= totalWeight;
              });
            }
            get(keyId) {
              return this._keyMap[keyId];
            }
            keys() {
              return this._keys;
            }
            toJSON() {
              return JSON.stringify(this._keys);
            }
          }
          function createKey(key) {
            let path = null;
            let id = null;
            let src = null;
            let weight = 1;
            if (isString3(key) || isArray2(key)) {
              src = key;
              path = createKeyPath(key);
              id = createKeyId(key);
            } else {
              if (!hasOwn.call(key, "name")) {
                throw new Error(MISSING_KEY_PROPERTY("name"));
              }
              const name2 = key.name;
              src = name2;
              if (hasOwn.call(key, "weight")) {
                weight = key.weight;
                if (weight <= 0) {
                  throw new Error(INVALID_KEY_WEIGHT_VALUE(name2));
                }
              }
              path = createKeyPath(name2);
              id = createKeyId(name2);
            }
            return {path, id, weight, src};
          }
          function createKeyPath(key) {
            return isArray2(key) ? key : key.split(".");
          }
          function createKeyId(key) {
            return isArray2(key) ? key.join(".") : key;
          }
          function get(obj, path) {
            let list2 = [];
            let arr = false;
            const deepGet = (obj2, path2, index2) => {
              if (!isDefined4(obj2)) {
                return;
              }
              if (!path2[index2]) {
                list2.push(obj2);
              } else {
                let key = path2[index2];
                const value = obj2[key];
                if (!isDefined4(value)) {
                  return;
                }
                if (index2 === path2.length - 1 && (isString3(value) || isNumber2(value) || isBoolean2(value))) {
                  list2.push(toString2(value));
                } else if (isArray2(value)) {
                  arr = true;
                  for (let i = 0, len = value.length; i < len; i += 1) {
                    deepGet(value[i], path2, index2 + 1);
                  }
                } else if (path2.length) {
                  deepGet(value, path2, index2 + 1);
                }
              }
            };
            deepGet(obj, isString3(path) ? path.split(".") : path, 0);
            return arr ? list2 : list2[0];
          }
          const MatchOptions = {
            includeMatches: false,
            findAllMatches: false,
            minMatchCharLength: 1
          };
          const BasicOptions = {
            isCaseSensitive: false,
            includeScore: false,
            keys: [],
            shouldSort: true,
            sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
          };
          const FuzzyOptions = {
            location: 0,
            threshold: 0.6,
            distance: 100
          };
          const AdvancedOptions = {
            useExtendedSearch: false,
            getFn: get,
            ignoreLocation: false,
            ignoreFieldNorm: false,
            fieldNormWeight: 1
          };
          var Config = {
            ...BasicOptions,
            ...MatchOptions,
            ...FuzzyOptions,
            ...AdvancedOptions
          };
          const SPACE = /[^ ]+/g;
          function norm(weight = 1, mantissa = 3) {
            const cache2 = new Map();
            const m = Math.pow(10, mantissa);
            return {
              get(value) {
                const numTokens = value.match(SPACE).length;
                if (cache2.has(numTokens)) {
                  return cache2.get(numTokens);
                }
                const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
                const n = parseFloat(Math.round(norm2 * m) / m);
                cache2.set(numTokens, n);
                return n;
              },
              clear() {
                cache2.clear();
              }
            };
          }
          class FuseIndex {
            constructor({
              getFn = Config.getFn,
              fieldNormWeight = Config.fieldNormWeight
            } = {}) {
              this.norm = norm(fieldNormWeight, 3);
              this.getFn = getFn;
              this.isCreated = false;
              this.setIndexRecords();
            }
            setSources(docs = []) {
              this.docs = docs;
            }
            setIndexRecords(records = []) {
              this.records = records;
            }
            setKeys(keys = []) {
              this.keys = keys;
              this._keysMap = {};
              keys.forEach((key, idx) => {
                this._keysMap[key.id] = idx;
              });
            }
            create() {
              if (this.isCreated || !this.docs.length) {
                return;
              }
              this.isCreated = true;
              if (isString3(this.docs[0])) {
                this.docs.forEach((doc, docIndex) => {
                  this._addString(doc, docIndex);
                });
              } else {
                this.docs.forEach((doc, docIndex) => {
                  this._addObject(doc, docIndex);
                });
              }
              this.norm.clear();
            }
            add(doc) {
              const idx = this.size();
              if (isString3(doc)) {
                this._addString(doc, idx);
              } else {
                this._addObject(doc, idx);
              }
            }
            removeAt(idx) {
              this.records.splice(idx, 1);
              for (let i = idx, len = this.size(); i < len; i += 1) {
                this.records[i].i -= 1;
              }
            }
            getValueForItemAtKeyId(item2, keyId) {
              return item2[this._keysMap[keyId]];
            }
            size() {
              return this.records.length;
            }
            _addString(doc, docIndex) {
              if (!isDefined4(doc) || isBlank(doc)) {
                return;
              }
              let record = {
                v: doc,
                i: docIndex,
                n: this.norm.get(doc)
              };
              this.records.push(record);
            }
            _addObject(doc, docIndex) {
              let record = {i: docIndex, $: {}};
              this.keys.forEach((key, keyIndex) => {
                let value = this.getFn(doc, key.path);
                if (!isDefined4(value)) {
                  return;
                }
                if (isArray2(value)) {
                  let subRecords = [];
                  const stack = [{nestedArrIndex: -1, value}];
                  while (stack.length) {
                    const {nestedArrIndex, value: value2} = stack.pop();
                    if (!isDefined4(value2)) {
                      continue;
                    }
                    if (isString3(value2) && !isBlank(value2)) {
                      let subRecord = {
                        v: value2,
                        i: nestedArrIndex,
                        n: this.norm.get(value2)
                      };
                      subRecords.push(subRecord);
                    } else if (isArray2(value2)) {
                      value2.forEach((item2, k) => {
                        stack.push({
                          nestedArrIndex: k,
                          value: item2
                        });
                      });
                    } else
                      ;
                  }
                  record.$[keyIndex] = subRecords;
                } else if (!isBlank(value)) {
                  let subRecord = {
                    v: value,
                    n: this.norm.get(value)
                  };
                  record.$[keyIndex] = subRecord;
                }
              });
              this.records.push(record);
            }
            toJSON() {
              return {
                keys: this.keys,
                records: this.records
              };
            }
          }
          function createIndex(keys, docs, {getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight} = {}) {
            const myIndex = new FuseIndex({getFn, fieldNormWeight});
            myIndex.setKeys(keys.map(createKey));
            myIndex.setSources(docs);
            myIndex.create();
            return myIndex;
          }
          function parseIndex(data3, {getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight} = {}) {
            const {keys, records} = data3;
            const myIndex = new FuseIndex({getFn, fieldNormWeight});
            myIndex.setKeys(keys);
            myIndex.setIndexRecords(records);
            return myIndex;
          }
          function computeScore$1(pattern, {
            errors = 0,
            currentLocation = 0,
            expectedLocation = 0,
            distance = Config.distance,
            ignoreLocation = Config.ignoreLocation
          } = {}) {
            const accuracy = errors / pattern.length;
            if (ignoreLocation) {
              return accuracy;
            }
            const proximity = Math.abs(expectedLocation - currentLocation);
            if (!distance) {
              return proximity ? 1 : accuracy;
            }
            return accuracy + proximity / distance;
          }
          function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
            let indices = [];
            let start = -1;
            let end = -1;
            let i = 0;
            for (let len = matchmask.length; i < len; i += 1) {
              let match = matchmask[i];
              if (match && start === -1) {
                start = i;
              } else if (!match && start !== -1) {
                end = i - 1;
                if (end - start + 1 >= minMatchCharLength) {
                  indices.push([start, end]);
                }
                start = -1;
              }
            }
            if (matchmask[i - 1] && i - start >= minMatchCharLength) {
              indices.push([start, i - 1]);
            }
            return indices;
          }
          const MAX_BITS = 32;
          function search(text2, pattern, patternAlphabet, {
            location: location2 = Config.location,
            distance = Config.distance,
            threshold = Config.threshold,
            findAllMatches = Config.findAllMatches,
            minMatchCharLength = Config.minMatchCharLength,
            includeMatches = Config.includeMatches,
            ignoreLocation = Config.ignoreLocation
          } = {}) {
            if (pattern.length > MAX_BITS) {
              throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
            }
            const patternLen = pattern.length;
            const textLen = text2.length;
            const expectedLocation = Math.max(0, Math.min(location2, textLen));
            let currentThreshold = threshold;
            let bestLocation = expectedLocation;
            const computeMatches = minMatchCharLength > 1 || includeMatches;
            const matchMask = computeMatches ? Array(textLen) : [];
            let index2;
            while ((index2 = text2.indexOf(pattern, bestLocation)) > -1) {
              let score = computeScore$1(pattern, {
                currentLocation: index2,
                expectedLocation,
                distance,
                ignoreLocation
              });
              currentThreshold = Math.min(score, currentThreshold);
              bestLocation = index2 + patternLen;
              if (computeMatches) {
                let i = 0;
                while (i < patternLen) {
                  matchMask[index2 + i] = 1;
                  i += 1;
                }
              }
            }
            bestLocation = -1;
            let lastBitArr = [];
            let finalScore = 1;
            let binMax = patternLen + textLen;
            const mask = 1 << patternLen - 1;
            for (let i = 0; i < patternLen; i += 1) {
              let binMin = 0;
              let binMid = binMax;
              while (binMin < binMid) {
                const score2 = computeScore$1(pattern, {
                  errors: i,
                  currentLocation: expectedLocation + binMid,
                  expectedLocation,
                  distance,
                  ignoreLocation
                });
                if (score2 <= currentThreshold) {
                  binMin = binMid;
                } else {
                  binMax = binMid;
                }
                binMid = Math.floor((binMax - binMin) / 2 + binMin);
              }
              binMax = binMid;
              let start = Math.max(1, expectedLocation - binMid + 1);
              let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
              let bitArr = Array(finish + 2);
              bitArr[finish + 1] = (1 << i) - 1;
              for (let j = finish; j >= start; j -= 1) {
                let currentLocation = j - 1;
                let charMatch = patternAlphabet[text2.charAt(currentLocation)];
                if (computeMatches) {
                  matchMask[currentLocation] = +!!charMatch;
                }
                bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
                if (i) {
                  bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
                }
                if (bitArr[j] & mask) {
                  finalScore = computeScore$1(pattern, {
                    errors: i,
                    currentLocation,
                    expectedLocation,
                    distance,
                    ignoreLocation
                  });
                  if (finalScore <= currentThreshold) {
                    currentThreshold = finalScore;
                    bestLocation = currentLocation;
                    if (bestLocation <= expectedLocation) {
                      break;
                    }
                    start = Math.max(1, 2 * expectedLocation - bestLocation);
                  }
                }
              }
              const score = computeScore$1(pattern, {
                errors: i + 1,
                currentLocation: expectedLocation,
                expectedLocation,
                distance,
                ignoreLocation
              });
              if (score > currentThreshold) {
                break;
              }
              lastBitArr = bitArr;
            }
            const result = {
              isMatch: bestLocation >= 0,
              score: Math.max(1e-3, finalScore)
            };
            if (computeMatches) {
              const indices = convertMaskToIndices(matchMask, minMatchCharLength);
              if (!indices.length) {
                result.isMatch = false;
              } else if (includeMatches) {
                result.indices = indices;
              }
            }
            return result;
          }
          function createPatternAlphabet(pattern) {
            let mask = {};
            for (let i = 0, len = pattern.length; i < len; i += 1) {
              const char = pattern.charAt(i);
              mask[char] = (mask[char] || 0) | 1 << len - i - 1;
            }
            return mask;
          }
          class BitapSearch {
            constructor(pattern, {
              location: location2 = Config.location,
              threshold = Config.threshold,
              distance = Config.distance,
              includeMatches = Config.includeMatches,
              findAllMatches = Config.findAllMatches,
              minMatchCharLength = Config.minMatchCharLength,
              isCaseSensitive = Config.isCaseSensitive,
              ignoreLocation = Config.ignoreLocation
            } = {}) {
              this.options = {
                location: location2,
                threshold,
                distance,
                includeMatches,
                findAllMatches,
                minMatchCharLength,
                isCaseSensitive,
                ignoreLocation
              };
              this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
              this.chunks = [];
              if (!this.pattern.length) {
                return;
              }
              const addChunk = (pattern2, startIndex) => {
                this.chunks.push({
                  pattern: pattern2,
                  alphabet: createPatternAlphabet(pattern2),
                  startIndex
                });
              };
              const len = this.pattern.length;
              if (len > MAX_BITS) {
                let i = 0;
                const remainder = len % MAX_BITS;
                const end = len - remainder;
                while (i < end) {
                  addChunk(this.pattern.substr(i, MAX_BITS), i);
                  i += MAX_BITS;
                }
                if (remainder) {
                  const startIndex = len - MAX_BITS;
                  addChunk(this.pattern.substr(startIndex), startIndex);
                }
              } else {
                addChunk(this.pattern, 0);
              }
            }
            searchIn(text2) {
              const {isCaseSensitive, includeMatches} = this.options;
              if (!isCaseSensitive) {
                text2 = text2.toLowerCase();
              }
              if (this.pattern === text2) {
                let result2 = {
                  isMatch: true,
                  score: 0
                };
                if (includeMatches) {
                  result2.indices = [[0, text2.length - 1]];
                }
                return result2;
              }
              const {
                location: location2,
                distance,
                threshold,
                findAllMatches,
                minMatchCharLength,
                ignoreLocation
              } = this.options;
              let allIndices = [];
              let totalScore = 0;
              let hasMatches = false;
              this.chunks.forEach(({pattern, alphabet, startIndex}) => {
                const {isMatch, score, indices} = search(text2, pattern, alphabet, {
                  location: location2 + startIndex,
                  distance,
                  threshold,
                  findAllMatches,
                  minMatchCharLength,
                  includeMatches,
                  ignoreLocation
                });
                if (isMatch) {
                  hasMatches = true;
                }
                totalScore += score;
                if (isMatch && indices) {
                  allIndices = [...allIndices, ...indices];
                }
              });
              let result = {
                isMatch: hasMatches,
                score: hasMatches ? totalScore / this.chunks.length : 1
              };
              if (hasMatches && includeMatches) {
                result.indices = allIndices;
              }
              return result;
            }
          }
          class BaseMatch {
            constructor(pattern) {
              this.pattern = pattern;
            }
            static isMultiMatch(pattern) {
              return getMatch(pattern, this.multiRegex);
            }
            static isSingleMatch(pattern) {
              return getMatch(pattern, this.singleRegex);
            }
            search() {
            }
          }
          function getMatch(pattern, exp) {
            const matches2 = pattern.match(exp);
            return matches2 ? matches2[1] : null;
          }
          class ExactMatch extends BaseMatch {
            constructor(pattern) {
              super(pattern);
            }
            static get type() {
              return "exact";
            }
            static get multiRegex() {
              return /^="(.*)"$/;
            }
            static get singleRegex() {
              return /^=(.*)$/;
            }
            search(text2) {
              const isMatch = text2 === this.pattern;
              return {
                isMatch,
                score: isMatch ? 0 : 1,
                indices: [0, this.pattern.length - 1]
              };
            }
          }
          class InverseExactMatch extends BaseMatch {
            constructor(pattern) {
              super(pattern);
            }
            static get type() {
              return "inverse-exact";
            }
            static get multiRegex() {
              return /^!"(.*)"$/;
            }
            static get singleRegex() {
              return /^!(.*)$/;
            }
            search(text2) {
              const index2 = text2.indexOf(this.pattern);
              const isMatch = index2 === -1;
              return {
                isMatch,
                score: isMatch ? 0 : 1,
                indices: [0, text2.length - 1]
              };
            }
          }
          class PrefixExactMatch extends BaseMatch {
            constructor(pattern) {
              super(pattern);
            }
            static get type() {
              return "prefix-exact";
            }
            static get multiRegex() {
              return /^\^"(.*)"$/;
            }
            static get singleRegex() {
              return /^\^(.*)$/;
            }
            search(text2) {
              const isMatch = text2.startsWith(this.pattern);
              return {
                isMatch,
                score: isMatch ? 0 : 1,
                indices: [0, this.pattern.length - 1]
              };
            }
          }
          class InversePrefixExactMatch extends BaseMatch {
            constructor(pattern) {
              super(pattern);
            }
            static get type() {
              return "inverse-prefix-exact";
            }
            static get multiRegex() {
              return /^!\^"(.*)"$/;
            }
            static get singleRegex() {
              return /^!\^(.*)$/;
            }
            search(text2) {
              const isMatch = !text2.startsWith(this.pattern);
              return {
                isMatch,
                score: isMatch ? 0 : 1,
                indices: [0, text2.length - 1]
              };
            }
          }
          class SuffixExactMatch extends BaseMatch {
            constructor(pattern) {
              super(pattern);
            }
            static get type() {
              return "suffix-exact";
            }
            static get multiRegex() {
              return /^"(.*)"\$$/;
            }
            static get singleRegex() {
              return /^(.*)\$$/;
            }
            search(text2) {
              const isMatch = text2.endsWith(this.pattern);
              return {
                isMatch,
                score: isMatch ? 0 : 1,
                indices: [text2.length - this.pattern.length, text2.length - 1]
              };
            }
          }
          class InverseSuffixExactMatch extends BaseMatch {
            constructor(pattern) {
              super(pattern);
            }
            static get type() {
              return "inverse-suffix-exact";
            }
            static get multiRegex() {
              return /^!"(.*)"\$$/;
            }
            static get singleRegex() {
              return /^!(.*)\$$/;
            }
            search(text2) {
              const isMatch = !text2.endsWith(this.pattern);
              return {
                isMatch,
                score: isMatch ? 0 : 1,
                indices: [0, text2.length - 1]
              };
            }
          }
          class FuzzyMatch extends BaseMatch {
            constructor(pattern, {
              location: location2 = Config.location,
              threshold = Config.threshold,
              distance = Config.distance,
              includeMatches = Config.includeMatches,
              findAllMatches = Config.findAllMatches,
              minMatchCharLength = Config.minMatchCharLength,
              isCaseSensitive = Config.isCaseSensitive,
              ignoreLocation = Config.ignoreLocation
            } = {}) {
              super(pattern);
              this._bitapSearch = new BitapSearch(pattern, {
                location: location2,
                threshold,
                distance,
                includeMatches,
                findAllMatches,
                minMatchCharLength,
                isCaseSensitive,
                ignoreLocation
              });
            }
            static get type() {
              return "fuzzy";
            }
            static get multiRegex() {
              return /^"(.*)"$/;
            }
            static get singleRegex() {
              return /^(.*)$/;
            }
            search(text2) {
              return this._bitapSearch.searchIn(text2);
            }
          }
          class IncludeMatch extends BaseMatch {
            constructor(pattern) {
              super(pattern);
            }
            static get type() {
              return "include";
            }
            static get multiRegex() {
              return /^'"(.*)"$/;
            }
            static get singleRegex() {
              return /^'(.*)$/;
            }
            search(text2) {
              let location2 = 0;
              let index2;
              const indices = [];
              const patternLen = this.pattern.length;
              while ((index2 = text2.indexOf(this.pattern, location2)) > -1) {
                location2 = index2 + patternLen;
                indices.push([index2, location2 - 1]);
              }
              const isMatch = !!indices.length;
              return {
                isMatch,
                score: isMatch ? 0 : 1,
                indices
              };
            }
          }
          const searchers = [
            ExactMatch,
            IncludeMatch,
            PrefixExactMatch,
            InversePrefixExactMatch,
            InverseSuffixExactMatch,
            SuffixExactMatch,
            InverseExactMatch,
            FuzzyMatch
          ];
          const searchersLen = searchers.length;
          const SPACE_RE = / +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/;
          const OR_TOKEN = "|";
          function parseQuery(pattern, options = {}) {
            return pattern.split(OR_TOKEN).map((item2) => {
              let query = item2.trim().split(SPACE_RE).filter((item3) => item3 && !!item3.trim());
              let results = [];
              for (let i = 0, len = query.length; i < len; i += 1) {
                const queryItem = query[i];
                let found = false;
                let idx = -1;
                while (!found && ++idx < searchersLen) {
                  const searcher = searchers[idx];
                  let token = searcher.isMultiMatch(queryItem);
                  if (token) {
                    results.push(new searcher(token, options));
                    found = true;
                  }
                }
                if (found) {
                  continue;
                }
                idx = -1;
                while (++idx < searchersLen) {
                  const searcher = searchers[idx];
                  let token = searcher.isSingleMatch(queryItem);
                  if (token) {
                    results.push(new searcher(token, options));
                    break;
                  }
                }
              }
              return results;
            });
          }
          const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);
          class ExtendedSearch {
            constructor(pattern, {
              isCaseSensitive = Config.isCaseSensitive,
              includeMatches = Config.includeMatches,
              minMatchCharLength = Config.minMatchCharLength,
              ignoreLocation = Config.ignoreLocation,
              findAllMatches = Config.findAllMatches,
              location: location2 = Config.location,
              threshold = Config.threshold,
              distance = Config.distance
            } = {}) {
              this.query = null;
              this.options = {
                isCaseSensitive,
                includeMatches,
                minMatchCharLength,
                findAllMatches,
                ignoreLocation,
                location: location2,
                threshold,
                distance
              };
              this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
              this.query = parseQuery(this.pattern, this.options);
            }
            static condition(_, options) {
              return options.useExtendedSearch;
            }
            searchIn(text2) {
              const query = this.query;
              if (!query) {
                return {
                  isMatch: false,
                  score: 1
                };
              }
              const {includeMatches, isCaseSensitive} = this.options;
              text2 = isCaseSensitive ? text2 : text2.toLowerCase();
              let numMatches = 0;
              let allIndices = [];
              let totalScore = 0;
              for (let i = 0, qLen = query.length; i < qLen; i += 1) {
                const searchers2 = query[i];
                allIndices.length = 0;
                numMatches = 0;
                for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
                  const searcher = searchers2[j];
                  const {isMatch, indices, score} = searcher.search(text2);
                  if (isMatch) {
                    numMatches += 1;
                    totalScore += score;
                    if (includeMatches) {
                      const type = searcher.constructor.type;
                      if (MultiMatchSet.has(type)) {
                        allIndices = [...allIndices, ...indices];
                      } else {
                        allIndices.push(indices);
                      }
                    }
                  } else {
                    totalScore = 0;
                    numMatches = 0;
                    allIndices.length = 0;
                    break;
                  }
                }
                if (numMatches) {
                  let result = {
                    isMatch: true,
                    score: totalScore / numMatches
                  };
                  if (includeMatches) {
                    result.indices = allIndices;
                  }
                  return result;
                }
              }
              return {
                isMatch: false,
                score: 1
              };
            }
          }
          const registeredSearchers = [];
          function register(...args) {
            registeredSearchers.push(...args);
          }
          function createSearcher(pattern, options) {
            for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
              let searcherClass = registeredSearchers[i];
              if (searcherClass.condition(pattern, options)) {
                return new searcherClass(pattern, options);
              }
            }
            return new BitapSearch(pattern, options);
          }
          const LogicalOperator = {
            AND: "$and",
            OR: "$or"
          };
          const KeyType = {
            PATH: "$path",
            PATTERN: "$val"
          };
          const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
          const isPath = (query) => !!query[KeyType.PATH];
          const isLeaf = (query) => !isArray2(query) && isObject2(query) && !isExpression(query);
          const convertToExplicit = (query) => ({
            [LogicalOperator.AND]: Object.keys(query).map((key) => ({
              [key]: query[key]
            }))
          });
          function parse4(query, options, {auto = true} = {}) {
            const next = (query2) => {
              let keys = Object.keys(query2);
              const isQueryPath = isPath(query2);
              if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
                return next(convertToExplicit(query2));
              }
              if (isLeaf(query2)) {
                const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
                const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
                if (!isString3(pattern)) {
                  throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
                }
                const obj = {
                  keyId: createKeyId(key),
                  pattern
                };
                if (auto) {
                  obj.searcher = createSearcher(pattern, options);
                }
                return obj;
              }
              let node = {
                children: [],
                operator: keys[0]
              };
              keys.forEach((key) => {
                const value = query2[key];
                if (isArray2(value)) {
                  value.forEach((item2) => {
                    node.children.push(next(item2));
                  });
                }
              });
              return node;
            };
            if (!isExpression(query)) {
              query = convertToExplicit(query);
            }
            return next(query);
          }
          function computeScore(results, {ignoreFieldNorm = Config.ignoreFieldNorm}) {
            results.forEach((result) => {
              let totalScore = 1;
              result.matches.forEach(({key, norm: norm2, score}) => {
                const weight = key ? key.weight : null;
                totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm2));
              });
              result.score = totalScore;
            });
          }
          function transformMatches(result, data3) {
            const matches2 = result.matches;
            data3.matches = [];
            if (!isDefined4(matches2)) {
              return;
            }
            matches2.forEach((match) => {
              if (!isDefined4(match.indices) || !match.indices.length) {
                return;
              }
              const {indices, value} = match;
              let obj = {
                indices,
                value
              };
              if (match.key) {
                obj.key = match.key.src;
              }
              if (match.idx > -1) {
                obj.refIndex = match.idx;
              }
              data3.matches.push(obj);
            });
          }
          function transformScore(result, data3) {
            data3.score = result.score;
          }
          function format4(results, docs, {
            includeMatches = Config.includeMatches,
            includeScore = Config.includeScore
          } = {}) {
            const transformers = [];
            if (includeMatches)
              transformers.push(transformMatches);
            if (includeScore)
              transformers.push(transformScore);
            return results.map((result) => {
              const {idx} = result;
              const data3 = {
                item: docs[idx],
                refIndex: idx
              };
              if (transformers.length) {
                transformers.forEach((transformer) => {
                  transformer(result, data3);
                });
              }
              return data3;
            });
          }
          class Fuse {
            constructor(docs, options = {}, index2) {
              this.options = {...Config, ...options};
              if (this.options.useExtendedSearch && false) {
              }
              this._keyStore = new KeyStore(this.options.keys);
              this.setCollection(docs, index2);
            }
            setCollection(docs, index2) {
              this._docs = docs;
              if (index2 && !(index2 instanceof FuseIndex)) {
                throw new Error(INCORRECT_INDEX_TYPE);
              }
              this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
                getFn: this.options.getFn,
                fieldNormWeight: this.options.fieldNormWeight
              });
            }
            add(doc) {
              if (!isDefined4(doc)) {
                return;
              }
              this._docs.push(doc);
              this._myIndex.add(doc);
            }
            remove(predicate = () => false) {
              const results = [];
              for (let i = 0, len = this._docs.length; i < len; i += 1) {
                const doc = this._docs[i];
                if (predicate(doc, i)) {
                  this.removeAt(i);
                  i -= 1;
                  len -= 1;
                  results.push(doc);
                }
              }
              return results;
            }
            removeAt(idx) {
              this._docs.splice(idx, 1);
              this._myIndex.removeAt(idx);
            }
            getIndex() {
              return this._myIndex;
            }
            search(query, {limit: limit2 = -1} = {}) {
              const {
                includeMatches,
                includeScore,
                shouldSort,
                sortFn,
                ignoreFieldNorm
              } = this.options;
              let results = isString3(query) ? isString3(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
              computeScore(results, {ignoreFieldNorm});
              if (shouldSort) {
                results.sort(sortFn);
              }
              if (isNumber2(limit2) && limit2 > -1) {
                results = results.slice(0, limit2);
              }
              return format4(results, this._docs, {
                includeMatches,
                includeScore
              });
            }
            _searchStringList(query) {
              const searcher = createSearcher(query, this.options);
              const {records} = this._myIndex;
              const results = [];
              records.forEach(({v: text2, i: idx, n: norm2}) => {
                if (!isDefined4(text2)) {
                  return;
                }
                const {isMatch, score, indices} = searcher.searchIn(text2);
                if (isMatch) {
                  results.push({
                    item: text2,
                    idx,
                    matches: [{score, value: text2, norm: norm2, indices}]
                  });
                }
              });
              return results;
            }
            _searchLogical(query) {
              const expression = parse4(query, this.options);
              const evaluate = (node, item2, idx) => {
                if (!node.children) {
                  const {keyId, searcher} = node;
                  const matches2 = this._findMatches({
                    key: this._keyStore.get(keyId),
                    value: this._myIndex.getValueForItemAtKeyId(item2, keyId),
                    searcher
                  });
                  if (matches2 && matches2.length) {
                    return [
                      {
                        idx,
                        item: item2,
                        matches: matches2
                      }
                    ];
                  }
                  return [];
                }
                const res2 = [];
                for (let i = 0, len = node.children.length; i < len; i += 1) {
                  const child = node.children[i];
                  const result = evaluate(child, item2, idx);
                  if (result.length) {
                    res2.push(...result);
                  } else if (node.operator === LogicalOperator.AND) {
                    return [];
                  }
                }
                return res2;
              };
              const records = this._myIndex.records;
              const resultMap = {};
              const results = [];
              records.forEach(({$: item2, i: idx}) => {
                if (isDefined4(item2)) {
                  let expResults = evaluate(expression, item2, idx);
                  if (expResults.length) {
                    if (!resultMap[idx]) {
                      resultMap[idx] = {idx, item: item2, matches: []};
                      results.push(resultMap[idx]);
                    }
                    expResults.forEach(({matches: matches2}) => {
                      resultMap[idx].matches.push(...matches2);
                    });
                  }
                }
              });
              return results;
            }
            _searchObjectList(query) {
              const searcher = createSearcher(query, this.options);
              const {keys, records} = this._myIndex;
              const results = [];
              records.forEach(({$: item2, i: idx}) => {
                if (!isDefined4(item2)) {
                  return;
                }
                let matches2 = [];
                keys.forEach((key, keyIndex) => {
                  matches2.push(...this._findMatches({
                    key,
                    value: item2[keyIndex],
                    searcher
                  }));
                });
                if (matches2.length) {
                  results.push({
                    idx,
                    item: item2,
                    matches: matches2
                  });
                }
              });
              return results;
            }
            _findMatches({key, value, searcher}) {
              if (!isDefined4(value)) {
                return [];
              }
              let matches2 = [];
              if (isArray2(value)) {
                value.forEach(({v: text2, i: idx, n: norm2}) => {
                  if (!isDefined4(text2)) {
                    return;
                  }
                  const {isMatch, score, indices} = searcher.searchIn(text2);
                  if (isMatch) {
                    matches2.push({
                      score,
                      key,
                      value: text2,
                      idx,
                      norm: norm2,
                      indices
                    });
                  }
                });
              } else {
                const {v: text2, n: norm2} = value;
                const {isMatch, score, indices} = searcher.searchIn(text2);
                if (isMatch) {
                  matches2.push({score, key, value: text2, norm: norm2, indices});
                }
              }
              return matches2;
            }
          }
          Fuse.version = "6.5.3";
          Fuse.createIndex = createIndex;
          Fuse.parseIndex = parseIndex;
          Fuse.config = Config;
          {
            Fuse.parseQuery = parse4;
          }
          {
            register(ExtendedSearch);
          }
        },
        857: function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
          __webpack_require__2.r(__webpack_exports__2);
          __webpack_require__2.d(__webpack_exports__2, {
            __DO_NOT_USE__ActionTypes: function() {
              return ActionTypes;
            },
            applyMiddleware: function() {
              return applyMiddleware;
            },
            bindActionCreators: function() {
              return bindActionCreators;
            },
            combineReducers: function() {
              return combineReducers;
            },
            compose: function() {
              return compose;
            },
            createStore: function() {
              return createStore2;
            }
          });
          ;
          function _defineProperty3(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          ;
          function ownKeys2(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              enumerableOnly && (symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              })), keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread22(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
                _defineProperty3(target, key, source[key]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
            return target;
          }
          ;
          function formatProdErrorMessage(code) {
            return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
          }
          var $$observable = function() {
            return typeof Symbol === "function" && Symbol.observable || "@@observable";
          }();
          var randomString = function randomString2() {
            return Math.random().toString(36).substring(7).split("").join(".");
          };
          var ActionTypes = {
            INIT: "@@redux/INIT" + randomString(),
            REPLACE: "@@redux/REPLACE" + randomString(),
            PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
              return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
            }
          };
          function isPlainObject(obj) {
            if (typeof obj !== "object" || obj === null)
              return false;
            var proto2 = obj;
            while (Object.getPrototypeOf(proto2) !== null) {
              proto2 = Object.getPrototypeOf(proto2);
            }
            return Object.getPrototypeOf(obj) === proto2;
          }
          function miniKindOf(val) {
            if (val === void 0)
              return "undefined";
            if (val === null)
              return "null";
            var type = typeof val;
            switch (type) {
              case "boolean":
              case "string":
              case "number":
              case "symbol":
              case "function": {
                return type;
              }
            }
            if (Array.isArray(val))
              return "array";
            if (isDate(val))
              return "date";
            if (isError(val))
              return "error";
            var constructorName = ctorName(val);
            switch (constructorName) {
              case "Symbol":
              case "Promise":
              case "WeakMap":
              case "WeakSet":
              case "Map":
              case "Set":
                return constructorName;
            }
            return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
          }
          function ctorName(val) {
            return typeof val.constructor === "function" ? val.constructor.name : null;
          }
          function isError(val) {
            return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
          }
          function isDate(val) {
            if (val instanceof Date)
              return true;
            return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
          }
          function kindOf(val) {
            var typeOfVal = typeof val;
            if (false) {
            }
            return typeOfVal;
          }
          function createStore2(reducer, preloadedState, enhancer) {
            var _ref2;
            if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
              throw new Error(true ? formatProdErrorMessage(0) : 0);
            }
            if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
              enhancer = preloadedState;
              preloadedState = void 0;
            }
            if (typeof enhancer !== "undefined") {
              if (typeof enhancer !== "function") {
                throw new Error(true ? formatProdErrorMessage(1) : 0);
              }
              return enhancer(createStore2)(reducer, preloadedState);
            }
            if (typeof reducer !== "function") {
              throw new Error(true ? formatProdErrorMessage(2) : 0);
            }
            var currentReducer = reducer;
            var currentState = preloadedState;
            var currentListeners = [];
            var nextListeners = currentListeners;
            var isDispatching = false;
            function ensureCanMutateNextListeners() {
              if (nextListeners === currentListeners) {
                nextListeners = currentListeners.slice();
              }
            }
            function getState() {
              if (isDispatching) {
                throw new Error(true ? formatProdErrorMessage(3) : 0);
              }
              return currentState;
            }
            function subscribe(listener) {
              if (typeof listener !== "function") {
                throw new Error(true ? formatProdErrorMessage(4) : 0);
              }
              if (isDispatching) {
                throw new Error(true ? formatProdErrorMessage(5) : 0);
              }
              var isSubscribed = true;
              ensureCanMutateNextListeners();
              nextListeners.push(listener);
              return function unsubscribe() {
                if (!isSubscribed) {
                  return;
                }
                if (isDispatching) {
                  throw new Error(true ? formatProdErrorMessage(6) : 0);
                }
                isSubscribed = false;
                ensureCanMutateNextListeners();
                var index2 = nextListeners.indexOf(listener);
                nextListeners.splice(index2, 1);
                currentListeners = null;
              };
            }
            function dispatch2(action) {
              if (!isPlainObject(action)) {
                throw new Error(true ? formatProdErrorMessage(7) : 0);
              }
              if (typeof action.type === "undefined") {
                throw new Error(true ? formatProdErrorMessage(8) : 0);
              }
              if (isDispatching) {
                throw new Error(true ? formatProdErrorMessage(9) : 0);
              }
              try {
                isDispatching = true;
                currentState = currentReducer(currentState, action);
              } finally {
                isDispatching = false;
              }
              var listeners2 = currentListeners = nextListeners;
              for (var i = 0; i < listeners2.length; i++) {
                var listener = listeners2[i];
                listener();
              }
              return action;
            }
            function replaceReducer(nextReducer) {
              if (typeof nextReducer !== "function") {
                throw new Error(true ? formatProdErrorMessage(10) : 0);
              }
              currentReducer = nextReducer;
              dispatch2({
                type: ActionTypes.REPLACE
              });
            }
            function observable() {
              var _ref;
              var outerSubscribe = subscribe;
              return _ref = {
                subscribe: function subscribe2(observer) {
                  if (typeof observer !== "object" || observer === null) {
                    throw new Error(true ? formatProdErrorMessage(11) : 0);
                  }
                  function observeState() {
                    if (observer.next) {
                      observer.next(getState());
                    }
                  }
                  observeState();
                  var unsubscribe = outerSubscribe(observeState);
                  return {
                    unsubscribe
                  };
                }
              }, _ref[$$observable] = function() {
                return this;
              }, _ref;
            }
            dispatch2({
              type: ActionTypes.INIT
            });
            return _ref2 = {
              dispatch: dispatch2,
              subscribe,
              getState,
              replaceReducer
            }, _ref2[$$observable] = observable, _ref2;
          }
          function warning(message) {
            if (typeof console !== "undefined" && typeof console.error === "function") {
              console.error(message);
            }
            try {
              throw new Error(message);
            } catch (e) {
            }
          }
          function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
            var reducerKeys = Object.keys(reducers);
            var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
            if (reducerKeys.length === 0) {
              return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
            }
            if (!isPlainObject(inputState)) {
              return "The " + argumentName + ' has unexpected type of "' + kindOf(inputState) + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
            }
            var unexpectedKeys = Object.keys(inputState).filter(function(key) {
              return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
            });
            unexpectedKeys.forEach(function(key) {
              unexpectedKeyCache[key] = true;
            });
            if (action && action.type === ActionTypes.REPLACE)
              return;
            if (unexpectedKeys.length > 0) {
              return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
            }
          }
          function assertReducerShape(reducers) {
            Object.keys(reducers).forEach(function(key) {
              var reducer = reducers[key];
              var initialState = reducer(void 0, {
                type: ActionTypes.INIT
              });
              if (typeof initialState === "undefined") {
                throw new Error(true ? formatProdErrorMessage(12) : 0);
              }
              if (typeof reducer(void 0, {
                type: ActionTypes.PROBE_UNKNOWN_ACTION()
              }) === "undefined") {
                throw new Error(true ? formatProdErrorMessage(13) : 0);
              }
            });
          }
          function combineReducers(reducers) {
            var reducerKeys = Object.keys(reducers);
            var finalReducers = {};
            for (var i = 0; i < reducerKeys.length; i++) {
              var key = reducerKeys[i];
              if (false) {
              }
              if (typeof reducers[key] === "function") {
                finalReducers[key] = reducers[key];
              }
            }
            var finalReducerKeys = Object.keys(finalReducers);
            var unexpectedKeyCache;
            if (false) {
            }
            var shapeAssertionError;
            try {
              assertReducerShape(finalReducers);
            } catch (e) {
              shapeAssertionError = e;
            }
            return function combination(state2, action) {
              if (state2 === void 0) {
                state2 = {};
              }
              if (shapeAssertionError) {
                throw shapeAssertionError;
              }
              if (false) {
                var warningMessage;
              }
              var hasChanged = false;
              var nextState = {};
              for (var _i = 0; _i < finalReducerKeys.length; _i++) {
                var _key = finalReducerKeys[_i];
                var reducer = finalReducers[_key];
                var previousStateForKey = state2[_key];
                var nextStateForKey = reducer(previousStateForKey, action);
                if (typeof nextStateForKey === "undefined") {
                  var actionType = action && action.type;
                  throw new Error(true ? formatProdErrorMessage(14) : 0);
                }
                nextState[_key] = nextStateForKey;
                hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
              }
              hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state2).length;
              return hasChanged ? nextState : state2;
            };
          }
          function bindActionCreator(actionCreator, dispatch2) {
            return function() {
              return dispatch2(actionCreator.apply(this, arguments));
            };
          }
          function bindActionCreators(actionCreators, dispatch2) {
            if (typeof actionCreators === "function") {
              return bindActionCreator(actionCreators, dispatch2);
            }
            if (typeof actionCreators !== "object" || actionCreators === null) {
              throw new Error(true ? formatProdErrorMessage(16) : 0);
            }
            var boundActionCreators = {};
            for (var key in actionCreators) {
              var actionCreator = actionCreators[key];
              if (typeof actionCreator === "function") {
                boundActionCreators[key] = bindActionCreator(actionCreator, dispatch2);
              }
            }
            return boundActionCreators;
          }
          function compose() {
            for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
              funcs[_key] = arguments[_key];
            }
            if (funcs.length === 0) {
              return function(arg) {
                return arg;
              };
            }
            if (funcs.length === 1) {
              return funcs[0];
            }
            return funcs.reduce(function(a, b) {
              return function() {
                return a(b.apply(void 0, arguments));
              };
            });
          }
          function applyMiddleware() {
            for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
              middlewares[_key] = arguments[_key];
            }
            return function(createStore3) {
              return function() {
                var store = createStore3.apply(void 0, arguments);
                var _dispatch = function dispatch2() {
                  throw new Error(true ? formatProdErrorMessage(15) : 0);
                };
                var middlewareAPI = {
                  getState: store.getState,
                  dispatch: function dispatch2() {
                    return _dispatch.apply(void 0, arguments);
                  }
                };
                var chain2 = middlewares.map(function(middleware) {
                  return middleware(middlewareAPI);
                });
                _dispatch = compose.apply(void 0, chain2)(store.dispatch);
                return _objectSpread22(_objectSpread22({}, store), {}, {
                  dispatch: _dispatch
                });
              };
            };
          }
          function isCrushed() {
          }
          if (false) {
          }
        }
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          exports: {}
        };
        __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      !function() {
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function() {
            return module2["default"];
          } : function() {
            return module2;
          };
          __webpack_require__.d(getter, {a: getter});
          return getter;
        };
      }();
      !function() {
        __webpack_require__.d = function(exports2, definition) {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, {enumerable: true, get: definition[key]});
            }
          }
        };
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      !function() {
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, {value: "Module"});
          }
          Object.defineProperty(exports2, "__esModule", {value: true});
        };
      }();
      var __webpack_exports__ = {};
      !function() {
        var _scripts_choices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(373);
        var _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__.n(_scripts_choices__WEBPACK_IMPORTED_MODULE_0__);
        var _scripts_interfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(187);
        var _scripts_interfaces__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__.n(_scripts_interfaces__WEBPACK_IMPORTED_MODULE_1__);
        var _scripts_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(883);
        var _scripts_defaults__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(789);
        var _scripts_templates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(686);
        __webpack_exports__["default"] = _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default();
      }();
      __webpack_exports__ = __webpack_exports__["default"];
      return __webpack_exports__;
    }();
  });
});

// node_modules/vanilla-colorful/lib/utils/math.js
var clamp = (number, min = 0, max = 1) => {
  return number > max ? max : number < min ? min : number;
};
var round = (number, digits = 0, base = Math.pow(10, digits)) => {
  return Math.round(base * number) / base;
};

// node_modules/vanilla-colorful/lib/utils/convert.js
var angleUnits = {
  grad: 360 / 400,
  turn: 360,
  rad: 360 / (Math.PI * 2)
};
var hexToHsva = (hex) => rgbaToHsva(hexToRgba(hex));
var hexToRgba = (hex) => {
  if (hex[0] === "#")
    hex = hex.substr(1);
  if (hex.length < 6) {
    return {
      r: parseInt(hex[0] + hex[0], 16),
      g: parseInt(hex[1] + hex[1], 16),
      b: parseInt(hex[2] + hex[2], 16),
      a: 1
    };
  }
  return {
    r: parseInt(hex.substr(0, 2), 16),
    g: parseInt(hex.substr(2, 2), 16),
    b: parseInt(hex.substr(4, 2), 16),
    a: 1
  };
};
var parseHue = (value, unit = "deg") => {
  return Number(value) * (angleUnits[unit] || 1);
};
var hslaStringToHsva = (hslString) => {
  const matcher = /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
  const match = matcher.exec(hslString);
  if (!match)
    return {h: 0, s: 0, v: 0, a: 1};
  return hslaToHsva({
    h: parseHue(match[1], match[2]),
    s: Number(match[3]),
    l: Number(match[4]),
    a: match[5] === void 0 ? 1 : Number(match[5]) / (match[6] ? 100 : 1)
  });
};
var hslStringToHsva = hslaStringToHsva;
var hslaToHsva = ({h, s, l, a}) => {
  s *= (l < 50 ? l : 100 - l) / 100;
  return {
    h,
    s: s > 0 ? 2 * s / (l + s) * 100 : 0,
    v: l + s,
    a
  };
};
var hsvaToHex = (hsva) => rgbaToHex(hsvaToRgba(hsva));
var hsvaToHsla = ({h, s, v, a}) => {
  const hh = (200 - s) * v / 100;
  return {
    h: round(h),
    s: round(hh > 0 && hh < 200 ? s * v / 100 / (hh <= 100 ? hh : 200 - hh) * 100 : 0),
    l: round(hh / 2),
    a: round(a, 2)
  };
};
var hsvaToHslString = (hsva) => {
  const {h, s, l} = hsvaToHsla(hsva);
  return `hsl(${h}, ${s}%, ${l}%)`;
};
var hsvaToHslaString = (hsva) => {
  const {h, s, l, a} = hsvaToHsla(hsva);
  return `hsla(${h}, ${s}%, ${l}%, ${a})`;
};
var hsvaToRgba = ({h, s, v, a}) => {
  h = h / 360 * 6;
  s = s / 100;
  v = v / 100;
  const hh = Math.floor(h), b = v * (1 - s), c = v * (1 - (h - hh) * s), d = v * (1 - (1 - h + hh) * s), module = hh % 6;
  return {
    r: round([v, c, b, b, d, v][module] * 255),
    g: round([d, v, v, c, b, b][module] * 255),
    b: round([b, b, d, v, v, c][module] * 255),
    a: round(a, 2)
  };
};
var hsvaToRgbString = (hsva) => {
  const {r, g, b} = hsvaToRgba(hsva);
  return `rgb(${r}, ${g}, ${b})`;
};
var hsvaToRgbaString = (hsva) => {
  const {r, g, b, a} = hsvaToRgba(hsva);
  return `rgba(${r}, ${g}, ${b}, ${a})`;
};
var rgbaStringToHsva = (rgbaString) => {
  const matcher = /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
  const match = matcher.exec(rgbaString);
  if (!match)
    return {h: 0, s: 0, v: 0, a: 1};
  return rgbaToHsva({
    r: Number(match[1]) / (match[2] ? 100 / 255 : 1),
    g: Number(match[3]) / (match[4] ? 100 / 255 : 1),
    b: Number(match[5]) / (match[6] ? 100 / 255 : 1),
    a: match[7] === void 0 ? 1 : Number(match[7]) / (match[8] ? 100 : 1)
  });
};
var rgbStringToHsva = rgbaStringToHsva;
var format = (number) => {
  const hex = number.toString(16);
  return hex.length < 2 ? "0" + hex : hex;
};
var rgbaToHex = ({r, g, b}) => {
  return "#" + format(r) + format(g) + format(b);
};
var rgbaToHsva = ({r, g, b, a}) => {
  const max = Math.max(r, g, b);
  const delta = max - Math.min(r, g, b);
  const hh = delta ? max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta : 0;
  return {
    h: round(60 * (hh < 0 ? hh + 6 : hh)),
    s: round(max ? delta / max * 100 : 0),
    v: round(max / 255 * 100),
    a
  };
};

// node_modules/vanilla-colorful/lib/utils/compare.js
var equalColorObjects = (first, second) => {
  if (first === second)
    return true;
  for (const prop in first) {
    if (first[prop] !== second[prop])
      return false;
  }
  return true;
};
var equalColorString = (first, second) => {
  return first.replace(/\s/g, "") === second.replace(/\s/g, "");
};
var equalHex = (first, second) => {
  if (first.toLowerCase() === second.toLowerCase())
    return true;
  return equalColorObjects(hexToRgba(first), hexToRgba(second));
};

// node_modules/vanilla-colorful/lib/utils/dom.js
var cache = {};
var tpl = (html) => {
  let template = cache[html];
  if (!template) {
    template = document.createElement("template");
    template.innerHTML = html;
    cache[html] = template;
  }
  return template;
};
var fire = (target, type, detail) => {
  target.dispatchEvent(new CustomEvent(type, {
    bubbles: true,
    detail
  }));
};

// node_modules/vanilla-colorful/lib/components/slider.js
var hasTouched = false;
var isTouch = (e) => "touches" in e;
var isValid = (event) => {
  if (hasTouched && !isTouch(event))
    return false;
  if (!hasTouched)
    hasTouched = isTouch(event);
  return true;
};
var pointerMove = (target, event) => {
  const pointer = isTouch(event) ? event.touches[0] : event;
  const rect = target.el.getBoundingClientRect();
  fire(target.el, "move", target.getMove({
    x: clamp((pointer.pageX - (rect.left + window.pageXOffset)) / rect.width),
    y: clamp((pointer.pageY - (rect.top + window.pageYOffset)) / rect.height)
  }));
};
var keyMove = (target, event) => {
  const keyCode = event.keyCode;
  if (keyCode > 40 || target.xy && keyCode < 37 || keyCode < 33)
    return;
  event.preventDefault();
  fire(target.el, "move", target.getMove({
    x: keyCode === 39 ? 0.01 : keyCode === 37 ? -0.01 : keyCode === 34 ? 0.05 : keyCode === 33 ? -0.05 : keyCode === 35 ? 1 : keyCode === 36 ? -1 : 0,
    y: keyCode === 40 ? 0.01 : keyCode === 38 ? -0.01 : 0
  }, true));
};
var Slider = class {
  constructor(root2, part, aria, xy) {
    const template = tpl(`<div role="slider" tabindex="0" part="${part}" ${aria}><div part="${part}-pointer"></div></div>`);
    root2.appendChild(template.content.cloneNode(true));
    const el = root2.querySelector(`[part=${part}]`);
    el.addEventListener("mousedown", this);
    el.addEventListener("touchstart", this);
    el.addEventListener("keydown", this);
    this.el = el;
    this.xy = xy;
    this.nodes = [el.firstChild, el];
  }
  set dragging(state2) {
    const toggleEvent = state2 ? document.addEventListener : document.removeEventListener;
    toggleEvent(hasTouched ? "touchmove" : "mousemove", this);
    toggleEvent(hasTouched ? "touchend" : "mouseup", this);
  }
  handleEvent(event) {
    switch (event.type) {
      case "mousedown":
      case "touchstart":
        event.preventDefault();
        if (!isValid(event) || !hasTouched && event.button != 0)
          return;
        this.el.focus();
        pointerMove(this, event);
        this.dragging = true;
        break;
      case "mousemove":
      case "touchmove":
        event.preventDefault();
        pointerMove(this, event);
        break;
      case "mouseup":
      case "touchend":
        this.dragging = false;
        break;
      case "keydown":
        keyMove(this, event);
        break;
    }
  }
  style(styles2) {
    styles2.forEach((style, i) => {
      for (const p in style) {
        this.nodes[i].style.setProperty(p, style[p]);
      }
    });
  }
};

// node_modules/vanilla-colorful/lib/components/hue.js
var Hue = class extends Slider {
  constructor(root2) {
    super(root2, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false);
  }
  update({h}) {
    this.h = h;
    this.style([
      {
        left: `${h / 360 * 100}%`,
        color: hsvaToHslString({h, s: 100, v: 100, a: 1})
      }
    ]);
    this.el.setAttribute("aria-valuenow", `${round(h)}`);
  }
  getMove(offset, key) {
    return {h: key ? clamp(this.h + offset.x * 360, 0, 360) : 360 * offset.x};
  }
};

// node_modules/vanilla-colorful/lib/components/saturation.js
var Saturation = class extends Slider {
  constructor(root2) {
    super(root2, "saturation", 'aria-label="Color"', true);
  }
  update(hsva) {
    this.hsva = hsva;
    this.style([
      {
        top: `${100 - hsva.v}%`,
        left: `${hsva.s}%`,
        color: hsvaToHslString(hsva)
      },
      {
        "background-color": hsvaToHslString({h: hsva.h, s: 100, v: 100, a: 1})
      }
    ]);
    this.el.setAttribute("aria-valuetext", `Saturation ${round(hsva.s)}%, Brightness ${round(hsva.v)}%`);
  }
  getMove(offset, key) {
    return {
      s: key ? clamp(this.hsva.s + offset.x * 100, 0, 100) : offset.x * 100,
      v: key ? clamp(this.hsva.v - offset.y * 100, 0, 100) : Math.round(100 - offset.y * 100)
    };
  }
};

// node_modules/vanilla-colorful/lib/styles/color-picker.js
var color_picker_default = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{display:block;content:'';position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`;

// node_modules/vanilla-colorful/lib/styles/hue.js
var hue_default = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`;

// node_modules/vanilla-colorful/lib/styles/saturation.js
var saturation_default = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`;

// node_modules/vanilla-colorful/lib/components/color-picker.js
var $isSame = Symbol("same");
var $color = Symbol("color");
var $hsva = Symbol("hsva");
var $change = Symbol("change");
var $update = Symbol("update");
var $parts = Symbol("parts");
var $css = Symbol("css");
var $sliders = Symbol("sliders");
var ColorPicker = class extends HTMLElement {
  static get observedAttributes() {
    return ["color"];
  }
  get [$css]() {
    return [color_picker_default, hue_default, saturation_default];
  }
  get [$sliders]() {
    return [Saturation, Hue];
  }
  get color() {
    return this[$color];
  }
  set color(newColor) {
    if (!this[$isSame](newColor)) {
      const newHsva = this.colorModel.toHsva(newColor);
      this[$update](newHsva);
      this[$change](newColor);
    }
  }
  constructor() {
    super();
    const template = tpl(`<style>${this[$css].join("")}</style>`);
    const root2 = this.attachShadow({mode: "open"});
    root2.appendChild(template.content.cloneNode(true));
    root2.addEventListener("move", this);
    this[$parts] = this[$sliders].map((slider) => new slider(root2));
  }
  connectedCallback() {
    if (this.hasOwnProperty("color")) {
      const value = this.color;
      delete this["color"];
      this.color = value;
    } else if (!this.color) {
      this.color = this.colorModel.defaultColor;
    }
  }
  attributeChangedCallback(_attr, _oldVal, newVal) {
    const color = this.colorModel.fromAttr(newVal);
    if (!this[$isSame](color)) {
      this.color = color;
    }
  }
  handleEvent(event) {
    const oldHsva = this[$hsva];
    const newHsva = {...oldHsva, ...event.detail};
    this[$update](newHsva);
    let newColor;
    if (!equalColorObjects(newHsva, oldHsva) && !this[$isSame](newColor = this.colorModel.fromHsva(newHsva))) {
      this[$change](newColor);
    }
  }
  [$isSame](color) {
    return this.color && this.colorModel.equal(color, this.color);
  }
  [$update](hsva) {
    this[$hsva] = hsva;
    this[$parts].forEach((part) => part.update(hsva));
  }
  [$change](value) {
    this[$color] = value;
    fire(this, "color-changed", {value});
  }
};

// node_modules/vanilla-colorful/lib/entrypoints/hex.js
var colorModel = {
  defaultColor: "#000",
  toHsva: hexToHsva,
  fromHsva: hsvaToHex,
  equal: equalHex,
  fromAttr: (color) => color
};
var HexBase = class extends ColorPicker {
  get colorModel() {
    return colorModel;
  }
};

// node_modules/vanilla-colorful/hex-color-picker.js
var HexColorPicker = class extends HexBase {
};
customElements.define("hex-color-picker", HexColorPicker);

// node_modules/vanilla-colorful/lib/entrypoints/hsl-string.js
var colorModel2 = {
  defaultColor: "hsl(0, 0%, 0%)",
  toHsva: hslStringToHsva,
  fromHsva: hsvaToHslString,
  equal: equalColorString,
  fromAttr: (color) => color
};
var HslStringBase = class extends ColorPicker {
  get colorModel() {
    return colorModel2;
  }
};

// node_modules/vanilla-colorful/hsl-string-color-picker.js
var HslStringColorPicker = class extends HslStringBase {
};
customElements.define("hsl-string-color-picker", HslStringColorPicker);

// node_modules/vanilla-colorful/lib/entrypoints/rgb-string.js
var colorModel3 = {
  defaultColor: "rgb(0, 0, 0)",
  toHsva: rgbStringToHsva,
  fromHsva: hsvaToRgbString,
  equal: equalColorString,
  fromAttr: (color) => color
};
var RgbStringBase = class extends ColorPicker {
  get colorModel() {
    return colorModel3;
  }
};

// node_modules/vanilla-colorful/rgb-string-color-picker.js
var RgbStringColorPicker = class extends RgbStringBase {
};
customElements.define("rgb-string-color-picker", RgbStringColorPicker);

// node_modules/vanilla-colorful/lib/components/alpha.js
var Alpha = class extends Slider {
  constructor(root2) {
    super(root2, "alpha", 'aria-label="Alpha" aria-valuemin="0" aria-valuemax="1"', false);
  }
  update(hsva) {
    this.hsva = hsva;
    const colorFrom = hsvaToHslaString({...hsva, a: 0});
    const colorTo = hsvaToHslaString({...hsva, a: 1});
    const value = hsva.a * 100;
    this.style([
      {
        left: `${value}%`,
        color: hsvaToHslaString(hsva)
      },
      {
        "--gradient": `linear-gradient(90deg, ${colorFrom}, ${colorTo}`
      }
    ]);
    const v = round(value);
    this.el.setAttribute("aria-valuenow", `${v}`);
    this.el.setAttribute("aria-valuetext", `${v}%`);
  }
  getMove(offset, key) {
    return {a: key ? clamp(this.hsva.a + offset.x) : offset.x};
  }
};

// node_modules/vanilla-colorful/lib/styles/alpha.js
var alpha_default = `[part=alpha]{flex:0 0 24px}[part=alpha]::after{display:block;content:'';position:absolute;top:0;left:0;right:0;bottom:0;border-radius:inherit;background-image:var(--gradient);box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part^=alpha]{background-color:#fff;background-image:url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><rect x="8" width="8" height="8"/><rect y="8" width="8" height="8"/></svg>')}[part=alpha-pointer]{top:50%}`;

// node_modules/vanilla-colorful/lib/components/alpha-color-picker.js
var AlphaColorPicker = class extends ColorPicker {
  get [$css]() {
    return [...super[$css], alpha_default];
  }
  get [$sliders]() {
    return [...super[$sliders], Alpha];
  }
};

// node_modules/vanilla-colorful/lib/entrypoints/rgba-string.js
var colorModel4 = {
  defaultColor: "rgba(0, 0, 0, 1)",
  toHsva: rgbaStringToHsva,
  fromHsva: hsvaToRgbaString,
  equal: equalColorString,
  fromAttr: (color) => color
};
var RgbaStringBase = class extends AlphaColorPicker {
  get colorModel() {
    return colorModel4;
  }
};

// node_modules/vanilla-colorful/rgba-string-color-picker.js
var RgbaStringColorPicker = class extends RgbaStringBase {
};
customElements.define("rgba-string-color-picker", RgbaStringColorPicker);

// packages/forms/resources/js/components/color-picker.js
var color_picker_default2 = (Alpine) => {
  Alpine.data("colorPickerFormComponent", ({
    isAutofocused,
    isDisabled,
    state: state2
  }) => {
    return {
      isOpen: false,
      state: state2,
      init: function() {
        if (!(this.state === null || this.state === "")) {
          this.setState(this.state);
        }
        if (isAutofocused) {
          this.openPicker();
        }
        this.$refs.input.addEventListener("change", (event) => {
          this.setState(event.target.value);
        });
        this.$refs.picker.addEventListener("color-changed", (event) => {
          this.setState(event.detail.value);
        });
      },
      openPicker: function() {
        if (isDisabled) {
          return;
        }
        this.isOpen = true;
      },
      closePicker: function() {
        this.isOpen = false;
      },
      setState: function(value) {
        this.state = value;
        this.$refs.input.value = value;
        this.$refs.picker.color = value;
      }
    };
  });
};

// node_modules/dayjs/esm/constant.js
var SECONDS_A_MINUTE = 60;
var SECONDS_A_HOUR = SECONDS_A_MINUTE * 60;
var SECONDS_A_DAY = SECONDS_A_HOUR * 24;
var SECONDS_A_WEEK = SECONDS_A_DAY * 7;
var MILLISECONDS_A_SECOND = 1e3;
var MILLISECONDS_A_MINUTE = SECONDS_A_MINUTE * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_HOUR = SECONDS_A_HOUR * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_DAY = SECONDS_A_DAY * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_WEEK = SECONDS_A_WEEK * MILLISECONDS_A_SECOND;
var MS = "millisecond";
var S = "second";
var MIN = "minute";
var H = "hour";
var D = "day";
var W = "week";
var M = "month";
var Q = "quarter";
var Y = "year";
var DATE = "date";
var FORMAT_DEFAULT = "YYYY-MM-DDTHH:mm:ssZ";
var INVALID_DATE_STRING = "Invalid Date";
var REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
var REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g;

// node_modules/dayjs/esm/locale/en.js
var en_default = {
  name: "en",
  weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
  months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
};

// node_modules/dayjs/esm/utils.js
var padStart = function padStart2(string, length, pad) {
  var s = String(string);
  if (!s || s.length >= length)
    return string;
  return "" + Array(length + 1 - s.length).join(pad) + string;
};
var padZoneStr = function padZoneStr2(instance) {
  var negMinutes = -instance.utcOffset();
  var minutes = Math.abs(negMinutes);
  var hourOffset = Math.floor(minutes / 60);
  var minuteOffset = minutes % 60;
  return "" + (negMinutes <= 0 ? "+" : "-") + padStart(hourOffset, 2, "0") + ":" + padStart(minuteOffset, 2, "0");
};
var monthDiff = function monthDiff2(a, b) {
  if (a.date() < b.date())
    return -monthDiff2(b, a);
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month());
  var anchor = a.clone().add(wholeMonthDiff, M);
  var c = b - anchor < 0;
  var anchor2 = a.clone().add(wholeMonthDiff + (c ? -1 : 1), M);
  return +(-(wholeMonthDiff + (b - anchor) / (c ? anchor - anchor2 : anchor2 - anchor)) || 0);
};
var absFloor = function absFloor2(n) {
  return n < 0 ? Math.ceil(n) || 0 : Math.floor(n);
};
var prettyUnit = function prettyUnit2(u) {
  var special = {
    M,
    y: Y,
    w: W,
    d: D,
    D: DATE,
    h: H,
    m: MIN,
    s: S,
    ms: MS,
    Q
  };
  return special[u] || String(u || "").toLowerCase().replace(/s$/, "");
};
var isUndefined = function isUndefined2(s) {
  return s === void 0;
};
var utils_default = {
  s: padStart,
  z: padZoneStr,
  m: monthDiff,
  a: absFloor,
  p: prettyUnit,
  u: isUndefined
};

// node_modules/dayjs/esm/index.js
var L = "en";
var Ls = {};
Ls[L] = en_default;
var isDayjs = function isDayjs2(d) {
  return d instanceof Dayjs;
};
var parseLocale = function parseLocale2(preset, object, isLocal) {
  var l;
  if (!preset)
    return L;
  if (typeof preset === "string") {
    var presetLower = preset.toLowerCase();
    if (Ls[presetLower]) {
      l = presetLower;
    }
    if (object) {
      Ls[presetLower] = object;
      l = presetLower;
    }
    var presetSplit = preset.split("-");
    if (!l && presetSplit.length > 1) {
      return parseLocale2(presetSplit[0]);
    }
  } else {
    var name2 = preset.name;
    Ls[name2] = preset;
    l = name2;
  }
  if (!isLocal && l)
    L = l;
  return l || !isLocal && L;
};
var dayjs = function dayjs2(date, c) {
  if (isDayjs(date)) {
    return date.clone();
  }
  var cfg = typeof c === "object" ? c : {};
  cfg.date = date;
  cfg.args = arguments;
  return new Dayjs(cfg);
};
var wrapper = function wrapper2(date, instance) {
  return dayjs(date, {
    locale: instance.$L,
    utc: instance.$u,
    x: instance.$x,
    $offset: instance.$offset
  });
};
var Utils = utils_default;
Utils.l = parseLocale;
Utils.i = isDayjs;
Utils.w = wrapper;
var parseDate = function parseDate2(cfg) {
  var date = cfg.date, utc2 = cfg.utc;
  if (date === null)
    return new Date(NaN);
  if (Utils.u(date))
    return new Date();
  if (date instanceof Date)
    return new Date(date);
  if (typeof date === "string" && !/Z$/i.test(date)) {
    var d = date.match(REGEX_PARSE);
    if (d) {
      var m = d[2] - 1 || 0;
      var ms = (d[7] || "0").substring(0, 3);
      if (utc2) {
        return new Date(Date.UTC(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms));
      }
      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }
  return new Date(date);
};
var Dayjs = /* @__PURE__ */ function() {
  function Dayjs2(cfg) {
    this.$L = parseLocale(cfg.locale, null, true);
    this.parse(cfg);
  }
  var _proto = Dayjs2.prototype;
  _proto.parse = function parse4(cfg) {
    this.$d = parseDate(cfg);
    this.$x = cfg.x || {};
    this.init();
  };
  _proto.init = function init() {
    var $d = this.$d;
    this.$y = $d.getFullYear();
    this.$M = $d.getMonth();
    this.$D = $d.getDate();
    this.$W = $d.getDay();
    this.$H = $d.getHours();
    this.$m = $d.getMinutes();
    this.$s = $d.getSeconds();
    this.$ms = $d.getMilliseconds();
  };
  _proto.$utils = function $utils() {
    return Utils;
  };
  _proto.isValid = function isValid2() {
    return !(this.$d.toString() === INVALID_DATE_STRING);
  };
  _proto.isSame = function isSame(that, units) {
    var other = dayjs(that);
    return this.startOf(units) <= other && other <= this.endOf(units);
  };
  _proto.isAfter = function isAfter(that, units) {
    return dayjs(that) < this.startOf(units);
  };
  _proto.isBefore = function isBefore(that, units) {
    return this.endOf(units) < dayjs(that);
  };
  _proto.$g = function $g(input, get, set2) {
    if (Utils.u(input))
      return this[get];
    return this.set(set2, input);
  };
  _proto.unix = function unix() {
    return Math.floor(this.valueOf() / 1e3);
  };
  _proto.valueOf = function valueOf() {
    return this.$d.getTime();
  };
  _proto.startOf = function startOf(units, _startOf) {
    var _this = this;
    var isStartOf = !Utils.u(_startOf) ? _startOf : true;
    var unit = Utils.p(units);
    var instanceFactory = function instanceFactory2(d, m) {
      var ins = Utils.w(_this.$u ? Date.UTC(_this.$y, m, d) : new Date(_this.$y, m, d), _this);
      return isStartOf ? ins : ins.endOf(D);
    };
    var instanceFactorySet = function instanceFactorySet2(method, slice) {
      var argumentStart = [0, 0, 0, 0];
      var argumentEnd = [23, 59, 59, 999];
      return Utils.w(_this.toDate()[method].apply(_this.toDate("s"), (isStartOf ? argumentStart : argumentEnd).slice(slice)), _this);
    };
    var $W = this.$W, $M = this.$M, $D = this.$D;
    var utcPad = "set" + (this.$u ? "UTC" : "");
    switch (unit) {
      case Y:
        return isStartOf ? instanceFactory(1, 0) : instanceFactory(31, 11);
      case M:
        return isStartOf ? instanceFactory(1, $M) : instanceFactory(0, $M + 1);
      case W: {
        var weekStart = this.$locale().weekStart || 0;
        var gap = ($W < weekStart ? $W + 7 : $W) - weekStart;
        return instanceFactory(isStartOf ? $D - gap : $D + (6 - gap), $M);
      }
      case D:
      case DATE:
        return instanceFactorySet(utcPad + "Hours", 0);
      case H:
        return instanceFactorySet(utcPad + "Minutes", 1);
      case MIN:
        return instanceFactorySet(utcPad + "Seconds", 2);
      case S:
        return instanceFactorySet(utcPad + "Milliseconds", 3);
      default:
        return this.clone();
    }
  };
  _proto.endOf = function endOf(arg) {
    return this.startOf(arg, false);
  };
  _proto.$set = function $set(units, _int) {
    var _C$D$C$DATE$C$M$C$Y$C;
    var unit = Utils.p(units);
    var utcPad = "set" + (this.$u ? "UTC" : "");
    var name2 = (_C$D$C$DATE$C$M$C$Y$C = {}, _C$D$C$DATE$C$M$C$Y$C[D] = utcPad + "Date", _C$D$C$DATE$C$M$C$Y$C[DATE] = utcPad + "Date", _C$D$C$DATE$C$M$C$Y$C[M] = utcPad + "Month", _C$D$C$DATE$C$M$C$Y$C[Y] = utcPad + "FullYear", _C$D$C$DATE$C$M$C$Y$C[H] = utcPad + "Hours", _C$D$C$DATE$C$M$C$Y$C[MIN] = utcPad + "Minutes", _C$D$C$DATE$C$M$C$Y$C[S] = utcPad + "Seconds", _C$D$C$DATE$C$M$C$Y$C[MS] = utcPad + "Milliseconds", _C$D$C$DATE$C$M$C$Y$C)[unit];
    var arg = unit === D ? this.$D + (_int - this.$W) : _int;
    if (unit === M || unit === Y) {
      var date = this.clone().set(DATE, 1);
      date.$d[name2](arg);
      date.init();
      this.$d = date.set(DATE, Math.min(this.$D, date.daysInMonth())).$d;
    } else if (name2)
      this.$d[name2](arg);
    this.init();
    return this;
  };
  _proto.set = function set2(string, _int2) {
    return this.clone().$set(string, _int2);
  };
  _proto.get = function get(unit) {
    return this[Utils.p(unit)]();
  };
  _proto.add = function add(number, units) {
    var _this2 = this, _C$MIN$C$H$C$S$unit;
    number = Number(number);
    var unit = Utils.p(units);
    var instanceFactorySet = function instanceFactorySet2(n) {
      var d = dayjs(_this2);
      return Utils.w(d.date(d.date() + Math.round(n * number)), _this2);
    };
    if (unit === M) {
      return this.set(M, this.$M + number);
    }
    if (unit === Y) {
      return this.set(Y, this.$y + number);
    }
    if (unit === D) {
      return instanceFactorySet(1);
    }
    if (unit === W) {
      return instanceFactorySet(7);
    }
    var step = (_C$MIN$C$H$C$S$unit = {}, _C$MIN$C$H$C$S$unit[MIN] = MILLISECONDS_A_MINUTE, _C$MIN$C$H$C$S$unit[H] = MILLISECONDS_A_HOUR, _C$MIN$C$H$C$S$unit[S] = MILLISECONDS_A_SECOND, _C$MIN$C$H$C$S$unit)[unit] || 1;
    var nextTimeStamp = this.$d.getTime() + number * step;
    return Utils.w(nextTimeStamp, this);
  };
  _proto.subtract = function subtract(number, string) {
    return this.add(number * -1, string);
  };
  _proto.format = function format4(formatStr) {
    var _this3 = this;
    var locale = this.$locale();
    if (!this.isValid())
      return locale.invalidDate || INVALID_DATE_STRING;
    var str = formatStr || FORMAT_DEFAULT;
    var zoneStr = Utils.z(this);
    var $H = this.$H, $m = this.$m, $M = this.$M;
    var weekdays = locale.weekdays, months = locale.months, meridiem = locale.meridiem;
    var getShort = function getShort2(arr, index2, full, length) {
      return arr && (arr[index2] || arr(_this3, str)) || full[index2].slice(0, length);
    };
    var get$H = function get$H2(num) {
      return Utils.s($H % 12 || 12, num, "0");
    };
    var meridiemFunc = meridiem || function(hour, minute, isLowercase) {
      var m = hour < 12 ? "AM" : "PM";
      return isLowercase ? m.toLowerCase() : m;
    };
    var matches2 = {
      YY: String(this.$y).slice(-2),
      YYYY: this.$y,
      M: $M + 1,
      MM: Utils.s($M + 1, 2, "0"),
      MMM: getShort(locale.monthsShort, $M, months, 3),
      MMMM: getShort(months, $M),
      D: this.$D,
      DD: Utils.s(this.$D, 2, "0"),
      d: String(this.$W),
      dd: getShort(locale.weekdaysMin, this.$W, weekdays, 2),
      ddd: getShort(locale.weekdaysShort, this.$W, weekdays, 3),
      dddd: weekdays[this.$W],
      H: String($H),
      HH: Utils.s($H, 2, "0"),
      h: get$H(1),
      hh: get$H(2),
      a: meridiemFunc($H, $m, true),
      A: meridiemFunc($H, $m, false),
      m: String($m),
      mm: Utils.s($m, 2, "0"),
      s: String(this.$s),
      ss: Utils.s(this.$s, 2, "0"),
      SSS: Utils.s(this.$ms, 3, "0"),
      Z: zoneStr
    };
    return str.replace(REGEX_FORMAT, function(match, $1) {
      return $1 || matches2[match] || zoneStr.replace(":", "");
    });
  };
  _proto.utcOffset = function utcOffset() {
    return -Math.round(this.$d.getTimezoneOffset() / 15) * 15;
  };
  _proto.diff = function diff(input, units, _float) {
    var _C$Y$C$M$C$Q$C$W$C$D$;
    var unit = Utils.p(units);
    var that = dayjs(input);
    var zoneDelta = (that.utcOffset() - this.utcOffset()) * MILLISECONDS_A_MINUTE;
    var diff2 = this - that;
    var result = Utils.m(this, that);
    result = (_C$Y$C$M$C$Q$C$W$C$D$ = {}, _C$Y$C$M$C$Q$C$W$C$D$[Y] = result / 12, _C$Y$C$M$C$Q$C$W$C$D$[M] = result, _C$Y$C$M$C$Q$C$W$C$D$[Q] = result / 3, _C$Y$C$M$C$Q$C$W$C$D$[W] = (diff2 - zoneDelta) / MILLISECONDS_A_WEEK, _C$Y$C$M$C$Q$C$W$C$D$[D] = (diff2 - zoneDelta) / MILLISECONDS_A_DAY, _C$Y$C$M$C$Q$C$W$C$D$[H] = diff2 / MILLISECONDS_A_HOUR, _C$Y$C$M$C$Q$C$W$C$D$[MIN] = diff2 / MILLISECONDS_A_MINUTE, _C$Y$C$M$C$Q$C$W$C$D$[S] = diff2 / MILLISECONDS_A_SECOND, _C$Y$C$M$C$Q$C$W$C$D$)[unit] || diff2;
    return _float ? result : Utils.a(result);
  };
  _proto.daysInMonth = function daysInMonth() {
    return this.endOf(M).$D;
  };
  _proto.$locale = function $locale() {
    return Ls[this.$L];
  };
  _proto.locale = function locale(preset, object) {
    if (!preset)
      return this.$L;
    var that = this.clone();
    var nextLocaleName = parseLocale(preset, object, true);
    if (nextLocaleName)
      that.$L = nextLocaleName;
    return that;
  };
  _proto.clone = function clone2() {
    return Utils.w(this.$d, this);
  };
  _proto.toDate = function toDate() {
    return new Date(this.valueOf());
  };
  _proto.toJSON = function toJSON() {
    return this.isValid() ? this.toISOString() : null;
  };
  _proto.toISOString = function toISOString() {
    return this.$d.toISOString();
  };
  _proto.toString = function toString2() {
    return this.$d.toUTCString();
  };
  return Dayjs2;
}();
var proto = Dayjs.prototype;
dayjs.prototype = proto;
[["$ms", MS], ["$s", S], ["$m", MIN], ["$H", H], ["$W", D], ["$M", M], ["$y", Y], ["$D", DATE]].forEach(function(g) {
  proto[g[1]] = function(input) {
    return this.$g(input, g[0], g[1]);
  };
});
dayjs.extend = function(plugin9, option3) {
  if (!plugin9.$i) {
    plugin9(option3, Dayjs, dayjs);
    plugin9.$i = true;
  }
  return dayjs;
};
dayjs.locale = parseLocale;
dayjs.isDayjs = isDayjs;
dayjs.unix = function(timestamp) {
  return dayjs(timestamp * 1e3);
};
dayjs.en = Ls[L];
dayjs.Ls = Ls;
dayjs.p = {};
var esm_default = dayjs;

// packages/forms/resources/js/components/date-time-picker.js
var import_customParseFormat = __toModule(require_customParseFormat());
var import_localeData = __toModule(require_localeData());
var import_timezone = __toModule(require_timezone());
var import_utc = __toModule(require_utc());
esm_default.extend(import_customParseFormat.default);
esm_default.extend(import_localeData.default);
esm_default.extend(import_timezone.default);
esm_default.extend(import_utc.default);
esm_default.extend((option3, Dayjs2, dayjs3) => {
  const listeners2 = [];
  dayjs3.addLocaleListeners = (listener) => listeners2.push(listener);
  dayjs3.onLocaleUpdated = () => {
    listeners2.forEach((listener) => listener());
  };
  dayjs3.updateLocale = (locale) => {
    dayjs3.locale(locale);
    dayjs3.onLocaleUpdated();
  };
});
window.dayjs = esm_default;
var date_time_picker_default = (Alpine) => {
  Alpine.data("dateTimePickerFormComponent", ({
    displayFormat,
    firstDayOfWeek,
    isAutofocused,
    state: state2
  }) => {
    const timezone2 = esm_default.tz.guess();
    return {
      daysInFocusedMonth: [],
      displayText: "",
      emptyDaysInFocusedMonth: [],
      focusedDate: null,
      focusedMonth: null,
      focusedYear: null,
      hour: null,
      isClearingState: false,
      minute: null,
      open: false,
      second: null,
      state: state2,
      dayLabels: [],
      months: [],
      init: function() {
        this.focusedDate = esm_default().tz(timezone2);
        let date = this.getSelectedDate() ?? esm_default().tz(timezone2).hour(0).minute(0).second(0);
        if (this.getMaxDate() !== null && date.isAfter(this.getMaxDate())) {
          date = null;
        } else if (this.getMinDate() !== null && date.isBefore(this.getMinDate())) {
          date = null;
        }
        this.hour = date?.hour() ?? 0;
        this.minute = date?.minute() ?? 0;
        this.second = date?.second() ?? 0;
        this.setDisplayText();
        this.setMonths();
        this.setDayLabels();
        if (isAutofocused) {
          this.$nextTick(() => this.openPicker());
        }
        esm_default.addLocaleListeners(() => {
          this.setDisplayText();
          this.setMonths();
          this.setDayLabels();
        });
        this.$watch("focusedMonth", () => {
          this.focusedMonth = +this.focusedMonth;
          if (this.focusedDate.month() === this.focusedMonth) {
            return;
          }
          this.focusedDate = this.focusedDate.month(this.focusedMonth);
        });
        this.$watch("focusedYear", () => {
          if (this.focusedYear?.length > 4) {
            this.focusedYear = this.focusedYear.substring(0, 4);
          }
          if (!this.focusedYear || this.focusedYear?.length !== 4) {
            return;
          }
          let year = +this.focusedYear;
          if (!Number.isInteger(year)) {
            year = esm_default().tz(timezone2).year();
            this.focusedYear = year;
          }
          if (this.focusedDate.year() === year) {
            return;
          }
          this.focusedDate = this.focusedDate.year(year);
        });
        this.$watch("focusedDate", () => {
          let month = this.focusedDate.month();
          let year = this.focusedDate.year();
          if (this.focusedMonth !== month) {
            this.focusedMonth = month;
          }
          if (this.focusedYear !== year) {
            this.focusedYear = year;
          }
          this.setupDaysGrid();
          this.$nextTick(() => {
            this.evaluatePosition();
          });
        });
        this.$watch("hour", () => {
          let hour = +this.hour;
          if (!Number.isInteger(hour)) {
            this.hour = 0;
          } else if (hour > 23) {
            this.hour = 0;
          } else if (hour < 0) {
            this.hour = 23;
          } else {
            this.hour = hour;
          }
          if (this.isClearingState) {
            return;
          }
          let date2 = this.getSelectedDate() ?? this.focusedDate;
          this.setState(date2.hour(this.hour ?? 0));
        });
        this.$watch("minute", () => {
          let minute = +this.minute;
          if (!Number.isInteger(minute)) {
            this.minute = 0;
          } else if (minute > 59) {
            this.minute = 0;
          } else if (minute < 0) {
            this.minute = 59;
          } else {
            this.minute = minute;
          }
          if (this.isClearingState) {
            return;
          }
          let date2 = this.getSelectedDate() ?? this.focusedDate;
          this.setState(date2.minute(this.minute ?? 0));
        });
        this.$watch("second", () => {
          let second = +this.second;
          if (!Number.isInteger(second)) {
            this.second = 0;
          } else if (second > 59) {
            this.second = 0;
          } else if (second < 0) {
            this.second = 59;
          } else {
            this.second = second;
          }
          if (this.isClearingState) {
            return;
          }
          let date2 = this.getSelectedDate() ?? this.focusedDate;
          this.setState(date2.second(this.second ?? 0));
        });
        this.$watch("state", () => {
          if (this.state === void 0) {
            return;
          }
          let date2 = this.getSelectedDate();
          if (this.getMaxDate() !== null && date2.isAfter(this.getMaxDate())) {
            date2 = null;
          }
          if (this.getMinDate() !== null && date2.isBefore(this.getMinDate())) {
            date2 = null;
          }
          const newHour = date2?.hour() ?? 0;
          if (this.hour !== newHour) {
            this.hour = newHour;
          }
          const newMinute = date2?.minute() ?? 0;
          if (this.minute !== newMinute) {
            this.minute = newMinute;
          }
          const newSecond = date2?.second() ?? 0;
          if (this.second !== newSecond) {
            this.second = newSecond;
          }
          this.setDisplayText();
        });
      },
      clearState: function() {
        this.isClearingState = true;
        this.setState(null);
        this.closePicker();
        this.$nextTick(() => this.isClearingState = false);
      },
      closePicker: function() {
        this.open = false;
      },
      dateIsDisabled: function(date) {
        if (this.getMaxDate() && date.isAfter(this.getMaxDate())) {
          return true;
        }
        if (this.getMinDate() && date.isBefore(this.getMinDate())) {
          return true;
        }
        return false;
      },
      dayIsDisabled: function(day) {
        this.focusedDate ??= esm_default().tz(timezone2);
        return this.dateIsDisabled(this.focusedDate.date(day));
      },
      dayIsSelected: function(day) {
        let selectedDate = this.getSelectedDate();
        if (selectedDate === null) {
          return false;
        }
        this.focusedDate ??= esm_default().tz(timezone2);
        return selectedDate.date() === day && selectedDate.month() === this.focusedDate.month() && selectedDate.year() === this.focusedDate.year();
      },
      dayIsToday: function(day) {
        let date = esm_default().tz(timezone2);
        this.focusedDate ??= date;
        return date.date() === day && date.month() === this.focusedDate.month() && date.year() === this.focusedDate.year();
      },
      evaluatePosition: function() {
        let availableHeight = window.innerHeight - this.$refs.button.offsetHeight;
        let element = this.$refs.button;
        while (element) {
          availableHeight -= element.offsetTop;
          element = element.offsetParent;
        }
        if (this.$refs.picker.offsetHeight <= availableHeight) {
          this.$refs.picker.style.bottom = "auto";
          return;
        }
        this.$refs.picker.style.bottom = `${this.$refs.button.offsetHeight}px`;
      },
      focusPreviousDay: function() {
        this.focusedDate ??= esm_default().tz(timezone2);
        this.focusedDate = this.focusedDate.subtract(1, "day");
      },
      focusPreviousWeek: function() {
        this.focusedDate ??= esm_default().tz(timezone2);
        this.focusedDate = this.focusedDate.subtract(1, "week");
      },
      focusNextDay: function() {
        this.focusedDate ??= esm_default().tz(timezone2);
        this.focusedDate = this.focusedDate.add(1, "day");
      },
      focusNextWeek: function() {
        this.focusedDate ??= esm_default().tz(timezone2);
        this.focusedDate = this.focusedDate.add(1, "week");
      },
      getDayLabels: function() {
        const labels = esm_default.weekdaysShort();
        if (firstDayOfWeek === 0) {
          return labels;
        }
        return [
          ...labels.slice(firstDayOfWeek),
          ...labels.slice(0, firstDayOfWeek)
        ];
      },
      getMaxDate: function() {
        let date = esm_default(this.$refs.maxDate.value);
        return date.isValid() ? date : null;
      },
      getMinDate: function() {
        let date = esm_default(this.$refs.minDate.value);
        return date.isValid() ? date : null;
      },
      getSelectedDate: function() {
        if (this.state === void 0) {
          return null;
        }
        let date = esm_default(this.state);
        if (!date.isValid()) {
          return null;
        }
        return date;
      },
      openPicker: function() {
        this.focusedDate = this.getSelectedDate() ?? this.getMinDate() ?? esm_default().tz(timezone2);
        this.setupDaysGrid();
        this.open = true;
        this.$nextTick(() => {
          this.evaluatePosition();
        });
      },
      selectDate: function(day = null) {
        if (day) {
          this.setFocusedDay(day);
        }
        this.focusedDate ??= esm_default().tz(timezone2);
        this.setState(this.focusedDate);
      },
      setDisplayText: function() {
        this.displayText = this.getSelectedDate() ? this.getSelectedDate().format(displayFormat) : "";
      },
      setMonths: function() {
        this.months = esm_default.months();
      },
      setDayLabels: function() {
        this.dayLabels = this.getDayLabels();
      },
      setupDaysGrid: function() {
        this.focusedDate ??= esm_default().tz(timezone2);
        this.emptyDaysInFocusedMonth = Array.from({
          length: this.focusedDate.date(8 - firstDayOfWeek).day()
        }, (_, i) => i + 1);
        this.daysInFocusedMonth = Array.from({
          length: this.focusedDate.daysInMonth()
        }, (_, i) => i + 1);
      },
      setFocusedDay: function(day) {
        this.focusedDate = (this.focusedDate ?? esm_default().tz(timezone2)).date(day);
      },
      setState: function(date) {
        if (date === null) {
          this.state = null;
          this.setDisplayText();
          return;
        }
        if (this.dateIsDisabled(date)) {
          return;
        }
        this.state = date.hour(this.hour ?? 0).minute(this.minute ?? 0).second(this.second ?? 0).format("YYYY-MM-DD HH:mm:ss");
        this.setDisplayText();
      },
      togglePickerVisibility: function() {
        if (this.open) {
          this.closePicker();
          return;
        }
        this.openPicker();
      }
    };
  });
};

// node_modules/filepond/dist/filepond.esm.js
var filepond_esm_exports = {};
__export(filepond_esm_exports, {
  FileOrigin: () => FileOrigin$1,
  FileStatus: () => FileStatus,
  OptionTypes: () => OptionTypes,
  Status: () => Status$1,
  create: () => create$f,
  destroy: () => destroy,
  find: () => find,
  getOptions: () => getOptions$1,
  parse: () => parse,
  registerPlugin: () => registerPlugin,
  setOptions: () => setOptions$1,
  supported: () => supported
});
/*!
 * FilePond 4.30.3
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
var isNode = (value) => value instanceof HTMLElement;
var createStore = (initialState, queries2 = [], actions2 = []) => {
  const state2 = {
    ...initialState
  };
  const actionQueue = [];
  const dispatchQueue = [];
  const getState = () => ({...state2});
  const processActionQueue = () => {
    const queue = [...actionQueue];
    actionQueue.length = 0;
    return queue;
  };
  const processDispatchQueue = () => {
    const queue = [...dispatchQueue];
    dispatchQueue.length = 0;
    queue.forEach(({type, data: data3}) => {
      dispatch2(type, data3);
    });
  };
  const dispatch2 = (type, data3, isBlocking) => {
    if (isBlocking && !document.hidden) {
      dispatchQueue.push({type, data: data3});
      return;
    }
    if (actionHandlers[type]) {
      actionHandlers[type](data3);
    }
    actionQueue.push({
      type,
      data: data3
    });
  };
  const query = (str, ...args) => queryHandles[str] ? queryHandles[str](...args) : null;
  const api = {
    getState,
    processActionQueue,
    processDispatchQueue,
    dispatch: dispatch2,
    query
  };
  let queryHandles = {};
  queries2.forEach((query2) => {
    queryHandles = {
      ...query2(state2),
      ...queryHandles
    };
  });
  let actionHandlers = {};
  actions2.forEach((action) => {
    actionHandlers = {
      ...action(dispatch2, query, state2),
      ...actionHandlers
    };
  });
  return api;
};
var defineProperty = (obj, property, definition) => {
  if (typeof definition === "function") {
    obj[property] = definition;
    return;
  }
  Object.defineProperty(obj, property, {...definition});
};
var forin = (obj, cb) => {
  for (const key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    cb(key, obj[key]);
  }
};
var createObject = (definition) => {
  const obj = {};
  forin(definition, (property) => {
    defineProperty(obj, property, definition[property]);
  });
  return obj;
};
var attr = (node, name2, value = null) => {
  if (value === null) {
    return node.getAttribute(name2) || node.hasAttribute(name2);
  }
  node.setAttribute(name2, value);
};
var ns = "http://www.w3.org/2000/svg";
var svgElements = ["svg", "path"];
var isSVGElement = (tag) => svgElements.includes(tag);
var createElement = (tag, className, attributes = {}) => {
  if (typeof className === "object") {
    attributes = className;
    className = null;
  }
  const element = isSVGElement(tag) ? document.createElementNS(ns, tag) : document.createElement(tag);
  if (className) {
    if (isSVGElement(tag)) {
      attr(element, "class", className);
    } else {
      element.className = className;
    }
  }
  forin(attributes, (name2, value) => {
    attr(element, name2, value);
  });
  return element;
};
var appendChild = (parent) => (child, index2) => {
  if (typeof index2 !== "undefined" && parent.children[index2]) {
    parent.insertBefore(child, parent.children[index2]);
  } else {
    parent.appendChild(child);
  }
};
var appendChildView = (parent, childViews) => (view, index2) => {
  if (typeof index2 !== "undefined") {
    childViews.splice(index2, 0, view);
  } else {
    childViews.push(view);
  }
  return view;
};
var removeChildView = (parent, childViews) => (view) => {
  childViews.splice(childViews.indexOf(view), 1);
  if (view.element.parentNode) {
    parent.removeChild(view.element);
  }
  return view;
};
var IS_BROWSER = (() => typeof window !== "undefined" && typeof window.document !== "undefined")();
var isBrowser = () => IS_BROWSER;
var testElement = isBrowser() ? createElement("svg") : {};
var getChildCount = "children" in testElement ? (el) => el.children.length : (el) => el.childNodes.length;
var getViewRect = (elementRect, childViews, offset, scale) => {
  const left = offset[0] || elementRect.left;
  const top = offset[1] || elementRect.top;
  const right = left + elementRect.width;
  const bottom = top + elementRect.height * (scale[1] || 1);
  const rect = {
    element: {
      ...elementRect
    },
    inner: {
      left: elementRect.left,
      top: elementRect.top,
      right: elementRect.right,
      bottom: elementRect.bottom
    },
    outer: {
      left,
      top,
      right,
      bottom
    }
  };
  childViews.filter((childView) => !childView.isRectIgnored()).map((childView) => childView.rect).forEach((childViewRect) => {
    expandRect(rect.inner, {...childViewRect.inner});
    expandRect(rect.outer, {...childViewRect.outer});
  });
  calculateRectSize(rect.inner);
  rect.outer.bottom += rect.element.marginBottom;
  rect.outer.right += rect.element.marginRight;
  calculateRectSize(rect.outer);
  return rect;
};
var expandRect = (parent, child) => {
  child.top += parent.top;
  child.right += parent.left;
  child.bottom += parent.top;
  child.left += parent.left;
  if (child.bottom > parent.bottom) {
    parent.bottom = child.bottom;
  }
  if (child.right > parent.right) {
    parent.right = child.right;
  }
};
var calculateRectSize = (rect) => {
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
};
var isNumber = (value) => typeof value === "number";
var thereYet = (position, destination, velocity, errorMargin = 1e-3) => {
  return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;
};
var spring = ({stiffness = 0.5, damping = 0.75, mass = 10} = {}) => {
  let target = null;
  let position = null;
  let velocity = 0;
  let resting = false;
  const interpolate = (ts, skipToEndState) => {
    if (resting)
      return;
    if (!(isNumber(target) && isNumber(position))) {
      resting = true;
      velocity = 0;
      return;
    }
    const f = -(position - target) * stiffness;
    velocity += f / mass;
    position += velocity;
    velocity *= damping;
    if (thereYet(position, target, velocity) || skipToEndState) {
      position = target;
      velocity = 0;
      resting = true;
      api.onupdate(position);
      api.oncomplete(position);
    } else {
      api.onupdate(position);
    }
  };
  const setTarget = (value) => {
    if (isNumber(value) && !isNumber(position)) {
      position = value;
    }
    if (target === null) {
      target = value;
      position = value;
    }
    target = value;
    if (position === target || typeof target === "undefined") {
      resting = true;
      velocity = 0;
      api.onupdate(position);
      api.oncomplete(position);
      return;
    }
    resting = false;
  };
  const api = createObject({
    interpolate,
    target: {
      set: setTarget,
      get: () => target
    },
    resting: {
      get: () => resting
    },
    onupdate: (value) => {
    },
    oncomplete: (value) => {
    }
  });
  return api;
};
var easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
var tween = ({duration = 500, easing = easeInOutQuad, delay = 0} = {}) => {
  let start = null;
  let t;
  let p;
  let resting = true;
  let reverse = false;
  let target = null;
  const interpolate = (ts, skipToEndState) => {
    if (resting || target === null)
      return;
    if (start === null) {
      start = ts;
    }
    if (ts - start < delay)
      return;
    t = ts - start - delay;
    if (t >= duration || skipToEndState) {
      t = 1;
      p = reverse ? 0 : 1;
      api.onupdate(p * target);
      api.oncomplete(p * target);
      resting = true;
    } else {
      p = t / duration;
      api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);
    }
  };
  const api = createObject({
    interpolate,
    target: {
      get: () => reverse ? 0 : target,
      set: (value) => {
        if (target === null) {
          target = value;
          api.onupdate(value);
          api.oncomplete(value);
          return;
        }
        if (value < target) {
          target = 1;
          reverse = true;
        } else {
          reverse = false;
          target = value;
        }
        resting = false;
        start = null;
      }
    },
    resting: {
      get: () => resting
    },
    onupdate: (value) => {
    },
    oncomplete: (value) => {
    }
  });
  return api;
};
var animator = {
  spring,
  tween
};
var createAnimator = (definition, category, property) => {
  const def = definition[category] && typeof definition[category][property] === "object" ? definition[category][property] : definition[category] || definition;
  const type = typeof def === "string" ? def : def.type;
  const props = typeof def === "object" ? {...def} : {};
  return animator[type] ? animator[type](props) : null;
};
var addGetSet = (keys, obj, props, overwrite = false) => {
  obj = Array.isArray(obj) ? obj : [obj];
  obj.forEach((o) => {
    keys.forEach((key) => {
      let name2 = key;
      let getter = () => props[key];
      let setter = (value) => props[key] = value;
      if (typeof key === "object") {
        name2 = key.key;
        getter = key.getter || getter;
        setter = key.setter || setter;
      }
      if (o[name2] && !overwrite) {
        return;
      }
      o[name2] = {
        get: getter,
        set: setter
      };
    });
  });
};
var animations = ({mixinConfig, viewProps, viewInternalAPI, viewExternalAPI}) => {
  const initialProps = {...viewProps};
  const animations2 = [];
  forin(mixinConfig, (property, animation) => {
    const animator2 = createAnimator(animation);
    if (!animator2) {
      return;
    }
    animator2.onupdate = (value) => {
      viewProps[property] = value;
    };
    animator2.target = initialProps[property];
    const prop = {
      key: property,
      setter: (value) => {
        if (animator2.target === value) {
          return;
        }
        animator2.target = value;
      },
      getter: () => viewProps[property]
    };
    addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);
    animations2.push(animator2);
  });
  return {
    write: (ts) => {
      let skipToEndState = document.hidden;
      let resting = true;
      animations2.forEach((animation) => {
        if (!animation.resting)
          resting = false;
        animation.interpolate(ts, skipToEndState);
      });
      return resting;
    },
    destroy: () => {
    }
  };
};
var addEvent = (element) => (type, fn2) => {
  element.addEventListener(type, fn2);
};
var removeEvent = (element) => (type, fn2) => {
  element.removeEventListener(type, fn2);
};
var listeners = ({
  mixinConfig,
  viewProps,
  viewInternalAPI,
  viewExternalAPI,
  viewState,
  view
}) => {
  const events = [];
  const add = addEvent(view.element);
  const remove = removeEvent(view.element);
  viewExternalAPI.on = (type, fn2) => {
    events.push({
      type,
      fn: fn2
    });
    add(type, fn2);
  };
  viewExternalAPI.off = (type, fn2) => {
    events.splice(events.findIndex((event) => event.type === type && event.fn === fn2), 1);
    remove(type, fn2);
  };
  return {
    write: () => {
      return true;
    },
    destroy: () => {
      events.forEach((event) => {
        remove(event.type, event.fn);
      });
    }
  };
};
var apis = ({mixinConfig, viewProps, viewExternalAPI}) => {
  addGetSet(mixinConfig, viewExternalAPI, viewProps);
};
var isDefined = (value) => value != null;
var defaults = {
  opacity: 1,
  scaleX: 1,
  scaleY: 1,
  translateX: 0,
  translateY: 0,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  originX: 0,
  originY: 0
};
var styles = ({mixinConfig, viewProps, viewInternalAPI, viewExternalAPI, view}) => {
  const initialProps = {...viewProps};
  const currentProps = {};
  addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);
  const getOffset = () => [viewProps["translateX"] || 0, viewProps["translateY"] || 0];
  const getScale = () => [viewProps["scaleX"] || 0, viewProps["scaleY"] || 0];
  const getRect2 = () => view.rect ? getViewRect(view.rect, view.childViews, getOffset(), getScale()) : null;
  viewInternalAPI.rect = {get: getRect2};
  viewExternalAPI.rect = {get: getRect2};
  mixinConfig.forEach((key) => {
    viewProps[key] = typeof initialProps[key] === "undefined" ? defaults[key] : initialProps[key];
  });
  return {
    write: () => {
      if (!propsHaveChanged(currentProps, viewProps)) {
        return;
      }
      applyStyles(view.element, viewProps);
      Object.assign(currentProps, {...viewProps});
      return true;
    },
    destroy: () => {
    }
  };
};
var propsHaveChanged = (currentProps, newProps) => {
  if (Object.keys(currentProps).length !== Object.keys(newProps).length) {
    return true;
  }
  for (const prop in newProps) {
    if (newProps[prop] !== currentProps[prop]) {
      return true;
    }
  }
  return false;
};
var applyStyles = (element, {
  opacity,
  perspective,
  translateX,
  translateY,
  scaleX,
  scaleY,
  rotateX,
  rotateY,
  rotateZ,
  originX,
  originY,
  width,
  height
}) => {
  let transforms2 = "";
  let styles2 = "";
  if (isDefined(originX) || isDefined(originY)) {
    styles2 += `transform-origin: ${originX || 0}px ${originY || 0}px;`;
  }
  if (isDefined(perspective)) {
    transforms2 += `perspective(${perspective}px) `;
  }
  if (isDefined(translateX) || isDefined(translateY)) {
    transforms2 += `translate3d(${translateX || 0}px, ${translateY || 0}px, 0) `;
  }
  if (isDefined(scaleX) || isDefined(scaleY)) {
    transforms2 += `scale3d(${isDefined(scaleX) ? scaleX : 1}, ${isDefined(scaleY) ? scaleY : 1}, 1) `;
  }
  if (isDefined(rotateZ)) {
    transforms2 += `rotateZ(${rotateZ}rad) `;
  }
  if (isDefined(rotateX)) {
    transforms2 += `rotateX(${rotateX}rad) `;
  }
  if (isDefined(rotateY)) {
    transforms2 += `rotateY(${rotateY}rad) `;
  }
  if (transforms2.length) {
    styles2 += `transform:${transforms2};`;
  }
  if (isDefined(opacity)) {
    styles2 += `opacity:${opacity};`;
    if (opacity === 0) {
      styles2 += `visibility:hidden;`;
    }
    if (opacity < 1) {
      styles2 += `pointer-events:none;`;
    }
  }
  if (isDefined(height)) {
    styles2 += `height:${height}px;`;
  }
  if (isDefined(width)) {
    styles2 += `width:${width}px;`;
  }
  const elementCurrentStyle = element.elementCurrentStyle || "";
  if (styles2.length !== elementCurrentStyle.length || styles2 !== elementCurrentStyle) {
    element.style.cssText = styles2;
    element.elementCurrentStyle = styles2;
  }
};
var Mixins = {
  styles,
  listeners,
  animations,
  apis
};
var updateRect = (rect = {}, element = {}, style = {}) => {
  if (!element.layoutCalculated) {
    rect.paddingTop = parseInt(style.paddingTop, 10) || 0;
    rect.marginTop = parseInt(style.marginTop, 10) || 0;
    rect.marginRight = parseInt(style.marginRight, 10) || 0;
    rect.marginBottom = parseInt(style.marginBottom, 10) || 0;
    rect.marginLeft = parseInt(style.marginLeft, 10) || 0;
    element.layoutCalculated = true;
  }
  rect.left = element.offsetLeft || 0;
  rect.top = element.offsetTop || 0;
  rect.width = element.offsetWidth || 0;
  rect.height = element.offsetHeight || 0;
  rect.right = rect.left + rect.width;
  rect.bottom = rect.top + rect.height;
  rect.scrollTop = element.scrollTop;
  rect.hidden = element.offsetParent === null;
  return rect;
};
var createView = ({
  tag = "div",
  name: name2 = null,
  attributes = {},
  read = () => {
  },
  write: write2 = () => {
  },
  create: create2 = () => {
  },
  destroy: destroy3 = () => {
  },
  filterFrameActionsForChild = (child, actions2) => actions2,
  didCreateView = () => {
  },
  didWriteView = () => {
  },
  ignoreRect = false,
  ignoreRectUpdate = false,
  mixins = []
} = {}) => (store, props = {}) => {
  const element = createElement(tag, `filepond--${name2}`, attributes);
  const style = window.getComputedStyle(element, null);
  const rect = updateRect();
  let frameRect = null;
  let isResting = false;
  const childViews = [];
  const activeMixins = [];
  const ref = {};
  const state2 = {};
  const writers = [
    write2
  ];
  const readers = [
    read
  ];
  const destroyers = [
    destroy3
  ];
  const getElement = () => element;
  const getChildViews = () => childViews.concat();
  const getReference = () => ref;
  const createChildView = (store2) => (view, props2) => view(store2, props2);
  const getRect2 = () => {
    if (frameRect) {
      return frameRect;
    }
    frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);
    return frameRect;
  };
  const getStyle = () => style;
  const _read = () => {
    frameRect = null;
    childViews.forEach((child) => child._read());
    const shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);
    if (shouldUpdate) {
      updateRect(rect, element, style);
    }
    const api = {root: internalAPI, props, rect};
    readers.forEach((reader) => reader(api));
  };
  const _write = (ts, frameActions, shouldOptimize) => {
    let resting = frameActions.length === 0;
    writers.forEach((writer) => {
      const writerResting = writer({
        props,
        root: internalAPI,
        actions: frameActions,
        timestamp: ts,
        shouldOptimize
      });
      if (writerResting === false) {
        resting = false;
      }
    });
    activeMixins.forEach((mixin) => {
      const mixinResting = mixin.write(ts);
      if (mixinResting === false) {
        resting = false;
      }
    });
    childViews.filter((child) => !!child.element.parentNode).forEach((child) => {
      const childResting = child._write(ts, filterFrameActionsForChild(child, frameActions), shouldOptimize);
      if (!childResting) {
        resting = false;
      }
    });
    childViews.forEach((child, index2) => {
      if (child.element.parentNode) {
        return;
      }
      internalAPI.appendChild(child.element, index2);
      child._read();
      child._write(ts, filterFrameActionsForChild(child, frameActions), shouldOptimize);
      resting = false;
    });
    isResting = resting;
    didWriteView({
      props,
      root: internalAPI,
      actions: frameActions,
      timestamp: ts
    });
    return resting;
  };
  const _destroy = () => {
    activeMixins.forEach((mixin) => mixin.destroy());
    destroyers.forEach((destroyer) => {
      destroyer({root: internalAPI, props});
    });
    childViews.forEach((child) => child._destroy());
  };
  const sharedAPIDefinition = {
    element: {
      get: getElement
    },
    style: {
      get: getStyle
    },
    childViews: {
      get: getChildViews
    }
  };
  const internalAPIDefinition = {
    ...sharedAPIDefinition,
    rect: {
      get: getRect2
    },
    ref: {
      get: getReference
    },
    is: (needle) => name2 === needle,
    appendChild: appendChild(element),
    createChildView: createChildView(store),
    linkView: (view) => {
      childViews.push(view);
      return view;
    },
    unlinkView: (view) => {
      childViews.splice(childViews.indexOf(view), 1);
    },
    appendChildView: appendChildView(element, childViews),
    removeChildView: removeChildView(element, childViews),
    registerWriter: (writer) => writers.push(writer),
    registerReader: (reader) => readers.push(reader),
    registerDestroyer: (destroyer) => destroyers.push(destroyer),
    invalidateLayout: () => element.layoutCalculated = false,
    dispatch: store.dispatch,
    query: store.query
  };
  const externalAPIDefinition = {
    element: {
      get: getElement
    },
    childViews: {
      get: getChildViews
    },
    rect: {
      get: getRect2
    },
    resting: {
      get: () => isResting
    },
    isRectIgnored: () => ignoreRect,
    _read,
    _write,
    _destroy
  };
  const mixinAPIDefinition = {
    ...sharedAPIDefinition,
    rect: {
      get: () => rect
    }
  };
  Object.keys(mixins).sort((a, b) => {
    if (a === "styles") {
      return 1;
    } else if (b === "styles") {
      return -1;
    }
    return 0;
  }).forEach((key) => {
    const mixinAPI = Mixins[key]({
      mixinConfig: mixins[key],
      viewProps: props,
      viewState: state2,
      viewInternalAPI: internalAPIDefinition,
      viewExternalAPI: externalAPIDefinition,
      view: createObject(mixinAPIDefinition)
    });
    if (mixinAPI) {
      activeMixins.push(mixinAPI);
    }
  });
  const internalAPI = createObject(internalAPIDefinition);
  create2({
    root: internalAPI,
    props
  });
  const childCount = getChildCount(element);
  childViews.forEach((child, index2) => {
    internalAPI.appendChild(child.element, childCount + index2);
  });
  didCreateView(internalAPI);
  return createObject(externalAPIDefinition);
};
var createPainter = (read, write2, fps = 60) => {
  const name2 = "__framePainter";
  if (window[name2]) {
    window[name2].readers.push(read);
    window[name2].writers.push(write2);
    return;
  }
  window[name2] = {
    readers: [read],
    writers: [write2]
  };
  const painter = window[name2];
  const interval = 1e3 / fps;
  let last = null;
  let id = null;
  let requestTick = null;
  let cancelTick = null;
  const setTimerType = () => {
    if (document.hidden) {
      requestTick = () => window.setTimeout(() => tick(performance.now()), interval);
      cancelTick = () => window.clearTimeout(id);
    } else {
      requestTick = () => window.requestAnimationFrame(tick);
      cancelTick = () => window.cancelAnimationFrame(id);
    }
  };
  document.addEventListener("visibilitychange", () => {
    if (cancelTick)
      cancelTick();
    setTimerType();
    tick(performance.now());
  });
  const tick = (ts) => {
    id = requestTick(tick);
    if (!last) {
      last = ts;
    }
    const delta = ts - last;
    if (delta <= interval) {
      return;
    }
    last = ts - delta % interval;
    painter.readers.forEach((read2) => read2());
    painter.writers.forEach((write3) => write3(ts));
  };
  setTimerType();
  tick(performance.now());
  return {
    pause: () => {
      cancelTick(id);
    }
  };
};
var createRoute = (routes, fn2) => ({root: root2, props, actions: actions2 = [], timestamp, shouldOptimize}) => {
  actions2.filter((action) => routes[action.type]).forEach((action) => routes[action.type]({root: root2, props, action: action.data, timestamp, shouldOptimize}));
  if (fn2) {
    fn2({root: root2, props, actions: actions2, timestamp, shouldOptimize});
  }
};
var insertBefore = (newNode, referenceNode) => referenceNode.parentNode.insertBefore(newNode, referenceNode);
var insertAfter = (newNode, referenceNode) => {
  return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
};
var isArray = (value) => Array.isArray(value);
var isEmpty = (value) => value == null;
var trim = (str) => str.trim();
var toString = (value) => "" + value;
var toArray = (value, splitter = ",") => {
  if (isEmpty(value)) {
    return [];
  }
  if (isArray(value)) {
    return value;
  }
  return toString(value).split(splitter).map(trim).filter((str) => str.length);
};
var isBoolean = (value) => typeof value === "boolean";
var toBoolean = (value) => isBoolean(value) ? value : value === "true";
var isString = (value) => typeof value === "string";
var toNumber = (value) => isNumber(value) ? value : isString(value) ? toString(value).replace(/[a-z]+/gi, "") : 0;
var toInt = (value) => parseInt(toNumber(value), 10);
var toFloat = (value) => parseFloat(toNumber(value));
var isInt = (value) => isNumber(value) && isFinite(value) && Math.floor(value) === value;
var toBytes = (value, base = 1e3) => {
  if (isInt(value)) {
    return value;
  }
  let naturalFileSize = toString(value).trim();
  if (/MB$/i.test(naturalFileSize)) {
    naturalFileSize = naturalFileSize.replace(/MB$i/, "").trim();
    return toInt(naturalFileSize) * base * base;
  }
  if (/KB/i.test(naturalFileSize)) {
    naturalFileSize = naturalFileSize.replace(/KB$i/, "").trim();
    return toInt(naturalFileSize) * base;
  }
  return toInt(naturalFileSize);
};
var isFunction = (value) => typeof value === "function";
var toFunctionReference = (string) => {
  let ref = self;
  let levels = string.split(".");
  let level = null;
  while (level = levels.shift()) {
    ref = ref[level];
    if (!ref) {
      return null;
    }
  }
  return ref;
};
var methods = {
  process: "POST",
  patch: "PATCH",
  revert: "DELETE",
  fetch: "GET",
  restore: "GET",
  load: "GET"
};
var createServerAPI = (outline) => {
  const api = {};
  api.url = isString(outline) ? outline : outline.url || "";
  api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;
  api.headers = outline.headers ? outline.headers : {};
  forin(methods, (key) => {
    api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);
  });
  api.process = outline.process || isString(outline) || outline.url ? api.process : null;
  api.remove = outline.remove || null;
  delete api.headers;
  return api;
};
var createAction = (name2, outline, method, timeout, headers) => {
  if (outline === null) {
    return null;
  }
  if (typeof outline === "function") {
    return outline;
  }
  const action = {
    url: method === "GET" || method === "PATCH" ? `?${name2}=` : "",
    method,
    headers,
    withCredentials: false,
    timeout,
    onload: null,
    ondata: null,
    onerror: null
  };
  if (isString(outline)) {
    action.url = outline;
    return action;
  }
  Object.assign(action, outline);
  if (isString(action.headers)) {
    const parts = action.headers.split(/:(.+)/);
    action.headers = {
      header: parts[0],
      value: parts[1]
    };
  }
  action.withCredentials = toBoolean(action.withCredentials);
  return action;
};
var toServerAPI = (value) => createServerAPI(value);
var isNull = (value) => value === null;
var isObject = (value) => typeof value === "object" && value !== null;
var isAPI = (value) => {
  return isObject(value) && isString(value.url) && isObject(value.process) && isObject(value.revert) && isObject(value.restore) && isObject(value.fetch);
};
var getType = (value) => {
  if (isArray(value)) {
    return "array";
  }
  if (isNull(value)) {
    return "null";
  }
  if (isInt(value)) {
    return "int";
  }
  if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {
    return "bytes";
  }
  if (isAPI(value)) {
    return "api";
  }
  return typeof value;
};
var replaceSingleQuotes = (str) => str.replace(/{\s*'/g, '{"').replace(/'\s*}/g, '"}').replace(/'\s*:/g, '":').replace(/:\s*'/g, ':"').replace(/,\s*'/g, ',"').replace(/'\s*,/g, '",');
var conversionTable = {
  array: toArray,
  boolean: toBoolean,
  int: (value) => getType(value) === "bytes" ? toBytes(value) : toInt(value),
  number: toFloat,
  float: toFloat,
  bytes: toBytes,
  string: (value) => isFunction(value) ? value : toString(value),
  function: (value) => toFunctionReference(value),
  serverapi: toServerAPI,
  object: (value) => {
    try {
      return JSON.parse(replaceSingleQuotes(value));
    } catch (e) {
      return null;
    }
  }
};
var convertTo = (value, type) => conversionTable[type](value);
var getValueByType = (newValue, defaultValue, valueType) => {
  if (newValue === defaultValue) {
    return newValue;
  }
  let newValueType = getType(newValue);
  if (newValueType !== valueType) {
    const convertedValue = convertTo(newValue, valueType);
    newValueType = getType(convertedValue);
    if (convertedValue === null) {
      throw `Trying to assign value with incorrect type to "${option}", allowed type: "${valueType}"`;
    } else {
      newValue = convertedValue;
    }
  }
  return newValue;
};
var createOption = (defaultValue, valueType) => {
  let currentValue = defaultValue;
  return {
    enumerable: true,
    get: () => currentValue,
    set: (newValue) => {
      currentValue = getValueByType(newValue, defaultValue, valueType);
    }
  };
};
var createOptions = (options) => {
  const obj = {};
  forin(options, (prop) => {
    const optionDefinition = options[prop];
    obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);
  });
  return createObject(obj);
};
var createInitialState = (options) => ({
  items: [],
  listUpdateTimeout: null,
  itemUpdateTimeout: null,
  processingQueue: [],
  options: createOptions(options)
});
var fromCamels = (string, separator = "-") => string.split(/(?=[A-Z])/).map((part) => part.toLowerCase()).join(separator);
var createOptionAPI = (store, options) => {
  const obj = {};
  forin(options, (key) => {
    obj[key] = {
      get: () => store.getState().options[key],
      set: (value) => {
        store.dispatch(`SET_${fromCamels(key, "_").toUpperCase()}`, {
          value
        });
      }
    };
  });
  return obj;
};
var createOptionActions = (options) => (dispatch2, query, state2) => {
  const obj = {};
  forin(options, (key) => {
    const name2 = fromCamels(key, "_").toUpperCase();
    obj[`SET_${name2}`] = (action) => {
      try {
        state2.options[key] = action.value;
      } catch (e) {
      }
      dispatch2(`DID_SET_${name2}`, {value: state2.options[key]});
    };
  });
  return obj;
};
var createOptionQueries = (options) => (state2) => {
  const obj = {};
  forin(options, (key) => {
    obj[`GET_${fromCamels(key, "_").toUpperCase()}`] = (action) => state2.options[key];
  });
  return obj;
};
var InteractionMethod = {
  API: 1,
  DROP: 2,
  BROWSE: 3,
  PASTE: 4,
  NONE: 5
};
var getUniqueId = () => Math.random().toString(36).substr(2, 9);
var arrayRemove = (arr, index2) => arr.splice(index2, 1);
var run = (cb, sync) => {
  if (sync) {
    cb();
  } else if (document.hidden) {
    Promise.resolve(1).then(cb);
  } else {
    setTimeout(cb, 0);
  }
};
var on = () => {
  const listeners2 = [];
  const off2 = (event, cb) => {
    arrayRemove(listeners2, listeners2.findIndex((listener) => listener.event === event && (listener.cb === cb || !cb)));
  };
  const fire2 = (event, args, sync) => {
    listeners2.filter((listener) => listener.event === event).map((listener) => listener.cb).forEach((cb) => run(() => cb(...args), sync));
  };
  return {
    fireSync: (event, ...args) => {
      fire2(event, args, true);
    },
    fire: (event, ...args) => {
      fire2(event, args, false);
    },
    on: (event, cb) => {
      listeners2.push({event, cb});
    },
    onOnce: (event, cb) => {
      listeners2.push({
        event,
        cb: (...args) => {
          off2(event, cb);
          cb(...args);
        }
      });
    },
    off: off2
  };
};
var copyObjectPropertiesToObject = (src, target, excluded) => {
  Object.getOwnPropertyNames(src).filter((property) => !excluded.includes(property)).forEach((key) => Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(src, key)));
};
var PRIVATE = [
  "fire",
  "process",
  "revert",
  "load",
  "on",
  "off",
  "onOnce",
  "retryLoad",
  "extend",
  "archive",
  "archived",
  "release",
  "released",
  "requestProcessing",
  "freeze"
];
var createItemAPI = (item2) => {
  const api = {};
  copyObjectPropertiesToObject(item2, api, PRIVATE);
  return api;
};
var removeReleasedItems = (items) => {
  items.forEach((item2, index2) => {
    if (item2.released) {
      arrayRemove(items, index2);
    }
  });
};
var ItemStatus = {
  INIT: 1,
  IDLE: 2,
  PROCESSING_QUEUED: 9,
  PROCESSING: 3,
  PROCESSING_COMPLETE: 5,
  PROCESSING_ERROR: 6,
  PROCESSING_REVERT_ERROR: 10,
  LOADING: 7,
  LOAD_ERROR: 8
};
var FileOrigin = {
  INPUT: 1,
  LIMBO: 2,
  LOCAL: 3
};
var getNonNumeric = (str) => /[^0-9]+/.exec(str);
var getDecimalSeparator = () => getNonNumeric(1.1 .toLocaleString())[0];
var getThousandsSeparator = () => {
  const decimalSeparator = getDecimalSeparator();
  const thousandsStringWithSeparator = 1e3 .toLocaleString();
  const thousandsStringWithoutSeparator = 1e3 .toString();
  if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {
    return getNonNumeric(thousandsStringWithSeparator)[0];
  }
  return decimalSeparator === "." ? "," : ".";
};
var Type = {
  BOOLEAN: "boolean",
  INT: "int",
  NUMBER: "number",
  STRING: "string",
  ARRAY: "array",
  OBJECT: "object",
  FUNCTION: "function",
  ACTION: "action",
  SERVER_API: "serverapi",
  REGEX: "regex"
};
var filters = [];
var applyFilterChain = (key, value, utils) => new Promise((resolve, reject) => {
  const matchingFilters = filters.filter((f) => f.key === key).map((f) => f.cb);
  if (matchingFilters.length === 0) {
    resolve(value);
    return;
  }
  const initialFilter = matchingFilters.shift();
  matchingFilters.reduce((current, next) => current.then((value2) => next(value2, utils)), initialFilter(value, utils)).then((value2) => resolve(value2)).catch((error2) => reject(error2));
});
var applyFilters = (key, value, utils) => filters.filter((f) => f.key === key).map((f) => f.cb(value, utils));
var addFilter = (key, cb) => filters.push({key, cb});
var extendDefaultOptions = (additionalOptions) => Object.assign(defaultOptions, additionalOptions);
var getOptions = () => ({...defaultOptions});
var setOptions = (opts) => {
  forin(opts, (key, value) => {
    if (!defaultOptions[key]) {
      return;
    }
    defaultOptions[key][0] = getValueByType(value, defaultOptions[key][0], defaultOptions[key][1]);
  });
};
var defaultOptions = {
  id: [null, Type.STRING],
  name: ["filepond", Type.STRING],
  disabled: [false, Type.BOOLEAN],
  className: [null, Type.STRING],
  required: [false, Type.BOOLEAN],
  captureMethod: [null, Type.STRING],
  allowSyncAcceptAttribute: [true, Type.BOOLEAN],
  allowDrop: [true, Type.BOOLEAN],
  allowBrowse: [true, Type.BOOLEAN],
  allowPaste: [true, Type.BOOLEAN],
  allowMultiple: [false, Type.BOOLEAN],
  allowReplace: [true, Type.BOOLEAN],
  allowRevert: [true, Type.BOOLEAN],
  allowRemove: [true, Type.BOOLEAN],
  allowProcess: [true, Type.BOOLEAN],
  allowReorder: [false, Type.BOOLEAN],
  allowDirectoriesOnly: [false, Type.BOOLEAN],
  storeAsFile: [false, Type.BOOLEAN],
  forceRevert: [false, Type.BOOLEAN],
  maxFiles: [null, Type.INT],
  checkValidity: [false, Type.BOOLEAN],
  itemInsertLocationFreedom: [true, Type.BOOLEAN],
  itemInsertLocation: ["before", Type.STRING],
  itemInsertInterval: [75, Type.INT],
  dropOnPage: [false, Type.BOOLEAN],
  dropOnElement: [true, Type.BOOLEAN],
  dropValidation: [false, Type.BOOLEAN],
  ignoredFiles: [[".ds_store", "thumbs.db", "desktop.ini"], Type.ARRAY],
  instantUpload: [true, Type.BOOLEAN],
  maxParallelUploads: [2, Type.INT],
  allowMinimumUploadDuration: [true, Type.BOOLEAN],
  chunkUploads: [false, Type.BOOLEAN],
  chunkForce: [false, Type.BOOLEAN],
  chunkSize: [5e6, Type.INT],
  chunkRetryDelays: [[500, 1e3, 3e3], Type.ARRAY],
  server: [null, Type.SERVER_API],
  fileSizeBase: [1e3, Type.INT],
  labelFileSizeBytes: ["bytes", Type.STRING],
  labelFileSizeKilobytes: ["KB", Type.STRING],
  labelFileSizeMegabytes: ["MB", Type.STRING],
  labelFileSizeGigabytes: ["GB", Type.STRING],
  labelDecimalSeparator: [getDecimalSeparator(), Type.STRING],
  labelThousandsSeparator: [getThousandsSeparator(), Type.STRING],
  labelIdle: [
    'Drag & Drop your files or <span class="filepond--label-action">Browse</span>',
    Type.STRING
  ],
  labelInvalidField: ["Field contains invalid files", Type.STRING],
  labelFileWaitingForSize: ["Waiting for size", Type.STRING],
  labelFileSizeNotAvailable: ["Size not available", Type.STRING],
  labelFileCountSingular: ["file in list", Type.STRING],
  labelFileCountPlural: ["files in list", Type.STRING],
  labelFileLoading: ["Loading", Type.STRING],
  labelFileAdded: ["Added", Type.STRING],
  labelFileLoadError: ["Error during load", Type.STRING],
  labelFileRemoved: ["Removed", Type.STRING],
  labelFileRemoveError: ["Error during remove", Type.STRING],
  labelFileProcessing: ["Uploading", Type.STRING],
  labelFileProcessingComplete: ["Upload complete", Type.STRING],
  labelFileProcessingAborted: ["Upload cancelled", Type.STRING],
  labelFileProcessingError: ["Error during upload", Type.STRING],
  labelFileProcessingRevertError: ["Error during revert", Type.STRING],
  labelTapToCancel: ["tap to cancel", Type.STRING],
  labelTapToRetry: ["tap to retry", Type.STRING],
  labelTapToUndo: ["tap to undo", Type.STRING],
  labelButtonRemoveItem: ["Remove", Type.STRING],
  labelButtonAbortItemLoad: ["Abort", Type.STRING],
  labelButtonRetryItemLoad: ["Retry", Type.STRING],
  labelButtonAbortItemProcessing: ["Cancel", Type.STRING],
  labelButtonUndoItemProcessing: ["Undo", Type.STRING],
  labelButtonRetryItemProcessing: ["Retry", Type.STRING],
  labelButtonProcessItem: ["Upload", Type.STRING],
  iconRemove: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  iconProcess: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z" fill="currentColor" fill-rule="evenodd"/></svg>',
    Type.STRING
  ],
  iconRetry: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  iconUndo: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  iconDone: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  oninit: [null, Type.FUNCTION],
  onwarning: [null, Type.FUNCTION],
  onerror: [null, Type.FUNCTION],
  onactivatefile: [null, Type.FUNCTION],
  oninitfile: [null, Type.FUNCTION],
  onaddfilestart: [null, Type.FUNCTION],
  onaddfileprogress: [null, Type.FUNCTION],
  onaddfile: [null, Type.FUNCTION],
  onprocessfilestart: [null, Type.FUNCTION],
  onprocessfileprogress: [null, Type.FUNCTION],
  onprocessfileabort: [null, Type.FUNCTION],
  onprocessfilerevert: [null, Type.FUNCTION],
  onprocessfile: [null, Type.FUNCTION],
  onprocessfiles: [null, Type.FUNCTION],
  onremovefile: [null, Type.FUNCTION],
  onpreparefile: [null, Type.FUNCTION],
  onupdatefiles: [null, Type.FUNCTION],
  onreorderfiles: [null, Type.FUNCTION],
  beforeDropFile: [null, Type.FUNCTION],
  beforeAddFile: [null, Type.FUNCTION],
  beforeRemoveFile: [null, Type.FUNCTION],
  beforePrepareFile: [null, Type.FUNCTION],
  stylePanelLayout: [null, Type.STRING],
  stylePanelAspectRatio: [null, Type.STRING],
  styleItemPanelAspectRatio: [null, Type.STRING],
  styleButtonRemoveItemPosition: ["left", Type.STRING],
  styleButtonProcessItemPosition: ["right", Type.STRING],
  styleLoadIndicatorPosition: ["right", Type.STRING],
  styleProgressIndicatorPosition: ["right", Type.STRING],
  styleButtonRemoveItemAlign: [false, Type.BOOLEAN],
  files: [[], Type.ARRAY],
  credits: [["https://pqina.nl/", "Powered by PQINA"], Type.ARRAY]
};
var getItemByQuery = (items, query) => {
  if (isEmpty(query)) {
    return items[0] || null;
  }
  if (isInt(query)) {
    return items[query] || null;
  }
  if (typeof query === "object") {
    query = query.id;
  }
  return items.find((item2) => item2.id === query) || null;
};
var getNumericAspectRatioFromString = (aspectRatio) => {
  if (isEmpty(aspectRatio)) {
    return aspectRatio;
  }
  if (/:/.test(aspectRatio)) {
    const parts = aspectRatio.split(":");
    return parts[1] / parts[0];
  }
  return parseFloat(aspectRatio);
};
var getActiveItems = (items) => items.filter((item2) => !item2.archived);
var Status = {
  EMPTY: 0,
  IDLE: 1,
  ERROR: 2,
  BUSY: 3,
  READY: 4
};
var res = null;
var canUpdateFileInput = () => {
  if (res === null) {
    try {
      const dataTransfer = new DataTransfer();
      dataTransfer.items.add(new File(["hello world"], "This_Works.txt"));
      const el = document.createElement("input");
      el.setAttribute("type", "file");
      el.files = dataTransfer.files;
      res = el.files.length === 1;
    } catch (err) {
      res = false;
    }
  }
  return res;
};
var ITEM_ERROR = [
  ItemStatus.LOAD_ERROR,
  ItemStatus.PROCESSING_ERROR,
  ItemStatus.PROCESSING_REVERT_ERROR
];
var ITEM_BUSY = [
  ItemStatus.LOADING,
  ItemStatus.PROCESSING,
  ItemStatus.PROCESSING_QUEUED,
  ItemStatus.INIT
];
var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];
var isItemInErrorState = (item2) => ITEM_ERROR.includes(item2.status);
var isItemInBusyState = (item2) => ITEM_BUSY.includes(item2.status);
var isItemInReadyState = (item2) => ITEM_READY.includes(item2.status);
var isAsync = (state2) => isObject(state2.options.server) && (isObject(state2.options.server.process) || isFunction(state2.options.server.process));
var queries = (state2) => ({
  GET_STATUS: () => {
    const items = getActiveItems(state2.items);
    const {EMPTY, ERROR, BUSY, IDLE, READY} = Status;
    if (items.length === 0)
      return EMPTY;
    if (items.some(isItemInErrorState))
      return ERROR;
    if (items.some(isItemInBusyState))
      return BUSY;
    if (items.some(isItemInReadyState))
      return READY;
    return IDLE;
  },
  GET_ITEM: (query) => getItemByQuery(state2.items, query),
  GET_ACTIVE_ITEM: (query) => getItemByQuery(getActiveItems(state2.items), query),
  GET_ACTIVE_ITEMS: () => getActiveItems(state2.items),
  GET_ITEMS: () => state2.items,
  GET_ITEM_NAME: (query) => {
    const item2 = getItemByQuery(state2.items, query);
    return item2 ? item2.filename : null;
  },
  GET_ITEM_SIZE: (query) => {
    const item2 = getItemByQuery(state2.items, query);
    return item2 ? item2.fileSize : null;
  },
  GET_STYLES: () => Object.keys(state2.options).filter((key) => /^style/.test(key)).map((option3) => ({
    name: option3,
    value: state2.options[option3]
  })),
  GET_PANEL_ASPECT_RATIO: () => {
    const isShapeCircle = /circle/.test(state2.options.stylePanelLayout);
    const aspectRatio = isShapeCircle ? 1 : getNumericAspectRatioFromString(state2.options.stylePanelAspectRatio);
    return aspectRatio;
  },
  GET_ITEM_PANEL_ASPECT_RATIO: () => state2.options.styleItemPanelAspectRatio,
  GET_ITEMS_BY_STATUS: (status) => getActiveItems(state2.items).filter((item2) => item2.status === status),
  GET_TOTAL_ITEMS: () => getActiveItems(state2.items).length,
  SHOULD_UPDATE_FILE_INPUT: () => state2.options.storeAsFile && canUpdateFileInput() && !isAsync(state2),
  IS_ASYNC: () => isAsync(state2),
  GET_FILE_SIZE_LABELS: (query) => ({
    labelBytes: query("GET_LABEL_FILE_SIZE_BYTES") || void 0,
    labelKilobytes: query("GET_LABEL_FILE_SIZE_KILOBYTES") || void 0,
    labelMegabytes: query("GET_LABEL_FILE_SIZE_MEGABYTES") || void 0,
    labelGigabytes: query("GET_LABEL_FILE_SIZE_GIGABYTES") || void 0
  })
});
var hasRoomForItem = (state2) => {
  const count = getActiveItems(state2.items).length;
  if (!state2.options.allowMultiple) {
    return count === 0;
  }
  const maxFileCount = state2.options.maxFiles;
  if (maxFileCount === null) {
    return true;
  }
  if (count < maxFileCount) {
    return true;
  }
  return false;
};
var limit = (value, min, max) => Math.max(Math.min(max, value), min);
var arrayInsert = (arr, index2, item2) => arr.splice(index2, 0, item2);
var insertItem = (items, item2, index2) => {
  if (isEmpty(item2)) {
    return null;
  }
  if (typeof index2 === "undefined") {
    items.push(item2);
    return item2;
  }
  index2 = limit(index2, 0, items.length);
  arrayInsert(items, index2, item2);
  return item2;
};
var isBase64DataURI = (str) => /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*)\s*$/i.test(str);
var getFilenameFromURL = (url) => url.split("/").pop().split("?").shift();
var getExtensionFromFilename = (name2) => name2.split(".").pop();
var guesstimateExtension = (type) => {
  if (typeof type !== "string") {
    return "";
  }
  const subtype = type.split("/").pop();
  if (/svg/.test(subtype)) {
    return "svg";
  }
  if (/zip|compressed/.test(subtype)) {
    return "zip";
  }
  if (/plain/.test(subtype)) {
    return "txt";
  }
  if (/msword/.test(subtype)) {
    return "doc";
  }
  if (/[a-z]+/.test(subtype)) {
    if (subtype === "jpeg") {
      return "jpg";
    }
    return subtype;
  }
  return "";
};
var leftPad = (value, padding = "") => (padding + value).slice(-padding.length);
var getDateString = (date = new Date()) => `${date.getFullYear()}-${leftPad(date.getMonth() + 1, "00")}-${leftPad(date.getDate(), "00")}_${leftPad(date.getHours(), "00")}-${leftPad(date.getMinutes(), "00")}-${leftPad(date.getSeconds(), "00")}`;
var getFileFromBlob = (blob2, filename, type = null, extension = null) => {
  const file2 = typeof type === "string" ? blob2.slice(0, blob2.size, type) : blob2.slice(0, blob2.size, blob2.type);
  file2.lastModifiedDate = new Date();
  if (blob2._relativePath)
    file2._relativePath = blob2._relativePath;
  if (!isString(filename)) {
    filename = getDateString();
  }
  if (filename && extension === null && getExtensionFromFilename(filename)) {
    file2.name = filename;
  } else {
    extension = extension || guesstimateExtension(file2.type);
    file2.name = filename + (extension ? "." + extension : "");
  }
  return file2;
};
var getBlobBuilder = () => {
  return window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
};
var createBlob = (arrayBuffer, mimeType) => {
  const BB = getBlobBuilder();
  if (BB) {
    const bb = new BB();
    bb.append(arrayBuffer);
    return bb.getBlob(mimeType);
  }
  return new Blob([arrayBuffer], {
    type: mimeType
  });
};
var getBlobFromByteStringWithMimeType = (byteString, mimeType) => {
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  return createBlob(ab, mimeType);
};
var getMimeTypeFromBase64DataURI = (dataURI) => {
  return (/^data:(.+);/.exec(dataURI) || [])[1] || null;
};
var getBase64DataFromBase64DataURI = (dataURI) => {
  const data3 = dataURI.split(",")[1];
  return data3.replace(/\s/g, "");
};
var getByteStringFromBase64DataURI = (dataURI) => {
  return atob(getBase64DataFromBase64DataURI(dataURI));
};
var getBlobFromBase64DataURI = (dataURI) => {
  const mimeType = getMimeTypeFromBase64DataURI(dataURI);
  const byteString = getByteStringFromBase64DataURI(dataURI);
  return getBlobFromByteStringWithMimeType(byteString, mimeType);
};
var getFileFromBase64DataURI = (dataURI, filename, extension) => {
  return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);
};
var getFileNameFromHeader = (header) => {
  if (!/^content-disposition:/i.test(header))
    return null;
  const matches2 = header.split(/filename=|filename\*=.+''/).splice(1).map((name2) => name2.trim().replace(/^["']|[;"']{0,2}$/g, "")).filter((name2) => name2.length);
  return matches2.length ? decodeURI(matches2[matches2.length - 1]) : null;
};
var getFileSizeFromHeader = (header) => {
  if (/content-length:/i.test(header)) {
    const size = header.match(/[0-9]+/)[0];
    return size ? parseInt(size, 10) : null;
  }
  return null;
};
var getTranfserIdFromHeader = (header) => {
  if (/x-content-transfer-id:/i.test(header)) {
    const id = (header.split(":")[1] || "").trim();
    return id || null;
  }
  return null;
};
var getFileInfoFromHeaders = (headers) => {
  const info = {
    source: null,
    name: null,
    size: null
  };
  const rows = headers.split("\n");
  for (let header of rows) {
    const name2 = getFileNameFromHeader(header);
    if (name2) {
      info.name = name2;
      continue;
    }
    const size = getFileSizeFromHeader(header);
    if (size) {
      info.size = size;
      continue;
    }
    const source = getTranfserIdFromHeader(header);
    if (source) {
      info.source = source;
      continue;
    }
  }
  return info;
};
var createFileLoader = (fetchFn) => {
  const state2 = {
    source: null,
    complete: false,
    progress: 0,
    size: null,
    timestamp: null,
    duration: 0,
    request: null
  };
  const getProgress = () => state2.progress;
  const abort = () => {
    if (state2.request && state2.request.abort) {
      state2.request.abort();
    }
  };
  const load = () => {
    const source = state2.source;
    api.fire("init", source);
    if (source instanceof File) {
      api.fire("load", source);
    } else if (source instanceof Blob) {
      api.fire("load", getFileFromBlob(source, source.name));
    } else if (isBase64DataURI(source)) {
      api.fire("load", getFileFromBase64DataURI(source));
    } else {
      loadURL(source);
    }
  };
  const loadURL = (url) => {
    if (!fetchFn) {
      api.fire("error", {
        type: "error",
        body: "Can't load URL",
        code: 400
      });
      return;
    }
    state2.timestamp = Date.now();
    state2.request = fetchFn(url, (response) => {
      state2.duration = Date.now() - state2.timestamp;
      state2.complete = true;
      if (response instanceof Blob) {
        response = getFileFromBlob(response, response.name || getFilenameFromURL(url));
      }
      api.fire("load", response instanceof Blob ? response : response ? response.body : null);
    }, (error2) => {
      api.fire("error", typeof error2 === "string" ? {
        type: "error",
        code: 0,
        body: error2
      } : error2);
    }, (computable, current, total) => {
      if (total) {
        state2.size = total;
      }
      state2.duration = Date.now() - state2.timestamp;
      if (!computable) {
        state2.progress = null;
        return;
      }
      state2.progress = current / total;
      api.fire("progress", state2.progress);
    }, () => {
      api.fire("abort");
    }, (response) => {
      const fileinfo = getFileInfoFromHeaders(typeof response === "string" ? response : response.headers);
      api.fire("meta", {
        size: state2.size || fileinfo.size,
        filename: fileinfo.name,
        source: fileinfo.source
      });
    });
  };
  const api = {
    ...on(),
    setSource: (source) => state2.source = source,
    getProgress,
    abort,
    load
  };
  return api;
};
var isGet = (method) => /GET|HEAD/.test(method);
var sendRequest = (data3, url, options) => {
  const api = {
    onheaders: () => {
    },
    onprogress: () => {
    },
    onload: () => {
    },
    ontimeout: () => {
    },
    onerror: () => {
    },
    onabort: () => {
    },
    abort: () => {
      aborted = true;
      xhr.abort();
    }
  };
  let aborted = false;
  let headersReceived = false;
  options = {
    method: "POST",
    headers: {},
    withCredentials: false,
    ...options
  };
  url = encodeURI(url);
  if (isGet(options.method) && data3) {
    url = `${url}${encodeURIComponent(typeof data3 === "string" ? data3 : JSON.stringify(data3))}`;
  }
  const xhr = new XMLHttpRequest();
  const process = isGet(options.method) ? xhr : xhr.upload;
  process.onprogress = (e) => {
    if (aborted) {
      return;
    }
    api.onprogress(e.lengthComputable, e.loaded, e.total);
  };
  xhr.onreadystatechange = () => {
    if (xhr.readyState < 2) {
      return;
    }
    if (xhr.readyState === 4 && xhr.status === 0) {
      return;
    }
    if (headersReceived) {
      return;
    }
    headersReceived = true;
    api.onheaders(xhr);
  };
  xhr.onload = () => {
    if (xhr.status >= 200 && xhr.status < 300) {
      api.onload(xhr);
    } else {
      api.onerror(xhr);
    }
  };
  xhr.onerror = () => api.onerror(xhr);
  xhr.onabort = () => {
    aborted = true;
    api.onabort();
  };
  xhr.ontimeout = () => api.ontimeout(xhr);
  xhr.open(options.method, url, true);
  if (isInt(options.timeout)) {
    xhr.timeout = options.timeout;
  }
  Object.keys(options.headers).forEach((key) => {
    const value = unescape(encodeURIComponent(options.headers[key]));
    xhr.setRequestHeader(key, value);
  });
  if (options.responseType) {
    xhr.responseType = options.responseType;
  }
  if (options.withCredentials) {
    xhr.withCredentials = true;
  }
  xhr.send(data3);
  return api;
};
var createResponse = (type, code, body, headers) => ({
  type,
  code,
  body,
  headers
});
var createTimeoutResponse = (cb) => (xhr) => {
  cb(createResponse("error", 0, "Timeout", xhr.getAllResponseHeaders()));
};
var hasQS = (str) => /\?/.test(str);
var buildURL = (...parts) => {
  let url = "";
  parts.forEach((part) => {
    url += hasQS(url) && hasQS(part) ? part.replace(/\?/, "&") : part;
  });
  return url;
};
var createFetchFunction = (apiUrl = "", action) => {
  if (typeof action === "function") {
    return action;
  }
  if (!action || !isString(action.url)) {
    return null;
  }
  const onload = action.onload || ((res2) => res2);
  const onerror = action.onerror || ((res2) => null);
  return (url, load, error2, progress, abort, headers) => {
    const request = sendRequest(url, buildURL(apiUrl, action.url), {
      ...action,
      responseType: "blob"
    });
    request.onload = (xhr) => {
      const headers2 = xhr.getAllResponseHeaders();
      const filename = getFileInfoFromHeaders(headers2).name || getFilenameFromURL(url);
      load(createResponse("load", xhr.status, action.method === "HEAD" ? null : getFileFromBlob(onload(xhr.response), filename), headers2));
    };
    request.onerror = (xhr) => {
      error2(createResponse("error", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));
    };
    request.onheaders = (xhr) => {
      headers(createResponse("headers", xhr.status, null, xhr.getAllResponseHeaders()));
    };
    request.ontimeout = createTimeoutResponse(error2);
    request.onprogress = progress;
    request.onabort = abort;
    return request;
  };
};
var ChunkStatus = {
  QUEUED: 0,
  COMPLETE: 1,
  PROCESSING: 2,
  ERROR: 3,
  WAITING: 4
};
var processFileChunked = (apiUrl, action, name2, file2, metadata, load, error2, progress, abort, transfer, options) => {
  const chunks = [];
  const {chunkTransferId, chunkServer, chunkSize, chunkRetryDelays} = options;
  const state2 = {
    serverId: chunkTransferId,
    aborted: false
  };
  const ondata = action.ondata || ((fd) => fd);
  const onload = action.onload || ((xhr, method) => method === "HEAD" ? xhr.getResponseHeader("Upload-Offset") : xhr.response);
  const onerror = action.onerror || ((res2) => null);
  const requestTransferId = (cb) => {
    const formData = new FormData();
    if (isObject(metadata))
      formData.append(name2, JSON.stringify(metadata));
    const headers = typeof action.headers === "function" ? action.headers(file2, metadata) : {
      ...action.headers,
      "Upload-Length": file2.size
    };
    const requestParams = {
      ...action,
      headers
    };
    const request = sendRequest(ondata(formData), buildURL(apiUrl, action.url), requestParams);
    request.onload = (xhr) => cb(onload(xhr, requestParams.method));
    request.onerror = (xhr) => error2(createResponse("error", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));
    request.ontimeout = createTimeoutResponse(error2);
  };
  const requestTransferOffset = (cb) => {
    const requestUrl = buildURL(apiUrl, chunkServer.url, state2.serverId);
    const headers = typeof action.headers === "function" ? action.headers(state2.serverId) : {
      ...action.headers
    };
    const requestParams = {
      headers,
      method: "HEAD"
    };
    const request = sendRequest(null, requestUrl, requestParams);
    request.onload = (xhr) => cb(onload(xhr, requestParams.method));
    request.onerror = (xhr) => error2(createResponse("error", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));
    request.ontimeout = createTimeoutResponse(error2);
  };
  const lastChunkIndex = Math.floor(file2.size / chunkSize);
  for (let i = 0; i <= lastChunkIndex; i++) {
    const offset = i * chunkSize;
    const data3 = file2.slice(offset, offset + chunkSize, "application/offset+octet-stream");
    chunks[i] = {
      index: i,
      size: data3.size,
      offset,
      data: data3,
      file: file2,
      progress: 0,
      retries: [...chunkRetryDelays],
      status: ChunkStatus.QUEUED,
      error: null,
      request: null,
      timeout: null
    };
  }
  const completeProcessingChunks = () => load(state2.serverId);
  const canProcessChunk = (chunk) => chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;
  const processChunk = (chunk) => {
    if (state2.aborted)
      return;
    chunk = chunk || chunks.find(canProcessChunk);
    if (!chunk) {
      if (chunks.every((chunk2) => chunk2.status === ChunkStatus.COMPLETE)) {
        completeProcessingChunks();
      }
      return;
    }
    chunk.status = ChunkStatus.PROCESSING;
    chunk.progress = null;
    const ondata2 = chunkServer.ondata || ((fd) => fd);
    const onerror2 = chunkServer.onerror || ((res2) => null);
    const requestUrl = buildURL(apiUrl, chunkServer.url, state2.serverId);
    const headers = typeof chunkServer.headers === "function" ? chunkServer.headers(chunk) : {
      ...chunkServer.headers,
      "Content-Type": "application/offset+octet-stream",
      "Upload-Offset": chunk.offset,
      "Upload-Length": file2.size,
      "Upload-Name": file2.name
    };
    const request = chunk.request = sendRequest(ondata2(chunk.data), requestUrl, {
      ...chunkServer,
      headers
    });
    request.onload = () => {
      chunk.status = ChunkStatus.COMPLETE;
      chunk.request = null;
      processChunks();
    };
    request.onprogress = (lengthComputable, loaded, total) => {
      chunk.progress = lengthComputable ? loaded : null;
      updateTotalProgress();
    };
    request.onerror = (xhr) => {
      chunk.status = ChunkStatus.ERROR;
      chunk.request = null;
      chunk.error = onerror2(xhr.response) || xhr.statusText;
      if (!retryProcessChunk(chunk)) {
        error2(createResponse("error", xhr.status, onerror2(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));
      }
    };
    request.ontimeout = (xhr) => {
      chunk.status = ChunkStatus.ERROR;
      chunk.request = null;
      if (!retryProcessChunk(chunk)) {
        createTimeoutResponse(error2)(xhr);
      }
    };
    request.onabort = () => {
      chunk.status = ChunkStatus.QUEUED;
      chunk.request = null;
      abort();
    };
  };
  const retryProcessChunk = (chunk) => {
    if (chunk.retries.length === 0)
      return false;
    chunk.status = ChunkStatus.WAITING;
    clearTimeout(chunk.timeout);
    chunk.timeout = setTimeout(() => {
      processChunk(chunk);
    }, chunk.retries.shift());
    return true;
  };
  const updateTotalProgress = () => {
    const totalBytesTransfered = chunks.reduce((p, chunk) => {
      if (p === null || chunk.progress === null)
        return null;
      return p + chunk.progress;
    }, 0);
    if (totalBytesTransfered === null)
      return progress(false, 0, 0);
    const totalSize = chunks.reduce((total, chunk) => total + chunk.size, 0);
    progress(true, totalBytesTransfered, totalSize);
  };
  const processChunks = () => {
    const totalProcessing = chunks.filter((chunk) => chunk.status === ChunkStatus.PROCESSING).length;
    if (totalProcessing >= 1)
      return;
    processChunk();
  };
  const abortChunks = () => {
    chunks.forEach((chunk) => {
      clearTimeout(chunk.timeout);
      if (chunk.request) {
        chunk.request.abort();
      }
    });
  };
  if (!state2.serverId) {
    requestTransferId((serverId) => {
      if (state2.aborted)
        return;
      transfer(serverId);
      state2.serverId = serverId;
      processChunks();
    });
  } else {
    requestTransferOffset((offset) => {
      if (state2.aborted)
        return;
      chunks.filter((chunk) => chunk.offset < offset).forEach((chunk) => {
        chunk.status = ChunkStatus.COMPLETE;
        chunk.progress = chunk.size;
      });
      processChunks();
    });
  }
  return {
    abort: () => {
      state2.aborted = true;
      abortChunks();
    }
  };
};
var createFileProcessorFunction = (apiUrl, action, name2, options) => (file2, metadata, load, error2, progress, abort, transfer) => {
  if (!file2)
    return;
  const canChunkUpload = options.chunkUploads;
  const shouldChunkUpload = canChunkUpload && file2.size > options.chunkSize;
  const willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);
  if (file2 instanceof Blob && willChunkUpload)
    return processFileChunked(apiUrl, action, name2, file2, metadata, load, error2, progress, abort, transfer, options);
  const ondata = action.ondata || ((fd) => fd);
  const onload = action.onload || ((res2) => res2);
  const onerror = action.onerror || ((res2) => null);
  const headers = typeof action.headers === "function" ? action.headers(file2, metadata) || {} : {
    ...action.headers
  };
  const requestParams = {
    ...action,
    headers
  };
  var formData = new FormData();
  if (isObject(metadata)) {
    formData.append(name2, JSON.stringify(metadata));
  }
  (file2 instanceof Blob ? [{name: null, file: file2}] : file2).forEach((item2) => {
    formData.append(name2, item2.file, item2.name === null ? item2.file.name : `${item2.name}${item2.file.name}`);
  });
  const request = sendRequest(ondata(formData), buildURL(apiUrl, action.url), requestParams);
  request.onload = (xhr) => {
    load(createResponse("load", xhr.status, onload(xhr.response), xhr.getAllResponseHeaders()));
  };
  request.onerror = (xhr) => {
    error2(createResponse("error", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));
  };
  request.ontimeout = createTimeoutResponse(error2);
  request.onprogress = progress;
  request.onabort = abort;
  return request;
};
var createProcessorFunction = (apiUrl = "", action, name2, options) => {
  if (typeof action === "function")
    return (...params) => action(name2, ...params, options);
  if (!action || !isString(action.url))
    return null;
  return createFileProcessorFunction(apiUrl, action, name2, options);
};
var createRevertFunction = (apiUrl = "", action) => {
  if (typeof action === "function") {
    return action;
  }
  if (!action || !isString(action.url)) {
    return (uniqueFileId, load) => load();
  }
  const onload = action.onload || ((res2) => res2);
  const onerror = action.onerror || ((res2) => null);
  return (uniqueFileId, load, error2) => {
    const request = sendRequest(uniqueFileId, apiUrl + action.url, action);
    request.onload = (xhr) => {
      load(createResponse("load", xhr.status, onload(xhr.response), xhr.getAllResponseHeaders()));
    };
    request.onerror = (xhr) => {
      error2(createResponse("error", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));
    };
    request.ontimeout = createTimeoutResponse(error2);
    return request;
  };
};
var getRandomNumber = (min = 0, max = 1) => min + Math.random() * (max - min);
var createPerceivedPerformanceUpdater = (cb, duration = 1e3, offset = 0, tickMin = 25, tickMax = 250) => {
  let timeout = null;
  const start = Date.now();
  const tick = () => {
    let runtime = Date.now() - start;
    let delay = getRandomNumber(tickMin, tickMax);
    if (runtime + delay > duration) {
      delay = runtime + delay - duration;
    }
    let progress = runtime / duration;
    if (progress >= 1 || document.hidden) {
      cb(1);
      return;
    }
    cb(progress);
    timeout = setTimeout(tick, delay);
  };
  if (duration > 0)
    tick();
  return {
    clear: () => {
      clearTimeout(timeout);
    }
  };
};
var createFileProcessor = (processFn, options) => {
  const state2 = {
    complete: false,
    perceivedProgress: 0,
    perceivedPerformanceUpdater: null,
    progress: null,
    timestamp: null,
    perceivedDuration: 0,
    duration: 0,
    request: null,
    response: null
  };
  const {allowMinimumUploadDuration} = options;
  const process = (file2, metadata) => {
    const progressFn = () => {
      if (state2.duration === 0 || state2.progress === null)
        return;
      api.fire("progress", api.getProgress());
    };
    const completeFn = () => {
      state2.complete = true;
      api.fire("load-perceived", state2.response.body);
    };
    api.fire("start");
    state2.timestamp = Date.now();
    state2.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater((progress) => {
      state2.perceivedProgress = progress;
      state2.perceivedDuration = Date.now() - state2.timestamp;
      progressFn();
      if (state2.response && state2.perceivedProgress === 1 && !state2.complete) {
        completeFn();
      }
    }, allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0);
    state2.request = processFn(file2, metadata, (response) => {
      state2.response = isObject(response) ? response : {
        type: "load",
        code: 200,
        body: `${response}`,
        headers: {}
      };
      state2.duration = Date.now() - state2.timestamp;
      state2.progress = 1;
      api.fire("load", state2.response.body);
      if (!allowMinimumUploadDuration || allowMinimumUploadDuration && state2.perceivedProgress === 1) {
        completeFn();
      }
    }, (error2) => {
      state2.perceivedPerformanceUpdater.clear();
      api.fire("error", isObject(error2) ? error2 : {
        type: "error",
        code: 0,
        body: `${error2}`
      });
    }, (computable, current, total) => {
      state2.duration = Date.now() - state2.timestamp;
      state2.progress = computable ? current / total : null;
      progressFn();
    }, () => {
      state2.perceivedPerformanceUpdater.clear();
      api.fire("abort", state2.response ? state2.response.body : null);
    }, (transferId) => {
      api.fire("transfer", transferId);
    });
  };
  const abort = () => {
    if (!state2.request)
      return;
    state2.perceivedPerformanceUpdater.clear();
    if (state2.request.abort)
      state2.request.abort();
    state2.complete = true;
  };
  const reset = () => {
    abort();
    state2.complete = false;
    state2.perceivedProgress = 0;
    state2.progress = 0;
    state2.timestamp = null;
    state2.perceivedDuration = 0;
    state2.duration = 0;
    state2.request = null;
    state2.response = null;
  };
  const getProgress = allowMinimumUploadDuration ? () => state2.progress ? Math.min(state2.progress, state2.perceivedProgress) : null : () => state2.progress || null;
  const getDuration = allowMinimumUploadDuration ? () => Math.min(state2.duration, state2.perceivedDuration) : () => state2.duration;
  const api = {
    ...on(),
    process,
    abort,
    getProgress,
    getDuration,
    reset
  };
  return api;
};
var getFilenameWithoutExtension = (name2) => name2.substr(0, name2.lastIndexOf(".")) || name2;
var createFileStub = (source) => {
  let data3 = [source.name, source.size, source.type];
  if (source instanceof Blob || isBase64DataURI(source)) {
    data3[0] = source.name || getDateString();
  } else if (isBase64DataURI(source)) {
    data3[1] = source.length;
    data3[2] = getMimeTypeFromBase64DataURI(source);
  } else if (isString(source)) {
    data3[0] = getFilenameFromURL(source);
    data3[1] = 0;
    data3[2] = "application/octet-stream";
  }
  return {
    name: data3[0],
    size: data3[1],
    type: data3[2]
  };
};
var isFile = (value) => !!(value instanceof File || value instanceof Blob && value.name);
var deepCloneObject = (src) => {
  if (!isObject(src))
    return src;
  const target = isArray(src) ? [] : {};
  for (const key in src) {
    if (!src.hasOwnProperty(key))
      continue;
    const v = src[key];
    target[key] = v && isObject(v) ? deepCloneObject(v) : v;
  }
  return target;
};
var createItem = (origin = null, serverFileReference = null, file2 = null) => {
  const id = getUniqueId();
  const state2 = {
    archived: false,
    frozen: false,
    released: false,
    source: null,
    file: file2,
    serverFileReference,
    transferId: null,
    processingAborted: false,
    status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,
    activeLoader: null,
    activeProcessor: null
  };
  let abortProcessingRequestComplete = null;
  const metadata = {};
  const setStatus = (status) => state2.status = status;
  const fire2 = (event, ...params) => {
    if (state2.released || state2.frozen)
      return;
    api.fire(event, ...params);
  };
  const getFileExtension = () => getExtensionFromFilename(state2.file.name);
  const getFileType = () => state2.file.type;
  const getFileSize = () => state2.file.size;
  const getFile = () => state2.file;
  const load = (source, loader, onload) => {
    state2.source = source;
    api.fireSync("init");
    if (state2.file) {
      api.fireSync("load-skip");
      return;
    }
    state2.file = createFileStub(source);
    loader.on("init", () => {
      fire2("load-init");
    });
    loader.on("meta", (meta) => {
      state2.file.size = meta.size;
      state2.file.filename = meta.filename;
      if (meta.source) {
        origin = FileOrigin.LIMBO;
        state2.serverFileReference = meta.source;
        state2.status = ItemStatus.PROCESSING_COMPLETE;
      }
      fire2("load-meta");
    });
    loader.on("progress", (progress) => {
      setStatus(ItemStatus.LOADING);
      fire2("load-progress", progress);
    });
    loader.on("error", (error2) => {
      setStatus(ItemStatus.LOAD_ERROR);
      fire2("load-request-error", error2);
    });
    loader.on("abort", () => {
      setStatus(ItemStatus.INIT);
      fire2("load-abort");
    });
    loader.on("load", (file3) => {
      state2.activeLoader = null;
      const success = (result) => {
        state2.file = isFile(result) ? result : state2.file;
        if (origin === FileOrigin.LIMBO && state2.serverFileReference) {
          setStatus(ItemStatus.PROCESSING_COMPLETE);
        } else {
          setStatus(ItemStatus.IDLE);
        }
        fire2("load");
      };
      const error2 = (result) => {
        state2.file = file3;
        fire2("load-meta");
        setStatus(ItemStatus.LOAD_ERROR);
        fire2("load-file-error", result);
      };
      if (state2.serverFileReference) {
        success(file3);
        return;
      }
      onload(file3, success, error2);
    });
    loader.setSource(source);
    state2.activeLoader = loader;
    loader.load();
  };
  const retryLoad = () => {
    if (!state2.activeLoader) {
      return;
    }
    state2.activeLoader.load();
  };
  const abortLoad = () => {
    if (state2.activeLoader) {
      state2.activeLoader.abort();
      return;
    }
    setStatus(ItemStatus.INIT);
    fire2("load-abort");
  };
  const process = (processor, onprocess) => {
    if (state2.processingAborted) {
      state2.processingAborted = false;
      return;
    }
    setStatus(ItemStatus.PROCESSING);
    abortProcessingRequestComplete = null;
    if (!(state2.file instanceof Blob)) {
      api.on("load", () => {
        process(processor, onprocess);
      });
      return;
    }
    processor.on("load", (serverFileReference2) => {
      state2.transferId = null;
      state2.serverFileReference = serverFileReference2;
    });
    processor.on("transfer", (transferId) => {
      state2.transferId = transferId;
    });
    processor.on("load-perceived", (serverFileReference2) => {
      state2.activeProcessor = null;
      state2.transferId = null;
      state2.serverFileReference = serverFileReference2;
      setStatus(ItemStatus.PROCESSING_COMPLETE);
      fire2("process-complete", serverFileReference2);
    });
    processor.on("start", () => {
      fire2("process-start");
    });
    processor.on("error", (error3) => {
      state2.activeProcessor = null;
      setStatus(ItemStatus.PROCESSING_ERROR);
      fire2("process-error", error3);
    });
    processor.on("abort", (serverFileReference2) => {
      state2.activeProcessor = null;
      state2.serverFileReference = serverFileReference2;
      setStatus(ItemStatus.IDLE);
      fire2("process-abort");
      if (abortProcessingRequestComplete) {
        abortProcessingRequestComplete();
      }
    });
    processor.on("progress", (progress) => {
      fire2("process-progress", progress);
    });
    const success = (file3) => {
      if (state2.archived)
        return;
      processor.process(file3, {...metadata});
    };
    const error2 = console.error;
    onprocess(state2.file, success, error2);
    state2.activeProcessor = processor;
  };
  const requestProcessing = () => {
    state2.processingAborted = false;
    setStatus(ItemStatus.PROCESSING_QUEUED);
  };
  const abortProcessing = () => new Promise((resolve) => {
    if (!state2.activeProcessor) {
      state2.processingAborted = true;
      setStatus(ItemStatus.IDLE);
      fire2("process-abort");
      resolve();
      return;
    }
    abortProcessingRequestComplete = () => {
      resolve();
    };
    state2.activeProcessor.abort();
  });
  const revert = (revertFileUpload, forceRevert) => new Promise((resolve, reject) => {
    const serverTransferId = state2.serverFileReference !== null ? state2.serverFileReference : state2.transferId;
    if (serverTransferId === null) {
      resolve();
      return;
    }
    revertFileUpload(serverTransferId, () => {
      state2.serverFileReference = null;
      state2.transferId = null;
      resolve();
    }, (error2) => {
      if (!forceRevert) {
        resolve();
        return;
      }
      setStatus(ItemStatus.PROCESSING_REVERT_ERROR);
      fire2("process-revert-error");
      reject(error2);
    });
    setStatus(ItemStatus.IDLE);
    fire2("process-revert");
  });
  const setMetadata = (key, value, silent) => {
    const keys = key.split(".");
    const root2 = keys[0];
    const last = keys.pop();
    let data3 = metadata;
    keys.forEach((key2) => data3 = data3[key2]);
    if (JSON.stringify(data3[last]) === JSON.stringify(value))
      return;
    data3[last] = value;
    fire2("metadata-update", {
      key: root2,
      value: metadata[root2],
      silent
    });
  };
  const getMetadata = (key) => deepCloneObject(key ? metadata[key] : metadata);
  const api = {
    id: {get: () => id},
    origin: {get: () => origin, set: (value) => origin = value},
    serverId: {get: () => state2.serverFileReference},
    transferId: {get: () => state2.transferId},
    status: {get: () => state2.status},
    filename: {get: () => state2.file.name},
    filenameWithoutExtension: {get: () => getFilenameWithoutExtension(state2.file.name)},
    fileExtension: {get: getFileExtension},
    fileType: {get: getFileType},
    fileSize: {get: getFileSize},
    file: {get: getFile},
    relativePath: {get: () => state2.file._relativePath},
    source: {get: () => state2.source},
    getMetadata,
    setMetadata: (key, value, silent) => {
      if (isObject(key)) {
        const data3 = key;
        Object.keys(data3).forEach((key2) => {
          setMetadata(key2, data3[key2], value);
        });
        return key;
      }
      setMetadata(key, value, silent);
      return value;
    },
    extend: (name2, handler) => itemAPI[name2] = handler,
    abortLoad,
    retryLoad,
    requestProcessing,
    abortProcessing,
    load,
    process,
    revert,
    ...on(),
    freeze: () => state2.frozen = true,
    release: () => state2.released = true,
    released: {get: () => state2.released},
    archive: () => state2.archived = true,
    archived: {get: () => state2.archived}
  };
  const itemAPI = createObject(api);
  return itemAPI;
};
var getItemIndexByQuery = (items, query) => {
  if (isEmpty(query)) {
    return 0;
  }
  if (!isString(query)) {
    return -1;
  }
  return items.findIndex((item2) => item2.id === query);
};
var getItemById = (items, itemId) => {
  const index2 = getItemIndexByQuery(items, itemId);
  if (index2 < 0) {
    return;
  }
  return items[index2] || null;
};
var fetchBlob = (url, load, error2, progress, abort, headers) => {
  const request = sendRequest(null, url, {
    method: "GET",
    responseType: "blob"
  });
  request.onload = (xhr) => {
    const headers2 = xhr.getAllResponseHeaders();
    const filename = getFileInfoFromHeaders(headers2).name || getFilenameFromURL(url);
    load(createResponse("load", xhr.status, getFileFromBlob(xhr.response, filename), headers2));
  };
  request.onerror = (xhr) => {
    error2(createResponse("error", xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));
  };
  request.onheaders = (xhr) => {
    headers(createResponse("headers", xhr.status, null, xhr.getAllResponseHeaders()));
  };
  request.ontimeout = createTimeoutResponse(error2);
  request.onprogress = progress;
  request.onabort = abort;
  return request;
};
var getDomainFromURL = (url) => {
  if (url.indexOf("//") === 0) {
    url = location.protocol + url;
  }
  return url.toLowerCase().replace("blob:", "").replace(/([a-z])?:\/\//, "$1").split("/")[0];
};
var isExternalURL = (url) => (url.indexOf(":") > -1 || url.indexOf("//") > -1) && getDomainFromURL(location.href) !== getDomainFromURL(url);
var dynamicLabel = (label) => (...params) => isFunction(label) ? label(...params) : label;
var isMockItem = (item2) => !isFile(item2.file);
var listUpdated = (dispatch2, state2) => {
  clearTimeout(state2.listUpdateTimeout);
  state2.listUpdateTimeout = setTimeout(() => {
    dispatch2("DID_UPDATE_ITEMS", {items: getActiveItems(state2.items)});
  }, 0);
};
var optionalPromise = (fn2, ...params) => new Promise((resolve) => {
  if (!fn2) {
    return resolve(true);
  }
  const result = fn2(...params);
  if (result == null) {
    return resolve(true);
  }
  if (typeof result === "boolean") {
    return resolve(result);
  }
  if (typeof result.then === "function") {
    result.then(resolve);
  }
});
var sortItems = (state2, compare) => {
  state2.items.sort((a, b) => compare(createItemAPI(a), createItemAPI(b)));
};
var getItemByQueryFromState = (state2, itemHandler) => ({
  query,
  success = () => {
  },
  failure = () => {
  },
  ...options
} = {}) => {
  const item2 = getItemByQuery(state2.items, query);
  if (!item2) {
    failure({
      error: createResponse("error", 0, "Item not found"),
      file: null
    });
    return;
  }
  itemHandler(item2, success, failure, options || {});
};
var actions = (dispatch2, query, state2) => ({
  ABORT_ALL: () => {
    getActiveItems(state2.items).forEach((item2) => {
      item2.freeze();
      item2.abortLoad();
      item2.abortProcessing();
    });
  },
  DID_SET_FILES: ({value = []}) => {
    const files = value.map((file2) => ({
      source: file2.source ? file2.source : file2,
      options: file2.options
    }));
    let activeItems = getActiveItems(state2.items);
    activeItems.forEach((item2) => {
      if (!files.find((file2) => file2.source === item2.source || file2.source === item2.file)) {
        dispatch2("REMOVE_ITEM", {query: item2, remove: false});
      }
    });
    activeItems = getActiveItems(state2.items);
    files.forEach((file2, index2) => {
      if (activeItems.find((item2) => item2.source === file2.source || item2.file === file2.source))
        return;
      dispatch2("ADD_ITEM", {
        ...file2,
        interactionMethod: InteractionMethod.NONE,
        index: index2
      });
    });
  },
  DID_UPDATE_ITEM_METADATA: ({id, action, change}) => {
    if (change.silent)
      return;
    clearTimeout(state2.itemUpdateTimeout);
    state2.itemUpdateTimeout = setTimeout(() => {
      const item2 = getItemById(state2.items, id);
      if (!query("IS_ASYNC")) {
        applyFilterChain("SHOULD_PREPARE_OUTPUT", false, {
          item: item2,
          query,
          action,
          change
        }).then((shouldPrepareOutput) => {
          const beforePrepareFile = query("GET_BEFORE_PREPARE_FILE");
          if (beforePrepareFile)
            shouldPrepareOutput = beforePrepareFile(item2, shouldPrepareOutput);
          if (!shouldPrepareOutput)
            return;
          dispatch2("REQUEST_PREPARE_OUTPUT", {
            query: id,
            item: item2,
            success: (file2) => {
              dispatch2("DID_PREPARE_OUTPUT", {id, file: file2});
            }
          }, true);
        });
        return;
      }
      if (item2.origin === FileOrigin.LOCAL) {
        dispatch2("DID_LOAD_ITEM", {
          id: item2.id,
          error: null,
          serverFileReference: item2.source
        });
      }
      const upload = () => {
        setTimeout(() => {
          dispatch2("REQUEST_ITEM_PROCESSING", {query: id});
        }, 32);
      };
      const revert = (doUpload) => {
        item2.revert(createRevertFunction(state2.options.server.url, state2.options.server.revert), query("GET_FORCE_REVERT")).then(doUpload ? upload : () => {
        }).catch(() => {
        });
      };
      const abort = (doUpload) => {
        item2.abortProcessing().then(doUpload ? upload : () => {
        });
      };
      if (item2.status === ItemStatus.PROCESSING_COMPLETE) {
        return revert(state2.options.instantUpload);
      }
      if (item2.status === ItemStatus.PROCESSING) {
        return abort(state2.options.instantUpload);
      }
      if (state2.options.instantUpload) {
        upload();
      }
    }, 0);
  },
  MOVE_ITEM: ({query: query2, index: index2}) => {
    const item2 = getItemByQuery(state2.items, query2);
    if (!item2)
      return;
    const currentIndex = state2.items.indexOf(item2);
    index2 = limit(index2, 0, state2.items.length - 1);
    if (currentIndex === index2)
      return;
    state2.items.splice(index2, 0, state2.items.splice(currentIndex, 1)[0]);
  },
  SORT: ({compare}) => {
    sortItems(state2, compare);
    dispatch2("DID_SORT_ITEMS", {
      items: query("GET_ACTIVE_ITEMS")
    });
  },
  ADD_ITEMS: ({items, index: index2, interactionMethod, success = () => {
  }, failure = () => {
  }}) => {
    let currentIndex = index2;
    if (index2 === -1 || typeof index2 === "undefined") {
      const insertLocation = query("GET_ITEM_INSERT_LOCATION");
      const totalItems = query("GET_TOTAL_ITEMS");
      currentIndex = insertLocation === "before" ? 0 : totalItems;
    }
    const ignoredFiles = query("GET_IGNORED_FILES");
    const isValidFile = (source) => isFile(source) ? !ignoredFiles.includes(source.name.toLowerCase()) : !isEmpty(source);
    const validItems = items.filter(isValidFile);
    const promises = validItems.map((source) => new Promise((resolve, reject) => {
      dispatch2("ADD_ITEM", {
        interactionMethod,
        source: source.source || source,
        success: resolve,
        failure: reject,
        index: currentIndex++,
        options: source.options || {}
      });
    }));
    Promise.all(promises).then(success).catch(failure);
  },
  ADD_ITEM: ({
    source,
    index: index2 = -1,
    interactionMethod,
    success = () => {
    },
    failure = () => {
    },
    options = {}
  }) => {
    if (isEmpty(source)) {
      failure({
        error: createResponse("error", 0, "No source"),
        file: null
      });
      return;
    }
    if (isFile(source) && state2.options.ignoredFiles.includes(source.name.toLowerCase())) {
      return;
    }
    if (!hasRoomForItem(state2)) {
      if (state2.options.allowMultiple || !state2.options.allowMultiple && !state2.options.allowReplace) {
        const error2 = createResponse("warning", 0, "Max files");
        dispatch2("DID_THROW_MAX_FILES", {
          source,
          error: error2
        });
        failure({error: error2, file: null});
        return;
      }
      const item3 = getActiveItems(state2.items)[0];
      if (item3.status === ItemStatus.PROCESSING_COMPLETE || item3.status === ItemStatus.PROCESSING_REVERT_ERROR) {
        const forceRevert = query("GET_FORCE_REVERT");
        item3.revert(createRevertFunction(state2.options.server.url, state2.options.server.revert), forceRevert).then(() => {
          if (!forceRevert)
            return;
          dispatch2("ADD_ITEM", {
            source,
            index: index2,
            interactionMethod,
            success,
            failure,
            options
          });
        }).catch(() => {
        });
        if (forceRevert)
          return;
      }
      dispatch2("REMOVE_ITEM", {query: item3.id});
    }
    const origin = options.type === "local" ? FileOrigin.LOCAL : options.type === "limbo" ? FileOrigin.LIMBO : FileOrigin.INPUT;
    const item2 = createItem(origin, origin === FileOrigin.INPUT ? null : source, options.file);
    Object.keys(options.metadata || {}).forEach((key) => {
      item2.setMetadata(key, options.metadata[key]);
    });
    applyFilters("DID_CREATE_ITEM", item2, {query, dispatch: dispatch2});
    const itemInsertLocation = query("GET_ITEM_INSERT_LOCATION");
    if (!state2.options.itemInsertLocationFreedom) {
      index2 = itemInsertLocation === "before" ? -1 : state2.items.length;
    }
    insertItem(state2.items, item2, index2);
    if (isFunction(itemInsertLocation) && source) {
      sortItems(state2, itemInsertLocation);
    }
    const id = item2.id;
    item2.on("init", () => {
      dispatch2("DID_INIT_ITEM", {id});
    });
    item2.on("load-init", () => {
      dispatch2("DID_START_ITEM_LOAD", {id});
    });
    item2.on("load-meta", () => {
      dispatch2("DID_UPDATE_ITEM_META", {id});
    });
    item2.on("load-progress", (progress) => {
      dispatch2("DID_UPDATE_ITEM_LOAD_PROGRESS", {id, progress});
    });
    item2.on("load-request-error", (error2) => {
      const mainStatus = dynamicLabel(state2.options.labelFileLoadError)(error2);
      if (error2.code >= 400 && error2.code < 500) {
        dispatch2("DID_THROW_ITEM_INVALID", {
          id,
          error: error2,
          status: {
            main: mainStatus,
            sub: `${error2.code} (${error2.body})`
          }
        });
        failure({error: error2, file: createItemAPI(item2)});
        return;
      }
      dispatch2("DID_THROW_ITEM_LOAD_ERROR", {
        id,
        error: error2,
        status: {
          main: mainStatus,
          sub: state2.options.labelTapToRetry
        }
      });
    });
    item2.on("load-file-error", (error2) => {
      dispatch2("DID_THROW_ITEM_INVALID", {
        id,
        error: error2.status,
        status: error2.status
      });
      failure({error: error2.status, file: createItemAPI(item2)});
    });
    item2.on("load-abort", () => {
      dispatch2("REMOVE_ITEM", {query: id});
    });
    item2.on("load-skip", () => {
      dispatch2("COMPLETE_LOAD_ITEM", {
        query: id,
        item: item2,
        data: {
          source,
          success
        }
      });
    });
    item2.on("load", () => {
      const handleAdd = (shouldAdd) => {
        if (!shouldAdd) {
          dispatch2("REMOVE_ITEM", {
            query: id
          });
          return;
        }
        item2.on("metadata-update", (change) => {
          dispatch2("DID_UPDATE_ITEM_METADATA", {id, change});
        });
        applyFilterChain("SHOULD_PREPARE_OUTPUT", false, {item: item2, query}).then((shouldPrepareOutput) => {
          const beforePrepareFile = query("GET_BEFORE_PREPARE_FILE");
          if (beforePrepareFile)
            shouldPrepareOutput = beforePrepareFile(item2, shouldPrepareOutput);
          const loadComplete = () => {
            dispatch2("COMPLETE_LOAD_ITEM", {
              query: id,
              item: item2,
              data: {
                source,
                success
              }
            });
            listUpdated(dispatch2, state2);
          };
          if (shouldPrepareOutput) {
            dispatch2("REQUEST_PREPARE_OUTPUT", {
              query: id,
              item: item2,
              success: (file2) => {
                dispatch2("DID_PREPARE_OUTPUT", {id, file: file2});
                loadComplete();
              }
            }, true);
            return;
          }
          loadComplete();
        });
      };
      applyFilterChain("DID_LOAD_ITEM", item2, {query, dispatch: dispatch2}).then(() => {
        optionalPromise(query("GET_BEFORE_ADD_FILE"), createItemAPI(item2)).then(handleAdd);
      }).catch((e) => {
        if (!e || !e.error || !e.status)
          return handleAdd(false);
        dispatch2("DID_THROW_ITEM_INVALID", {
          id,
          error: e.error,
          status: e.status
        });
      });
    });
    item2.on("process-start", () => {
      dispatch2("DID_START_ITEM_PROCESSING", {id});
    });
    item2.on("process-progress", (progress) => {
      dispatch2("DID_UPDATE_ITEM_PROCESS_PROGRESS", {id, progress});
    });
    item2.on("process-error", (error2) => {
      dispatch2("DID_THROW_ITEM_PROCESSING_ERROR", {
        id,
        error: error2,
        status: {
          main: dynamicLabel(state2.options.labelFileProcessingError)(error2),
          sub: state2.options.labelTapToRetry
        }
      });
    });
    item2.on("process-revert-error", (error2) => {
      dispatch2("DID_THROW_ITEM_PROCESSING_REVERT_ERROR", {
        id,
        error: error2,
        status: {
          main: dynamicLabel(state2.options.labelFileProcessingRevertError)(error2),
          sub: state2.options.labelTapToRetry
        }
      });
    });
    item2.on("process-complete", (serverFileReference) => {
      dispatch2("DID_COMPLETE_ITEM_PROCESSING", {
        id,
        error: null,
        serverFileReference
      });
      dispatch2("DID_DEFINE_VALUE", {id, value: serverFileReference});
    });
    item2.on("process-abort", () => {
      dispatch2("DID_ABORT_ITEM_PROCESSING", {id});
    });
    item2.on("process-revert", () => {
      dispatch2("DID_REVERT_ITEM_PROCESSING", {id});
      dispatch2("DID_DEFINE_VALUE", {id, value: null});
    });
    dispatch2("DID_ADD_ITEM", {id, index: index2, interactionMethod});
    listUpdated(dispatch2, state2);
    const {url, load, restore, fetch: fetch2} = state2.options.server || {};
    item2.load(source, createFileLoader(origin === FileOrigin.INPUT ? isString(source) && isExternalURL(source) ? fetch2 ? createFetchFunction(url, fetch2) : fetchBlob : fetchBlob : origin === FileOrigin.LIMBO ? createFetchFunction(url, restore) : createFetchFunction(url, load)), (file2, success2, error2) => {
      applyFilterChain("LOAD_FILE", file2, {query}).then(success2).catch(error2);
    });
  },
  REQUEST_PREPARE_OUTPUT: ({item: item2, success, failure = () => {
  }}) => {
    const err = {
      error: createResponse("error", 0, "Item not found"),
      file: null
    };
    if (item2.archived)
      return failure(err);
    applyFilterChain("PREPARE_OUTPUT", item2.file, {query, item: item2}).then((result) => {
      applyFilterChain("COMPLETE_PREPARE_OUTPUT", result, {query, item: item2}).then((result2) => {
        if (item2.archived)
          return failure(err);
        success(result2);
      });
    });
  },
  COMPLETE_LOAD_ITEM: ({item: item2, data: data3}) => {
    const {success, source} = data3;
    const itemInsertLocation = query("GET_ITEM_INSERT_LOCATION");
    if (isFunction(itemInsertLocation) && source) {
      sortItems(state2, itemInsertLocation);
    }
    dispatch2("DID_LOAD_ITEM", {
      id: item2.id,
      error: null,
      serverFileReference: item2.origin === FileOrigin.INPUT ? null : source
    });
    success(createItemAPI(item2));
    if (item2.origin === FileOrigin.LOCAL) {
      dispatch2("DID_LOAD_LOCAL_ITEM", {id: item2.id});
      return;
    }
    if (item2.origin === FileOrigin.LIMBO) {
      dispatch2("DID_COMPLETE_ITEM_PROCESSING", {
        id: item2.id,
        error: null,
        serverFileReference: source
      });
      dispatch2("DID_DEFINE_VALUE", {
        id: item2.id,
        value: item2.serverId || source
      });
      return;
    }
    if (query("IS_ASYNC") && state2.options.instantUpload) {
      dispatch2("REQUEST_ITEM_PROCESSING", {query: item2.id});
    }
  },
  RETRY_ITEM_LOAD: getItemByQueryFromState(state2, (item2) => {
    item2.retryLoad();
  }),
  REQUEST_ITEM_PREPARE: getItemByQueryFromState(state2, (item2, success, failure) => {
    dispatch2("REQUEST_PREPARE_OUTPUT", {
      query: item2.id,
      item: item2,
      success: (file2) => {
        dispatch2("DID_PREPARE_OUTPUT", {id: item2.id, file: file2});
        success({
          file: item2,
          output: file2
        });
      },
      failure
    }, true);
  }),
  REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2, success, failure) => {
    const itemCanBeQueuedForProcessing = item2.status === ItemStatus.IDLE || item2.status === ItemStatus.PROCESSING_ERROR;
    if (!itemCanBeQueuedForProcessing) {
      const processNow = () => dispatch2("REQUEST_ITEM_PROCESSING", {query: item2, success, failure});
      const process = () => document.hidden ? processNow() : setTimeout(processNow, 32);
      if (item2.status === ItemStatus.PROCESSING_COMPLETE || item2.status === ItemStatus.PROCESSING_REVERT_ERROR) {
        item2.revert(createRevertFunction(state2.options.server.url, state2.options.server.revert), query("GET_FORCE_REVERT")).then(process).catch(() => {
        });
      } else if (item2.status === ItemStatus.PROCESSING) {
        item2.abortProcessing().then(process);
      }
      return;
    }
    if (item2.status === ItemStatus.PROCESSING_QUEUED)
      return;
    item2.requestProcessing();
    dispatch2("DID_REQUEST_ITEM_PROCESSING", {id: item2.id});
    dispatch2("PROCESS_ITEM", {query: item2, success, failure}, true);
  }),
  PROCESS_ITEM: getItemByQueryFromState(state2, (item2, success, failure) => {
    const maxParallelUploads = query("GET_MAX_PARALLEL_UPLOADS");
    const totalCurrentUploads = query("GET_ITEMS_BY_STATUS", ItemStatus.PROCESSING).length;
    if (totalCurrentUploads === maxParallelUploads) {
      state2.processingQueue.push({
        id: item2.id,
        success,
        failure
      });
      return;
    }
    if (item2.status === ItemStatus.PROCESSING)
      return;
    const processNext = () => {
      const queueEntry = state2.processingQueue.shift();
      if (!queueEntry)
        return;
      const {id, success: success2, failure: failure2} = queueEntry;
      const itemReference = getItemByQuery(state2.items, id);
      if (!itemReference || itemReference.archived) {
        processNext();
        return;
      }
      dispatch2("PROCESS_ITEM", {query: id, success: success2, failure: failure2}, true);
    };
    item2.onOnce("process-complete", () => {
      success(createItemAPI(item2));
      processNext();
      const server = state2.options.server;
      const instantUpload = state2.options.instantUpload;
      if (instantUpload && item2.origin === FileOrigin.LOCAL && isFunction(server.remove)) {
        const noop = () => {
        };
        item2.origin = FileOrigin.LIMBO;
        state2.options.server.remove(item2.source, noop, noop);
      }
      const allItemsProcessed = query("GET_ITEMS_BY_STATUS", ItemStatus.PROCESSING_COMPLETE).length === state2.items.length;
      if (allItemsProcessed) {
        dispatch2("DID_COMPLETE_ITEM_PROCESSING_ALL");
      }
    });
    item2.onOnce("process-error", (error2) => {
      failure({error: error2, file: createItemAPI(item2)});
      processNext();
    });
    const options = state2.options;
    item2.process(createFileProcessor(createProcessorFunction(options.server.url, options.server.process, options.name, {
      chunkTransferId: item2.transferId,
      chunkServer: options.server.patch,
      chunkUploads: options.chunkUploads,
      chunkForce: options.chunkForce,
      chunkSize: options.chunkSize,
      chunkRetryDelays: options.chunkRetryDelays
    }), {
      allowMinimumUploadDuration: query("GET_ALLOW_MINIMUM_UPLOAD_DURATION")
    }), (file2, success2, error2) => {
      applyFilterChain("PREPARE_OUTPUT", file2, {query, item: item2}).then((file3) => {
        dispatch2("DID_PREPARE_OUTPUT", {id: item2.id, file: file3});
        success2(file3);
      }).catch(error2);
    });
  }),
  RETRY_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    dispatch2("REQUEST_ITEM_PROCESSING", {query: item2});
  }),
  REQUEST_REMOVE_ITEM: getItemByQueryFromState(state2, (item2) => {
    optionalPromise(query("GET_BEFORE_REMOVE_FILE"), createItemAPI(item2)).then((shouldRemove) => {
      if (!shouldRemove) {
        return;
      }
      dispatch2("REMOVE_ITEM", {query: item2});
    });
  }),
  RELEASE_ITEM: getItemByQueryFromState(state2, (item2) => {
    item2.release();
  }),
  REMOVE_ITEM: getItemByQueryFromState(state2, (item2, success, failure, options) => {
    const removeFromView = () => {
      const id = item2.id;
      getItemById(state2.items, id).archive();
      dispatch2("DID_REMOVE_ITEM", {error: null, id, item: item2});
      listUpdated(dispatch2, state2);
      success(createItemAPI(item2));
    };
    const server = state2.options.server;
    if (item2.origin === FileOrigin.LOCAL && server && isFunction(server.remove) && options.remove !== false) {
      dispatch2("DID_START_ITEM_REMOVE", {id: item2.id});
      server.remove(item2.source, () => removeFromView(), (status) => {
        dispatch2("DID_THROW_ITEM_REMOVE_ERROR", {
          id: item2.id,
          error: createResponse("error", 0, status, null),
          status: {
            main: dynamicLabel(state2.options.labelFileRemoveError)(status),
            sub: state2.options.labelTapToRetry
          }
        });
      });
    } else {
      if (options.revert && item2.origin !== FileOrigin.LOCAL && item2.serverId !== null || state2.options.chunkUploads && item2.file.size > state2.options.chunkSize || state2.options.chunkUploads && state2.options.chunkForce) {
        item2.revert(createRevertFunction(state2.options.server.url, state2.options.server.revert), query("GET_FORCE_REVERT"));
      }
      removeFromView();
    }
  }),
  ABORT_ITEM_LOAD: getItemByQueryFromState(state2, (item2) => {
    item2.abortLoad();
  }),
  ABORT_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    if (item2.serverId) {
      dispatch2("REVERT_ITEM_PROCESSING", {id: item2.id});
      return;
    }
    item2.abortProcessing().then(() => {
      const shouldRemove = state2.options.instantUpload;
      if (shouldRemove) {
        dispatch2("REMOVE_ITEM", {query: item2.id});
      }
    });
  }),
  REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    if (!state2.options.instantUpload) {
      dispatch2("REVERT_ITEM_PROCESSING", {query: item2});
      return;
    }
    const handleRevert2 = (shouldRevert) => {
      if (!shouldRevert)
        return;
      dispatch2("REVERT_ITEM_PROCESSING", {query: item2});
    };
    const fn2 = query("GET_BEFORE_REMOVE_FILE");
    if (!fn2) {
      return handleRevert2(true);
    }
    const requestRemoveResult = fn2(createItemAPI(item2));
    if (requestRemoveResult == null) {
      return handleRevert2(true);
    }
    if (typeof requestRemoveResult === "boolean") {
      return handleRevert2(requestRemoveResult);
    }
    if (typeof requestRemoveResult.then === "function") {
      requestRemoveResult.then(handleRevert2);
    }
  }),
  REVERT_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    item2.revert(createRevertFunction(state2.options.server.url, state2.options.server.revert), query("GET_FORCE_REVERT")).then(() => {
      const shouldRemove = state2.options.instantUpload || isMockItem(item2);
      if (shouldRemove) {
        dispatch2("REMOVE_ITEM", {query: item2.id});
      }
    }).catch(() => {
    });
  }),
  SET_OPTIONS: ({options}) => {
    const optionKeys = Object.keys(options);
    const prioritizedOptionKeys = PrioritizedOptions.filter((key) => optionKeys.includes(key));
    const orderedOptionKeys = [
      ...prioritizedOptionKeys,
      ...Object.keys(options).filter((key) => !prioritizedOptionKeys.includes(key))
    ];
    orderedOptionKeys.forEach((key) => {
      dispatch2(`SET_${fromCamels(key, "_").toUpperCase()}`, {
        value: options[key]
      });
    });
  }
});
var PrioritizedOptions = [
  "server"
];
var formatFilename = (name2) => name2;
var createElement$1 = (tagName) => {
  return document.createElement(tagName);
};
var text = (node, value) => {
  let textNode = node.childNodes[0];
  if (!textNode) {
    textNode = document.createTextNode(value);
    node.appendChild(textNode);
  } else if (value !== textNode.nodeValue) {
    textNode.nodeValue = value;
  }
};
var polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {
  const angleInRadians = (angleInDegrees % 360 - 90) * Math.PI / 180;
  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians)
  };
};
var describeArc = (x, y, radius, startAngle, endAngle, arcSweep) => {
  const start = polarToCartesian(x, y, radius, endAngle);
  const end = polarToCartesian(x, y, radius, startAngle);
  return ["M", start.x, start.y, "A", radius, radius, 0, arcSweep, 0, end.x, end.y].join(" ");
};
var percentageArc = (x, y, radius, from, to) => {
  let arcSweep = 1;
  if (to > from && to - from <= 0.5) {
    arcSweep = 0;
  }
  if (from > to && from - to >= 0.5) {
    arcSweep = 0;
  }
  return describeArc(x, y, radius, Math.min(0.9999, from) * 360, Math.min(0.9999, to) * 360, arcSweep);
};
var create = ({root: root2, props}) => {
  props.spin = false;
  props.progress = 0;
  props.opacity = 0;
  const svg3 = createElement("svg");
  root2.ref.path = createElement("path", {
    "stroke-width": 2,
    "stroke-linecap": "round"
  });
  svg3.appendChild(root2.ref.path);
  root2.ref.svg = svg3;
  root2.appendChild(svg3);
};
var write = ({root: root2, props}) => {
  if (props.opacity === 0) {
    return;
  }
  if (props.align) {
    root2.element.dataset.align = props.align;
  }
  const ringStrokeWidth = parseInt(attr(root2.ref.path, "stroke-width"), 10);
  const size = root2.rect.element.width * 0.5;
  let ringFrom = 0;
  let ringTo = 0;
  if (props.spin) {
    ringFrom = 0;
    ringTo = 0.5;
  } else {
    ringFrom = 0;
    ringTo = props.progress;
  }
  const coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);
  attr(root2.ref.path, "d", coordinates);
  attr(root2.ref.path, "stroke-opacity", props.spin || props.progress > 0 ? 1 : 0);
};
var progressIndicator = createView({
  tag: "div",
  name: "progress-indicator",
  ignoreRectUpdate: true,
  ignoreRect: true,
  create,
  write,
  mixins: {
    apis: ["progress", "spin", "align"],
    styles: ["opacity"],
    animations: {
      opacity: {type: "tween", duration: 500},
      progress: {
        type: "spring",
        stiffness: 0.95,
        damping: 0.65,
        mass: 10
      }
    }
  }
});
var create$1 = ({root: root2, props}) => {
  root2.element.innerHTML = (props.icon || "") + `<span>${props.label}</span>`;
  props.isDisabled = false;
};
var write$1 = ({root: root2, props}) => {
  const {isDisabled} = props;
  const shouldDisable = root2.query("GET_DISABLED") || props.opacity === 0;
  if (shouldDisable && !isDisabled) {
    props.isDisabled = true;
    attr(root2.element, "disabled", "disabled");
  } else if (!shouldDisable && isDisabled) {
    props.isDisabled = false;
    root2.element.removeAttribute("disabled");
  }
};
var fileActionButton = createView({
  tag: "button",
  attributes: {
    type: "button"
  },
  ignoreRect: true,
  ignoreRectUpdate: true,
  name: "file-action-button",
  mixins: {
    apis: ["label"],
    styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: "spring",
      scaleY: "spring",
      translateX: "spring",
      translateY: "spring",
      opacity: {type: "tween", duration: 250}
    },
    listeners: true
  },
  create: create$1,
  write: write$1
});
var toNaturalFileSize = (bytes, decimalSeparator = ".", base = 1e3, options = {}) => {
  const {
    labelBytes = "bytes",
    labelKilobytes = "KB",
    labelMegabytes = "MB",
    labelGigabytes = "GB"
  } = options;
  bytes = Math.round(Math.abs(bytes));
  const KB = base;
  const MB = base * base;
  const GB = base * base * base;
  if (bytes < KB) {
    return `${bytes} ${labelBytes}`;
  }
  if (bytes < MB) {
    return `${Math.floor(bytes / KB)} ${labelKilobytes}`;
  }
  if (bytes < GB) {
    return `${removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator)} ${labelMegabytes}`;
  }
  return `${removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator)} ${labelGigabytes}`;
};
var removeDecimalsWhenZero = (value, decimalCount, separator) => {
  return value.toFixed(decimalCount).split(".").filter((part) => part !== "0").join(separator);
};
var create$2 = ({root: root2, props}) => {
  const fileName = createElement$1("span");
  fileName.className = "filepond--file-info-main";
  attr(fileName, "aria-hidden", "true");
  root2.appendChild(fileName);
  root2.ref.fileName = fileName;
  const fileSize = createElement$1("span");
  fileSize.className = "filepond--file-info-sub";
  root2.appendChild(fileSize);
  root2.ref.fileSize = fileSize;
  text(fileSize, root2.query("GET_LABEL_FILE_WAITING_FOR_SIZE"));
  text(fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
};
var updateFile = ({root: root2, props}) => {
  text(root2.ref.fileSize, toNaturalFileSize(root2.query("GET_ITEM_SIZE", props.id), ".", root2.query("GET_FILE_SIZE_BASE"), root2.query("GET_FILE_SIZE_LABELS", root2.query)));
  text(root2.ref.fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
};
var updateFileSizeOnError = ({root: root2, props}) => {
  if (isInt(root2.query("GET_ITEM_SIZE", props.id))) {
    updateFile({root: root2, props});
    return;
  }
  text(root2.ref.fileSize, root2.query("GET_LABEL_FILE_SIZE_NOT_AVAILABLE"));
};
var fileInfo = createView({
  name: "file-info",
  ignoreRect: true,
  ignoreRectUpdate: true,
  write: createRoute({
    DID_LOAD_ITEM: updateFile,
    DID_UPDATE_ITEM_META: updateFile,
    DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,
    DID_THROW_ITEM_INVALID: updateFileSizeOnError
  }),
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", {...root2, view: root2});
  },
  create: create$2,
  mixins: {
    styles: ["translateX", "translateY"],
    animations: {
      translateX: "spring",
      translateY: "spring"
    }
  }
});
var toPercentage = (value) => Math.round(value * 100);
var create$3 = ({root: root2}) => {
  const main = createElement$1("span");
  main.className = "filepond--file-status-main";
  root2.appendChild(main);
  root2.ref.main = main;
  const sub = createElement$1("span");
  sub.className = "filepond--file-status-sub";
  root2.appendChild(sub);
  root2.ref.sub = sub;
  didSetItemLoadProgress({root: root2, action: {progress: null}});
};
var didSetItemLoadProgress = ({root: root2, action}) => {
  const title = action.progress === null ? root2.query("GET_LABEL_FILE_LOADING") : `${root2.query("GET_LABEL_FILE_LOADING")} ${toPercentage(action.progress)}%`;
  text(root2.ref.main, title);
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
};
var didSetItemProcessProgress = ({root: root2, action}) => {
  const title = action.progress === null ? root2.query("GET_LABEL_FILE_PROCESSING") : `${root2.query("GET_LABEL_FILE_PROCESSING")} ${toPercentage(action.progress)}%`;
  text(root2.ref.main, title);
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
};
var didRequestItemProcessing = ({root: root2}) => {
  text(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING"));
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
};
var didAbortItemProcessing = ({root: root2}) => {
  text(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING_ABORTED"));
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_RETRY"));
};
var didCompleteItemProcessing = ({root: root2}) => {
  text(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING_COMPLETE"));
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_UNDO"));
};
var clear = ({root: root2}) => {
  text(root2.ref.main, "");
  text(root2.ref.sub, "");
};
var error = ({root: root2, action}) => {
  text(root2.ref.main, action.status.main);
  text(root2.ref.sub, action.status.sub);
};
var fileStatus = createView({
  name: "file-status",
  ignoreRect: true,
  ignoreRectUpdate: true,
  write: createRoute({
    DID_LOAD_ITEM: clear,
    DID_REVERT_ITEM_PROCESSING: clear,
    DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,
    DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,
    DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,
    DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,
    DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,
    DID_THROW_ITEM_LOAD_ERROR: error,
    DID_THROW_ITEM_INVALID: error,
    DID_THROW_ITEM_PROCESSING_ERROR: error,
    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,
    DID_THROW_ITEM_REMOVE_ERROR: error
  }),
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", {...root2, view: root2});
  },
  create: create$3,
  mixins: {
    styles: ["translateX", "translateY", "opacity"],
    animations: {
      opacity: {type: "tween", duration: 250},
      translateX: "spring",
      translateY: "spring"
    }
  }
});
var Buttons = {
  AbortItemLoad: {
    label: "GET_LABEL_BUTTON_ABORT_ITEM_LOAD",
    action: "ABORT_ITEM_LOAD",
    className: "filepond--action-abort-item-load",
    align: "LOAD_INDICATOR_POSITION"
  },
  RetryItemLoad: {
    label: "GET_LABEL_BUTTON_RETRY_ITEM_LOAD",
    action: "RETRY_ITEM_LOAD",
    icon: "GET_ICON_RETRY",
    className: "filepond--action-retry-item-load",
    align: "BUTTON_PROCESS_ITEM_POSITION"
  },
  RemoveItem: {
    label: "GET_LABEL_BUTTON_REMOVE_ITEM",
    action: "REQUEST_REMOVE_ITEM",
    icon: "GET_ICON_REMOVE",
    className: "filepond--action-remove-item",
    align: "BUTTON_REMOVE_ITEM_POSITION"
  },
  ProcessItem: {
    label: "GET_LABEL_BUTTON_PROCESS_ITEM",
    action: "REQUEST_ITEM_PROCESSING",
    icon: "GET_ICON_PROCESS",
    className: "filepond--action-process-item",
    align: "BUTTON_PROCESS_ITEM_POSITION"
  },
  AbortItemProcessing: {
    label: "GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING",
    action: "ABORT_ITEM_PROCESSING",
    className: "filepond--action-abort-item-processing",
    align: "BUTTON_PROCESS_ITEM_POSITION"
  },
  RetryItemProcessing: {
    label: "GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING",
    action: "RETRY_ITEM_PROCESSING",
    icon: "GET_ICON_RETRY",
    className: "filepond--action-retry-item-processing",
    align: "BUTTON_PROCESS_ITEM_POSITION"
  },
  RevertItemProcessing: {
    label: "GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING",
    action: "REQUEST_REVERT_ITEM_PROCESSING",
    icon: "GET_ICON_UNDO",
    className: "filepond--action-revert-item-processing",
    align: "BUTTON_PROCESS_ITEM_POSITION"
  }
};
var ButtonKeys = [];
forin(Buttons, (key) => {
  ButtonKeys.push(key);
});
var calculateFileInfoOffset = (root2) => {
  if (getRemoveIndicatorAligment(root2) === "right")
    return 0;
  const buttonRect = root2.ref.buttonRemoveItem.rect.element;
  return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;
};
var calculateButtonWidth = (root2) => {
  const buttonRect = root2.ref.buttonAbortItemLoad.rect.element;
  return buttonRect.width;
};
var calculateFileVerticalCenterOffset = (root2) => Math.floor(root2.ref.buttonRemoveItem.rect.element.height / 4);
var calculateFileHorizontalCenterOffset = (root2) => Math.floor(root2.ref.buttonRemoveItem.rect.element.left / 2);
var getLoadIndicatorAlignment = (root2) => root2.query("GET_STYLE_LOAD_INDICATOR_POSITION");
var getProcessIndicatorAlignment = (root2) => root2.query("GET_STYLE_PROGRESS_INDICATOR_POSITION");
var getRemoveIndicatorAligment = (root2) => root2.query("GET_STYLE_BUTTON_REMOVE_ITEM_POSITION");
var DefaultStyle = {
  buttonAbortItemLoad: {opacity: 0},
  buttonRetryItemLoad: {opacity: 0},
  buttonRemoveItem: {opacity: 0},
  buttonProcessItem: {opacity: 0},
  buttonAbortItemProcessing: {opacity: 0},
  buttonRetryItemProcessing: {opacity: 0},
  buttonRevertItemProcessing: {opacity: 0},
  loadProgressIndicator: {opacity: 0, align: getLoadIndicatorAlignment},
  processProgressIndicator: {opacity: 0, align: getProcessIndicatorAlignment},
  processingCompleteIndicator: {opacity: 0, scaleX: 0.75, scaleY: 0.75},
  info: {translateX: 0, translateY: 0, opacity: 0},
  status: {translateX: 0, translateY: 0, opacity: 0}
};
var IdleStyle = {
  buttonRemoveItem: {opacity: 1},
  buttonProcessItem: {opacity: 1},
  info: {translateX: calculateFileInfoOffset},
  status: {translateX: calculateFileInfoOffset}
};
var ProcessingStyle = {
  buttonAbortItemProcessing: {opacity: 1},
  processProgressIndicator: {opacity: 1},
  status: {opacity: 1}
};
var StyleMap = {
  DID_THROW_ITEM_INVALID: {
    buttonRemoveItem: {opacity: 1},
    info: {translateX: calculateFileInfoOffset},
    status: {translateX: calculateFileInfoOffset, opacity: 1}
  },
  DID_START_ITEM_LOAD: {
    buttonAbortItemLoad: {opacity: 1},
    loadProgressIndicator: {opacity: 1},
    status: {opacity: 1}
  },
  DID_THROW_ITEM_LOAD_ERROR: {
    buttonRetryItemLoad: {opacity: 1},
    buttonRemoveItem: {opacity: 1},
    info: {translateX: calculateFileInfoOffset},
    status: {opacity: 1}
  },
  DID_START_ITEM_REMOVE: {
    processProgressIndicator: {opacity: 1, align: getRemoveIndicatorAligment},
    info: {translateX: calculateFileInfoOffset},
    status: {opacity: 0}
  },
  DID_THROW_ITEM_REMOVE_ERROR: {
    processProgressIndicator: {opacity: 0, align: getRemoveIndicatorAligment},
    buttonRemoveItem: {opacity: 1},
    info: {translateX: calculateFileInfoOffset},
    status: {opacity: 1, translateX: calculateFileInfoOffset}
  },
  DID_LOAD_ITEM: IdleStyle,
  DID_LOAD_LOCAL_ITEM: {
    buttonRemoveItem: {opacity: 1},
    info: {translateX: calculateFileInfoOffset},
    status: {translateX: calculateFileInfoOffset}
  },
  DID_START_ITEM_PROCESSING: ProcessingStyle,
  DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,
  DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,
  DID_COMPLETE_ITEM_PROCESSING: {
    buttonRevertItemProcessing: {opacity: 1},
    info: {opacity: 1},
    status: {opacity: 1}
  },
  DID_THROW_ITEM_PROCESSING_ERROR: {
    buttonRemoveItem: {opacity: 1},
    buttonRetryItemProcessing: {opacity: 1},
    status: {opacity: 1},
    info: {translateX: calculateFileInfoOffset}
  },
  DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {
    buttonRevertItemProcessing: {opacity: 1},
    status: {opacity: 1},
    info: {opacity: 1}
  },
  DID_ABORT_ITEM_PROCESSING: {
    buttonRemoveItem: {opacity: 1},
    buttonProcessItem: {opacity: 1},
    info: {translateX: calculateFileInfoOffset},
    status: {opacity: 1}
  },
  DID_REVERT_ITEM_PROCESSING: IdleStyle
};
var processingCompleteIndicatorView = createView({
  create: ({root: root2}) => {
    root2.element.innerHTML = root2.query("GET_ICON_DONE");
  },
  name: "processing-complete-indicator",
  ignoreRect: true,
  mixins: {
    styles: ["scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: "spring",
      scaleY: "spring",
      opacity: {type: "tween", duration: 250}
    }
  }
});
var create$4 = ({root: root2, props}) => {
  const LocalButtons = Object.keys(Buttons).reduce((prev, curr) => {
    prev[curr] = {...Buttons[curr]};
    return prev;
  }, {});
  const {id} = props;
  const allowRevert = root2.query("GET_ALLOW_REVERT");
  const allowRemove = root2.query("GET_ALLOW_REMOVE");
  const allowProcess = root2.query("GET_ALLOW_PROCESS");
  const instantUpload = root2.query("GET_INSTANT_UPLOAD");
  const isAsync2 = root2.query("IS_ASYNC");
  const alignRemoveItemButton = root2.query("GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN");
  let buttonFilter;
  if (isAsync2) {
    if (allowProcess && !allowRevert) {
      buttonFilter = (key) => !/RevertItemProcessing/.test(key);
    } else if (!allowProcess && allowRevert) {
      buttonFilter = (key) => !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);
    } else if (!allowProcess && !allowRevert) {
      buttonFilter = (key) => !/Process/.test(key);
    }
  } else {
    buttonFilter = (key) => !/Process/.test(key);
  }
  const enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();
  if (instantUpload && allowRevert) {
    LocalButtons["RevertItemProcessing"].label = "GET_LABEL_BUTTON_REMOVE_ITEM";
    LocalButtons["RevertItemProcessing"].icon = "GET_ICON_REMOVE";
  }
  if (isAsync2 && !allowRevert) {
    const map2 = StyleMap["DID_COMPLETE_ITEM_PROCESSING"];
    map2.info.translateX = calculateFileHorizontalCenterOffset;
    map2.info.translateY = calculateFileVerticalCenterOffset;
    map2.status.translateY = calculateFileVerticalCenterOffset;
    map2.processingCompleteIndicator = {opacity: 1, scaleX: 1, scaleY: 1};
  }
  if (isAsync2 && !allowProcess) {
    [
      "DID_START_ITEM_PROCESSING",
      "DID_REQUEST_ITEM_PROCESSING",
      "DID_UPDATE_ITEM_PROCESS_PROGRESS",
      "DID_THROW_ITEM_PROCESSING_ERROR"
    ].forEach((key) => {
      StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;
    });
    StyleMap["DID_THROW_ITEM_PROCESSING_ERROR"].status.translateX = calculateButtonWidth;
  }
  if (alignRemoveItemButton && allowRevert) {
    LocalButtons["RevertItemProcessing"].align = "BUTTON_REMOVE_ITEM_POSITION";
    const map2 = StyleMap["DID_COMPLETE_ITEM_PROCESSING"];
    map2.info.translateX = calculateFileInfoOffset;
    map2.status.translateY = calculateFileVerticalCenterOffset;
    map2.processingCompleteIndicator = {opacity: 1, scaleX: 1, scaleY: 1};
  }
  if (!allowRemove) {
    LocalButtons["RemoveItem"].disabled = true;
  }
  forin(LocalButtons, (key, definition) => {
    const buttonView = root2.createChildView(fileActionButton, {
      label: root2.query(definition.label),
      icon: root2.query(definition.icon),
      opacity: 0
    });
    if (enabledButtons.includes(key)) {
      root2.appendChildView(buttonView);
    }
    if (definition.disabled) {
      buttonView.element.setAttribute("disabled", "disabled");
      buttonView.element.setAttribute("hidden", "hidden");
    }
    buttonView.element.dataset.align = root2.query(`GET_STYLE_${definition.align}`);
    buttonView.element.classList.add(definition.className);
    buttonView.on("click", (e) => {
      e.stopPropagation();
      if (definition.disabled)
        return;
      root2.dispatch(definition.action, {query: id});
    });
    root2.ref[`button${key}`] = buttonView;
  });
  root2.ref.processingCompleteIndicator = root2.appendChildView(root2.createChildView(processingCompleteIndicatorView));
  root2.ref.processingCompleteIndicator.element.dataset.align = root2.query(`GET_STYLE_BUTTON_PROCESS_ITEM_POSITION`);
  root2.ref.info = root2.appendChildView(root2.createChildView(fileInfo, {id}));
  root2.ref.status = root2.appendChildView(root2.createChildView(fileStatus, {id}));
  const loadIndicatorView = root2.appendChildView(root2.createChildView(progressIndicator, {
    opacity: 0,
    align: root2.query(`GET_STYLE_LOAD_INDICATOR_POSITION`)
  }));
  loadIndicatorView.element.classList.add("filepond--load-indicator");
  root2.ref.loadProgressIndicator = loadIndicatorView;
  const progressIndicatorView = root2.appendChildView(root2.createChildView(progressIndicator, {
    opacity: 0,
    align: root2.query(`GET_STYLE_PROGRESS_INDICATOR_POSITION`)
  }));
  progressIndicatorView.element.classList.add("filepond--process-indicator");
  root2.ref.processProgressIndicator = progressIndicatorView;
  root2.ref.activeStyles = [];
};
var write$2 = ({root: root2, actions: actions2, props}) => {
  route({root: root2, actions: actions2, props});
  let action = actions2.concat().filter((action2) => /^DID_/.test(action2.type)).reverse().find((action2) => StyleMap[action2.type]);
  if (action) {
    root2.ref.activeStyles = [];
    const stylesToApply = StyleMap[action.type];
    forin(DefaultStyle, (name2, defaultStyles) => {
      const control = root2.ref[name2];
      forin(defaultStyles, (key, defaultValue) => {
        const value = stylesToApply[name2] && typeof stylesToApply[name2][key] !== "undefined" ? stylesToApply[name2][key] : defaultValue;
        root2.ref.activeStyles.push({control, key, value});
      });
    });
  }
  root2.ref.activeStyles.forEach(({control, key, value}) => {
    control[key] = typeof value === "function" ? value(root2) : value;
  });
};
var route = createRoute({
  DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: ({root: root2, action}) => {
    root2.ref.buttonAbortItemProcessing.label = action.value;
  },
  DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: ({root: root2, action}) => {
    root2.ref.buttonAbortItemLoad.label = action.value;
  },
  DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: ({root: root2, action}) => {
    root2.ref.buttonAbortItemRemoval.label = action.value;
  },
  DID_REQUEST_ITEM_PROCESSING: ({root: root2}) => {
    root2.ref.processProgressIndicator.spin = true;
    root2.ref.processProgressIndicator.progress = 0;
  },
  DID_START_ITEM_LOAD: ({root: root2}) => {
    root2.ref.loadProgressIndicator.spin = true;
    root2.ref.loadProgressIndicator.progress = 0;
  },
  DID_START_ITEM_REMOVE: ({root: root2}) => {
    root2.ref.processProgressIndicator.spin = true;
    root2.ref.processProgressIndicator.progress = 0;
  },
  DID_UPDATE_ITEM_LOAD_PROGRESS: ({root: root2, action}) => {
    root2.ref.loadProgressIndicator.spin = false;
    root2.ref.loadProgressIndicator.progress = action.progress;
  },
  DID_UPDATE_ITEM_PROCESS_PROGRESS: ({root: root2, action}) => {
    root2.ref.processProgressIndicator.spin = false;
    root2.ref.processProgressIndicator.progress = action.progress;
  }
});
var file = createView({
  create: create$4,
  write: write$2,
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", {...root2, view: root2});
  },
  name: "file"
});
var create$5 = ({root: root2, props}) => {
  root2.ref.fileName = createElement$1("legend");
  root2.appendChild(root2.ref.fileName);
  root2.ref.file = root2.appendChildView(root2.createChildView(file, {id: props.id}));
  root2.ref.data = false;
};
var didLoadItem = ({root: root2, props}) => {
  text(root2.ref.fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
};
var fileWrapper = createView({
  create: create$5,
  ignoreRect: true,
  write: createRoute({
    DID_LOAD_ITEM: didLoadItem
  }),
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", {...root2, view: root2});
  },
  tag: "fieldset",
  name: "file-wrapper"
});
var PANEL_SPRING_PROPS = {type: "spring", damping: 0.6, mass: 7};
var create$6 = ({root: root2, props}) => {
  [
    {
      name: "top"
    },
    {
      name: "center",
      props: {
        translateY: null,
        scaleY: null
      },
      mixins: {
        animations: {
          scaleY: PANEL_SPRING_PROPS
        },
        styles: ["translateY", "scaleY"]
      }
    },
    {
      name: "bottom",
      props: {
        translateY: null
      },
      mixins: {
        animations: {
          translateY: PANEL_SPRING_PROPS
        },
        styles: ["translateY"]
      }
    }
  ].forEach((section) => {
    createSection(root2, section, props.name);
  });
  root2.element.classList.add(`filepond--${props.name}`);
  root2.ref.scalable = null;
};
var createSection = (root2, section, className) => {
  const viewConstructor = createView({
    name: `panel-${section.name} filepond--${className}`,
    mixins: section.mixins,
    ignoreRectUpdate: true
  });
  const view = root2.createChildView(viewConstructor, section.props);
  root2.ref[section.name] = root2.appendChildView(view);
};
var write$3 = ({root: root2, props}) => {
  if (root2.ref.scalable === null || props.scalable !== root2.ref.scalable) {
    root2.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;
    root2.element.dataset.scalable = root2.ref.scalable;
  }
  if (!props.height)
    return;
  const topRect = root2.ref.top.rect.element;
  const bottomRect = root2.ref.bottom.rect.element;
  const height = Math.max(topRect.height + bottomRect.height, props.height);
  root2.ref.center.translateY = topRect.height;
  root2.ref.center.scaleY = (height - topRect.height - bottomRect.height) / 100;
  root2.ref.bottom.translateY = height - bottomRect.height;
};
var panel = createView({
  name: "panel",
  read: ({root: root2, props}) => props.heightCurrent = root2.ref.bottom.translateY,
  write: write$3,
  create: create$6,
  ignoreRect: true,
  mixins: {
    apis: ["height", "heightCurrent", "scalable"]
  }
});
var createDragHelper = (items) => {
  const itemIds = items.map((item2) => item2.id);
  let prevIndex = void 0;
  return {
    setIndex: (index2) => {
      prevIndex = index2;
    },
    getIndex: () => prevIndex,
    getItemIndex: (item2) => itemIds.indexOf(item2.id)
  };
};
var ITEM_TRANSLATE_SPRING = {
  type: "spring",
  stiffness: 0.75,
  damping: 0.45,
  mass: 10
};
var ITEM_SCALE_SPRING = "spring";
var StateMap = {
  DID_START_ITEM_LOAD: "busy",
  DID_UPDATE_ITEM_LOAD_PROGRESS: "loading",
  DID_THROW_ITEM_INVALID: "load-invalid",
  DID_THROW_ITEM_LOAD_ERROR: "load-error",
  DID_LOAD_ITEM: "idle",
  DID_THROW_ITEM_REMOVE_ERROR: "remove-error",
  DID_START_ITEM_REMOVE: "busy",
  DID_START_ITEM_PROCESSING: "busy processing",
  DID_REQUEST_ITEM_PROCESSING: "busy processing",
  DID_UPDATE_ITEM_PROCESS_PROGRESS: "processing",
  DID_COMPLETE_ITEM_PROCESSING: "processing-complete",
  DID_THROW_ITEM_PROCESSING_ERROR: "processing-error",
  DID_THROW_ITEM_PROCESSING_REVERT_ERROR: "processing-revert-error",
  DID_ABORT_ITEM_PROCESSING: "cancelled",
  DID_REVERT_ITEM_PROCESSING: "idle"
};
var create$7 = ({root: root2, props}) => {
  root2.ref.handleClick = (e) => root2.dispatch("DID_ACTIVATE_ITEM", {id: props.id});
  root2.element.id = `filepond--item-${props.id}`;
  root2.element.addEventListener("click", root2.ref.handleClick);
  root2.ref.container = root2.appendChildView(root2.createChildView(fileWrapper, {id: props.id}));
  root2.ref.panel = root2.appendChildView(root2.createChildView(panel, {name: "item-panel"}));
  root2.ref.panel.height = null;
  props.markedForRemoval = false;
  if (!root2.query("GET_ALLOW_REORDER"))
    return;
  root2.element.dataset.dragState = "idle";
  const grab = (e) => {
    if (!e.isPrimary)
      return;
    let removedActivateListener = false;
    const origin = {
      x: e.pageX,
      y: e.pageY
    };
    props.dragOrigin = {
      x: root2.translateX,
      y: root2.translateY
    };
    props.dragCenter = {
      x: e.offsetX,
      y: e.offsetY
    };
    const dragState = createDragHelper(root2.query("GET_ACTIVE_ITEMS"));
    root2.dispatch("DID_GRAB_ITEM", {id: props.id, dragState});
    const drag = (e2) => {
      if (!e2.isPrimary)
        return;
      e2.stopPropagation();
      e2.preventDefault();
      props.dragOffset = {
        x: e2.pageX - origin.x,
        y: e2.pageY - origin.y
      };
      const dist = props.dragOffset.x * props.dragOffset.x + props.dragOffset.y * props.dragOffset.y;
      if (dist > 16 && !removedActivateListener) {
        removedActivateListener = true;
        root2.element.removeEventListener("click", root2.ref.handleClick);
      }
      root2.dispatch("DID_DRAG_ITEM", {id: props.id, dragState});
    };
    const drop4 = (e2) => {
      if (!e2.isPrimary)
        return;
      document.removeEventListener("pointermove", drag);
      document.removeEventListener("pointerup", drop4);
      props.dragOffset = {
        x: e2.pageX - origin.x,
        y: e2.pageY - origin.y
      };
      root2.dispatch("DID_DROP_ITEM", {id: props.id, dragState});
      if (removedActivateListener) {
        setTimeout(() => root2.element.addEventListener("click", root2.ref.handleClick), 0);
      }
    };
    document.addEventListener("pointermove", drag);
    document.addEventListener("pointerup", drop4);
  };
  root2.element.addEventListener("pointerdown", grab);
};
var route$1 = createRoute({
  DID_UPDATE_PANEL_HEIGHT: ({root: root2, action}) => {
    root2.height = action.height;
  }
});
var write$4 = createRoute({
  DID_GRAB_ITEM: ({root: root2, props}) => {
    props.dragOrigin = {
      x: root2.translateX,
      y: root2.translateY
    };
  },
  DID_DRAG_ITEM: ({root: root2}) => {
    root2.element.dataset.dragState = "drag";
  },
  DID_DROP_ITEM: ({root: root2, props}) => {
    props.dragOffset = null;
    props.dragOrigin = null;
    root2.element.dataset.dragState = "drop";
  }
}, ({root: root2, actions: actions2, props, shouldOptimize}) => {
  if (root2.element.dataset.dragState === "drop") {
    if (root2.scaleX <= 1) {
      root2.element.dataset.dragState = "idle";
    }
  }
  let action = actions2.concat().filter((action2) => /^DID_/.test(action2.type)).reverse().find((action2) => StateMap[action2.type]);
  if (action && action.type !== props.currentState) {
    props.currentState = action.type;
    root2.element.dataset.filepondItemState = StateMap[props.currentState] || "";
  }
  const aspectRatio = root2.query("GET_ITEM_PANEL_ASPECT_RATIO") || root2.query("GET_PANEL_ASPECT_RATIO");
  if (!aspectRatio) {
    route$1({root: root2, actions: actions2, props});
    if (!root2.height && root2.ref.container.rect.element.height > 0) {
      root2.height = root2.ref.container.rect.element.height;
    }
  } else if (!shouldOptimize) {
    root2.height = root2.rect.element.width * aspectRatio;
  }
  if (shouldOptimize) {
    root2.ref.panel.height = null;
  }
  root2.ref.panel.height = root2.height;
});
var item = createView({
  create: create$7,
  write: write$4,
  destroy: ({root: root2, props}) => {
    root2.element.removeEventListener("click", root2.ref.handleClick);
    root2.dispatch("RELEASE_ITEM", {query: props.id});
  },
  tag: "li",
  name: "item",
  mixins: {
    apis: [
      "id",
      "interactionMethod",
      "markedForRemoval",
      "spawnDate",
      "dragCenter",
      "dragOrigin",
      "dragOffset"
    ],
    styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity", "height"],
    animations: {
      scaleX: ITEM_SCALE_SPRING,
      scaleY: ITEM_SCALE_SPRING,
      translateX: ITEM_TRANSLATE_SPRING,
      translateY: ITEM_TRANSLATE_SPRING,
      opacity: {type: "tween", duration: 150}
    }
  }
});
var getItemsPerRow = (horizontalSpace, itemWidth) => {
  return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));
};
var getItemIndexByPosition = (view, children, positionInView) => {
  if (!positionInView)
    return;
  const horizontalSpace = view.rect.element.width;
  const l = children.length;
  let last = null;
  if (l === 0 || positionInView.top < children[0].rect.element.top)
    return -1;
  const item2 = children[0];
  const itemRect = item2.rect.element;
  const itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;
  const itemWidth = itemRect.width + itemHorizontalMargin;
  const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
  if (itemsPerRow === 1) {
    for (let index2 = 0; index2 < l; index2++) {
      const child = children[index2];
      const childMid = child.rect.outer.top + child.rect.element.height * 0.5;
      if (positionInView.top < childMid) {
        return index2;
      }
    }
    return l;
  }
  const itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;
  const itemHeight = itemRect.height + itemVerticalMargin;
  for (let index2 = 0; index2 < l; index2++) {
    const indexX = index2 % itemsPerRow;
    const indexY = Math.floor(index2 / itemsPerRow);
    const offsetX = indexX * itemWidth;
    const offsetY = indexY * itemHeight;
    const itemTop = offsetY - itemRect.marginTop;
    const itemRight = offsetX + itemWidth;
    const itemBottom = offsetY + itemHeight + itemRect.marginBottom;
    if (positionInView.top < itemBottom && positionInView.top > itemTop) {
      if (positionInView.left < itemRight) {
        return index2;
      } else if (index2 !== l - 1) {
        last = index2;
      } else {
        last = null;
      }
    }
  }
  if (last !== null) {
    return last;
  }
  return l;
};
var dropAreaDimensions = {
  height: 0,
  width: 0,
  get getHeight() {
    return this.height;
  },
  set setHeight(val) {
    if (this.height === 0 || val === 0)
      this.height = val;
  },
  get getWidth() {
    return this.width;
  },
  set setWidth(val) {
    if (this.width === 0 || val === 0)
      this.width = val;
  },
  setDimensions: function(height, width) {
    if (this.height === 0 || height === 0)
      this.height = height;
    if (this.width === 0 || width === 0)
      this.width = width;
  }
};
var create$8 = ({root: root2}) => {
  attr(root2.element, "role", "list");
  root2.ref.lastItemSpanwDate = Date.now();
};
var addItemView = ({root: root2, action}) => {
  const {id, index: index2, interactionMethod} = action;
  root2.ref.addIndex = index2;
  const now = Date.now();
  let spawnDate = now;
  let opacity = 1;
  if (interactionMethod !== InteractionMethod.NONE) {
    opacity = 0;
    const cooldown = root2.query("GET_ITEM_INSERT_INTERVAL");
    const dist = now - root2.ref.lastItemSpanwDate;
    spawnDate = dist < cooldown ? now + (cooldown - dist) : now;
  }
  root2.ref.lastItemSpanwDate = spawnDate;
  root2.appendChildView(root2.createChildView(item, {
    spawnDate,
    id,
    opacity,
    interactionMethod
  }), index2);
};
var moveItem = (item2, x, y, vx = 0, vy = 1) => {
  if (item2.dragOffset) {
    item2.translateX = null;
    item2.translateY = null;
    item2.translateX = item2.dragOrigin.x + item2.dragOffset.x;
    item2.translateY = item2.dragOrigin.y + item2.dragOffset.y;
    item2.scaleX = 1.025;
    item2.scaleY = 1.025;
  } else {
    item2.translateX = x;
    item2.translateY = y;
    if (Date.now() > item2.spawnDate) {
      if (item2.opacity === 0) {
        introItemView(item2, x, y, vx, vy);
      }
      item2.scaleX = 1;
      item2.scaleY = 1;
      item2.opacity = 1;
    }
  }
};
var introItemView = (item2, x, y, vx, vy) => {
  if (item2.interactionMethod === InteractionMethod.NONE) {
    item2.translateX = null;
    item2.translateX = x;
    item2.translateY = null;
    item2.translateY = y;
  } else if (item2.interactionMethod === InteractionMethod.DROP) {
    item2.translateX = null;
    item2.translateX = x - vx * 20;
    item2.translateY = null;
    item2.translateY = y - vy * 10;
    item2.scaleX = 0.8;
    item2.scaleY = 0.8;
  } else if (item2.interactionMethod === InteractionMethod.BROWSE) {
    item2.translateY = null;
    item2.translateY = y - 30;
  } else if (item2.interactionMethod === InteractionMethod.API) {
    item2.translateX = null;
    item2.translateX = x - 30;
    item2.translateY = null;
  }
};
var removeItemView = ({root: root2, action}) => {
  const {id} = action;
  const view = root2.childViews.find((child) => child.id === id);
  if (!view) {
    return;
  }
  view.scaleX = 0.9;
  view.scaleY = 0.9;
  view.opacity = 0;
  view.markedForRemoval = true;
};
var getItemHeight = (child) => child.rect.element.height + child.rect.element.marginBottom * 0.5 + child.rect.element.marginTop * 0.5;
var getItemWidth = (child) => child.rect.element.width + child.rect.element.marginLeft * 0.5 + child.rect.element.marginRight * 0.5;
var dragItem = ({root: root2, action}) => {
  const {id, dragState} = action;
  const item2 = root2.query("GET_ITEM", {id});
  const view = root2.childViews.find((child) => child.id === id);
  const numItems = root2.childViews.length;
  const oldIndex2 = dragState.getItemIndex(item2);
  if (!view)
    return;
  const dragPosition = {
    x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,
    y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y
  };
  const dragHeight = getItemHeight(view);
  const dragWidth = getItemWidth(view);
  let cols = Math.floor(root2.rect.outer.width / dragWidth);
  if (cols > numItems)
    cols = numItems;
  const rows = Math.floor(numItems / cols + 1);
  dropAreaDimensions.setHeight = dragHeight * rows;
  dropAreaDimensions.setWidth = dragWidth * cols;
  var location2 = {
    y: Math.floor(dragPosition.y / dragHeight),
    x: Math.floor(dragPosition.x / dragWidth),
    getGridIndex: function getGridIndex() {
      if (dragPosition.y > dropAreaDimensions.getHeight || dragPosition.y < 0 || dragPosition.x > dropAreaDimensions.getWidth || dragPosition.x < 0)
        return oldIndex2;
      return this.y * cols + this.x;
    },
    getColIndex: function getColIndex() {
      const items = root2.query("GET_ACTIVE_ITEMS");
      const visibleChildren = root2.childViews.filter((child) => child.rect.element.height);
      const children = items.map((item3) => visibleChildren.find((childView) => childView.id === item3.id));
      const currentIndex2 = children.findIndex((child) => child === view);
      const dragHeight2 = getItemHeight(view);
      const l = children.length;
      let idx = l;
      let childHeight = 0;
      let childBottom = 0;
      let childTop = 0;
      for (let i = 0; i < l; i++) {
        childHeight = getItemHeight(children[i]);
        childTop = childBottom;
        childBottom = childTop + childHeight;
        if (dragPosition.y < childBottom) {
          if (currentIndex2 > i) {
            if (dragPosition.y < childTop + dragHeight2) {
              idx = i;
              break;
            }
            continue;
          }
          idx = i;
          break;
        }
      }
      return idx;
    }
  };
  const index2 = cols > 1 ? location2.getGridIndex() : location2.getColIndex();
  root2.dispatch("MOVE_ITEM", {query: view, index: index2});
  const currentIndex = dragState.getIndex();
  if (currentIndex === void 0 || currentIndex !== index2) {
    dragState.setIndex(index2);
    if (currentIndex === void 0)
      return;
    root2.dispatch("DID_REORDER_ITEMS", {
      items: root2.query("GET_ACTIVE_ITEMS"),
      origin: oldIndex2,
      target: index2
    });
  }
};
var route$2 = createRoute({
  DID_ADD_ITEM: addItemView,
  DID_REMOVE_ITEM: removeItemView,
  DID_DRAG_ITEM: dragItem
});
var write$5 = ({root: root2, props, actions: actions2, shouldOptimize}) => {
  route$2({root: root2, props, actions: actions2});
  const {dragCoordinates} = props;
  const horizontalSpace = root2.rect.element.width;
  const visibleChildren = root2.childViews.filter((child) => child.rect.element.height);
  const children = root2.query("GET_ACTIVE_ITEMS").map((item2) => visibleChildren.find((child) => child.id === item2.id)).filter((item2) => item2);
  const dragIndex = dragCoordinates ? getItemIndexByPosition(root2, children, dragCoordinates) : null;
  const addIndex = root2.ref.addIndex || null;
  root2.ref.addIndex = null;
  let dragIndexOffset = 0;
  let removeIndexOffset = 0;
  let addIndexOffset = 0;
  if (children.length === 0)
    return;
  const childRect = children[0].rect.element;
  const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
  const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;
  const itemWidth = childRect.width + itemHorizontalMargin;
  const itemHeight = childRect.height + itemVerticalMargin;
  const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
  if (itemsPerRow === 1) {
    let offsetY = 0;
    let dragOffset = 0;
    children.forEach((child, index2) => {
      if (dragIndex) {
        let dist = index2 - dragIndex;
        if (dist === -2) {
          dragOffset = -itemVerticalMargin * 0.25;
        } else if (dist === -1) {
          dragOffset = -itemVerticalMargin * 0.75;
        } else if (dist === 0) {
          dragOffset = itemVerticalMargin * 0.75;
        } else if (dist === 1) {
          dragOffset = itemVerticalMargin * 0.25;
        } else {
          dragOffset = 0;
        }
      }
      if (shouldOptimize) {
        child.translateX = null;
        child.translateY = null;
      }
      if (!child.markedForRemoval) {
        moveItem(child, 0, offsetY + dragOffset);
      }
      let itemHeight2 = child.rect.element.height + itemVerticalMargin;
      let visualHeight = itemHeight2 * (child.markedForRemoval ? child.opacity : 1);
      offsetY += visualHeight;
    });
  } else {
    let prevX = 0;
    let prevY = 0;
    children.forEach((child, index2) => {
      if (index2 === dragIndex) {
        dragIndexOffset = 1;
      }
      if (index2 === addIndex) {
        addIndexOffset += 1;
      }
      if (child.markedForRemoval && child.opacity < 0.5) {
        removeIndexOffset -= 1;
      }
      const visualIndex = index2 + addIndexOffset + dragIndexOffset + removeIndexOffset;
      const indexX = visualIndex % itemsPerRow;
      const indexY = Math.floor(visualIndex / itemsPerRow);
      const offsetX = indexX * itemWidth;
      const offsetY = indexY * itemHeight;
      const vectorX = Math.sign(offsetX - prevX);
      const vectorY = Math.sign(offsetY - prevY);
      prevX = offsetX;
      prevY = offsetY;
      if (child.markedForRemoval)
        return;
      if (shouldOptimize) {
        child.translateX = null;
        child.translateY = null;
      }
      moveItem(child, offsetX, offsetY, vectorX, vectorY);
    });
  }
};
var filterSetItemActions = (child, actions2) => actions2.filter((action) => {
  if (action.data && action.data.id) {
    return child.id === action.data.id;
  }
  return true;
});
var list = createView({
  create: create$8,
  write: write$5,
  tag: "ul",
  name: "list",
  didWriteView: ({root: root2}) => {
    root2.childViews.filter((view) => view.markedForRemoval && view.opacity === 0 && view.resting).forEach((view) => {
      view._destroy();
      root2.removeChildView(view);
    });
  },
  filterFrameActionsForChild: filterSetItemActions,
  mixins: {
    apis: ["dragCoordinates"]
  }
});
var create$9 = ({root: root2, props}) => {
  root2.ref.list = root2.appendChildView(root2.createChildView(list));
  props.dragCoordinates = null;
  props.overflowing = false;
};
var storeDragCoordinates = ({root: root2, props, action}) => {
  if (!root2.query("GET_ITEM_INSERT_LOCATION_FREEDOM"))
    return;
  props.dragCoordinates = {
    left: action.position.scopeLeft - root2.ref.list.rect.element.left,
    top: action.position.scopeTop - (root2.rect.outer.top + root2.rect.element.marginTop + root2.rect.element.scrollTop)
  };
};
var clearDragCoordinates = ({props}) => {
  props.dragCoordinates = null;
};
var route$3 = createRoute({
  DID_DRAG: storeDragCoordinates,
  DID_END_DRAG: clearDragCoordinates
});
var write$6 = ({root: root2, props, actions: actions2}) => {
  route$3({root: root2, props, actions: actions2});
  root2.ref.list.dragCoordinates = props.dragCoordinates;
  if (props.overflowing && !props.overflow) {
    props.overflowing = false;
    root2.element.dataset.state = "";
    root2.height = null;
  }
  if (props.overflow) {
    const newHeight = Math.round(props.overflow);
    if (newHeight !== root2.height) {
      props.overflowing = true;
      root2.element.dataset.state = "overflow";
      root2.height = newHeight;
    }
  }
};
var listScroller = createView({
  create: create$9,
  write: write$6,
  name: "list-scroller",
  mixins: {
    apis: ["overflow", "dragCoordinates"],
    styles: ["height", "translateY"],
    animations: {
      translateY: "spring"
    }
  }
});
var attrToggle = (element, name2, state2, enabledValue = "") => {
  if (state2) {
    attr(element, name2, enabledValue);
  } else {
    element.removeAttribute(name2);
  }
};
var resetFileInput = (input) => {
  if (!input || input.value === "") {
    return;
  }
  try {
    input.value = "";
  } catch (err) {
  }
  if (input.value) {
    const form = createElement$1("form");
    const parentNode = input.parentNode;
    const ref = input.nextSibling;
    form.appendChild(input);
    form.reset();
    if (ref) {
      parentNode.insertBefore(input, ref);
    } else {
      parentNode.appendChild(input);
    }
  }
};
var create$a = ({root: root2, props}) => {
  root2.element.id = `filepond--browser-${props.id}`;
  attr(root2.element, "name", root2.query("GET_NAME"));
  attr(root2.element, "aria-controls", `filepond--assistant-${props.id}`);
  attr(root2.element, "aria-labelledby", `filepond--drop-label-${props.id}`);
  setAcceptedFileTypes({root: root2, action: {value: root2.query("GET_ACCEPTED_FILE_TYPES")}});
  toggleAllowMultiple({root: root2, action: {value: root2.query("GET_ALLOW_MULTIPLE")}});
  toggleDirectoryFilter({root: root2, action: {value: root2.query("GET_ALLOW_DIRECTORIES_ONLY")}});
  toggleDisabled({root: root2});
  toggleRequired({root: root2, action: {value: root2.query("GET_REQUIRED")}});
  setCaptureMethod({root: root2, action: {value: root2.query("GET_CAPTURE_METHOD")}});
  root2.ref.handleChange = (e) => {
    if (!root2.element.value) {
      return;
    }
    const files = Array.from(root2.element.files).map((file2) => {
      file2._relativePath = file2.webkitRelativePath;
      return file2;
    });
    setTimeout(() => {
      props.onload(files);
      resetFileInput(root2.element);
    }, 250);
  };
  root2.element.addEventListener("change", root2.ref.handleChange);
};
var setAcceptedFileTypes = ({root: root2, action}) => {
  if (!root2.query("GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE"))
    return;
  attrToggle(root2.element, "accept", !!action.value, action.value ? action.value.join(",") : "");
};
var toggleAllowMultiple = ({root: root2, action}) => {
  attrToggle(root2.element, "multiple", action.value);
};
var toggleDirectoryFilter = ({root: root2, action}) => {
  attrToggle(root2.element, "webkitdirectory", action.value);
};
var toggleDisabled = ({root: root2}) => {
  const isDisabled = root2.query("GET_DISABLED");
  const doesAllowBrowse = root2.query("GET_ALLOW_BROWSE");
  const disableField = isDisabled || !doesAllowBrowse;
  attrToggle(root2.element, "disabled", disableField);
};
var toggleRequired = ({root: root2, action}) => {
  if (!action.value) {
    attrToggle(root2.element, "required", false);
  } else if (root2.query("GET_TOTAL_ITEMS") === 0) {
    attrToggle(root2.element, "required", true);
  }
};
var setCaptureMethod = ({root: root2, action}) => {
  attrToggle(root2.element, "capture", !!action.value, action.value === true ? "" : action.value);
};
var updateRequiredStatus = ({root: root2}) => {
  const {element} = root2;
  if (root2.query("GET_TOTAL_ITEMS") > 0) {
    attrToggle(element, "required", false);
    attrToggle(element, "name", false);
  } else {
    attrToggle(element, "name", true, root2.query("GET_NAME"));
    const shouldCheckValidity = root2.query("GET_CHECK_VALIDITY");
    if (shouldCheckValidity) {
      element.setCustomValidity("");
    }
    if (root2.query("GET_REQUIRED")) {
      attrToggle(element, "required", true);
    }
  }
};
var updateFieldValidityStatus = ({root: root2}) => {
  const shouldCheckValidity = root2.query("GET_CHECK_VALIDITY");
  if (!shouldCheckValidity)
    return;
  root2.element.setCustomValidity(root2.query("GET_LABEL_INVALID_FIELD"));
};
var browser = createView({
  tag: "input",
  name: "browser",
  ignoreRect: true,
  ignoreRectUpdate: true,
  attributes: {
    type: "file"
  },
  create: create$a,
  destroy: ({root: root2}) => {
    root2.element.removeEventListener("change", root2.ref.handleChange);
  },
  write: createRoute({
    DID_LOAD_ITEM: updateRequiredStatus,
    DID_REMOVE_ITEM: updateRequiredStatus,
    DID_THROW_ITEM_INVALID: updateFieldValidityStatus,
    DID_SET_DISABLED: toggleDisabled,
    DID_SET_ALLOW_BROWSE: toggleDisabled,
    DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,
    DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,
    DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,
    DID_SET_CAPTURE_METHOD: setCaptureMethod,
    DID_SET_REQUIRED: toggleRequired
  })
});
var Key = {
  ENTER: 13,
  SPACE: 32
};
var create$b = ({root: root2, props}) => {
  const label = createElement$1("label");
  attr(label, "for", `filepond--browser-${props.id}`);
  attr(label, "id", `filepond--drop-label-${props.id}`);
  attr(label, "aria-hidden", "true");
  root2.ref.handleKeyDown = (e) => {
    const isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;
    if (!isActivationKey)
      return;
    e.preventDefault();
    root2.ref.label.click();
  };
  root2.ref.handleClick = (e) => {
    const isLabelClick = e.target === label || label.contains(e.target);
    if (isLabelClick)
      return;
    root2.ref.label.click();
  };
  label.addEventListener("keydown", root2.ref.handleKeyDown);
  root2.element.addEventListener("click", root2.ref.handleClick);
  updateLabelValue(label, props.caption);
  root2.appendChild(label);
  root2.ref.label = label;
};
var updateLabelValue = (label, value) => {
  label.innerHTML = value;
  const clickable = label.querySelector(".filepond--label-action");
  if (clickable) {
    attr(clickable, "tabindex", "0");
  }
  return value;
};
var dropLabel = createView({
  name: "drop-label",
  ignoreRect: true,
  create: create$b,
  destroy: ({root: root2}) => {
    root2.ref.label.addEventListener("keydown", root2.ref.handleKeyDown);
    root2.element.removeEventListener("click", root2.ref.handleClick);
  },
  write: createRoute({
    DID_SET_LABEL_IDLE: ({root: root2, action}) => {
      updateLabelValue(root2.ref.label, action.value);
    }
  }),
  mixins: {
    styles: ["opacity", "translateX", "translateY"],
    animations: {
      opacity: {type: "tween", duration: 150},
      translateX: "spring",
      translateY: "spring"
    }
  }
});
var blob = createView({
  name: "drip-blob",
  ignoreRect: true,
  mixins: {
    styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: "spring",
      scaleY: "spring",
      translateX: "spring",
      translateY: "spring",
      opacity: {type: "tween", duration: 250}
    }
  }
});
var addBlob = ({root: root2}) => {
  const centerX = root2.rect.element.width * 0.5;
  const centerY = root2.rect.element.height * 0.5;
  root2.ref.blob = root2.appendChildView(root2.createChildView(blob, {
    opacity: 0,
    scaleX: 2.5,
    scaleY: 2.5,
    translateX: centerX,
    translateY: centerY
  }));
};
var moveBlob = ({root: root2, action}) => {
  if (!root2.ref.blob) {
    addBlob({root: root2});
    return;
  }
  root2.ref.blob.translateX = action.position.scopeLeft;
  root2.ref.blob.translateY = action.position.scopeTop;
  root2.ref.blob.scaleX = 1;
  root2.ref.blob.scaleY = 1;
  root2.ref.blob.opacity = 1;
};
var hideBlob = ({root: root2}) => {
  if (!root2.ref.blob) {
    return;
  }
  root2.ref.blob.opacity = 0;
};
var explodeBlob = ({root: root2}) => {
  if (!root2.ref.blob) {
    return;
  }
  root2.ref.blob.scaleX = 2.5;
  root2.ref.blob.scaleY = 2.5;
  root2.ref.blob.opacity = 0;
};
var write$7 = ({root: root2, props, actions: actions2}) => {
  route$4({root: root2, props, actions: actions2});
  const {blob: blob2} = root2.ref;
  if (actions2.length === 0 && blob2 && blob2.opacity === 0) {
    root2.removeChildView(blob2);
    root2.ref.blob = null;
  }
};
var route$4 = createRoute({
  DID_DRAG: moveBlob,
  DID_DROP: explodeBlob,
  DID_END_DRAG: hideBlob
});
var drip = createView({
  ignoreRect: true,
  ignoreRectUpdate: true,
  name: "drip",
  write: write$7
});
var setInputFiles = (element, files) => {
  try {
    const dataTransfer = new DataTransfer();
    files.forEach((file2) => {
      if (file2 instanceof File) {
        dataTransfer.items.add(file2);
      } else {
        dataTransfer.items.add(new File([file2], file2.name, {
          type: file2.type
        }));
      }
    });
    element.files = dataTransfer.files;
  } catch (err) {
    return false;
  }
  return true;
};
var create$c = ({root: root2}) => root2.ref.fields = {};
var getField = (root2, id) => root2.ref.fields[id];
var syncFieldPositionsWithItems = (root2) => {
  root2.query("GET_ACTIVE_ITEMS").forEach((item2) => {
    if (!root2.ref.fields[item2.id])
      return;
    root2.element.appendChild(root2.ref.fields[item2.id]);
  });
};
var didReorderItems = ({root: root2}) => syncFieldPositionsWithItems(root2);
var didAddItem = ({root: root2, action}) => {
  const fileItem = root2.query("GET_ITEM", action.id);
  const isLocalFile = fileItem.origin === FileOrigin.LOCAL;
  const shouldUseFileInput = !isLocalFile && root2.query("SHOULD_UPDATE_FILE_INPUT");
  const dataContainer = createElement$1("input");
  dataContainer.type = shouldUseFileInput ? "file" : "hidden";
  dataContainer.name = root2.query("GET_NAME");
  dataContainer.disabled = root2.query("GET_DISABLED");
  root2.ref.fields[action.id] = dataContainer;
  syncFieldPositionsWithItems(root2);
};
var didLoadItem$1 = ({root: root2, action}) => {
  const field = getField(root2, action.id);
  if (!field)
    return;
  if (action.serverFileReference !== null)
    field.value = action.serverFileReference;
  if (!root2.query("SHOULD_UPDATE_FILE_INPUT"))
    return;
  const fileItem = root2.query("GET_ITEM", action.id);
  setInputFiles(field, [fileItem.file]);
};
var didPrepareOutput = ({root: root2, action}) => {
  if (!root2.query("SHOULD_UPDATE_FILE_INPUT"))
    return;
  setTimeout(() => {
    const field = getField(root2, action.id);
    if (!field)
      return;
    setInputFiles(field, [action.file]);
  }, 0);
};
var didSetDisabled = ({root: root2}) => {
  root2.element.disabled = root2.query("GET_DISABLED");
};
var didRemoveItem = ({root: root2, action}) => {
  const field = getField(root2, action.id);
  if (!field)
    return;
  if (field.parentNode)
    field.parentNode.removeChild(field);
  delete root2.ref.fields[action.id];
};
var didDefineValue = ({root: root2, action}) => {
  const field = getField(root2, action.id);
  if (!field)
    return;
  if (action.value === null) {
    field.removeAttribute("value");
  } else {
    field.value = action.value;
  }
  syncFieldPositionsWithItems(root2);
};
var write$8 = createRoute({
  DID_SET_DISABLED: didSetDisabled,
  DID_ADD_ITEM: didAddItem,
  DID_LOAD_ITEM: didLoadItem$1,
  DID_REMOVE_ITEM: didRemoveItem,
  DID_DEFINE_VALUE: didDefineValue,
  DID_PREPARE_OUTPUT: didPrepareOutput,
  DID_REORDER_ITEMS: didReorderItems,
  DID_SORT_ITEMS: didReorderItems
});
var data2 = createView({
  tag: "fieldset",
  name: "data",
  create: create$c,
  write: write$8,
  ignoreRect: true
});
var getRootNode = (element) => "getRootNode" in element ? element.getRootNode() : document;
var images = ["jpg", "jpeg", "png", "gif", "bmp", "webp", "svg", "tiff"];
var text$1 = ["css", "csv", "html", "txt"];
var map = {
  zip: "zip|compressed",
  epub: "application/epub+zip"
};
var guesstimateMimeType = (extension = "") => {
  extension = extension.toLowerCase();
  if (images.includes(extension)) {
    return "image/" + (extension === "jpg" ? "jpeg" : extension === "svg" ? "svg+xml" : extension);
  }
  if (text$1.includes(extension)) {
    return "text/" + extension;
  }
  return map[extension] || "";
};
var requestDataTransferItems = (dataTransfer) => new Promise((resolve, reject) => {
  const links = getLinks(dataTransfer);
  if (links.length && !hasFiles(dataTransfer)) {
    return resolve(links);
  }
  getFiles(dataTransfer).then(resolve);
});
var hasFiles = (dataTransfer) => {
  if (dataTransfer.files)
    return dataTransfer.files.length > 0;
  return false;
};
var getFiles = (dataTransfer) => new Promise((resolve, reject) => {
  const promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : []).filter((item2) => isFileSystemItem(item2)).map((item2) => getFilesFromItem(item2));
  if (!promisedFiles.length) {
    resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);
    return;
  }
  Promise.all(promisedFiles).then((returnedFileGroups) => {
    const files = [];
    returnedFileGroups.forEach((group) => {
      files.push.apply(files, group);
    });
    resolve(files.filter((file2) => file2).map((file2) => {
      if (!file2._relativePath)
        file2._relativePath = file2.webkitRelativePath;
      return file2;
    }));
  }).catch(console.error);
});
var isFileSystemItem = (item2) => {
  if (isEntry(item2)) {
    const entry = getAsEntry(item2);
    if (entry) {
      return entry.isFile || entry.isDirectory;
    }
  }
  return item2.kind === "file";
};
var getFilesFromItem = (item2) => new Promise((resolve, reject) => {
  if (isDirectoryEntry(item2)) {
    getFilesInDirectory(getAsEntry(item2)).then(resolve).catch(reject);
    return;
  }
  resolve([item2.getAsFile()]);
});
var getFilesInDirectory = (entry) => new Promise((resolve, reject) => {
  const files = [];
  let dirCounter = 0;
  let fileCounter = 0;
  const resolveIfDone = () => {
    if (fileCounter === 0 && dirCounter === 0) {
      resolve(files);
    }
  };
  const readEntries = (dirEntry) => {
    dirCounter++;
    const directoryReader = dirEntry.createReader();
    const readBatch = () => {
      directoryReader.readEntries((entries) => {
        if (entries.length === 0) {
          dirCounter--;
          resolveIfDone();
          return;
        }
        entries.forEach((entry2) => {
          if (entry2.isDirectory) {
            readEntries(entry2);
          } else {
            fileCounter++;
            entry2.file((file2) => {
              const correctedFile = correctMissingFileType(file2);
              if (entry2.fullPath)
                correctedFile._relativePath = entry2.fullPath;
              files.push(correctedFile);
              fileCounter--;
              resolveIfDone();
            });
          }
        });
        readBatch();
      }, reject);
    };
    readBatch();
  };
  readEntries(entry);
});
var correctMissingFileType = (file2) => {
  if (file2.type.length)
    return file2;
  const date = file2.lastModifiedDate;
  const name2 = file2.name;
  const type = guesstimateMimeType(getExtensionFromFilename(file2.name));
  if (!type.length)
    return file2;
  file2 = file2.slice(0, file2.size, type);
  file2.name = name2;
  file2.lastModifiedDate = date;
  return file2;
};
var isDirectoryEntry = (item2) => isEntry(item2) && (getAsEntry(item2) || {}).isDirectory;
var isEntry = (item2) => "webkitGetAsEntry" in item2;
var getAsEntry = (item2) => item2.webkitGetAsEntry();
var getLinks = (dataTransfer) => {
  let links = [];
  try {
    links = getLinksFromTransferMetaData(dataTransfer);
    if (links.length) {
      return links;
    }
    links = getLinksFromTransferURLData(dataTransfer);
  } catch (e) {
  }
  return links;
};
var getLinksFromTransferURLData = (dataTransfer) => {
  let data3 = dataTransfer.getData("url");
  if (typeof data3 === "string" && data3.length) {
    return [data3];
  }
  return [];
};
var getLinksFromTransferMetaData = (dataTransfer) => {
  let data3 = dataTransfer.getData("text/html");
  if (typeof data3 === "string" && data3.length) {
    const matches2 = data3.match(/src\s*=\s*"(.+?)"/);
    if (matches2) {
      return [matches2[1]];
    }
  }
  return [];
};
var dragNDropObservers = [];
var eventPosition = (e) => ({
  pageLeft: e.pageX,
  pageTop: e.pageY,
  scopeLeft: e.offsetX || e.layerX,
  scopeTop: e.offsetY || e.layerY
});
var createDragNDropClient = (element, scopeToObserve, filterElement) => {
  const observer = getDragNDropObserver(scopeToObserve);
  const client = {
    element,
    filterElement,
    state: null,
    ondrop: () => {
    },
    onenter: () => {
    },
    ondrag: () => {
    },
    onexit: () => {
    },
    onload: () => {
    },
    allowdrop: () => {
    }
  };
  client.destroy = observer.addListener(client);
  return client;
};
var getDragNDropObserver = (element) => {
  const observer = dragNDropObservers.find((item2) => item2.element === element);
  if (observer) {
    return observer;
  }
  const newObserver = createDragNDropObserver(element);
  dragNDropObservers.push(newObserver);
  return newObserver;
};
var createDragNDropObserver = (element) => {
  const clients = [];
  const routes = {
    dragenter,
    dragover,
    dragleave,
    drop
  };
  const handlers = {};
  forin(routes, (event, createHandler) => {
    handlers[event] = createHandler(element, clients);
    element.addEventListener(event, handlers[event], false);
  });
  const observer = {
    element,
    addListener: (client) => {
      clients.push(client);
      return () => {
        clients.splice(clients.indexOf(client), 1);
        if (clients.length === 0) {
          dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);
          forin(routes, (event) => {
            element.removeEventListener(event, handlers[event], false);
          });
        }
      };
    }
  };
  return observer;
};
var elementFromPoint = (root2, point) => {
  if (!("elementFromPoint" in root2)) {
    root2 = document;
  }
  return root2.elementFromPoint(point.x, point.y);
};
var isEventTarget = (e, target) => {
  const root2 = getRootNode(target);
  const elementAtPosition = elementFromPoint(root2, {
    x: e.pageX - window.pageXOffset,
    y: e.pageY - window.pageYOffset
  });
  return elementAtPosition === target || target.contains(elementAtPosition);
};
var initialTarget = null;
var setDropEffect = (dataTransfer, effect) => {
  try {
    dataTransfer.dropEffect = effect;
  } catch (e) {
  }
};
var dragenter = (root2, clients) => (e) => {
  e.preventDefault();
  initialTarget = e.target;
  clients.forEach((client) => {
    const {element, onenter} = client;
    if (isEventTarget(e, element)) {
      client.state = "enter";
      onenter(eventPosition(e));
    }
  });
};
var dragover = (root2, clients) => (e) => {
  e.preventDefault();
  const dataTransfer = e.dataTransfer;
  requestDataTransferItems(dataTransfer).then((items) => {
    let overDropTarget = false;
    clients.some((client) => {
      const {filterElement, element, onenter, onexit, ondrag, allowdrop} = client;
      setDropEffect(dataTransfer, "copy");
      const allowsTransfer = allowdrop(items);
      if (!allowsTransfer) {
        setDropEffect(dataTransfer, "none");
        return;
      }
      if (isEventTarget(e, element)) {
        overDropTarget = true;
        if (client.state === null) {
          client.state = "enter";
          onenter(eventPosition(e));
          return;
        }
        client.state = "over";
        if (filterElement && !allowsTransfer) {
          setDropEffect(dataTransfer, "none");
          return;
        }
        ondrag(eventPosition(e));
      } else {
        if (filterElement && !overDropTarget) {
          setDropEffect(dataTransfer, "none");
        }
        if (client.state) {
          client.state = null;
          onexit(eventPosition(e));
        }
      }
    });
  });
};
var drop = (root2, clients) => (e) => {
  e.preventDefault();
  const dataTransfer = e.dataTransfer;
  requestDataTransferItems(dataTransfer).then((items) => {
    clients.forEach((client) => {
      const {filterElement, element, ondrop, onexit, allowdrop} = client;
      client.state = null;
      if (filterElement && !isEventTarget(e, element))
        return;
      if (!allowdrop(items))
        return onexit(eventPosition(e));
      ondrop(eventPosition(e), items);
    });
  });
};
var dragleave = (root2, clients) => (e) => {
  if (initialTarget !== e.target) {
    return;
  }
  clients.forEach((client) => {
    const {onexit} = client;
    client.state = null;
    onexit(eventPosition(e));
  });
};
var createHopper = (scope, validateItems, options) => {
  scope.classList.add("filepond--hopper");
  const {catchesDropsOnPage, requiresDropOnElement, filterItems = (items) => items} = options;
  const client = createDragNDropClient(scope, catchesDropsOnPage ? document.documentElement : scope, requiresDropOnElement);
  let lastState = "";
  let currentState = "";
  client.allowdrop = (items) => {
    return validateItems(filterItems(items));
  };
  client.ondrop = (position, items) => {
    const filteredItems = filterItems(items);
    if (!validateItems(filteredItems)) {
      api.ondragend(position);
      return;
    }
    currentState = "drag-drop";
    api.onload(filteredItems, position);
  };
  client.ondrag = (position) => {
    api.ondrag(position);
  };
  client.onenter = (position) => {
    currentState = "drag-over";
    api.ondragstart(position);
  };
  client.onexit = (position) => {
    currentState = "drag-exit";
    api.ondragend(position);
  };
  const api = {
    updateHopperState: () => {
      if (lastState !== currentState) {
        scope.dataset.hopperState = currentState;
        lastState = currentState;
      }
    },
    onload: () => {
    },
    ondragstart: () => {
    },
    ondrag: () => {
    },
    ondragend: () => {
    },
    destroy: () => {
      client.destroy();
    }
  };
  return api;
};
var listening = false;
var listeners$1 = [];
var handlePaste = (e) => {
  const activeEl = document.activeElement;
  if (activeEl && /textarea|input/i.test(activeEl.nodeName)) {
    let inScope = false;
    let element = activeEl;
    while (element !== document.body) {
      if (element.classList.contains("filepond--root")) {
        inScope = true;
        break;
      }
      element = element.parentNode;
    }
    if (!inScope)
      return;
  }
  requestDataTransferItems(e.clipboardData).then((files) => {
    if (!files.length) {
      return;
    }
    listeners$1.forEach((listener) => listener(files));
  });
};
var listen = (cb) => {
  if (listeners$1.includes(cb)) {
    return;
  }
  listeners$1.push(cb);
  if (listening) {
    return;
  }
  listening = true;
  document.addEventListener("paste", handlePaste);
};
var unlisten = (listener) => {
  arrayRemove(listeners$1, listeners$1.indexOf(listener));
  if (listeners$1.length === 0) {
    document.removeEventListener("paste", handlePaste);
    listening = false;
  }
};
var createPaster = () => {
  const cb = (files) => {
    api.onload(files);
  };
  const api = {
    destroy: () => {
      unlisten(cb);
    },
    onload: () => {
    }
  };
  listen(cb);
  return api;
};
var create$d = ({root: root2, props}) => {
  root2.element.id = `filepond--assistant-${props.id}`;
  attr(root2.element, "role", "status");
  attr(root2.element, "aria-live", "polite");
  attr(root2.element, "aria-relevant", "additions");
};
var addFilesNotificationTimeout = null;
var notificationClearTimeout = null;
var filenames = [];
var assist = (root2, message) => {
  root2.element.textContent = message;
};
var clear$1 = (root2) => {
  root2.element.textContent = "";
};
var listModified = (root2, filename, label) => {
  const total = root2.query("GET_TOTAL_ITEMS");
  assist(root2, `${label} ${filename}, ${total} ${total === 1 ? root2.query("GET_LABEL_FILE_COUNT_SINGULAR") : root2.query("GET_LABEL_FILE_COUNT_PLURAL")}`);
  clearTimeout(notificationClearTimeout);
  notificationClearTimeout = setTimeout(() => {
    clear$1(root2);
  }, 1500);
};
var isUsingFilePond = (root2) => root2.element.parentNode.contains(document.activeElement);
var itemAdded = ({root: root2, action}) => {
  if (!isUsingFilePond(root2)) {
    return;
  }
  root2.element.textContent = "";
  const item2 = root2.query("GET_ITEM", action.id);
  filenames.push(item2.filename);
  clearTimeout(addFilesNotificationTimeout);
  addFilesNotificationTimeout = setTimeout(() => {
    listModified(root2, filenames.join(", "), root2.query("GET_LABEL_FILE_ADDED"));
    filenames.length = 0;
  }, 750);
};
var itemRemoved = ({root: root2, action}) => {
  if (!isUsingFilePond(root2)) {
    return;
  }
  const item2 = action.item;
  listModified(root2, item2.filename, root2.query("GET_LABEL_FILE_REMOVED"));
};
var itemProcessed = ({root: root2, action}) => {
  const item2 = root2.query("GET_ITEM", action.id);
  const filename = item2.filename;
  const label = root2.query("GET_LABEL_FILE_PROCESSING_COMPLETE");
  assist(root2, `${filename} ${label}`);
};
var itemProcessedUndo = ({root: root2, action}) => {
  const item2 = root2.query("GET_ITEM", action.id);
  const filename = item2.filename;
  const label = root2.query("GET_LABEL_FILE_PROCESSING_ABORTED");
  assist(root2, `${filename} ${label}`);
};
var itemError = ({root: root2, action}) => {
  const item2 = root2.query("GET_ITEM", action.id);
  const filename = item2.filename;
  assist(root2, `${action.status.main} ${filename} ${action.status.sub}`);
};
var assistant = createView({
  create: create$d,
  ignoreRect: true,
  ignoreRectUpdate: true,
  write: createRoute({
    DID_LOAD_ITEM: itemAdded,
    DID_REMOVE_ITEM: itemRemoved,
    DID_COMPLETE_ITEM_PROCESSING: itemProcessed,
    DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,
    DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,
    DID_THROW_ITEM_REMOVE_ERROR: itemError,
    DID_THROW_ITEM_LOAD_ERROR: itemError,
    DID_THROW_ITEM_INVALID: itemError,
    DID_THROW_ITEM_PROCESSING_ERROR: itemError
  }),
  tag: "span",
  name: "assistant"
});
var toCamels = (string, separator = "-") => string.replace(new RegExp(`${separator}.`, "g"), (sub) => sub.charAt(1).toUpperCase());
var debounce = (func, interval = 16, immidiateOnly = true) => {
  let last = Date.now();
  let timeout = null;
  return (...args) => {
    clearTimeout(timeout);
    const dist = Date.now() - last;
    const fn2 = () => {
      last = Date.now();
      func(...args);
    };
    if (dist < interval) {
      if (!immidiateOnly) {
        timeout = setTimeout(fn2, interval - dist);
      }
    } else {
      fn2();
    }
  };
};
var MAX_FILES_LIMIT = 1e6;
var prevent = (e) => e.preventDefault();
var create$e = ({root: root2, props}) => {
  const id = root2.query("GET_ID");
  if (id) {
    root2.element.id = id;
  }
  const className = root2.query("GET_CLASS_NAME");
  if (className) {
    className.split(" ").filter((name2) => name2.length).forEach((name2) => {
      root2.element.classList.add(name2);
    });
  }
  root2.ref.label = root2.appendChildView(root2.createChildView(dropLabel, {
    ...props,
    translateY: null,
    caption: root2.query("GET_LABEL_IDLE")
  }));
  root2.ref.list = root2.appendChildView(root2.createChildView(listScroller, {translateY: null}));
  root2.ref.panel = root2.appendChildView(root2.createChildView(panel, {name: "panel-root"}));
  root2.ref.assistant = root2.appendChildView(root2.createChildView(assistant, {...props}));
  root2.ref.data = root2.appendChildView(root2.createChildView(data2, {...props}));
  root2.ref.measure = createElement$1("div");
  root2.ref.measure.style.height = "100%";
  root2.element.appendChild(root2.ref.measure);
  root2.ref.bounds = null;
  root2.query("GET_STYLES").filter((style) => !isEmpty(style.value)).map(({name: name2, value}) => {
    root2.element.dataset[name2] = value;
  });
  root2.ref.widthPrevious = null;
  root2.ref.widthUpdated = debounce(() => {
    root2.ref.updateHistory = [];
    root2.dispatch("DID_RESIZE_ROOT");
  }, 250);
  root2.ref.previousAspectRatio = null;
  root2.ref.updateHistory = [];
  const canHover = window.matchMedia("(pointer: fine) and (hover: hover)").matches;
  const hasPointerEvents = "PointerEvent" in window;
  if (root2.query("GET_ALLOW_REORDER") && hasPointerEvents && !canHover) {
    root2.element.addEventListener("touchmove", prevent, {passive: false});
    root2.element.addEventListener("gesturestart", prevent);
  }
  const credits = root2.query("GET_CREDITS");
  const hasCredits = credits.length === 2;
  if (hasCredits) {
    const frag = document.createElement("a");
    frag.className = "filepond--credits";
    frag.setAttribute("aria-hidden", "true");
    frag.href = credits[0];
    frag.tabindex = -1;
    frag.target = "_blank";
    frag.rel = "noopener noreferrer";
    frag.textContent = credits[1];
    root2.element.appendChild(frag);
    root2.ref.credits = frag;
  }
};
var write$9 = ({root: root2, props, actions: actions2}) => {
  route$5({root: root2, props, actions: actions2});
  actions2.filter((action) => /^DID_SET_STYLE_/.test(action.type)).filter((action) => !isEmpty(action.data.value)).map(({type, data: data3}) => {
    const name2 = toCamels(type.substr(8).toLowerCase(), "_");
    root2.element.dataset[name2] = data3.value;
    root2.invalidateLayout();
  });
  if (root2.rect.element.hidden)
    return;
  if (root2.rect.element.width !== root2.ref.widthPrevious) {
    root2.ref.widthPrevious = root2.rect.element.width;
    root2.ref.widthUpdated();
  }
  let bounds = root2.ref.bounds;
  if (!bounds) {
    bounds = root2.ref.bounds = calculateRootBoundingBoxHeight(root2);
    root2.element.removeChild(root2.ref.measure);
    root2.ref.measure = null;
  }
  const {hopper, label, list: list2, panel: panel2} = root2.ref;
  if (hopper) {
    hopper.updateHopperState();
  }
  const aspectRatio = root2.query("GET_PANEL_ASPECT_RATIO");
  const isMultiItem = root2.query("GET_ALLOW_MULTIPLE");
  const totalItems = root2.query("GET_TOTAL_ITEMS");
  const maxItems = isMultiItem ? root2.query("GET_MAX_FILES") || MAX_FILES_LIMIT : 1;
  const atMaxCapacity = totalItems === maxItems;
  const addAction = actions2.find((action) => action.type === "DID_ADD_ITEM");
  if (atMaxCapacity && addAction) {
    const interactionMethod = addAction.data.interactionMethod;
    label.opacity = 0;
    if (isMultiItem) {
      label.translateY = -40;
    } else {
      if (interactionMethod === InteractionMethod.API) {
        label.translateX = 40;
      } else if (interactionMethod === InteractionMethod.BROWSE) {
        label.translateY = 40;
      } else {
        label.translateY = 30;
      }
    }
  } else if (!atMaxCapacity) {
    label.opacity = 1;
    label.translateX = 0;
    label.translateY = 0;
  }
  const listItemMargin = calculateListItemMargin(root2);
  const listHeight = calculateListHeight(root2);
  const labelHeight = label.rect.element.height;
  const currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;
  const listMarginTop = atMaxCapacity ? list2.rect.element.marginTop : 0;
  const listMarginBottom = totalItems === 0 ? 0 : list2.rect.element.marginBottom;
  const visualHeight = currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;
  const boundsHeight = currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;
  list2.translateY = Math.max(0, currentLabelHeight - list2.rect.element.marginTop) - listItemMargin.top;
  if (aspectRatio) {
    const width = root2.rect.element.width;
    const height = width * aspectRatio;
    if (aspectRatio !== root2.ref.previousAspectRatio) {
      root2.ref.previousAspectRatio = aspectRatio;
      root2.ref.updateHistory = [];
    }
    const history = root2.ref.updateHistory;
    history.push(width);
    const MAX_BOUNCES = 2;
    if (history.length > MAX_BOUNCES * 2) {
      const l = history.length;
      const bottom = l - 10;
      let bounces = 0;
      for (let i = l; i >= bottom; i--) {
        if (history[i] === history[i - 2]) {
          bounces++;
        }
        if (bounces >= MAX_BOUNCES) {
          return;
        }
      }
    }
    panel2.scalable = false;
    panel2.height = height;
    const listAvailableHeight = height - currentLabelHeight - (listMarginBottom - listItemMargin.bottom) - (atMaxCapacity ? listMarginTop : 0);
    if (listHeight.visual > listAvailableHeight) {
      list2.overflow = listAvailableHeight;
    } else {
      list2.overflow = null;
    }
    root2.height = height;
  } else if (bounds.fixedHeight) {
    panel2.scalable = false;
    const listAvailableHeight = bounds.fixedHeight - currentLabelHeight - (listMarginBottom - listItemMargin.bottom) - (atMaxCapacity ? listMarginTop : 0);
    if (listHeight.visual > listAvailableHeight) {
      list2.overflow = listAvailableHeight;
    } else {
      list2.overflow = null;
    }
  } else if (bounds.cappedHeight) {
    const isCappedHeight = visualHeight >= bounds.cappedHeight;
    const panelHeight = Math.min(bounds.cappedHeight, visualHeight);
    panel2.scalable = true;
    panel2.height = isCappedHeight ? panelHeight : panelHeight - listItemMargin.top - listItemMargin.bottom;
    const listAvailableHeight = panelHeight - currentLabelHeight - (listMarginBottom - listItemMargin.bottom) - (atMaxCapacity ? listMarginTop : 0);
    if (visualHeight > bounds.cappedHeight && listHeight.visual > listAvailableHeight) {
      list2.overflow = listAvailableHeight;
    } else {
      list2.overflow = null;
    }
    root2.height = Math.min(bounds.cappedHeight, boundsHeight - listItemMargin.top - listItemMargin.bottom);
  } else {
    const itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;
    panel2.scalable = true;
    panel2.height = Math.max(labelHeight, visualHeight - itemMargin);
    root2.height = Math.max(labelHeight, boundsHeight - itemMargin);
  }
  if (root2.ref.credits && panel2.heightCurrent)
    root2.ref.credits.style.transform = `translateY(${panel2.heightCurrent}px)`;
};
var calculateListItemMargin = (root2) => {
  const item2 = root2.ref.list.childViews[0].childViews[0];
  return item2 ? {
    top: item2.rect.element.marginTop,
    bottom: item2.rect.element.marginBottom
  } : {
    top: 0,
    bottom: 0
  };
};
var calculateListHeight = (root2) => {
  let visual = 0;
  let bounds = 0;
  const scrollList = root2.ref.list;
  const itemList = scrollList.childViews[0];
  const visibleChildren = itemList.childViews.filter((child) => child.rect.element.height);
  const children = root2.query("GET_ACTIVE_ITEMS").map((item2) => visibleChildren.find((child) => child.id === item2.id)).filter((item2) => item2);
  if (children.length === 0)
    return {visual, bounds};
  const horizontalSpace = itemList.rect.element.width;
  const dragIndex = getItemIndexByPosition(itemList, children, scrollList.dragCoordinates);
  const childRect = children[0].rect.element;
  const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
  const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;
  const itemWidth = childRect.width + itemHorizontalMargin;
  const itemHeight = childRect.height + itemVerticalMargin;
  const newItem = typeof dragIndex !== "undefined" && dragIndex >= 0 ? 1 : 0;
  const removedItem = children.find((child) => child.markedForRemoval && child.opacity < 0.45) ? -1 : 0;
  const verticalItemCount = children.length + newItem + removedItem;
  const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
  if (itemsPerRow === 1) {
    children.forEach((item2) => {
      const height = item2.rect.element.height + itemVerticalMargin;
      bounds += height;
      visual += height * item2.opacity;
    });
  } else {
    bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;
    visual = bounds;
  }
  return {visual, bounds};
};
var calculateRootBoundingBoxHeight = (root2) => {
  const height = root2.ref.measureHeight || null;
  const cappedHeight = parseInt(root2.style.maxHeight, 10) || null;
  const fixedHeight = height === 0 ? null : height;
  return {
    cappedHeight,
    fixedHeight
  };
};
var exceedsMaxFiles = (root2, items) => {
  const allowReplace = root2.query("GET_ALLOW_REPLACE");
  const allowMultiple = root2.query("GET_ALLOW_MULTIPLE");
  const totalItems = root2.query("GET_TOTAL_ITEMS");
  let maxItems = root2.query("GET_MAX_FILES");
  const totalBrowseItems = items.length;
  if (!allowMultiple && totalBrowseItems > 1) {
    return true;
  }
  maxItems = allowMultiple ? maxItems : allowReplace ? maxItems : 1;
  const hasMaxItems = isInt(maxItems);
  if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {
    root2.dispatch("DID_THROW_MAX_FILES", {
      source: items,
      error: createResponse("warning", 0, "Max files")
    });
    return true;
  }
  return false;
};
var getDragIndex = (list2, children, position) => {
  const itemList = list2.childViews[0];
  return getItemIndexByPosition(itemList, children, {
    left: position.scopeLeft - itemList.rect.element.left,
    top: position.scopeTop - (list2.rect.outer.top + list2.rect.element.marginTop + list2.rect.element.scrollTop)
  });
};
var toggleDrop = (root2) => {
  const isAllowed = root2.query("GET_ALLOW_DROP");
  const isDisabled = root2.query("GET_DISABLED");
  const enabled = isAllowed && !isDisabled;
  if (enabled && !root2.ref.hopper) {
    const hopper = createHopper(root2.element, (items) => {
      const beforeDropFile = root2.query("GET_BEFORE_DROP_FILE") || (() => true);
      const dropValidation = root2.query("GET_DROP_VALIDATION");
      return dropValidation ? items.every((item2) => applyFilters("ALLOW_HOPPER_ITEM", item2, {
        query: root2.query
      }).every((result) => result === true) && beforeDropFile(item2)) : true;
    }, {
      filterItems: (items) => {
        const ignoredFiles = root2.query("GET_IGNORED_FILES");
        return items.filter((item2) => {
          if (isFile(item2)) {
            return !ignoredFiles.includes(item2.name.toLowerCase());
          }
          return true;
        });
      },
      catchesDropsOnPage: root2.query("GET_DROP_ON_PAGE"),
      requiresDropOnElement: root2.query("GET_DROP_ON_ELEMENT")
    });
    hopper.onload = (items, position) => {
      const list2 = root2.ref.list.childViews[0];
      const visibleChildren = list2.childViews.filter((child) => child.rect.element.height);
      const children = root2.query("GET_ACTIVE_ITEMS").map((item2) => visibleChildren.find((child) => child.id === item2.id)).filter((item2) => item2);
      applyFilterChain("ADD_ITEMS", items, {dispatch: root2.dispatch}).then((queue) => {
        if (exceedsMaxFiles(root2, queue))
          return false;
        root2.dispatch("ADD_ITEMS", {
          items: queue,
          index: getDragIndex(root2.ref.list, children, position),
          interactionMethod: InteractionMethod.DROP
        });
      });
      root2.dispatch("DID_DROP", {position});
      root2.dispatch("DID_END_DRAG", {position});
    };
    hopper.ondragstart = (position) => {
      root2.dispatch("DID_START_DRAG", {position});
    };
    hopper.ondrag = debounce((position) => {
      root2.dispatch("DID_DRAG", {position});
    });
    hopper.ondragend = (position) => {
      root2.dispatch("DID_END_DRAG", {position});
    };
    root2.ref.hopper = hopper;
    root2.ref.drip = root2.appendChildView(root2.createChildView(drip));
  } else if (!enabled && root2.ref.hopper) {
    root2.ref.hopper.destroy();
    root2.ref.hopper = null;
    root2.removeChildView(root2.ref.drip);
  }
};
var toggleBrowse = (root2, props) => {
  const isAllowed = root2.query("GET_ALLOW_BROWSE");
  const isDisabled = root2.query("GET_DISABLED");
  const enabled = isAllowed && !isDisabled;
  if (enabled && !root2.ref.browser) {
    root2.ref.browser = root2.appendChildView(root2.createChildView(browser, {
      ...props,
      onload: (items) => {
        applyFilterChain("ADD_ITEMS", items, {
          dispatch: root2.dispatch
        }).then((queue) => {
          if (exceedsMaxFiles(root2, queue))
            return false;
          root2.dispatch("ADD_ITEMS", {
            items: queue,
            index: -1,
            interactionMethod: InteractionMethod.BROWSE
          });
        });
      }
    }), 0);
  } else if (!enabled && root2.ref.browser) {
    root2.removeChildView(root2.ref.browser);
    root2.ref.browser = null;
  }
};
var togglePaste = (root2) => {
  const isAllowed = root2.query("GET_ALLOW_PASTE");
  const isDisabled = root2.query("GET_DISABLED");
  const enabled = isAllowed && !isDisabled;
  if (enabled && !root2.ref.paster) {
    root2.ref.paster = createPaster();
    root2.ref.paster.onload = (items) => {
      applyFilterChain("ADD_ITEMS", items, {dispatch: root2.dispatch}).then((queue) => {
        if (exceedsMaxFiles(root2, queue))
          return false;
        root2.dispatch("ADD_ITEMS", {
          items: queue,
          index: -1,
          interactionMethod: InteractionMethod.PASTE
        });
      });
    };
  } else if (!enabled && root2.ref.paster) {
    root2.ref.paster.destroy();
    root2.ref.paster = null;
  }
};
var route$5 = createRoute({
  DID_SET_ALLOW_BROWSE: ({root: root2, props}) => {
    toggleBrowse(root2, props);
  },
  DID_SET_ALLOW_DROP: ({root: root2}) => {
    toggleDrop(root2);
  },
  DID_SET_ALLOW_PASTE: ({root: root2}) => {
    togglePaste(root2);
  },
  DID_SET_DISABLED: ({root: root2, props}) => {
    toggleDrop(root2);
    togglePaste(root2);
    toggleBrowse(root2, props);
    const isDisabled = root2.query("GET_DISABLED");
    if (isDisabled) {
      root2.element.dataset.disabled = "disabled";
    } else {
      root2.element.removeAttribute("data-disabled");
    }
  }
});
var root = createView({
  name: "root",
  read: ({root: root2}) => {
    if (root2.ref.measure) {
      root2.ref.measureHeight = root2.ref.measure.offsetHeight;
    }
  },
  create: create$e,
  write: write$9,
  destroy: ({root: root2}) => {
    if (root2.ref.paster) {
      root2.ref.paster.destroy();
    }
    if (root2.ref.hopper) {
      root2.ref.hopper.destroy();
    }
    root2.element.removeEventListener("touchmove", prevent);
    root2.element.removeEventListener("gesturestart", prevent);
  },
  mixins: {
    styles: ["height"]
  }
});
var createApp = (initialOptions = {}) => {
  let originalElement = null;
  const defaultOptions2 = getOptions();
  const store = createStore(createInitialState(defaultOptions2), [queries, createOptionQueries(defaultOptions2)], [actions, createOptionActions(defaultOptions2)]);
  store.dispatch("SET_OPTIONS", {options: initialOptions});
  const visibilityHandler = () => {
    if (document.hidden)
      return;
    store.dispatch("KICK");
  };
  document.addEventListener("visibilitychange", visibilityHandler);
  let resizeDoneTimer = null;
  let isResizing = false;
  let isResizingHorizontally = false;
  let initialWindowWidth = null;
  let currentWindowWidth = null;
  const resizeHandler = () => {
    if (!isResizing) {
      isResizing = true;
    }
    clearTimeout(resizeDoneTimer);
    resizeDoneTimer = setTimeout(() => {
      isResizing = false;
      initialWindowWidth = null;
      currentWindowWidth = null;
      if (isResizingHorizontally) {
        isResizingHorizontally = false;
        store.dispatch("DID_STOP_RESIZE");
      }
    }, 500);
  };
  window.addEventListener("resize", resizeHandler);
  const view = root(store, {id: getUniqueId()});
  let isResting = false;
  let isHidden = false;
  const readWriteApi = {
    _read: () => {
      if (isResizing) {
        currentWindowWidth = window.innerWidth;
        if (!initialWindowWidth) {
          initialWindowWidth = currentWindowWidth;
        }
        if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {
          store.dispatch("DID_START_RESIZE");
          isResizingHorizontally = true;
        }
      }
      if (isHidden && isResting) {
        isResting = view.element.offsetParent === null;
      }
      if (isResting)
        return;
      view._read();
      isHidden = view.rect.element.hidden;
    },
    _write: (ts) => {
      const actions2 = store.processActionQueue().filter((action) => !/^SET_/.test(action.type));
      if (isResting && !actions2.length)
        return;
      routeActionsToEvents(actions2);
      isResting = view._write(ts, actions2, isResizingHorizontally);
      removeReleasedItems(store.query("GET_ITEMS"));
      if (isResting) {
        store.processDispatchQueue();
      }
    }
  };
  const createEvent = (name2) => (data3) => {
    const event = {
      type: name2
    };
    if (!data3) {
      return event;
    }
    if (data3.hasOwnProperty("error")) {
      event.error = data3.error ? {...data3.error} : null;
    }
    if (data3.status) {
      event.status = {...data3.status};
    }
    if (data3.file) {
      event.output = data3.file;
    }
    if (data3.source) {
      event.file = data3.source;
    } else if (data3.item || data3.id) {
      const item2 = data3.item ? data3.item : store.query("GET_ITEM", data3.id);
      event.file = item2 ? createItemAPI(item2) : null;
    }
    if (data3.items) {
      event.items = data3.items.map(createItemAPI);
    }
    if (/progress/.test(name2)) {
      event.progress = data3.progress;
    }
    if (data3.hasOwnProperty("origin") && data3.hasOwnProperty("target")) {
      event.origin = data3.origin;
      event.target = data3.target;
    }
    return event;
  };
  const eventRoutes = {
    DID_DESTROY: createEvent("destroy"),
    DID_INIT: createEvent("init"),
    DID_THROW_MAX_FILES: createEvent("warning"),
    DID_INIT_ITEM: createEvent("initfile"),
    DID_START_ITEM_LOAD: createEvent("addfilestart"),
    DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent("addfileprogress"),
    DID_LOAD_ITEM: createEvent("addfile"),
    DID_THROW_ITEM_INVALID: [createEvent("error"), createEvent("addfile")],
    DID_THROW_ITEM_LOAD_ERROR: [createEvent("error"), createEvent("addfile")],
    DID_THROW_ITEM_REMOVE_ERROR: [createEvent("error"), createEvent("removefile")],
    DID_PREPARE_OUTPUT: createEvent("preparefile"),
    DID_START_ITEM_PROCESSING: createEvent("processfilestart"),
    DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent("processfileprogress"),
    DID_ABORT_ITEM_PROCESSING: createEvent("processfileabort"),
    DID_COMPLETE_ITEM_PROCESSING: createEvent("processfile"),
    DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent("processfiles"),
    DID_REVERT_ITEM_PROCESSING: createEvent("processfilerevert"),
    DID_THROW_ITEM_PROCESSING_ERROR: [createEvent("error"), createEvent("processfile")],
    DID_REMOVE_ITEM: createEvent("removefile"),
    DID_UPDATE_ITEMS: createEvent("updatefiles"),
    DID_ACTIVATE_ITEM: createEvent("activatefile"),
    DID_REORDER_ITEMS: createEvent("reorderfiles")
  };
  const exposeEvent = (event) => {
    const detail = {pond: exports, ...event};
    delete detail.type;
    view.element.dispatchEvent(new CustomEvent(`FilePond:${event.type}`, {
      detail,
      bubbles: true,
      cancelable: true,
      composed: true
    }));
    const params = [];
    if (event.hasOwnProperty("error")) {
      params.push(event.error);
    }
    if (event.hasOwnProperty("file")) {
      params.push(event.file);
    }
    const filtered = ["type", "error", "file"];
    Object.keys(event).filter((key) => !filtered.includes(key)).forEach((key) => params.push(event[key]));
    exports.fire(event.type, ...params);
    const handler = store.query(`GET_ON${event.type.toUpperCase()}`);
    if (handler) {
      handler(...params);
    }
  };
  const routeActionsToEvents = (actions2) => {
    if (!actions2.length)
      return;
    actions2.filter((action) => eventRoutes[action.type]).forEach((action) => {
      const routes = eventRoutes[action.type];
      (Array.isArray(routes) ? routes : [routes]).forEach((route2) => {
        if (action.type === "DID_INIT_ITEM") {
          exposeEvent(route2(action.data));
        } else {
          setTimeout(() => {
            exposeEvent(route2(action.data));
          }, 0);
        }
      });
    });
  };
  const setOptions2 = (options) => store.dispatch("SET_OPTIONS", {options});
  const getFile = (query) => store.query("GET_ACTIVE_ITEM", query);
  const prepareFile = (query) => new Promise((resolve, reject) => {
    store.dispatch("REQUEST_ITEM_PREPARE", {
      query,
      success: (item2) => {
        resolve(item2);
      },
      failure: (error2) => {
        reject(error2);
      }
    });
  });
  const addFile = (source, options = {}) => new Promise((resolve, reject) => {
    addFiles([{source, options}], {index: options.index}).then((items) => resolve(items && items[0])).catch(reject);
  });
  const isFilePondFile = (obj) => obj.file && obj.id;
  const removeFile = (query, options) => {
    if (typeof query === "object" && !isFilePondFile(query) && !options) {
      options = query;
      query = void 0;
    }
    store.dispatch("REMOVE_ITEM", {...options, query});
    return store.query("GET_ACTIVE_ITEM", query) === null;
  };
  const addFiles = (...args) => new Promise((resolve, reject) => {
    const sources = [];
    const options = {};
    if (isArray(args[0])) {
      sources.push.apply(sources, args[0]);
      Object.assign(options, args[1] || {});
    } else {
      const lastArgument = args[args.length - 1];
      if (typeof lastArgument === "object" && !(lastArgument instanceof Blob)) {
        Object.assign(options, args.pop());
      }
      sources.push(...args);
    }
    store.dispatch("ADD_ITEMS", {
      items: sources,
      index: options.index,
      interactionMethod: InteractionMethod.API,
      success: resolve,
      failure: reject
    });
  });
  const getFiles2 = () => store.query("GET_ACTIVE_ITEMS");
  const processFile = (query) => new Promise((resolve, reject) => {
    store.dispatch("REQUEST_ITEM_PROCESSING", {
      query,
      success: (item2) => {
        resolve(item2);
      },
      failure: (error2) => {
        reject(error2);
      }
    });
  });
  const prepareFiles = (...args) => {
    const queries2 = Array.isArray(args[0]) ? args[0] : args;
    const items = queries2.length ? queries2 : getFiles2();
    return Promise.all(items.map(prepareFile));
  };
  const processFiles = (...args) => {
    const queries2 = Array.isArray(args[0]) ? args[0] : args;
    if (!queries2.length) {
      const files = getFiles2().filter((item2) => !(item2.status === ItemStatus.IDLE && item2.origin === FileOrigin.LOCAL) && item2.status !== ItemStatus.PROCESSING && item2.status !== ItemStatus.PROCESSING_COMPLETE && item2.status !== ItemStatus.PROCESSING_REVERT_ERROR);
      return Promise.all(files.map(processFile));
    }
    return Promise.all(queries2.map(processFile));
  };
  const removeFiles = (...args) => {
    const queries2 = Array.isArray(args[0]) ? args[0] : args;
    let options;
    if (typeof queries2[queries2.length - 1] === "object") {
      options = queries2.pop();
    } else if (Array.isArray(args[0])) {
      options = args[1];
    }
    const files = getFiles2();
    if (!queries2.length)
      return Promise.all(files.map((file2) => removeFile(file2, options)));
    const mappedQueries = queries2.map((query) => isNumber(query) ? files[query] ? files[query].id : null : query).filter((query) => query);
    return mappedQueries.map((q) => removeFile(q, options));
  };
  const exports = {
    ...on(),
    ...readWriteApi,
    ...createOptionAPI(store, defaultOptions2),
    setOptions: setOptions2,
    addFile,
    addFiles,
    getFile,
    processFile,
    prepareFile,
    removeFile,
    moveFile: (query, index2) => store.dispatch("MOVE_ITEM", {query, index: index2}),
    getFiles: getFiles2,
    processFiles,
    removeFiles,
    prepareFiles,
    sort: (compare) => store.dispatch("SORT", {compare}),
    browse: () => {
      var input = view.element.querySelector("input[type=file]");
      if (input) {
        input.click();
      }
    },
    destroy: () => {
      exports.fire("destroy", view.element);
      store.dispatch("ABORT_ALL");
      view._destroy();
      window.removeEventListener("resize", resizeHandler);
      document.removeEventListener("visibilitychange", visibilityHandler);
      store.dispatch("DID_DESTROY");
    },
    insertBefore: (element) => insertBefore(view.element, element),
    insertAfter: (element) => insertAfter(view.element, element),
    appendTo: (element) => element.appendChild(view.element),
    replaceElement: (element) => {
      insertBefore(view.element, element);
      element.parentNode.removeChild(element);
      originalElement = element;
    },
    restoreElement: () => {
      if (!originalElement) {
        return;
      }
      insertAfter(originalElement, view.element);
      view.element.parentNode.removeChild(view.element);
      originalElement = null;
    },
    isAttachedTo: (element) => view.element === element || originalElement === element,
    element: {
      get: () => view.element
    },
    status: {
      get: () => store.query("GET_STATUS")
    }
  };
  store.dispatch("DID_INIT");
  return createObject(exports);
};
var createAppObject = (customOptions = {}) => {
  const defaultOptions2 = {};
  forin(getOptions(), (key, value) => {
    defaultOptions2[key] = value[0];
  });
  const app = createApp({
    ...defaultOptions2,
    ...customOptions
  });
  return app;
};
var lowerCaseFirstLetter = (string) => string.charAt(0).toLowerCase() + string.slice(1);
var attributeNameToPropertyName = (attributeName) => toCamels(attributeName.replace(/^data-/, ""));
var mapObject = (object, propertyMap) => {
  forin(propertyMap, (selector, mapping) => {
    forin(object, (property, value) => {
      const selectorRegExp = new RegExp(selector);
      const matches2 = selectorRegExp.test(property);
      if (!matches2) {
        return;
      }
      delete object[property];
      if (mapping === false) {
        return;
      }
      if (isString(mapping)) {
        object[mapping] = value;
        return;
      }
      const group = mapping.group;
      if (isObject(mapping) && !object[group]) {
        object[group] = {};
      }
      object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, ""))] = value;
    });
    if (mapping.mapping) {
      mapObject(object[mapping.group], mapping.mapping);
    }
  });
};
var getAttributesAsObject = (node, attributeMapping = {}) => {
  const attributes = [];
  forin(node.attributes, (index2) => {
    attributes.push(node.attributes[index2]);
  });
  const output = attributes.filter((attribute) => attribute.name).reduce((obj, attribute) => {
    const value = attr(node, attribute.name);
    obj[attributeNameToPropertyName(attribute.name)] = value === attribute.name ? true : value;
    return obj;
  }, {});
  mapObject(output, attributeMapping);
  return output;
};
var createAppAtElement = (element, options = {}) => {
  const attributeMapping = {
    "^class$": "className",
    "^multiple$": "allowMultiple",
    "^capture$": "captureMethod",
    "^webkitdirectory$": "allowDirectoriesOnly",
    "^server": {
      group: "server",
      mapping: {
        "^process": {
          group: "process"
        },
        "^revert": {
          group: "revert"
        },
        "^fetch": {
          group: "fetch"
        },
        "^restore": {
          group: "restore"
        },
        "^load": {
          group: "load"
        }
      }
    },
    "^type$": false,
    "^files$": false
  };
  applyFilters("SET_ATTRIBUTE_TO_OPTION_MAP", attributeMapping);
  const mergedOptions = {
    ...options
  };
  const attributeOptions = getAttributesAsObject(element.nodeName === "FIELDSET" ? element.querySelector("input[type=file]") : element, attributeMapping);
  Object.keys(attributeOptions).forEach((key) => {
    if (isObject(attributeOptions[key])) {
      if (!isObject(mergedOptions[key])) {
        mergedOptions[key] = {};
      }
      Object.assign(mergedOptions[key], attributeOptions[key]);
    } else {
      mergedOptions[key] = attributeOptions[key];
    }
  });
  mergedOptions.files = (options.files || []).concat(Array.from(element.querySelectorAll("input:not([type=file])")).map((input) => ({
    source: input.value,
    options: {
      type: input.dataset.type
    }
  })));
  const app = createAppObject(mergedOptions);
  if (element.files) {
    Array.from(element.files).forEach((file2) => {
      app.addFile(file2);
    });
  }
  app.replaceElement(element);
  return app;
};
var createApp$1 = (...args) => isNode(args[0]) ? createAppAtElement(...args) : createAppObject(...args);
var PRIVATE_METHODS = ["fire", "_read", "_write"];
var createAppAPI = (app) => {
  const api = {};
  copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);
  return api;
};
var replaceInString = (string, replacements) => string.replace(/(?:{([a-zA-Z]+)})/g, (match, group) => replacements[group]);
var createWorker = (fn2) => {
  const workerBlob = new Blob(["(", fn2.toString(), ")()"], {
    type: "application/javascript"
  });
  const workerURL = URL.createObjectURL(workerBlob);
  const worker = new Worker(workerURL);
  return {
    transfer: (message, cb) => {
    },
    post: (message, cb, transferList) => {
      const id = getUniqueId();
      worker.onmessage = (e) => {
        if (e.data.id === id) {
          cb(e.data.message);
        }
      };
      worker.postMessage({
        id,
        message
      }, transferList);
    },
    terminate: () => {
      worker.terminate();
      URL.revokeObjectURL(workerURL);
    }
  };
};
var loadImage = (url) => new Promise((resolve, reject) => {
  const img = new Image();
  img.onload = () => {
    resolve(img);
  };
  img.onerror = (e) => {
    reject(e);
  };
  img.src = url;
});
var renameFile = (file2, name2) => {
  const renamedFile = file2.slice(0, file2.size, file2.type);
  renamedFile.lastModifiedDate = file2.lastModifiedDate;
  renamedFile.name = name2;
  return renamedFile;
};
var copyFile = (file2) => renameFile(file2, file2.name);
var registeredPlugins = [];
var createAppPlugin = (plugin9) => {
  if (registeredPlugins.includes(plugin9)) {
    return;
  }
  registeredPlugins.push(plugin9);
  const pluginOutline = plugin9({
    addFilter,
    utils: {
      Type,
      forin,
      isString,
      isFile,
      toNaturalFileSize,
      replaceInString,
      getExtensionFromFilename,
      getFilenameWithoutExtension,
      guesstimateMimeType,
      getFileFromBlob,
      getFilenameFromURL,
      createRoute,
      createWorker,
      createView,
      createItemAPI,
      loadImage,
      copyFile,
      renameFile,
      createBlob,
      applyFilterChain,
      text,
      getNumericAspectRatioFromString
    },
    views: {
      fileActionButton
    }
  });
  extendDefaultOptions(pluginOutline.options);
};
var isOperaMini = () => Object.prototype.toString.call(window.operamini) === "[object OperaMini]";
var hasPromises = () => "Promise" in window;
var hasBlobSlice = () => "slice" in Blob.prototype;
var hasCreateObjectURL = () => "URL" in window && "createObjectURL" in window.URL;
var hasVisibility = () => "visibilityState" in document;
var hasTiming = () => "performance" in window;
var hasCSSSupports = () => "supports" in (window.CSS || {});
var isIE11 = () => /MSIE|Trident/.test(window.navigator.userAgent);
var supported = (() => {
  const isSupported = isBrowser() && !isOperaMini() && hasVisibility() && hasPromises() && hasBlobSlice() && hasCreateObjectURL() && hasTiming() && (hasCSSSupports() || isIE11());
  return () => isSupported;
})();
var state = {
  apps: []
};
var name = "filepond";
var fn = () => {
};
var Status$1 = {};
var FileStatus = {};
var FileOrigin$1 = {};
var OptionTypes = {};
var create$f = fn;
var destroy = fn;
var parse = fn;
var find = fn;
var registerPlugin = fn;
var getOptions$1 = fn;
var setOptions$1 = fn;
if (supported()) {
  createPainter(() => {
    state.apps.forEach((app) => app._read());
  }, (ts) => {
    state.apps.forEach((app) => app._write(ts));
  });
  const dispatch2 = () => {
    document.dispatchEvent(new CustomEvent("FilePond:loaded", {
      detail: {
        supported,
        create: create$f,
        destroy,
        parse,
        find,
        registerPlugin,
        setOptions: setOptions$1
      }
    }));
    document.removeEventListener("DOMContentLoaded", dispatch2);
  };
  if (document.readyState !== "loading") {
    setTimeout(() => dispatch2(), 0);
  } else {
    document.addEventListener("DOMContentLoaded", dispatch2);
  }
  const updateOptionTypes = () => forin(getOptions(), (key, value) => {
    OptionTypes[key] = value[1];
  });
  Status$1 = {...Status};
  FileOrigin$1 = {...FileOrigin};
  FileStatus = {...ItemStatus};
  OptionTypes = {};
  updateOptionTypes();
  create$f = (...args) => {
    const app = createApp$1(...args);
    app.on("destroy", destroy);
    state.apps.push(app);
    return createAppAPI(app);
  };
  destroy = (hook) => {
    const indexToRemove = state.apps.findIndex((app) => app.isAttachedTo(hook));
    if (indexToRemove >= 0) {
      const app = state.apps.splice(indexToRemove, 1)[0];
      app.restoreElement();
      return true;
    }
    return false;
  };
  parse = (context) => {
    const matchedHooks = Array.from(context.querySelectorAll(`.${name}`));
    const newHooks = matchedHooks.filter((newHook) => !state.apps.find((app) => app.isAttachedTo(newHook)));
    return newHooks.map((hook) => create$f(hook));
  };
  find = (hook) => {
    const app = state.apps.find((app2) => app2.isAttachedTo(hook));
    if (!app) {
      return null;
    }
    return createAppAPI(app);
  };
  registerPlugin = (...plugins2) => {
    plugins2.forEach(createAppPlugin);
    updateOptionTypes();
  };
  getOptions$1 = () => {
    const opts = {};
    forin(getOptions(), (key, value) => {
      opts[key] = value[0];
    });
    return opts;
  };
  setOptions$1 = (opts) => {
    if (isObject(opts)) {
      state.apps.forEach((app) => {
        app.setOptions(opts);
      });
      setOptions(opts);
    }
    return getOptions$1();
  };
}

// node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.esm.js
/*!
 * FilePondPluginFileValidateSize 2.2.7
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
var plugin = ({addFilter: addFilter2, utils}) => {
  const {Type: Type2, replaceInString: replaceInString2, toNaturalFileSize: toNaturalFileSize2} = utils;
  addFilter2("ALLOW_HOPPER_ITEM", (file2, {query}) => {
    if (!query("GET_ALLOW_FILE_SIZE_VALIDATION")) {
      return true;
    }
    const sizeMax = query("GET_MAX_FILE_SIZE");
    if (sizeMax !== null && file2.size > sizeMax) {
      return false;
    }
    const sizeMin = query("GET_MIN_FILE_SIZE");
    if (sizeMin !== null && file2.size < sizeMin) {
      return false;
    }
    return true;
  });
  addFilter2("LOAD_FILE", (file2, {query}) => new Promise((resolve, reject) => {
    if (!query("GET_ALLOW_FILE_SIZE_VALIDATION")) {
      return resolve(file2);
    }
    const fileFilter = query("GET_FILE_VALIDATE_SIZE_FILTER");
    if (fileFilter && !fileFilter(file2)) {
      return resolve(file2);
    }
    const sizeMax = query("GET_MAX_FILE_SIZE");
    if (sizeMax !== null && file2.size > sizeMax) {
      reject({
        status: {
          main: query("GET_LABEL_MAX_FILE_SIZE_EXCEEDED"),
          sub: replaceInString2(query("GET_LABEL_MAX_FILE_SIZE"), {
            filesize: toNaturalFileSize2(sizeMax, ".", query("GET_FILE_SIZE_BASE"), query("GET_FILE_SIZE_LABELS", query))
          })
        }
      });
      return;
    }
    const sizeMin = query("GET_MIN_FILE_SIZE");
    if (sizeMin !== null && file2.size < sizeMin) {
      reject({
        status: {
          main: query("GET_LABEL_MIN_FILE_SIZE_EXCEEDED"),
          sub: replaceInString2(query("GET_LABEL_MIN_FILE_SIZE"), {
            filesize: toNaturalFileSize2(sizeMin, ".", query("GET_FILE_SIZE_BASE"), query("GET_FILE_SIZE_LABELS", query))
          })
        }
      });
      return;
    }
    const totalSizeMax = query("GET_MAX_TOTAL_FILE_SIZE");
    if (totalSizeMax !== null) {
      const currentTotalSize = query("GET_ACTIVE_ITEMS").reduce((total, item2) => {
        return total + item2.fileSize;
      }, 0);
      if (currentTotalSize > totalSizeMax) {
        reject({
          status: {
            main: query("GET_LABEL_MAX_TOTAL_FILE_SIZE_EXCEEDED"),
            sub: replaceInString2(query("GET_LABEL_MAX_TOTAL_FILE_SIZE"), {
              filesize: toNaturalFileSize2(totalSizeMax, ".", query("GET_FILE_SIZE_BASE"), query("GET_FILE_SIZE_LABELS", query))
            })
          }
        });
        return;
      }
    }
    resolve(file2);
  }));
  return {
    options: {
      allowFileSizeValidation: [true, Type2.BOOLEAN],
      maxFileSize: [null, Type2.INT],
      minFileSize: [null, Type2.INT],
      maxTotalFileSize: [null, Type2.INT],
      fileValidateSizeFilter: [null, Type2.FUNCTION],
      labelMinFileSizeExceeded: ["File is too small", Type2.STRING],
      labelMinFileSize: ["Minimum file size is {filesize}", Type2.STRING],
      labelMaxFileSizeExceeded: ["File is too large", Type2.STRING],
      labelMaxFileSize: ["Maximum file size is {filesize}", Type2.STRING],
      labelMaxTotalFileSizeExceeded: ["Maximum total size exceeded", Type2.STRING],
      labelMaxTotalFileSize: ["Maximum total file size is {filesize}", Type2.STRING]
    }
  };
};
var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser2) {
  document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", {detail: plugin}));
}
var filepond_plugin_file_validate_size_esm_default = plugin;

// node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js
/*!
 * FilePondPluginFileValidateType 1.2.8
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
var plugin2 = ({addFilter: addFilter2, utils}) => {
  const {
    Type: Type2,
    isString: isString3,
    replaceInString: replaceInString2,
    guesstimateMimeType: guesstimateMimeType2,
    getExtensionFromFilename: getExtensionFromFilename2,
    getFilenameFromURL: getFilenameFromURL2
  } = utils;
  const mimeTypeMatchesWildCard = (mimeType, wildcard) => {
    const mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop();
    const wildcardGroup = wildcard.slice(0, -2);
    return mimeTypeGroup === wildcardGroup;
  };
  const isValidMimeType = (acceptedTypes, userInputType) => acceptedTypes.some((acceptedType) => {
    if (/\*$/.test(acceptedType)) {
      return mimeTypeMatchesWildCard(userInputType, acceptedType);
    }
    return acceptedType === userInputType;
  });
  const getItemType = (item2) => {
    let type = "";
    if (isString3(item2)) {
      const filename = getFilenameFromURL2(item2);
      const extension = getExtensionFromFilename2(filename);
      if (extension) {
        type = guesstimateMimeType2(extension);
      }
    } else {
      type = item2.type;
    }
    return type;
  };
  const validateFile = (item2, acceptedFileTypes, typeDetector) => {
    if (acceptedFileTypes.length === 0) {
      return true;
    }
    const type = getItemType(item2);
    if (!typeDetector) {
      return isValidMimeType(acceptedFileTypes, type);
    }
    return new Promise((resolve, reject) => {
      typeDetector(item2, type).then((detectedType) => {
        if (isValidMimeType(acceptedFileTypes, detectedType)) {
          resolve();
        } else {
          reject();
        }
      }).catch(reject);
    });
  };
  const applyMimeTypeMap = (map2) => (acceptedFileType) => map2[acceptedFileType] === null ? false : map2[acceptedFileType] || acceptedFileType;
  addFilter2("SET_ATTRIBUTE_TO_OPTION_MAP", (map2) => Object.assign(map2, {
    accept: "acceptedFileTypes"
  }));
  addFilter2("ALLOW_HOPPER_ITEM", (file2, {query}) => {
    if (!query("GET_ALLOW_FILE_TYPE_VALIDATION")) {
      return true;
    }
    return validateFile(file2, query("GET_ACCEPTED_FILE_TYPES"));
  });
  addFilter2("LOAD_FILE", (file2, {query}) => new Promise((resolve, reject) => {
    if (!query("GET_ALLOW_FILE_TYPE_VALIDATION")) {
      resolve(file2);
      return;
    }
    const acceptedFileTypes = query("GET_ACCEPTED_FILE_TYPES");
    const typeDetector = query("GET_FILE_VALIDATE_TYPE_DETECT_TYPE");
    const validationResult = validateFile(file2, acceptedFileTypes, typeDetector);
    const handleRejection = () => {
      const acceptedFileTypesMapped = acceptedFileTypes.map(applyMimeTypeMap(query("GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP"))).filter((label) => label !== false);
      const acceptedFileTypesMapped_unique = acceptedFileTypesMapped.filter(function(item2, index2) {
        return acceptedFileTypesMapped.indexOf(item2) === index2;
      });
      reject({
        status: {
          main: query("GET_LABEL_FILE_TYPE_NOT_ALLOWED"),
          sub: replaceInString2(query("GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES"), {
            allTypes: acceptedFileTypesMapped_unique.join(", "),
            allButLastType: acceptedFileTypesMapped_unique.slice(0, -1).join(", "),
            lastType: acceptedFileTypesMapped_unique[acceptedFileTypesMapped.length - 1]
          })
        }
      });
    };
    if (typeof validationResult === "boolean") {
      if (!validationResult) {
        return handleRejection();
      }
      return resolve(file2);
    }
    validationResult.then(() => {
      resolve(file2);
    }).catch(handleRejection);
  }));
  return {
    options: {
      allowFileTypeValidation: [true, Type2.BOOLEAN],
      acceptedFileTypes: [[], Type2.ARRAY],
      labelFileTypeNotAllowed: ["File is of invalid type", Type2.STRING],
      fileValidateTypeLabelExpectedTypes: [
        "Expects {allButLastType} or {lastType}",
        Type2.STRING
      ],
      fileValidateTypeLabelExpectedTypesMap: [{}, Type2.OBJECT],
      fileValidateTypeDetectType: [null, Type2.FUNCTION]
    }
  };
};
var isBrowser3 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser3) {
  document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", {detail: plugin2}));
}
var filepond_plugin_file_validate_type_esm_default = plugin2;

// node_modules/filepond-plugin-image-crop/dist/filepond-plugin-image-crop.esm.js
/*!
 * FilePondPluginImageCrop 2.0.6
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
var isImage = (file2) => /^image/.test(file2.type);
var plugin3 = ({addFilter: addFilter2, utils}) => {
  const {Type: Type2, isFile: isFile2, getNumericAspectRatioFromString: getNumericAspectRatioFromString2} = utils;
  const allowCrop = (item2, query) => !(!isImage(item2.file) || !query("GET_ALLOW_IMAGE_CROP"));
  const isObject2 = (value) => typeof value === "object";
  const isNumber2 = (value) => typeof value === "number";
  const updateCrop = (item2, obj) => item2.setMetadata("crop", Object.assign({}, item2.getMetadata("crop"), obj));
  addFilter2("DID_CREATE_ITEM", (item2, {query}) => {
    item2.extend("setImageCrop", (crop) => {
      if (!allowCrop(item2, query) || !isObject2(center))
        return;
      item2.setMetadata("crop", crop);
      return crop;
    });
    item2.extend("setImageCropCenter", (center2) => {
      if (!allowCrop(item2, query) || !isObject2(center2))
        return;
      return updateCrop(item2, {center: center2});
    });
    item2.extend("setImageCropZoom", (zoom) => {
      if (!allowCrop(item2, query) || !isNumber2(zoom))
        return;
      return updateCrop(item2, {zoom: Math.max(1, zoom)});
    });
    item2.extend("setImageCropRotation", (rotation) => {
      if (!allowCrop(item2, query) || !isNumber2(rotation))
        return;
      return updateCrop(item2, {rotation});
    });
    item2.extend("setImageCropFlip", (flip) => {
      if (!allowCrop(item2, query) || !isObject2(flip))
        return;
      return updateCrop(item2, {flip});
    });
    item2.extend("setImageCropAspectRatio", (newAspectRatio) => {
      if (!allowCrop(item2, query) || typeof newAspectRatio === "undefined")
        return;
      const currentCrop = item2.getMetadata("crop");
      const aspectRatio = getNumericAspectRatioFromString2(newAspectRatio);
      const newCrop = {
        center: {
          x: 0.5,
          y: 0.5
        },
        flip: currentCrop ? Object.assign({}, currentCrop.flip) : {
          horizontal: false,
          vertical: false
        },
        rotation: 0,
        zoom: 1,
        aspectRatio
      };
      item2.setMetadata("crop", newCrop);
      return newCrop;
    });
  });
  addFilter2("DID_LOAD_ITEM", (item2, {query}) => new Promise((resolve, reject) => {
    const file2 = item2.file;
    if (!isFile2(file2) || !isImage(file2) || !query("GET_ALLOW_IMAGE_CROP")) {
      return resolve(item2);
    }
    const crop = item2.getMetadata("crop");
    if (crop) {
      return resolve(item2);
    }
    const humanAspectRatio = query("GET_IMAGE_CROP_ASPECT_RATIO");
    item2.setMetadata("crop", {
      center: {
        x: 0.5,
        y: 0.5
      },
      flip: {
        horizontal: false,
        vertical: false
      },
      rotation: 0,
      zoom: 1,
      aspectRatio: humanAspectRatio ? getNumericAspectRatioFromString2(humanAspectRatio) : null
    });
    resolve(item2);
  }));
  return {
    options: {
      allowImageCrop: [true, Type2.BOOLEAN],
      imageCropAspectRatio: [null, Type2.STRING]
    }
  };
};
var isBrowser4 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser4) {
  document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", {detail: plugin3}));
}
var filepond_plugin_image_crop_esm_default = plugin3;

// node_modules/filepond-plugin-image-exif-orientation/dist/filepond-plugin-image-exif-orientation.esm.js
/*!
 * FilePondPluginImageExifOrientation 1.0.11
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
var isJPEG = (file2) => /^image\/jpeg/.test(file2.type);
var Marker = {
  JPEG: 65496,
  APP1: 65505,
  EXIF: 1165519206,
  TIFF: 18761,
  Orientation: 274,
  Unknown: 65280
};
var getUint16 = (view, offset, little = false) => view.getUint16(offset, little);
var getUint32 = (view, offset, little = false) => view.getUint32(offset, little);
var getImageOrientation = (file2) => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = function(e) {
    const view = new DataView(e.target.result);
    if (getUint16(view, 0) !== Marker.JPEG) {
      resolve(-1);
      return;
    }
    const length = view.byteLength;
    let offset = 2;
    while (offset < length) {
      const marker = getUint16(view, offset);
      offset += 2;
      if (marker === Marker.APP1) {
        if (getUint32(view, offset += 2) !== Marker.EXIF) {
          break;
        }
        const little = getUint16(view, offset += 6) === Marker.TIFF;
        offset += getUint32(view, offset + 4, little);
        const tags = getUint16(view, offset, little);
        offset += 2;
        for (let i = 0; i < tags; i++) {
          if (getUint16(view, offset + i * 12, little) === Marker.Orientation) {
            resolve(getUint16(view, offset + i * 12 + 8, little));
            return;
          }
        }
      } else if ((marker & Marker.Unknown) !== Marker.Unknown) {
        break;
      } else {
        offset += getUint16(view, offset);
      }
    }
    resolve(-1);
  };
  reader.readAsArrayBuffer(file2.slice(0, 64 * 1024));
});
var IS_BROWSER2 = (() => typeof window !== "undefined" && typeof window.document !== "undefined")();
var isBrowser5 = () => IS_BROWSER2;
var testSrc = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4QA6RXhpZgAATU0AKgAAAAgAAwESAAMAAAABAAYAAAEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAD/2wBDAP//////////////////////////////////////////////////////////////////////////////////////wAALCAABAAIBASIA/8QAJgABAAAAAAAAAAAAAAAAAAAAAxABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQAAPwBH/9k=";
var shouldCorrect = void 0;
var testImage = isBrowser5() ? new Image() : {};
testImage.onload = () => shouldCorrect = testImage.naturalWidth > testImage.naturalHeight;
testImage.src = testSrc;
var shouldCorrectImageExifOrientation = () => shouldCorrect;
var plugin4 = ({addFilter: addFilter2, utils}) => {
  const {Type: Type2, isFile: isFile2} = utils;
  addFilter2("DID_LOAD_ITEM", (item2, {query}) => new Promise((resolve, reject) => {
    const file2 = item2.file;
    if (!isFile2(file2) || !isJPEG(file2) || !query("GET_ALLOW_IMAGE_EXIF_ORIENTATION") || !shouldCorrectImageExifOrientation()) {
      return resolve(item2);
    }
    getImageOrientation(file2).then((orientation) => {
      item2.setMetadata("exif", {orientation});
      resolve(item2);
    });
  }));
  return {
    options: {
      allowImageExifOrientation: [true, Type2.BOOLEAN]
    }
  };
};
var isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser$1) {
  document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", {detail: plugin4}));
}
var filepond_plugin_image_exif_orientation_esm_default = plugin4;

// node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.esm.js
/*!
 * FilePondPluginImagePreview 4.6.11
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
var isPreviewableImage = (file2) => /^image/.test(file2.type);
var vectorMultiply = (v, amount) => createVector(v.x * amount, v.y * amount);
var vectorAdd = (a, b) => createVector(a.x + b.x, a.y + b.y);
var vectorNormalize = (v) => {
  const l = Math.sqrt(v.x * v.x + v.y * v.y);
  if (l === 0) {
    return {
      x: 0,
      y: 0
    };
  }
  return createVector(v.x / l, v.y / l);
};
var vectorRotate = (v, radians, origin) => {
  const cos = Math.cos(radians);
  const sin = Math.sin(radians);
  const t = createVector(v.x - origin.x, v.y - origin.y);
  return createVector(origin.x + cos * t.x - sin * t.y, origin.y + sin * t.x + cos * t.y);
};
var createVector = (x = 0, y = 0) => ({x, y});
var getMarkupValue = (value, size, scalar = 1, axis) => {
  if (typeof value === "string") {
    return parseFloat(value) * scalar;
  }
  if (typeof value === "number") {
    return value * (axis ? size[axis] : Math.min(size.width, size.height));
  }
  return;
};
var getMarkupStyles = (markup, size, scale) => {
  const lineStyle = markup.borderStyle || markup.lineStyle || "solid";
  const fill = markup.backgroundColor || markup.fontColor || "transparent";
  const stroke = markup.borderColor || markup.lineColor || "transparent";
  const strokeWidth = getMarkupValue(markup.borderWidth || markup.lineWidth, size, scale);
  const lineCap = markup.lineCap || "round";
  const lineJoin = markup.lineJoin || "round";
  const dashes = typeof lineStyle === "string" ? "" : lineStyle.map((v) => getMarkupValue(v, size, scale)).join(",");
  const opacity = markup.opacity || 1;
  return {
    "stroke-linecap": lineCap,
    "stroke-linejoin": lineJoin,
    "stroke-width": strokeWidth || 0,
    "stroke-dasharray": dashes,
    stroke,
    fill,
    opacity
  };
};
var isDefined2 = (value) => value != null;
var getMarkupRect = (rect, size, scalar = 1) => {
  let left = getMarkupValue(rect.x, size, scalar, "width") || getMarkupValue(rect.left, size, scalar, "width");
  let top = getMarkupValue(rect.y, size, scalar, "height") || getMarkupValue(rect.top, size, scalar, "height");
  let width = getMarkupValue(rect.width, size, scalar, "width");
  let height = getMarkupValue(rect.height, size, scalar, "height");
  let right = getMarkupValue(rect.right, size, scalar, "width");
  let bottom = getMarkupValue(rect.bottom, size, scalar, "height");
  if (!isDefined2(top)) {
    if (isDefined2(height) && isDefined2(bottom)) {
      top = size.height - height - bottom;
    } else {
      top = bottom;
    }
  }
  if (!isDefined2(left)) {
    if (isDefined2(width) && isDefined2(right)) {
      left = size.width - width - right;
    } else {
      left = right;
    }
  }
  if (!isDefined2(width)) {
    if (isDefined2(left) && isDefined2(right)) {
      width = size.width - left - right;
    } else {
      width = 0;
    }
  }
  if (!isDefined2(height)) {
    if (isDefined2(top) && isDefined2(bottom)) {
      height = size.height - top - bottom;
    } else {
      height = 0;
    }
  }
  return {
    x: left || 0,
    y: top || 0,
    width: width || 0,
    height: height || 0
  };
};
var pointsToPathShape = (points) => points.map((point, index2) => `${index2 === 0 ? "M" : "L"} ${point.x} ${point.y}`).join(" ");
var setAttributes = (element, attr2) => Object.keys(attr2).forEach((key) => element.setAttribute(key, attr2[key]));
var ns2 = "http://www.w3.org/2000/svg";
var svg = (tag, attr2) => {
  const element = document.createElementNS(ns2, tag);
  if (attr2) {
    setAttributes(element, attr2);
  }
  return element;
};
var updateRect2 = (element) => setAttributes(element, {
  ...element.rect,
  ...element.styles
});
var updateEllipse = (element) => {
  const cx = element.rect.x + element.rect.width * 0.5;
  const cy = element.rect.y + element.rect.height * 0.5;
  const rx = element.rect.width * 0.5;
  const ry = element.rect.height * 0.5;
  return setAttributes(element, {
    cx,
    cy,
    rx,
    ry,
    ...element.styles
  });
};
var IMAGE_FIT_STYLE = {
  contain: "xMidYMid meet",
  cover: "xMidYMid slice"
};
var updateImage = (element, markup) => {
  setAttributes(element, {
    ...element.rect,
    ...element.styles,
    preserveAspectRatio: IMAGE_FIT_STYLE[markup.fit] || "none"
  });
};
var TEXT_ANCHOR = {
  left: "start",
  center: "middle",
  right: "end"
};
var updateText = (element, markup, size, scale) => {
  const fontSize = getMarkupValue(markup.fontSize, size, scale);
  const fontFamily = markup.fontFamily || "sans-serif";
  const fontWeight = markup.fontWeight || "normal";
  const textAlign = TEXT_ANCHOR[markup.textAlign] || "start";
  setAttributes(element, {
    ...element.rect,
    ...element.styles,
    "stroke-width": 0,
    "font-weight": fontWeight,
    "font-size": fontSize,
    "font-family": fontFamily,
    "text-anchor": textAlign
  });
  if (element.text !== markup.text) {
    element.text = markup.text;
    element.textContent = markup.text.length ? markup.text : " ";
  }
};
var updateLine = (element, markup, size, scale) => {
  setAttributes(element, {
    ...element.rect,
    ...element.styles,
    fill: "none"
  });
  const line = element.childNodes[0];
  const begin = element.childNodes[1];
  const end = element.childNodes[2];
  const origin = element.rect;
  const target = {
    x: element.rect.x + element.rect.width,
    y: element.rect.y + element.rect.height
  };
  setAttributes(line, {
    x1: origin.x,
    y1: origin.y,
    x2: target.x,
    y2: target.y
  });
  if (!markup.lineDecoration)
    return;
  begin.style.display = "none";
  end.style.display = "none";
  const v = vectorNormalize({
    x: target.x - origin.x,
    y: target.y - origin.y
  });
  const l = getMarkupValue(0.05, size, scale);
  if (markup.lineDecoration.indexOf("arrow-begin") !== -1) {
    const arrowBeginRotationPoint = vectorMultiply(v, l);
    const arrowBeginCenter = vectorAdd(origin, arrowBeginRotationPoint);
    const arrowBeginA = vectorRotate(origin, 2, arrowBeginCenter);
    const arrowBeginB = vectorRotate(origin, -2, arrowBeginCenter);
    setAttributes(begin, {
      style: "display:block;",
      d: `M${arrowBeginA.x},${arrowBeginA.y} L${origin.x},${origin.y} L${arrowBeginB.x},${arrowBeginB.y}`
    });
  }
  if (markup.lineDecoration.indexOf("arrow-end") !== -1) {
    const arrowEndRotationPoint = vectorMultiply(v, -l);
    const arrowEndCenter = vectorAdd(target, arrowEndRotationPoint);
    const arrowEndA = vectorRotate(target, 2, arrowEndCenter);
    const arrowEndB = vectorRotate(target, -2, arrowEndCenter);
    setAttributes(end, {
      style: "display:block;",
      d: `M${arrowEndA.x},${arrowEndA.y} L${target.x},${target.y} L${arrowEndB.x},${arrowEndB.y}`
    });
  }
};
var updatePath = (element, markup, size, scale) => {
  setAttributes(element, {
    ...element.styles,
    fill: "none",
    d: pointsToPathShape(markup.points.map((point) => ({
      x: getMarkupValue(point.x, size, scale, "width"),
      y: getMarkupValue(point.y, size, scale, "height")
    })))
  });
};
var createShape = (node) => (markup) => svg(node, {id: markup.id});
var createImage = (markup) => {
  const shape = svg("image", {
    id: markup.id,
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    opacity: "0"
  });
  shape.onload = () => {
    shape.setAttribute("opacity", markup.opacity || 1);
  };
  shape.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", markup.src);
  return shape;
};
var createLine = (markup) => {
  const shape = svg("g", {
    id: markup.id,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  });
  const line = svg("line");
  shape.appendChild(line);
  const begin = svg("path");
  shape.appendChild(begin);
  const end = svg("path");
  shape.appendChild(end);
  return shape;
};
var CREATE_TYPE_ROUTES = {
  image: createImage,
  rect: createShape("rect"),
  ellipse: createShape("ellipse"),
  text: createShape("text"),
  path: createShape("path"),
  line: createLine
};
var UPDATE_TYPE_ROUTES = {
  rect: updateRect2,
  ellipse: updateEllipse,
  image: updateImage,
  text: updateText,
  path: updatePath,
  line: updateLine
};
var createMarkupByType = (type, markup) => CREATE_TYPE_ROUTES[type](markup);
var updateMarkupByType = (element, type, markup, size, scale) => {
  if (type !== "path") {
    element.rect = getMarkupRect(markup, size, scale);
  }
  element.styles = getMarkupStyles(markup, size, scale);
  UPDATE_TYPE_ROUTES[type](element, markup, size, scale);
};
var MARKUP_RECT = [
  "x",
  "y",
  "left",
  "top",
  "right",
  "bottom",
  "width",
  "height"
];
var toOptionalFraction = (value) => typeof value === "string" && /%/.test(value) ? parseFloat(value) / 100 : value;
var prepareMarkup = (markup) => {
  const [type, props] = markup;
  const rect = props.points ? {} : MARKUP_RECT.reduce((prev, curr) => {
    prev[curr] = toOptionalFraction(props[curr]);
    return prev;
  }, {});
  return [
    type,
    {
      zIndex: 0,
      ...props,
      ...rect
    }
  ];
};
var sortMarkupByZIndex = (a, b) => {
  if (a[1].zIndex > b[1].zIndex) {
    return 1;
  }
  if (a[1].zIndex < b[1].zIndex) {
    return -1;
  }
  return 0;
};
var createMarkupView = (_) => _.utils.createView({
  name: "image-preview-markup",
  tag: "svg",
  ignoreRect: true,
  mixins: {
    apis: ["width", "height", "crop", "markup", "resize", "dirty"]
  },
  write: ({root: root2, props}) => {
    if (!props.dirty)
      return;
    const {crop, resize, markup} = props;
    const viewWidth = props.width;
    const viewHeight = props.height;
    let cropWidth = crop.width;
    let cropHeight = crop.height;
    if (resize) {
      const {size: size2} = resize;
      let outputWidth = size2 && size2.width;
      let outputHeight = size2 && size2.height;
      const outputFit = resize.mode;
      const outputUpscale = resize.upscale;
      if (outputWidth && !outputHeight)
        outputHeight = outputWidth;
      if (outputHeight && !outputWidth)
        outputWidth = outputHeight;
      const shouldUpscale = cropWidth < outputWidth && cropHeight < outputHeight;
      if (!shouldUpscale || shouldUpscale && outputUpscale) {
        let scalarWidth = outputWidth / cropWidth;
        let scalarHeight = outputHeight / cropHeight;
        if (outputFit === "force") {
          cropWidth = outputWidth;
          cropHeight = outputHeight;
        } else {
          let scalar;
          if (outputFit === "cover") {
            scalar = Math.max(scalarWidth, scalarHeight);
          } else if (outputFit === "contain") {
            scalar = Math.min(scalarWidth, scalarHeight);
          }
          cropWidth = cropWidth * scalar;
          cropHeight = cropHeight * scalar;
        }
      }
    }
    const size = {
      width: viewWidth,
      height: viewHeight
    };
    root2.element.setAttribute("width", size.width);
    root2.element.setAttribute("height", size.height);
    const scale = Math.min(viewWidth / cropWidth, viewHeight / cropHeight);
    root2.element.innerHTML = "";
    const markupFilter = root2.query("GET_IMAGE_PREVIEW_MARKUP_FILTER");
    markup.filter(markupFilter).map(prepareMarkup).sort(sortMarkupByZIndex).forEach((markup2) => {
      const [type, settings] = markup2;
      const element = createMarkupByType(type, settings);
      updateMarkupByType(element, type, settings, size, scale);
      root2.element.appendChild(element);
    });
  }
});
var createVector$1 = (x, y) => ({x, y});
var vectorDot = (a, b) => a.x * b.x + a.y * b.y;
var vectorSubtract = (a, b) => createVector$1(a.x - b.x, a.y - b.y);
var vectorDistanceSquared = (a, b) => vectorDot(vectorSubtract(a, b), vectorSubtract(a, b));
var vectorDistance = (a, b) => Math.sqrt(vectorDistanceSquared(a, b));
var getOffsetPointOnEdge = (length, rotation) => {
  const a = length;
  const A = 1.5707963267948966;
  const B = rotation;
  const C3 = 1.5707963267948966 - rotation;
  const sinA = Math.sin(A);
  const sinB = Math.sin(B);
  const sinC = Math.sin(C3);
  const cosC = Math.cos(C3);
  const ratio = a / sinA;
  const b = ratio * sinB;
  const c = ratio * sinC;
  return createVector$1(cosC * b, cosC * c);
};
var getRotatedRectSize = (rect, rotation) => {
  const w = rect.width;
  const h = rect.height;
  const hor = getOffsetPointOnEdge(w, rotation);
  const ver = getOffsetPointOnEdge(h, rotation);
  const tl = createVector$1(rect.x + Math.abs(hor.x), rect.y - Math.abs(hor.y));
  const tr = createVector$1(rect.x + rect.width + Math.abs(ver.y), rect.y + Math.abs(ver.x));
  const bl = createVector$1(rect.x - Math.abs(ver.y), rect.y + rect.height - Math.abs(ver.x));
  return {
    width: vectorDistance(tl, tr),
    height: vectorDistance(tl, bl)
  };
};
var calculateCanvasSize = (image, canvasAspectRatio, zoom = 1) => {
  const imageAspectRatio = image.height / image.width;
  let canvasWidth = 1;
  let canvasHeight = canvasAspectRatio;
  let imgWidth = 1;
  let imgHeight = imageAspectRatio;
  if (imgHeight > canvasHeight) {
    imgHeight = canvasHeight;
    imgWidth = imgHeight / imageAspectRatio;
  }
  const scalar = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);
  const width = image.width / (zoom * scalar * imgWidth);
  const height = width * canvasAspectRatio;
  return {
    width,
    height
  };
};
var getImageRectZoomFactor = (imageRect, cropRect, rotation, center2) => {
  const cx = center2.x > 0.5 ? 1 - center2.x : center2.x;
  const cy = center2.y > 0.5 ? 1 - center2.y : center2.y;
  const imageWidth = cx * 2 * imageRect.width;
  const imageHeight = cy * 2 * imageRect.height;
  const rotatedCropSize = getRotatedRectSize(cropRect, rotation);
  return Math.max(rotatedCropSize.width / imageWidth, rotatedCropSize.height / imageHeight);
};
var getCenteredCropRect = (container, aspectRatio) => {
  let width = container.width;
  let height = width * aspectRatio;
  if (height > container.height) {
    height = container.height;
    width = height / aspectRatio;
  }
  const x = (container.width - width) * 0.5;
  const y = (container.height - height) * 0.5;
  return {
    x,
    y,
    width,
    height
  };
};
var getCurrentCropSize = (imageSize, crop = {}) => {
  let {zoom, rotation, center: center2, aspectRatio} = crop;
  if (!aspectRatio)
    aspectRatio = imageSize.height / imageSize.width;
  const canvasSize = calculateCanvasSize(imageSize, aspectRatio, zoom);
  const canvasCenter = {
    x: canvasSize.width * 0.5,
    y: canvasSize.height * 0.5
  };
  const stage = {
    x: 0,
    y: 0,
    width: canvasSize.width,
    height: canvasSize.height,
    center: canvasCenter
  };
  const shouldLimit = typeof crop.scaleToFit === "undefined" || crop.scaleToFit;
  const stageZoomFactor = getImageRectZoomFactor(imageSize, getCenteredCropRect(stage, aspectRatio), rotation, shouldLimit ? center2 : {x: 0.5, y: 0.5});
  const scale = zoom * stageZoomFactor;
  return {
    widthFloat: canvasSize.width / scale,
    heightFloat: canvasSize.height / scale,
    width: Math.round(canvasSize.width / scale),
    height: Math.round(canvasSize.height / scale)
  };
};
var IMAGE_SCALE_SPRING_PROPS = {
  type: "spring",
  stiffness: 0.5,
  damping: 0.45,
  mass: 10
};
var createBitmapView = (_) => _.utils.createView({
  name: "image-bitmap",
  ignoreRect: true,
  mixins: {styles: ["scaleX", "scaleY"]},
  create: ({root: root2, props}) => {
    root2.appendChild(props.image);
  }
});
var createImageCanvasWrapper = (_) => _.utils.createView({
  name: "image-canvas-wrapper",
  tag: "div",
  ignoreRect: true,
  mixins: {
    apis: ["crop", "width", "height"],
    styles: [
      "originX",
      "originY",
      "translateX",
      "translateY",
      "scaleX",
      "scaleY",
      "rotateZ"
    ],
    animations: {
      originX: IMAGE_SCALE_SPRING_PROPS,
      originY: IMAGE_SCALE_SPRING_PROPS,
      scaleX: IMAGE_SCALE_SPRING_PROPS,
      scaleY: IMAGE_SCALE_SPRING_PROPS,
      translateX: IMAGE_SCALE_SPRING_PROPS,
      translateY: IMAGE_SCALE_SPRING_PROPS,
      rotateZ: IMAGE_SCALE_SPRING_PROPS
    }
  },
  create: ({root: root2, props}) => {
    props.width = props.image.width;
    props.height = props.image.height;
    root2.ref.bitmap = root2.appendChildView(root2.createChildView(createBitmapView(_), {image: props.image}));
  },
  write: ({root: root2, props}) => {
    const {flip} = props.crop;
    const {bitmap} = root2.ref;
    bitmap.scaleX = flip.horizontal ? -1 : 1;
    bitmap.scaleY = flip.vertical ? -1 : 1;
  }
});
var createClipView = (_) => _.utils.createView({
  name: "image-clip",
  tag: "div",
  ignoreRect: true,
  mixins: {
    apis: [
      "crop",
      "markup",
      "resize",
      "width",
      "height",
      "dirty",
      "background"
    ],
    styles: ["width", "height", "opacity"],
    animations: {
      opacity: {type: "tween", duration: 250}
    }
  },
  didWriteView: function({root: root2, props}) {
    if (!props.background)
      return;
    root2.element.style.backgroundColor = props.background;
  },
  create: ({root: root2, props}) => {
    root2.ref.image = root2.appendChildView(root2.createChildView(createImageCanvasWrapper(_), Object.assign({}, props)));
    root2.ref.createMarkup = () => {
      if (root2.ref.markup)
        return;
      root2.ref.markup = root2.appendChildView(root2.createChildView(createMarkupView(_), Object.assign({}, props)));
    };
    root2.ref.destroyMarkup = () => {
      if (!root2.ref.markup)
        return;
      root2.removeChildView(root2.ref.markup);
      root2.ref.markup = null;
    };
    const transparencyIndicator = root2.query("GET_IMAGE_PREVIEW_TRANSPARENCY_INDICATOR");
    if (transparencyIndicator === null)
      return;
    if (transparencyIndicator === "grid") {
      root2.element.dataset.transparencyIndicator = transparencyIndicator;
    } else {
      root2.element.dataset.transparencyIndicator = "color";
    }
  },
  write: ({root: root2, props, shouldOptimize}) => {
    const {crop, markup, resize, dirty, width, height} = props;
    root2.ref.image.crop = crop;
    const stage = {
      x: 0,
      y: 0,
      width,
      height,
      center: {
        x: width * 0.5,
        y: height * 0.5
      }
    };
    const image = {
      width: root2.ref.image.width,
      height: root2.ref.image.height
    };
    const origin = {
      x: crop.center.x * image.width,
      y: crop.center.y * image.height
    };
    const translation = {
      x: stage.center.x - image.width * crop.center.x,
      y: stage.center.y - image.height * crop.center.y
    };
    const rotation = Math.PI * 2 + crop.rotation % (Math.PI * 2);
    const cropAspectRatio = crop.aspectRatio || image.height / image.width;
    const shouldLimit = typeof crop.scaleToFit === "undefined" || crop.scaleToFit;
    const stageZoomFactor = getImageRectZoomFactor(image, getCenteredCropRect(stage, cropAspectRatio), rotation, shouldLimit ? crop.center : {x: 0.5, y: 0.5});
    const scale = crop.zoom * stageZoomFactor;
    if (markup && markup.length) {
      root2.ref.createMarkup();
      root2.ref.markup.width = width;
      root2.ref.markup.height = height;
      root2.ref.markup.resize = resize;
      root2.ref.markup.dirty = dirty;
      root2.ref.markup.markup = markup;
      root2.ref.markup.crop = getCurrentCropSize(image, crop);
    } else if (root2.ref.markup) {
      root2.ref.destroyMarkup();
    }
    const imageView = root2.ref.image;
    if (shouldOptimize) {
      imageView.originX = null;
      imageView.originY = null;
      imageView.translateX = null;
      imageView.translateY = null;
      imageView.rotateZ = null;
      imageView.scaleX = null;
      imageView.scaleY = null;
      return;
    }
    imageView.originX = origin.x;
    imageView.originY = origin.y;
    imageView.translateX = translation.x;
    imageView.translateY = translation.y;
    imageView.rotateZ = rotation;
    imageView.scaleX = scale;
    imageView.scaleY = scale;
  }
});
var createImageView = (_) => _.utils.createView({
  name: "image-preview",
  tag: "div",
  ignoreRect: true,
  mixins: {
    apis: ["image", "crop", "markup", "resize", "dirty", "background"],
    styles: ["translateY", "scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: IMAGE_SCALE_SPRING_PROPS,
      scaleY: IMAGE_SCALE_SPRING_PROPS,
      translateY: IMAGE_SCALE_SPRING_PROPS,
      opacity: {type: "tween", duration: 400}
    }
  },
  create: ({root: root2, props}) => {
    root2.ref.clip = root2.appendChildView(root2.createChildView(createClipView(_), {
      id: props.id,
      image: props.image,
      crop: props.crop,
      markup: props.markup,
      resize: props.resize,
      dirty: props.dirty,
      background: props.background
    }));
  },
  write: ({root: root2, props, shouldOptimize}) => {
    const {clip} = root2.ref;
    const {image, crop, markup, resize, dirty} = props;
    clip.crop = crop;
    clip.markup = markup;
    clip.resize = resize;
    clip.dirty = dirty;
    clip.opacity = shouldOptimize ? 0 : 1;
    if (shouldOptimize || root2.rect.element.hidden)
      return;
    const imageAspectRatio = image.height / image.width;
    let aspectRatio = crop.aspectRatio || imageAspectRatio;
    const containerWidth = root2.rect.inner.width;
    const containerHeight = root2.rect.inner.height;
    let fixedPreviewHeight = root2.query("GET_IMAGE_PREVIEW_HEIGHT");
    const minPreviewHeight = root2.query("GET_IMAGE_PREVIEW_MIN_HEIGHT");
    const maxPreviewHeight = root2.query("GET_IMAGE_PREVIEW_MAX_HEIGHT");
    const panelAspectRatio = root2.query("GET_PANEL_ASPECT_RATIO");
    const allowMultiple = root2.query("GET_ALLOW_MULTIPLE");
    if (panelAspectRatio && !allowMultiple) {
      fixedPreviewHeight = containerWidth * panelAspectRatio;
      aspectRatio = panelAspectRatio;
    }
    let clipHeight = fixedPreviewHeight !== null ? fixedPreviewHeight : Math.max(minPreviewHeight, Math.min(containerWidth * aspectRatio, maxPreviewHeight));
    let clipWidth = clipHeight / aspectRatio;
    if (clipWidth > containerWidth) {
      clipWidth = containerWidth;
      clipHeight = clipWidth * aspectRatio;
    }
    if (clipHeight > containerHeight) {
      clipHeight = containerHeight;
      clipWidth = containerHeight / aspectRatio;
    }
    clip.width = clipWidth;
    clip.height = clipHeight;
  }
});
var SVG_MASK = `<svg width="500" height="200" viewBox="0 0 500 200" preserveAspectRatio="none">
    <defs>
        <radialGradient id="gradient-__UID__" cx=".5" cy="1.25" r="1.15">
            <stop offset='50%' stop-color='#000000'/>
            <stop offset='56%' stop-color='#0a0a0a'/>
            <stop offset='63%' stop-color='#262626'/>
            <stop offset='69%' stop-color='#4f4f4f'/>
            <stop offset='75%' stop-color='#808080'/>
            <stop offset='81%' stop-color='#b1b1b1'/>
            <stop offset='88%' stop-color='#dadada'/>
            <stop offset='94%' stop-color='#f6f6f6'/>
            <stop offset='100%' stop-color='#ffffff'/>
        </radialGradient>
        <mask id="mask-__UID__">
            <rect x="0" y="0" width="500" height="200" fill="url(#gradient-__UID__)"></rect>
        </mask>
    </defs>
    <rect x="0" width="500" height="200" fill="currentColor" mask="url(#mask-__UID__)"></rect>
</svg>`;
var SVGMaskUniqueId = 0;
var createImageOverlayView = (fpAPI) => fpAPI.utils.createView({
  name: "image-preview-overlay",
  tag: "div",
  ignoreRect: true,
  create: ({root: root2, props}) => {
    let mask = SVG_MASK;
    if (document.querySelector("base")) {
      const url = new URL(window.location.href.replace(window.location.hash, "")).href;
      mask = mask.replace(/url\(\#/g, "url(" + url + "#");
    }
    SVGMaskUniqueId++;
    root2.element.classList.add(`filepond--image-preview-overlay-${props.status}`);
    root2.element.innerHTML = mask.replace(/__UID__/g, SVGMaskUniqueId);
  },
  mixins: {
    styles: ["opacity"],
    animations: {
      opacity: {type: "spring", mass: 25}
    }
  }
});
var BitmapWorker = function() {
  self.onmessage = (e) => {
    createImageBitmap(e.data.message.file).then((bitmap) => {
      self.postMessage({id: e.data.id, message: bitmap}, [bitmap]);
    });
  };
};
var ColorMatrixWorker = function() {
  self.onmessage = (e) => {
    const imageData = e.data.message.imageData;
    const matrix2 = e.data.message.colorMatrix;
    const data3 = imageData.data;
    const l = data3.length;
    const m11 = matrix2[0];
    const m12 = matrix2[1];
    const m13 = matrix2[2];
    const m14 = matrix2[3];
    const m15 = matrix2[4];
    const m21 = matrix2[5];
    const m22 = matrix2[6];
    const m23 = matrix2[7];
    const m24 = matrix2[8];
    const m25 = matrix2[9];
    const m31 = matrix2[10];
    const m32 = matrix2[11];
    const m33 = matrix2[12];
    const m34 = matrix2[13];
    const m35 = matrix2[14];
    const m41 = matrix2[15];
    const m42 = matrix2[16];
    const m43 = matrix2[17];
    const m44 = matrix2[18];
    const m45 = matrix2[19];
    let index2 = 0, r = 0, g = 0, b = 0, a = 0;
    for (; index2 < l; index2 += 4) {
      r = data3[index2] / 255;
      g = data3[index2 + 1] / 255;
      b = data3[index2 + 2] / 255;
      a = data3[index2 + 3] / 255;
      data3[index2] = Math.max(0, Math.min((r * m11 + g * m12 + b * m13 + a * m14 + m15) * 255, 255));
      data3[index2 + 1] = Math.max(0, Math.min((r * m21 + g * m22 + b * m23 + a * m24 + m25) * 255, 255));
      data3[index2 + 2] = Math.max(0, Math.min((r * m31 + g * m32 + b * m33 + a * m34 + m35) * 255, 255));
      data3[index2 + 3] = Math.max(0, Math.min((r * m41 + g * m42 + b * m43 + a * m44 + m45) * 255, 255));
    }
    self.postMessage({id: e.data.id, message: imageData}, [
      imageData.data.buffer
    ]);
  };
};
var getImageSize = (url, cb) => {
  let image = new Image();
  image.onload = () => {
    const width = image.naturalWidth;
    const height = image.naturalHeight;
    image = null;
    cb(width, height);
  };
  image.src = url;
};
var transforms = {
  1: () => [1, 0, 0, 1, 0, 0],
  2: (width) => [-1, 0, 0, 1, width, 0],
  3: (width, height) => [-1, 0, 0, -1, width, height],
  4: (width, height) => [1, 0, 0, -1, 0, height],
  5: () => [0, 1, 1, 0, 0, 0],
  6: (width, height) => [0, 1, -1, 0, height, 0],
  7: (width, height) => [0, -1, -1, 0, height, width],
  8: (width) => [0, -1, 1, 0, 0, width]
};
var fixImageOrientation = (ctx, width, height, orientation) => {
  if (orientation === -1) {
    return;
  }
  ctx.transform.apply(ctx, transforms[orientation](width, height));
};
var createPreviewImage = (data3, width, height, orientation) => {
  width = Math.round(width);
  height = Math.round(height);
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  if (orientation >= 5 && orientation <= 8) {
    [width, height] = [height, width];
  }
  fixImageOrientation(ctx, width, height, orientation);
  ctx.drawImage(data3, 0, 0, width, height);
  return canvas;
};
var isBitmap = (file2) => /^image/.test(file2.type) && !/svg/.test(file2.type);
var MAX_WIDTH = 10;
var MAX_HEIGHT = 10;
var calculateAverageColor = (image) => {
  const scalar = Math.min(MAX_WIDTH / image.width, MAX_HEIGHT / image.height);
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const width = canvas.width = Math.ceil(image.width * scalar);
  const height = canvas.height = Math.ceil(image.height * scalar);
  ctx.drawImage(image, 0, 0, width, height);
  let data3 = null;
  try {
    data3 = ctx.getImageData(0, 0, width, height).data;
  } catch (e) {
    return null;
  }
  const l = data3.length;
  let r = 0;
  let g = 0;
  let b = 0;
  let i = 0;
  for (; i < l; i += 4) {
    r += data3[i] * data3[i];
    g += data3[i + 1] * data3[i + 1];
    b += data3[i + 2] * data3[i + 2];
  }
  r = averageColor(r, l);
  g = averageColor(g, l);
  b = averageColor(b, l);
  return {r, g, b};
};
var averageColor = (c, l) => Math.floor(Math.sqrt(c / (l / 4)));
var cloneCanvas = (origin, target) => {
  target = target || document.createElement("canvas");
  target.width = origin.width;
  target.height = origin.height;
  const ctx = target.getContext("2d");
  ctx.drawImage(origin, 0, 0);
  return target;
};
var cloneImageData = (imageData) => {
  let id;
  try {
    id = new ImageData(imageData.width, imageData.height);
  } catch (e) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    id = ctx.createImageData(imageData.width, imageData.height);
  }
  id.data.set(new Uint8ClampedArray(imageData.data));
  return id;
};
var loadImage2 = (url) => new Promise((resolve, reject) => {
  const img = new Image();
  img.crossOrigin = "Anonymous";
  img.onload = () => {
    resolve(img);
  };
  img.onerror = (e) => {
    reject(e);
  };
  img.src = url;
});
var createImageWrapperView = (_) => {
  const OverlayView = createImageOverlayView(_);
  const ImageView = createImageView(_);
  const {createWorker: createWorker3} = _.utils;
  const applyFilter = (root2, filter, target) => new Promise((resolve) => {
    if (!root2.ref.imageData) {
      root2.ref.imageData = target.getContext("2d").getImageData(0, 0, target.width, target.height);
    }
    const imageData = cloneImageData(root2.ref.imageData);
    if (!filter || filter.length !== 20) {
      target.getContext("2d").putImageData(imageData, 0, 0);
      return resolve();
    }
    const worker = createWorker3(ColorMatrixWorker);
    worker.post({
      imageData,
      colorMatrix: filter
    }, (response) => {
      target.getContext("2d").putImageData(response, 0, 0);
      worker.terminate();
      resolve();
    }, [imageData.data.buffer]);
  });
  const removeImageView = (root2, imageView) => {
    root2.removeChildView(imageView);
    imageView.image.width = 1;
    imageView.image.height = 1;
    imageView._destroy();
  };
  const shiftImage = ({root: root2}) => {
    const imageView = root2.ref.images.shift();
    imageView.opacity = 0;
    imageView.translateY = -15;
    root2.ref.imageViewBin.push(imageView);
    return imageView;
  };
  const pushImage = ({root: root2, props, image}) => {
    const id = props.id;
    const item2 = root2.query("GET_ITEM", {id});
    if (!item2)
      return;
    const crop = item2.getMetadata("crop") || {
      center: {
        x: 0.5,
        y: 0.5
      },
      flip: {
        horizontal: false,
        vertical: false
      },
      zoom: 1,
      rotation: 0,
      aspectRatio: null
    };
    const background = root2.query("GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR");
    let markup;
    let resize;
    let dirty = false;
    if (root2.query("GET_IMAGE_PREVIEW_MARKUP_SHOW")) {
      markup = item2.getMetadata("markup") || [];
      resize = item2.getMetadata("resize");
      dirty = true;
    }
    const imageView = root2.appendChildView(root2.createChildView(ImageView, {
      id,
      image,
      crop,
      resize,
      markup,
      dirty,
      background,
      opacity: 0,
      scaleX: 1.15,
      scaleY: 1.15,
      translateY: 15
    }), root2.childViews.length);
    root2.ref.images.push(imageView);
    imageView.opacity = 1;
    imageView.scaleX = 1;
    imageView.scaleY = 1;
    imageView.translateY = 0;
    setTimeout(() => {
      root2.dispatch("DID_IMAGE_PREVIEW_SHOW", {id});
    }, 250);
  };
  const updateImage3 = ({root: root2, props}) => {
    const item2 = root2.query("GET_ITEM", {id: props.id});
    if (!item2)
      return;
    const imageView = root2.ref.images[root2.ref.images.length - 1];
    imageView.crop = item2.getMetadata("crop");
    imageView.background = root2.query("GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR");
    if (root2.query("GET_IMAGE_PREVIEW_MARKUP_SHOW")) {
      imageView.dirty = true;
      imageView.resize = item2.getMetadata("resize");
      imageView.markup = item2.getMetadata("markup");
    }
  };
  const didUpdateItemMetadata = ({root: root2, props, action}) => {
    if (!/crop|filter|markup|resize/.test(action.change.key))
      return;
    if (!root2.ref.images.length)
      return;
    const item2 = root2.query("GET_ITEM", {id: props.id});
    if (!item2)
      return;
    if (/filter/.test(action.change.key)) {
      const imageView = root2.ref.images[root2.ref.images.length - 1];
      applyFilter(root2, action.change.value, imageView.image);
      return;
    }
    if (/crop|markup|resize/.test(action.change.key)) {
      const crop = item2.getMetadata("crop");
      const image = root2.ref.images[root2.ref.images.length - 1];
      if (crop && crop.aspectRatio && image.crop && image.crop.aspectRatio && Math.abs(crop.aspectRatio - image.crop.aspectRatio) > 1e-5) {
        const imageView = shiftImage({root: root2});
        pushImage({root: root2, props, image: cloneCanvas(imageView.image)});
      } else {
        updateImage3({root: root2, props});
      }
    }
  };
  const canCreateImageBitmap = (file2) => {
    const userAgent2 = window.navigator.userAgent;
    const isFirefox = userAgent2.match(/Firefox\/([0-9]+)\./);
    const firefoxVersion = isFirefox ? parseInt(isFirefox[1]) : null;
    if (firefoxVersion <= 58)
      return false;
    return "createImageBitmap" in window && isBitmap(file2);
  };
  const didCreatePreviewContainer = ({root: root2, props}) => {
    const {id} = props;
    const item2 = root2.query("GET_ITEM", id);
    if (!item2)
      return;
    const fileURL = URL.createObjectURL(item2.file);
    getImageSize(fileURL, (width, height) => {
      root2.dispatch("DID_IMAGE_PREVIEW_CALCULATE_SIZE", {
        id,
        width,
        height
      });
    });
  };
  const drawPreview = ({root: root2, props}) => {
    const {id} = props;
    const item2 = root2.query("GET_ITEM", id);
    if (!item2)
      return;
    const fileURL = URL.createObjectURL(item2.file);
    const loadPreviewFallback = () => {
      loadImage2(fileURL).then(previewImageLoaded);
    };
    const previewImageLoaded = (imageData) => {
      URL.revokeObjectURL(fileURL);
      const exif = item2.getMetadata("exif") || {};
      const orientation = exif.orientation || -1;
      let {width, height} = imageData;
      if (!width || !height)
        return;
      if (orientation >= 5 && orientation <= 8) {
        [width, height] = [height, width];
      }
      const pixelDensityFactor = Math.max(1, window.devicePixelRatio * 0.75);
      const zoomFactor = root2.query("GET_IMAGE_PREVIEW_ZOOM_FACTOR");
      const scaleFactor = zoomFactor * pixelDensityFactor;
      const previewImageRatio = height / width;
      const previewContainerWidth = root2.rect.element.width;
      const previewContainerHeight = root2.rect.element.height;
      let imageWidth = previewContainerWidth;
      let imageHeight = imageWidth * previewImageRatio;
      if (previewImageRatio > 1) {
        imageWidth = Math.min(width, previewContainerWidth * scaleFactor);
        imageHeight = imageWidth * previewImageRatio;
      } else {
        imageHeight = Math.min(height, previewContainerHeight * scaleFactor);
        imageWidth = imageHeight / previewImageRatio;
      }
      const previewImage = createPreviewImage(imageData, imageWidth, imageHeight, orientation);
      const done = () => {
        const averageColor2 = root2.query("GET_IMAGE_PREVIEW_CALCULATE_AVERAGE_IMAGE_COLOR") ? calculateAverageColor(data) : null;
        item2.setMetadata("color", averageColor2, true);
        if ("close" in imageData) {
          imageData.close();
        }
        root2.ref.overlayShadow.opacity = 1;
        pushImage({root: root2, props, image: previewImage});
      };
      const filter = item2.getMetadata("filter");
      if (filter) {
        applyFilter(root2, filter, previewImage).then(done);
      } else {
        done();
      }
    };
    if (canCreateImageBitmap(item2.file)) {
      const worker = createWorker3(BitmapWorker);
      worker.post({
        file: item2.file
      }, (imageBitmap) => {
        worker.terminate();
        if (!imageBitmap) {
          loadPreviewFallback();
          return;
        }
        previewImageLoaded(imageBitmap);
      });
    } else {
      loadPreviewFallback();
    }
  };
  const didDrawPreview = ({root: root2}) => {
    const image = root2.ref.images[root2.ref.images.length - 1];
    image.translateY = 0;
    image.scaleX = 1;
    image.scaleY = 1;
    image.opacity = 1;
  };
  const restoreOverlay = ({root: root2}) => {
    root2.ref.overlayShadow.opacity = 1;
    root2.ref.overlayError.opacity = 0;
    root2.ref.overlaySuccess.opacity = 0;
  };
  const didThrowError = ({root: root2}) => {
    root2.ref.overlayShadow.opacity = 0.25;
    root2.ref.overlayError.opacity = 1;
  };
  const didCompleteProcessing = ({root: root2}) => {
    root2.ref.overlayShadow.opacity = 0.25;
    root2.ref.overlaySuccess.opacity = 1;
  };
  const create2 = ({root: root2}) => {
    root2.ref.images = [];
    root2.ref.imageData = null;
    root2.ref.imageViewBin = [];
    root2.ref.overlayShadow = root2.appendChildView(root2.createChildView(OverlayView, {
      opacity: 0,
      status: "idle"
    }));
    root2.ref.overlaySuccess = root2.appendChildView(root2.createChildView(OverlayView, {
      opacity: 0,
      status: "success"
    }));
    root2.ref.overlayError = root2.appendChildView(root2.createChildView(OverlayView, {
      opacity: 0,
      status: "failure"
    }));
  };
  return _.utils.createView({
    name: "image-preview-wrapper",
    create: create2,
    styles: ["height"],
    apis: ["height"],
    destroy: ({root: root2}) => {
      root2.ref.images.forEach((imageView) => {
        imageView.image.width = 1;
        imageView.image.height = 1;
      });
    },
    didWriteView: ({root: root2}) => {
      root2.ref.images.forEach((imageView) => {
        imageView.dirty = false;
      });
    },
    write: _.utils.createRoute({
      DID_IMAGE_PREVIEW_DRAW: didDrawPreview,
      DID_IMAGE_PREVIEW_CONTAINER_CREATE: didCreatePreviewContainer,
      DID_FINISH_CALCULATE_PREVIEWSIZE: drawPreview,
      DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata,
      DID_THROW_ITEM_LOAD_ERROR: didThrowError,
      DID_THROW_ITEM_PROCESSING_ERROR: didThrowError,
      DID_THROW_ITEM_INVALID: didThrowError,
      DID_COMPLETE_ITEM_PROCESSING: didCompleteProcessing,
      DID_START_ITEM_PROCESSING: restoreOverlay,
      DID_REVERT_ITEM_PROCESSING: restoreOverlay
    }, ({root: root2}) => {
      const viewsToRemove = root2.ref.imageViewBin.filter((imageView) => imageView.opacity === 0);
      root2.ref.imageViewBin = root2.ref.imageViewBin.filter((imageView) => imageView.opacity > 0);
      viewsToRemove.forEach((imageView) => removeImageView(root2, imageView));
      viewsToRemove.length = 0;
    })
  });
};
var plugin5 = (fpAPI) => {
  const {addFilter: addFilter2, utils} = fpAPI;
  const {Type: Type2, createRoute: createRoute2, isFile: isFile2} = utils;
  const imagePreviewView = createImageWrapperView(fpAPI);
  addFilter2("CREATE_VIEW", (viewAPI) => {
    const {is: is2, view, query} = viewAPI;
    if (!is2("file") || !query("GET_ALLOW_IMAGE_PREVIEW"))
      return;
    const didLoadItem2 = ({root: root2, props}) => {
      const {id} = props;
      const item2 = query("GET_ITEM", id);
      if (!item2 || !isFile2(item2.file) || item2.archived)
        return;
      const file2 = item2.file;
      if (!isPreviewableImage(file2))
        return;
      if (!query("GET_IMAGE_PREVIEW_FILTER_ITEM")(item2))
        return;
      const supportsCreateImageBitmap = "createImageBitmap" in (window || {});
      const maxPreviewFileSize = query("GET_IMAGE_PREVIEW_MAX_FILE_SIZE");
      if (!supportsCreateImageBitmap && (maxPreviewFileSize && file2.size > maxPreviewFileSize))
        return;
      root2.ref.imagePreview = view.appendChildView(view.createChildView(imagePreviewView, {id}));
      const fixedPreviewHeight = root2.query("GET_IMAGE_PREVIEW_HEIGHT");
      if (fixedPreviewHeight) {
        root2.dispatch("DID_UPDATE_PANEL_HEIGHT", {
          id: item2.id,
          height: fixedPreviewHeight
        });
      }
      const queue = !supportsCreateImageBitmap && file2.size > query("GET_IMAGE_PREVIEW_MAX_INSTANT_PREVIEW_FILE_SIZE");
      root2.dispatch("DID_IMAGE_PREVIEW_CONTAINER_CREATE", {id}, queue);
    };
    const rescaleItem = (root2, props) => {
      if (!root2.ref.imagePreview)
        return;
      let {id} = props;
      const item2 = root2.query("GET_ITEM", {id});
      if (!item2)
        return;
      const panelAspectRatio = root2.query("GET_PANEL_ASPECT_RATIO");
      const itemPanelAspectRatio = root2.query("GET_ITEM_PANEL_ASPECT_RATIO");
      const fixedHeight = root2.query("GET_IMAGE_PREVIEW_HEIGHT");
      if (panelAspectRatio || itemPanelAspectRatio || fixedHeight)
        return;
      let {imageWidth, imageHeight} = root2.ref;
      if (!imageWidth || !imageHeight)
        return;
      const minPreviewHeight = root2.query("GET_IMAGE_PREVIEW_MIN_HEIGHT");
      const maxPreviewHeight = root2.query("GET_IMAGE_PREVIEW_MAX_HEIGHT");
      const exif = item2.getMetadata("exif") || {};
      const orientation = exif.orientation || -1;
      if (orientation >= 5 && orientation <= 8)
        [imageWidth, imageHeight] = [imageHeight, imageWidth];
      if (!isBitmap(item2.file) || root2.query("GET_IMAGE_PREVIEW_UPSCALE")) {
        const scalar = 2048 / imageWidth;
        imageWidth *= scalar;
        imageHeight *= scalar;
      }
      const imageAspectRatio = imageHeight / imageWidth;
      const previewAspectRatio = (item2.getMetadata("crop") || {}).aspectRatio || imageAspectRatio;
      let previewHeightMax = Math.max(minPreviewHeight, Math.min(imageHeight, maxPreviewHeight));
      const itemWidth = root2.rect.element.width;
      const previewHeight = Math.min(itemWidth * previewAspectRatio, previewHeightMax);
      root2.dispatch("DID_UPDATE_PANEL_HEIGHT", {
        id: item2.id,
        height: previewHeight
      });
    };
    const didResizeView = ({root: root2}) => {
      root2.ref.shouldRescale = true;
    };
    const didUpdateItemMetadata = ({root: root2, action}) => {
      if (action.change.key !== "crop")
        return;
      root2.ref.shouldRescale = true;
    };
    const didCalculatePreviewSize = ({root: root2, action}) => {
      root2.ref.imageWidth = action.width;
      root2.ref.imageHeight = action.height;
      root2.ref.shouldRescale = true;
      root2.ref.shouldDrawPreview = true;
      root2.dispatch("KICK");
    };
    view.registerWriter(createRoute2({
      DID_RESIZE_ROOT: didResizeView,
      DID_STOP_RESIZE: didResizeView,
      DID_LOAD_ITEM: didLoadItem2,
      DID_IMAGE_PREVIEW_CALCULATE_SIZE: didCalculatePreviewSize,
      DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata
    }, ({root: root2, props}) => {
      if (!root2.ref.imagePreview)
        return;
      if (root2.rect.element.hidden)
        return;
      if (root2.ref.shouldRescale) {
        rescaleItem(root2, props);
        root2.ref.shouldRescale = false;
      }
      if (root2.ref.shouldDrawPreview) {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            root2.dispatch("DID_FINISH_CALCULATE_PREVIEWSIZE", {
              id: props.id
            });
          });
        });
        root2.ref.shouldDrawPreview = false;
      }
    }));
  });
  return {
    options: {
      allowImagePreview: [true, Type2.BOOLEAN],
      imagePreviewFilterItem: [() => true, Type2.FUNCTION],
      imagePreviewHeight: [null, Type2.INT],
      imagePreviewMinHeight: [44, Type2.INT],
      imagePreviewMaxHeight: [256, Type2.INT],
      imagePreviewMaxFileSize: [null, Type2.INT],
      imagePreviewZoomFactor: [2, Type2.INT],
      imagePreviewUpscale: [false, Type2.BOOLEAN],
      imagePreviewMaxInstantPreviewFileSize: [1e6, Type2.INT],
      imagePreviewTransparencyIndicator: [null, Type2.STRING],
      imagePreviewCalculateAverageImageColor: [false, Type2.BOOLEAN],
      imagePreviewMarkupShow: [true, Type2.BOOLEAN],
      imagePreviewMarkupFilter: [() => true, Type2.FUNCTION]
    }
  };
};
var isBrowser6 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser6) {
  document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", {detail: plugin5}));
}
var filepond_plugin_image_preview_esm_default = plugin5;

// node_modules/filepond-plugin-image-resize/dist/filepond-plugin-image-resize.esm.js
/*!
 * FilePondPluginImageResize 2.0.10
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
var isImage2 = (file2) => /^image/.test(file2.type);
var getImageSize2 = (url, cb) => {
  let image = new Image();
  image.onload = () => {
    const width = image.naturalWidth;
    const height = image.naturalHeight;
    image = null;
    cb({width, height});
  };
  image.onerror = () => cb(null);
  image.src = url;
};
var plugin6 = ({addFilter: addFilter2, utils}) => {
  const {Type: Type2} = utils;
  addFilter2("DID_LOAD_ITEM", (item2, {query}) => new Promise((resolve, reject) => {
    const file2 = item2.file;
    if (!isImage2(file2) || !query("GET_ALLOW_IMAGE_RESIZE")) {
      return resolve(item2);
    }
    const mode = query("GET_IMAGE_RESIZE_MODE");
    const width = query("GET_IMAGE_RESIZE_TARGET_WIDTH");
    const height = query("GET_IMAGE_RESIZE_TARGET_HEIGHT");
    const upscale = query("GET_IMAGE_RESIZE_UPSCALE");
    if (width === null && height === null)
      return resolve(item2);
    const targetWidth = width === null ? height : width;
    const targetHeight = height === null ? targetWidth : height;
    const fileURL = URL.createObjectURL(file2);
    getImageSize2(fileURL, (size) => {
      URL.revokeObjectURL(fileURL);
      if (!size)
        return resolve(item2);
      let {width: imageWidth, height: imageHeight} = size;
      const orientation = (item2.getMetadata("exif") || {}).orientation || -1;
      if (orientation >= 5 && orientation <= 8) {
        [imageWidth, imageHeight] = [imageHeight, imageWidth];
      }
      if (imageWidth === targetWidth && imageHeight === targetHeight)
        return resolve(item2);
      if (!upscale) {
        if (mode === "cover") {
          if (imageWidth <= targetWidth || imageHeight <= targetHeight)
            return resolve(item2);
        } else if (imageWidth <= targetWidth && imageHeight <= targetWidth) {
          return resolve(item2);
        }
      }
      item2.setMetadata("resize", {
        mode,
        upscale,
        size: {
          width: targetWidth,
          height: targetHeight
        }
      });
      resolve(item2);
    });
  }));
  return {
    options: {
      allowImageResize: [true, Type2.BOOLEAN],
      imageResizeMode: ["cover", Type2.STRING],
      imageResizeUpscale: [true, Type2.BOOLEAN],
      imageResizeTargetWidth: [null, Type2.INT],
      imageResizeTargetHeight: [null, Type2.INT]
    }
  };
};
var isBrowser7 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser7) {
  document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", {detail: plugin6}));
}
var filepond_plugin_image_resize_esm_default = plugin6;

// node_modules/filepond-plugin-image-transform/dist/filepond-plugin-image-transform.esm.js
/*!
 * FilePondPluginImageTransform 3.8.7
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
var isImage3 = (file2) => /^image/.test(file2.type);
var getFilenameWithoutExtension2 = (name2) => name2.substr(0, name2.lastIndexOf(".")) || name2;
var ExtensionMap = {
  jpeg: "jpg",
  "svg+xml": "svg"
};
var renameFileToMatchMimeType = (filename, mimeType) => {
  const name2 = getFilenameWithoutExtension2(filename);
  const type = mimeType.split("/")[1];
  const extension = ExtensionMap[type] || type;
  return `${name2}.${extension}`;
};
var getValidOutputMimeType = (type) => /jpeg|png|svg\+xml/.test(type) ? type : "image/jpeg";
var isImage$1 = (file2) => /^image/.test(file2.type);
var MATRICES = {
  1: () => [1, 0, 0, 1, 0, 0],
  2: (width) => [-1, 0, 0, 1, width, 0],
  3: (width, height) => [-1, 0, 0, -1, width, height],
  4: (width, height) => [1, 0, 0, -1, 0, height],
  5: () => [0, 1, 1, 0, 0, 0],
  6: (width, height) => [0, 1, -1, 0, height, 0],
  7: (width, height) => [0, -1, -1, 0, height, width],
  8: (width) => [0, -1, 1, 0, 0, width]
};
var getImageOrientationMatrix = (width, height, orientation) => {
  if (orientation === -1) {
    orientation = 1;
  }
  return MATRICES[orientation](width, height);
};
var createVector2 = (x, y) => ({x, y});
var vectorDot2 = (a, b) => a.x * b.x + a.y * b.y;
var vectorSubtract2 = (a, b) => createVector2(a.x - b.x, a.y - b.y);
var vectorDistanceSquared2 = (a, b) => vectorDot2(vectorSubtract2(a, b), vectorSubtract2(a, b));
var vectorDistance2 = (a, b) => Math.sqrt(vectorDistanceSquared2(a, b));
var getOffsetPointOnEdge2 = (length, rotation) => {
  const a = length;
  const A = 1.5707963267948966;
  const B = rotation;
  const C3 = 1.5707963267948966 - rotation;
  const sinA = Math.sin(A);
  const sinB = Math.sin(B);
  const sinC = Math.sin(C3);
  const cosC = Math.cos(C3);
  const ratio = a / sinA;
  const b = ratio * sinB;
  const c = ratio * sinC;
  return createVector2(cosC * b, cosC * c);
};
var getRotatedRectSize2 = (rect, rotation) => {
  const w = rect.width;
  const h = rect.height;
  const hor = getOffsetPointOnEdge2(w, rotation);
  const ver = getOffsetPointOnEdge2(h, rotation);
  const tl = createVector2(rect.x + Math.abs(hor.x), rect.y - Math.abs(hor.y));
  const tr = createVector2(rect.x + rect.width + Math.abs(ver.y), rect.y + Math.abs(ver.x));
  const bl = createVector2(rect.x - Math.abs(ver.y), rect.y + rect.height - Math.abs(ver.x));
  return {
    width: vectorDistance2(tl, tr),
    height: vectorDistance2(tl, bl)
  };
};
var getImageRectZoomFactor2 = (imageRect, cropRect, rotation = 0, center2 = {x: 0.5, y: 0.5}) => {
  const cx = center2.x > 0.5 ? 1 - center2.x : center2.x;
  const cy = center2.y > 0.5 ? 1 - center2.y : center2.y;
  const imageWidth = cx * 2 * imageRect.width;
  const imageHeight = cy * 2 * imageRect.height;
  const rotatedCropSize = getRotatedRectSize2(cropRect, rotation);
  return Math.max(rotatedCropSize.width / imageWidth, rotatedCropSize.height / imageHeight);
};
var getCenteredCropRect2 = (container, aspectRatio) => {
  let width = container.width;
  let height = width * aspectRatio;
  if (height > container.height) {
    height = container.height;
    width = height / aspectRatio;
  }
  const x = (container.width - width) * 0.5;
  const y = (container.height - height) * 0.5;
  return {
    x,
    y,
    width,
    height
  };
};
var calculateCanvasSize2 = (image, canvasAspectRatio, zoom = 1) => {
  const imageAspectRatio = image.height / image.width;
  let canvasWidth = 1;
  let canvasHeight = canvasAspectRatio;
  let imgWidth = 1;
  let imgHeight = imageAspectRatio;
  if (imgHeight > canvasHeight) {
    imgHeight = canvasHeight;
    imgWidth = imgHeight / imageAspectRatio;
  }
  const scalar = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);
  const width = image.width / (zoom * scalar * imgWidth);
  const height = width * canvasAspectRatio;
  return {
    width,
    height
  };
};
var canvasRelease = (canvas) => {
  canvas.width = 1;
  canvas.height = 1;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, 1, 1);
};
var isFlipped = (flip) => flip && (flip.horizontal || flip.vertical);
var getBitmap = (image, orientation, flip) => {
  if (orientation <= 1 && !isFlipped(flip)) {
    image.width = image.naturalWidth;
    image.height = image.naturalHeight;
    return image;
  }
  const canvas = document.createElement("canvas");
  const width = image.naturalWidth;
  const height = image.naturalHeight;
  const swapped = orientation >= 5 && orientation <= 8;
  if (swapped) {
    canvas.width = height;
    canvas.height = width;
  } else {
    canvas.width = width;
    canvas.height = height;
  }
  const ctx = canvas.getContext("2d");
  if (orientation) {
    ctx.transform.apply(ctx, getImageOrientationMatrix(width, height, orientation));
  }
  if (isFlipped(flip)) {
    const matrix2 = [1, 0, 0, 1, 0, 0];
    if (!swapped && flip.horizontal || swapped & flip.vertical) {
      matrix2[0] = -1;
      matrix2[4] = width;
    }
    if (!swapped && flip.vertical || swapped && flip.horizontal) {
      matrix2[3] = -1;
      matrix2[5] = height;
    }
    ctx.transform(...matrix2);
  }
  ctx.drawImage(image, 0, 0, width, height);
  return canvas;
};
var imageToImageData = (imageElement, orientation, crop = {}, options = {}) => {
  const {canvasMemoryLimit, background = null} = options;
  const zoom = crop.zoom || 1;
  const bitmap = getBitmap(imageElement, orientation, crop.flip);
  const imageSize = {
    width: bitmap.width,
    height: bitmap.height
  };
  const aspectRatio = crop.aspectRatio || imageSize.height / imageSize.width;
  let canvasSize = calculateCanvasSize2(imageSize, aspectRatio, zoom);
  if (canvasMemoryLimit) {
    const requiredMemory = canvasSize.width * canvasSize.height;
    if (requiredMemory > canvasMemoryLimit) {
      const scalar = Math.sqrt(canvasMemoryLimit) / Math.sqrt(requiredMemory);
      imageSize.width = Math.floor(imageSize.width * scalar);
      imageSize.height = Math.floor(imageSize.height * scalar);
      canvasSize = calculateCanvasSize2(imageSize, aspectRatio, zoom);
    }
  }
  const canvas = document.createElement("canvas");
  const canvasCenter = {
    x: canvasSize.width * 0.5,
    y: canvasSize.height * 0.5
  };
  const stage = {
    x: 0,
    y: 0,
    width: canvasSize.width,
    height: canvasSize.height,
    center: canvasCenter
  };
  const shouldLimit = typeof crop.scaleToFit === "undefined" || crop.scaleToFit;
  const scale = zoom * getImageRectZoomFactor2(imageSize, getCenteredCropRect2(stage, aspectRatio), crop.rotation, shouldLimit ? crop.center : {x: 0.5, y: 0.5});
  canvas.width = Math.round(canvasSize.width / scale);
  canvas.height = Math.round(canvasSize.height / scale);
  canvasCenter.x /= scale;
  canvasCenter.y /= scale;
  const imageOffset = {
    x: canvasCenter.x - imageSize.width * (crop.center ? crop.center.x : 0.5),
    y: canvasCenter.y - imageSize.height * (crop.center ? crop.center.y : 0.5)
  };
  const ctx = canvas.getContext("2d");
  if (background) {
    ctx.fillStyle = background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  ctx.translate(canvasCenter.x, canvasCenter.y);
  ctx.rotate(crop.rotation || 0);
  ctx.drawImage(bitmap, imageOffset.x - canvasCenter.x, imageOffset.y - canvasCenter.y, imageSize.width, imageSize.height);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  canvasRelease(canvas);
  return imageData;
};
var IS_BROWSER3 = (() => typeof window !== "undefined" && typeof window.document !== "undefined")();
if (IS_BROWSER3) {
  if (!HTMLCanvasElement.prototype.toBlob) {
    Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
      value: function(callback, type, quality) {
        var dataURL = this.toDataURL(type, quality).split(",")[1];
        setTimeout(function() {
          var binStr = atob(dataURL);
          var len = binStr.length;
          var arr = new Uint8Array(len);
          for (var i = 0; i < len; i++) {
            arr[i] = binStr.charCodeAt(i);
          }
          callback(new Blob([arr], {type: type || "image/png"}));
        });
      }
    });
  }
}
var canvasToBlob = (canvas, options, beforeCreateBlob = null) => new Promise((resolve) => {
  const promisedImage = beforeCreateBlob ? beforeCreateBlob(canvas) : canvas;
  Promise.resolve(promisedImage).then((canvas2) => {
    canvas2.toBlob(resolve, options.type, options.quality);
  });
});
var vectorMultiply2 = (v, amount) => createVector$12(v.x * amount, v.y * amount);
var vectorAdd2 = (a, b) => createVector$12(a.x + b.x, a.y + b.y);
var vectorNormalize2 = (v) => {
  const l = Math.sqrt(v.x * v.x + v.y * v.y);
  if (l === 0) {
    return {
      x: 0,
      y: 0
    };
  }
  return createVector$12(v.x / l, v.y / l);
};
var vectorRotate2 = (v, radians, origin) => {
  const cos = Math.cos(radians);
  const sin = Math.sin(radians);
  const t = createVector$12(v.x - origin.x, v.y - origin.y);
  return createVector$12(origin.x + cos * t.x - sin * t.y, origin.y + sin * t.x + cos * t.y);
};
var createVector$12 = (x = 0, y = 0) => ({x, y});
var getMarkupValue2 = (value, size, scalar = 1, axis) => {
  if (typeof value === "string") {
    return parseFloat(value) * scalar;
  }
  if (typeof value === "number") {
    return value * (axis ? size[axis] : Math.min(size.width, size.height));
  }
  return;
};
var getMarkupStyles2 = (markup, size, scale) => {
  const lineStyle = markup.borderStyle || markup.lineStyle || "solid";
  const fill = markup.backgroundColor || markup.fontColor || "transparent";
  const stroke = markup.borderColor || markup.lineColor || "transparent";
  const strokeWidth = getMarkupValue2(markup.borderWidth || markup.lineWidth, size, scale);
  const lineCap = markup.lineCap || "round";
  const lineJoin = markup.lineJoin || "round";
  const dashes = typeof lineStyle === "string" ? "" : lineStyle.map((v) => getMarkupValue2(v, size, scale)).join(",");
  const opacity = markup.opacity || 1;
  return {
    "stroke-linecap": lineCap,
    "stroke-linejoin": lineJoin,
    "stroke-width": strokeWidth || 0,
    "stroke-dasharray": dashes,
    stroke,
    fill,
    opacity
  };
};
var isDefined3 = (value) => value != null;
var getMarkupRect2 = (rect, size, scalar = 1) => {
  let left = getMarkupValue2(rect.x, size, scalar, "width") || getMarkupValue2(rect.left, size, scalar, "width");
  let top = getMarkupValue2(rect.y, size, scalar, "height") || getMarkupValue2(rect.top, size, scalar, "height");
  let width = getMarkupValue2(rect.width, size, scalar, "width");
  let height = getMarkupValue2(rect.height, size, scalar, "height");
  let right = getMarkupValue2(rect.right, size, scalar, "width");
  let bottom = getMarkupValue2(rect.bottom, size, scalar, "height");
  if (!isDefined3(top)) {
    if (isDefined3(height) && isDefined3(bottom)) {
      top = size.height - height - bottom;
    } else {
      top = bottom;
    }
  }
  if (!isDefined3(left)) {
    if (isDefined3(width) && isDefined3(right)) {
      left = size.width - width - right;
    } else {
      left = right;
    }
  }
  if (!isDefined3(width)) {
    if (isDefined3(left) && isDefined3(right)) {
      width = size.width - left - right;
    } else {
      width = 0;
    }
  }
  if (!isDefined3(height)) {
    if (isDefined3(top) && isDefined3(bottom)) {
      height = size.height - top - bottom;
    } else {
      height = 0;
    }
  }
  return {
    x: left || 0,
    y: top || 0,
    width: width || 0,
    height: height || 0
  };
};
var pointsToPathShape2 = (points) => points.map((point, index2) => `${index2 === 0 ? "M" : "L"} ${point.x} ${point.y}`).join(" ");
var setAttributes2 = (element, attr2) => Object.keys(attr2).forEach((key) => element.setAttribute(key, attr2[key]));
var ns3 = "http://www.w3.org/2000/svg";
var svg2 = (tag, attr2) => {
  const element = document.createElementNS(ns3, tag);
  if (attr2) {
    setAttributes2(element, attr2);
  }
  return element;
};
var updateRect3 = (element) => setAttributes2(element, {
  ...element.rect,
  ...element.styles
});
var updateEllipse2 = (element) => {
  const cx = element.rect.x + element.rect.width * 0.5;
  const cy = element.rect.y + element.rect.height * 0.5;
  const rx = element.rect.width * 0.5;
  const ry = element.rect.height * 0.5;
  return setAttributes2(element, {
    cx,
    cy,
    rx,
    ry,
    ...element.styles
  });
};
var IMAGE_FIT_STYLE2 = {
  contain: "xMidYMid meet",
  cover: "xMidYMid slice"
};
var updateImage2 = (element, markup) => {
  setAttributes2(element, {
    ...element.rect,
    ...element.styles,
    preserveAspectRatio: IMAGE_FIT_STYLE2[markup.fit] || "none"
  });
};
var TEXT_ANCHOR2 = {
  left: "start",
  center: "middle",
  right: "end"
};
var updateText2 = (element, markup, size, scale) => {
  const fontSize = getMarkupValue2(markup.fontSize, size, scale);
  const fontFamily = markup.fontFamily || "sans-serif";
  const fontWeight = markup.fontWeight || "normal";
  const textAlign = TEXT_ANCHOR2[markup.textAlign] || "start";
  setAttributes2(element, {
    ...element.rect,
    ...element.styles,
    "stroke-width": 0,
    "font-weight": fontWeight,
    "font-size": fontSize,
    "font-family": fontFamily,
    "text-anchor": textAlign
  });
  if (element.text !== markup.text) {
    element.text = markup.text;
    element.textContent = markup.text.length ? markup.text : " ";
  }
};
var updateLine2 = (element, markup, size, scale) => {
  setAttributes2(element, {
    ...element.rect,
    ...element.styles,
    fill: "none"
  });
  const line = element.childNodes[0];
  const begin = element.childNodes[1];
  const end = element.childNodes[2];
  const origin = element.rect;
  const target = {
    x: element.rect.x + element.rect.width,
    y: element.rect.y + element.rect.height
  };
  setAttributes2(line, {
    x1: origin.x,
    y1: origin.y,
    x2: target.x,
    y2: target.y
  });
  if (!markup.lineDecoration)
    return;
  begin.style.display = "none";
  end.style.display = "none";
  const v = vectorNormalize2({
    x: target.x - origin.x,
    y: target.y - origin.y
  });
  const l = getMarkupValue2(0.05, size, scale);
  if (markup.lineDecoration.indexOf("arrow-begin") !== -1) {
    const arrowBeginRotationPoint = vectorMultiply2(v, l);
    const arrowBeginCenter = vectorAdd2(origin, arrowBeginRotationPoint);
    const arrowBeginA = vectorRotate2(origin, 2, arrowBeginCenter);
    const arrowBeginB = vectorRotate2(origin, -2, arrowBeginCenter);
    setAttributes2(begin, {
      style: "display:block;",
      d: `M${arrowBeginA.x},${arrowBeginA.y} L${origin.x},${origin.y} L${arrowBeginB.x},${arrowBeginB.y}`
    });
  }
  if (markup.lineDecoration.indexOf("arrow-end") !== -1) {
    const arrowEndRotationPoint = vectorMultiply2(v, -l);
    const arrowEndCenter = vectorAdd2(target, arrowEndRotationPoint);
    const arrowEndA = vectorRotate2(target, 2, arrowEndCenter);
    const arrowEndB = vectorRotate2(target, -2, arrowEndCenter);
    setAttributes2(end, {
      style: "display:block;",
      d: `M${arrowEndA.x},${arrowEndA.y} L${target.x},${target.y} L${arrowEndB.x},${arrowEndB.y}`
    });
  }
};
var updatePath2 = (element, markup, size, scale) => {
  setAttributes2(element, {
    ...element.styles,
    fill: "none",
    d: pointsToPathShape2(markup.points.map((point) => ({
      x: getMarkupValue2(point.x, size, scale, "width"),
      y: getMarkupValue2(point.y, size, scale, "height")
    })))
  });
};
var createShape2 = (node) => (markup) => svg2(node, {id: markup.id});
var createImage2 = (markup) => {
  const shape = svg2("image", {
    id: markup.id,
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    opacity: "0"
  });
  shape.onload = () => {
    shape.setAttribute("opacity", markup.opacity || 1);
  };
  shape.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", markup.src);
  return shape;
};
var createLine2 = (markup) => {
  const shape = svg2("g", {
    id: markup.id,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  });
  const line = svg2("line");
  shape.appendChild(line);
  const begin = svg2("path");
  shape.appendChild(begin);
  const end = svg2("path");
  shape.appendChild(end);
  return shape;
};
var CREATE_TYPE_ROUTES2 = {
  image: createImage2,
  rect: createShape2("rect"),
  ellipse: createShape2("ellipse"),
  text: createShape2("text"),
  path: createShape2("path"),
  line: createLine2
};
var UPDATE_TYPE_ROUTES2 = {
  rect: updateRect3,
  ellipse: updateEllipse2,
  image: updateImage2,
  text: updateText2,
  path: updatePath2,
  line: updateLine2
};
var createMarkupByType2 = (type, markup) => CREATE_TYPE_ROUTES2[type](markup);
var updateMarkupByType2 = (element, type, markup, size, scale) => {
  if (type !== "path") {
    element.rect = getMarkupRect2(markup, size, scale);
  }
  element.styles = getMarkupStyles2(markup, size, scale);
  UPDATE_TYPE_ROUTES2[type](element, markup, size, scale);
};
var sortMarkupByZIndex2 = (a, b) => {
  if (a[1].zIndex > b[1].zIndex) {
    return 1;
  }
  if (a[1].zIndex < b[1].zIndex) {
    return -1;
  }
  return 0;
};
var cropSVG = (blob2, crop = {}, markup, options) => new Promise((resolve) => {
  const {background = null} = options;
  const fr = new FileReader();
  fr.onloadend = () => {
    const text2 = fr.result;
    const original = document.createElement("div");
    original.style.cssText = `position:absolute;pointer-events:none;width:0;height:0;visibility:hidden;`;
    original.innerHTML = text2;
    const originalNode = original.querySelector("svg");
    document.body.appendChild(original);
    const bBox = originalNode.getBBox();
    original.parentNode.removeChild(original);
    const titleNode = original.querySelector("title");
    const viewBoxAttribute = originalNode.getAttribute("viewBox") || "";
    const widthAttribute = originalNode.getAttribute("width") || "";
    const heightAttribute = originalNode.getAttribute("height") || "";
    let width = parseFloat(widthAttribute) || null;
    let height = parseFloat(heightAttribute) || null;
    const widthUnits = (widthAttribute.match(/[a-z]+/) || [])[0] || "";
    const heightUnits = (heightAttribute.match(/[a-z]+/) || [])[0] || "";
    const viewBoxList = viewBoxAttribute.split(" ").map(parseFloat);
    const viewBox = viewBoxList.length ? {
      x: viewBoxList[0],
      y: viewBoxList[1],
      width: viewBoxList[2],
      height: viewBoxList[3]
    } : bBox;
    let imageWidth = width != null ? width : viewBox.width;
    let imageHeight = height != null ? height : viewBox.height;
    originalNode.style.overflow = "visible";
    originalNode.setAttribute("width", imageWidth);
    originalNode.setAttribute("height", imageHeight);
    let markupSVG = "";
    if (markup && markup.length) {
      const size = {
        width: imageWidth,
        height: imageHeight
      };
      markupSVG = markup.sort(sortMarkupByZIndex2).reduce((prev, shape) => {
        const el = createMarkupByType2(shape[0], shape[1]);
        updateMarkupByType2(el, shape[0], shape[1], size);
        el.removeAttribute("id");
        if (el.getAttribute("opacity") === 1) {
          el.removeAttribute("opacity");
        }
        return prev + "\n" + el.outerHTML + "\n";
      }, "");
      markupSVG = `

<g>${markupSVG.replace(/&nbsp;/g, " ")}</g>

`;
    }
    const aspectRatio = crop.aspectRatio || imageHeight / imageWidth;
    const canvasWidth = imageWidth;
    const canvasHeight = canvasWidth * aspectRatio;
    const shouldLimit = typeof crop.scaleToFit === "undefined" || crop.scaleToFit;
    const cropCenterX = crop.center ? crop.center.x : 0.5;
    const cropCenterY = crop.center ? crop.center.y : 0.5;
    const canvasZoomFactor = getImageRectZoomFactor2({
      width: imageWidth,
      height: imageHeight
    }, getCenteredCropRect2({
      width: canvasWidth,
      height: canvasHeight
    }, aspectRatio), crop.rotation, shouldLimit ? {x: cropCenterX, y: cropCenterY} : {
      x: 0.5,
      y: 0.5
    });
    const scale = crop.zoom * canvasZoomFactor;
    const rotation = crop.rotation * (180 / Math.PI);
    const canvasCenter = {
      x: canvasWidth * 0.5,
      y: canvasHeight * 0.5
    };
    const imageOffset = {
      x: canvasCenter.x - imageWidth * cropCenterX,
      y: canvasCenter.y - imageHeight * cropCenterY
    };
    const cropTransforms = [
      `rotate(${rotation} ${canvasCenter.x} ${canvasCenter.y})`,
      `translate(${canvasCenter.x} ${canvasCenter.y})`,
      `scale(${scale})`,
      `translate(${-canvasCenter.x} ${-canvasCenter.y})`,
      `translate(${imageOffset.x} ${imageOffset.y})`
    ];
    const cropFlipHorizontal = crop.flip && crop.flip.horizontal;
    const cropFlipVertical = crop.flip && crop.flip.vertical;
    const flipTransforms = [
      `scale(${cropFlipHorizontal ? -1 : 1} ${cropFlipVertical ? -1 : 1})`,
      `translate(${cropFlipHorizontal ? -imageWidth : 0} ${cropFlipVertical ? -imageHeight : 0})`
    ];
    const transformed = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${canvasWidth}${widthUnits}" height="${canvasHeight}${heightUnits}" 
viewBox="0 0 ${canvasWidth} ${canvasHeight}" ${background ? 'style="background:' + background + '" ' : ""}
preserveAspectRatio="xMinYMin"
xmlns:xlink="http://www.w3.org/1999/xlink"
xmlns="http://www.w3.org/2000/svg">
<!-- Generated by PQINA - https://pqina.nl/ -->
<title>${titleNode ? titleNode.textContent : ""}</title>
<g transform="${cropTransforms.join(" ")}">
<g transform="${flipTransforms.join(" ")}">
${originalNode.outerHTML}${markupSVG}
</g>
</g>
</svg>`;
    resolve(transformed);
  };
  fr.readAsText(blob2);
});
var objectToImageData = (obj) => {
  let imageData;
  try {
    imageData = new ImageData(obj.width, obj.height);
  } catch (e) {
    const canvas = document.createElement("canvas");
    imageData = canvas.getContext("2d").createImageData(obj.width, obj.height);
  }
  imageData.data.set(obj.data);
  return imageData;
};
var TransformWorker = () => {
  const TRANSFORMS = {resize, filter};
  const applyTransforms = (transforms2, imageData) => {
    transforms2.forEach((transform2) => {
      imageData = TRANSFORMS[transform2.type](imageData, transform2.data);
    });
    return imageData;
  };
  const transform = (data3, cb) => {
    let transforms2 = data3.transforms;
    let filterTransform = null;
    transforms2.forEach((transform2) => {
      if (transform2.type === "filter") {
        filterTransform = transform2;
      }
    });
    if (filterTransform) {
      let resizeTransform = null;
      transforms2.forEach((transform2) => {
        if (transform2.type === "resize") {
          resizeTransform = transform2;
        }
      });
      if (resizeTransform) {
        resizeTransform.data.matrix = filterTransform.data;
        transforms2 = transforms2.filter((transform2) => transform2.type !== "filter");
      }
    }
    cb(applyTransforms(transforms2, data3.imageData));
  };
  self.onmessage = (e) => {
    transform(e.data.message, (response) => {
      self.postMessage({id: e.data.id, message: response}, [response.data.buffer]);
    });
  };
  const br = 1;
  const bg = 1;
  const bb = 1;
  function applyFilterMatrix(index2, data3, m) {
    const ir = data3[index2] / 255;
    const ig = data3[index2 + 1] / 255;
    const ib = data3[index2 + 2] / 255;
    const ia = data3[index2 + 3] / 255;
    const mr = ir * m[0] + ig * m[1] + ib * m[2] + ia * m[3] + m[4];
    const mg = ir * m[5] + ig * m[6] + ib * m[7] + ia * m[8] + m[9];
    const mb = ir * m[10] + ig * m[11] + ib * m[12] + ia * m[13] + m[14];
    const ma = ir * m[15] + ig * m[16] + ib * m[17] + ia * m[18] + m[19];
    const or = Math.max(0, mr * ma) + br * (1 - ma);
    const og = Math.max(0, mg * ma) + bg * (1 - ma);
    const ob = Math.max(0, mb * ma) + bb * (1 - ma);
    data3[index2] = Math.max(0, Math.min(1, or)) * 255;
    data3[index2 + 1] = Math.max(0, Math.min(1, og)) * 255;
    data3[index2 + 2] = Math.max(0, Math.min(1, ob)) * 255;
  }
  const identityMatrix = self.JSON.stringify([
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0
  ]);
  function isIdentityMatrix(filter2) {
    return self.JSON.stringify(filter2 || []) === identityMatrix;
  }
  function filter(imageData, matrix2) {
    if (!matrix2 || isIdentityMatrix(matrix2))
      return imageData;
    const data3 = imageData.data;
    const l = data3.length;
    const m11 = matrix2[0];
    const m12 = matrix2[1];
    const m13 = matrix2[2];
    const m14 = matrix2[3];
    const m15 = matrix2[4];
    const m21 = matrix2[5];
    const m22 = matrix2[6];
    const m23 = matrix2[7];
    const m24 = matrix2[8];
    const m25 = matrix2[9];
    const m31 = matrix2[10];
    const m32 = matrix2[11];
    const m33 = matrix2[12];
    const m34 = matrix2[13];
    const m35 = matrix2[14];
    const m41 = matrix2[15];
    const m42 = matrix2[16];
    const m43 = matrix2[17];
    const m44 = matrix2[18];
    const m45 = matrix2[19];
    let index2 = 0, r = 0, g = 0, b = 0, a = 0, mr = 0, mg = 0, mb = 0, ma = 0, or = 0, og = 0, ob = 0;
    for (; index2 < l; index2 += 4) {
      r = data3[index2] / 255;
      g = data3[index2 + 1] / 255;
      b = data3[index2 + 2] / 255;
      a = data3[index2 + 3] / 255;
      mr = r * m11 + g * m12 + b * m13 + a * m14 + m15;
      mg = r * m21 + g * m22 + b * m23 + a * m24 + m25;
      mb = r * m31 + g * m32 + b * m33 + a * m34 + m35;
      ma = r * m41 + g * m42 + b * m43 + a * m44 + m45;
      or = Math.max(0, mr * ma) + br * (1 - ma);
      og = Math.max(0, mg * ma) + bg * (1 - ma);
      ob = Math.max(0, mb * ma) + bb * (1 - ma);
      data3[index2] = Math.max(0, Math.min(1, or)) * 255;
      data3[index2 + 1] = Math.max(0, Math.min(1, og)) * 255;
      data3[index2 + 2] = Math.max(0, Math.min(1, ob)) * 255;
    }
    return imageData;
  }
  function resize(imageData, data3) {
    let {mode = "contain", upscale = false, width, height, matrix: matrix2} = data3;
    matrix2 = !matrix2 || isIdentityMatrix(matrix2) ? null : matrix2;
    if (!width && !height) {
      return filter(imageData, matrix2);
    }
    if (width === null) {
      width = height;
    } else if (height === null) {
      height = width;
    }
    if (mode !== "force") {
      let scalarWidth = width / imageData.width;
      let scalarHeight = height / imageData.height;
      let scalar = 1;
      if (mode === "cover") {
        scalar = Math.max(scalarWidth, scalarHeight);
      } else if (mode === "contain") {
        scalar = Math.min(scalarWidth, scalarHeight);
      }
      if (scalar > 1 && upscale === false) {
        return filter(imageData, matrix2);
      }
      width = imageData.width * scalar;
      height = imageData.height * scalar;
    }
    const originWidth = imageData.width;
    const originHeight = imageData.height;
    const targetWidth = Math.round(width);
    const targetHeight = Math.round(height);
    const inputData = imageData.data;
    const outputData = new Uint8ClampedArray(targetWidth * targetHeight * 4);
    const ratioWidth = originWidth / targetWidth;
    const ratioHeight = originHeight / targetHeight;
    const ratioWidthHalf = Math.ceil(ratioWidth * 0.5);
    const ratioHeightHalf = Math.ceil(ratioHeight * 0.5);
    for (let j = 0; j < targetHeight; j++) {
      for (let i = 0; i < targetWidth; i++) {
        let x2 = (i + j * targetWidth) * 4;
        let weight = 0;
        let weights = 0;
        let weightsAlpha = 0;
        let r = 0;
        let g = 0;
        let b = 0;
        let a = 0;
        let centerY = (j + 0.5) * ratioHeight;
        for (let yy = Math.floor(j * ratioHeight); yy < (j + 1) * ratioHeight; yy++) {
          let dy = Math.abs(centerY - (yy + 0.5)) / ratioHeightHalf;
          let centerX = (i + 0.5) * ratioWidth;
          let w0 = dy * dy;
          for (let xx = Math.floor(i * ratioWidth); xx < (i + 1) * ratioWidth; xx++) {
            let dx = Math.abs(centerX - (xx + 0.5)) / ratioWidthHalf;
            let w = Math.sqrt(w0 + dx * dx);
            if (w >= -1 && w <= 1) {
              weight = 2 * w * w * w - 3 * w * w + 1;
              if (weight > 0) {
                dx = 4 * (xx + yy * originWidth);
                let ref = inputData[dx + 3];
                a += weight * ref;
                weightsAlpha += weight;
                if (ref < 255) {
                  weight = weight * ref / 250;
                }
                r += weight * inputData[dx];
                g += weight * inputData[dx + 1];
                b += weight * inputData[dx + 2];
                weights += weight;
              }
            }
          }
        }
        outputData[x2] = r / weights;
        outputData[x2 + 1] = g / weights;
        outputData[x2 + 2] = b / weights;
        outputData[x2 + 3] = a / weightsAlpha;
        matrix2 && applyFilterMatrix(x2, outputData, matrix2);
      }
    }
    return {
      data: outputData,
      width: targetWidth,
      height: targetHeight
    };
  }
};
var correctOrientation = (view, offset) => {
  if (view.getUint32(offset + 4, false) !== 1165519206)
    return;
  offset += 4;
  const intelByteAligned = view.getUint16(offset += 6, false) === 18761;
  offset += view.getUint32(offset + 4, intelByteAligned);
  const tags = view.getUint16(offset, intelByteAligned);
  offset += 2;
  for (let i = 0; i < tags; i++) {
    if (view.getUint16(offset + i * 12, intelByteAligned) === 274) {
      view.setUint16(offset + i * 12 + 8, 1, intelByteAligned);
      return true;
    }
  }
  return false;
};
var readData = (data3) => {
  const view = new DataView(data3);
  if (view.getUint16(0) !== 65496)
    return null;
  let offset = 2;
  let marker;
  let markerLength;
  let orientationCorrected = false;
  while (offset < view.byteLength) {
    marker = view.getUint16(offset, false);
    markerLength = view.getUint16(offset + 2, false) + 2;
    const isData = marker >= 65504 && marker <= 65519 || marker === 65534;
    if (!isData) {
      break;
    }
    if (!orientationCorrected) {
      orientationCorrected = correctOrientation(view, offset, markerLength);
    }
    if (offset + markerLength > view.byteLength) {
      break;
    }
    offset += markerLength;
  }
  return data3.slice(0, offset);
};
var getImageHead = (file2) => new Promise((resolve) => {
  const reader = new FileReader();
  reader.onload = () => resolve(readData(reader.result) || null);
  reader.readAsArrayBuffer(file2.slice(0, 256 * 1024));
});
var getBlobBuilder2 = () => {
  return window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
};
var createBlob2 = (arrayBuffer, mimeType) => {
  const BB = getBlobBuilder2();
  if (BB) {
    const bb = new BB();
    bb.append(arrayBuffer);
    return bb.getBlob(mimeType);
  }
  return new Blob([arrayBuffer], {
    type: mimeType
  });
};
var getUniqueId2 = () => Math.random().toString(36).substr(2, 9);
var createWorker2 = (fn2) => {
  const workerBlob = new Blob(["(", fn2.toString(), ")()"], {type: "application/javascript"});
  const workerURL = URL.createObjectURL(workerBlob);
  const worker = new Worker(workerURL);
  const trips = [];
  return {
    transfer: () => {
    },
    post: (message, cb, transferList) => {
      const id = getUniqueId2();
      trips[id] = cb;
      worker.onmessage = (e) => {
        const cb2 = trips[e.data.id];
        if (!cb2)
          return;
        cb2(e.data.message);
        delete trips[e.data.id];
      };
      worker.postMessage({
        id,
        message
      }, transferList);
    },
    terminate: () => {
      worker.terminate();
      URL.revokeObjectURL(workerURL);
    }
  };
};
var loadImage3 = (url) => new Promise((resolve, reject) => {
  const img = new Image();
  img.onload = () => {
    resolve(img);
  };
  img.onerror = (e) => {
    reject(e);
  };
  img.src = url;
});
var chain = (funcs) => funcs.reduce((promise, func) => promise.then((result) => func().then(Array.prototype.concat.bind(result))), Promise.resolve([]));
var canvasApplyMarkup = (canvas, markup) => new Promise((resolve) => {
  const size = {
    width: canvas.width,
    height: canvas.height
  };
  const ctx = canvas.getContext("2d");
  const drawers = markup.sort(sortMarkupByZIndex2).map((item2) => () => new Promise((resolve2) => {
    const result = TYPE_DRAW_ROUTES[item2[0]](ctx, size, item2[1], resolve2);
    if (result)
      resolve2();
  }));
  chain(drawers).then(() => resolve(canvas));
});
var applyMarkupStyles = (ctx, styles2) => {
  ctx.beginPath();
  ctx.lineCap = styles2["stroke-linecap"];
  ctx.lineJoin = styles2["stroke-linejoin"];
  ctx.lineWidth = styles2["stroke-width"];
  if (styles2["stroke-dasharray"].length) {
    ctx.setLineDash(styles2["stroke-dasharray"].split(","));
  }
  ctx.fillStyle = styles2["fill"];
  ctx.strokeStyle = styles2["stroke"];
  ctx.globalAlpha = styles2.opacity || 1;
};
var drawMarkupStyles = (ctx) => {
  ctx.fill();
  ctx.stroke();
  ctx.globalAlpha = 1;
};
var drawRect = (ctx, size, markup) => {
  const rect = getMarkupRect2(markup, size);
  const styles2 = getMarkupStyles2(markup, size);
  applyMarkupStyles(ctx, styles2);
  ctx.rect(rect.x, rect.y, rect.width, rect.height);
  drawMarkupStyles(ctx, styles2);
  return true;
};
var drawEllipse = (ctx, size, markup) => {
  const rect = getMarkupRect2(markup, size);
  const styles2 = getMarkupStyles2(markup, size);
  applyMarkupStyles(ctx, styles2);
  const x = rect.x, y = rect.y, w = rect.width, h = rect.height, kappa = 0.5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  drawMarkupStyles(ctx, styles2);
  return true;
};
var drawImage = (ctx, size, markup, done) => {
  const rect = getMarkupRect2(markup, size);
  const styles2 = getMarkupStyles2(markup, size);
  applyMarkupStyles(ctx, styles2);
  const image = new Image();
  const isCrossOriginImage = new URL(markup.src, window.location.href).origin !== window.location.origin;
  if (isCrossOriginImage)
    image.crossOrigin = "";
  image.onload = () => {
    if (markup.fit === "cover") {
      const ar = rect.width / rect.height;
      const width = ar > 1 ? image.width : image.height * ar;
      const height = ar > 1 ? image.width / ar : image.height;
      const x = image.width * 0.5 - width * 0.5;
      const y = image.height * 0.5 - height * 0.5;
      ctx.drawImage(image, x, y, width, height, rect.x, rect.y, rect.width, rect.height);
    } else if (markup.fit === "contain") {
      const scalar = Math.min(rect.width / image.width, rect.height / image.height);
      const width = scalar * image.width;
      const height = scalar * image.height;
      const x = rect.x + rect.width * 0.5 - width * 0.5;
      const y = rect.y + rect.height * 0.5 - height * 0.5;
      ctx.drawImage(image, 0, 0, image.width, image.height, x, y, width, height);
    } else {
      ctx.drawImage(image, 0, 0, image.width, image.height, rect.x, rect.y, rect.width, rect.height);
    }
    drawMarkupStyles(ctx, styles2);
    done();
  };
  image.src = markup.src;
};
var drawText = (ctx, size, markup) => {
  const rect = getMarkupRect2(markup, size);
  const styles2 = getMarkupStyles2(markup, size);
  applyMarkupStyles(ctx, styles2);
  const fontSize = getMarkupValue2(markup.fontSize, size);
  const fontFamily = markup.fontFamily || "sans-serif";
  const fontWeight = markup.fontWeight || "normal";
  const textAlign = markup.textAlign || "left";
  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx.textAlign = textAlign;
  ctx.fillText(markup.text, rect.x, rect.y);
  drawMarkupStyles(ctx, styles2);
  return true;
};
var drawPath = (ctx, size, markup) => {
  const styles2 = getMarkupStyles2(markup, size);
  applyMarkupStyles(ctx, styles2);
  ctx.beginPath();
  const points = markup.points.map((point) => ({
    x: getMarkupValue2(point.x, size, 1, "width"),
    y: getMarkupValue2(point.y, size, 1, "height")
  }));
  ctx.moveTo(points[0].x, points[0].y);
  const l = points.length;
  for (let i = 1; i < l; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  drawMarkupStyles(ctx, styles2);
  return true;
};
var drawLine = (ctx, size, markup) => {
  const rect = getMarkupRect2(markup, size);
  const styles2 = getMarkupStyles2(markup, size);
  applyMarkupStyles(ctx, styles2);
  ctx.beginPath();
  const origin = {
    x: rect.x,
    y: rect.y
  };
  const target = {
    x: rect.x + rect.width,
    y: rect.y + rect.height
  };
  ctx.moveTo(origin.x, origin.y);
  ctx.lineTo(target.x, target.y);
  const v = vectorNormalize2({
    x: target.x - origin.x,
    y: target.y - origin.y
  });
  const l = 0.04 * Math.min(size.width, size.height);
  if (markup.lineDecoration.indexOf("arrow-begin") !== -1) {
    const arrowBeginRotationPoint = vectorMultiply2(v, l);
    const arrowBeginCenter = vectorAdd2(origin, arrowBeginRotationPoint);
    const arrowBeginA = vectorRotate2(origin, 2, arrowBeginCenter);
    const arrowBeginB = vectorRotate2(origin, -2, arrowBeginCenter);
    ctx.moveTo(arrowBeginA.x, arrowBeginA.y);
    ctx.lineTo(origin.x, origin.y);
    ctx.lineTo(arrowBeginB.x, arrowBeginB.y);
  }
  if (markup.lineDecoration.indexOf("arrow-end") !== -1) {
    const arrowEndRotationPoint = vectorMultiply2(v, -l);
    const arrowEndCenter = vectorAdd2(target, arrowEndRotationPoint);
    const arrowEndA = vectorRotate2(target, 2, arrowEndCenter);
    const arrowEndB = vectorRotate2(target, -2, arrowEndCenter);
    ctx.moveTo(arrowEndA.x, arrowEndA.y);
    ctx.lineTo(target.x, target.y);
    ctx.lineTo(arrowEndB.x, arrowEndB.y);
  }
  drawMarkupStyles(ctx, styles2);
  return true;
};
var TYPE_DRAW_ROUTES = {
  rect: drawRect,
  ellipse: drawEllipse,
  image: drawImage,
  text: drawText,
  line: drawLine,
  path: drawPath
};
var imageDataToCanvas = (imageData) => {
  const image = document.createElement("canvas");
  image.width = imageData.width;
  image.height = imageData.height;
  const ctx = image.getContext("2d");
  ctx.putImageData(imageData, 0, 0);
  return image;
};
var transformImage = (file2, instructions, options = {}) => new Promise((resolve, reject) => {
  if (!file2 || !isImage$1(file2))
    return reject({status: "not an image file", file: file2});
  const {stripImageHead, beforeCreateBlob, afterCreateBlob, canvasMemoryLimit} = options;
  const {crop, size, filter, markup, output} = instructions;
  const orientation = instructions.image && instructions.image.orientation ? Math.max(1, Math.min(8, instructions.image.orientation)) : null;
  const qualityAsPercentage = output && output.quality;
  const quality = qualityAsPercentage === null ? null : qualityAsPercentage / 100;
  const type = output && output.type || null;
  const background = output && output.background || null;
  const transforms2 = [];
  if (size && (typeof size.width === "number" || typeof size.height === "number")) {
    transforms2.push({type: "resize", data: size});
  }
  if (filter && filter.length === 20) {
    transforms2.push({type: "filter", data: filter});
  }
  const resolveWithBlob = (blob2) => {
    const promisedBlob = afterCreateBlob ? afterCreateBlob(blob2) : blob2;
    Promise.resolve(promisedBlob).then(resolve);
  };
  const toBlob = (imageData, options2) => {
    const canvas = imageDataToCanvas(imageData);
    const promisedCanvas = markup.length ? canvasApplyMarkup(canvas, markup) : canvas;
    Promise.resolve(promisedCanvas).then((canvas2) => {
      canvasToBlob(canvas2, options2, beforeCreateBlob).then((blob2) => {
        canvasRelease(canvas2);
        if (stripImageHead)
          return resolveWithBlob(blob2);
        getImageHead(file2).then((imageHead) => {
          if (imageHead !== null) {
            blob2 = new Blob([imageHead, blob2.slice(20)], {type: blob2.type});
          }
          resolveWithBlob(blob2);
        });
      }).catch(reject);
    });
  };
  if (/svg/.test(file2.type) && type === null) {
    return cropSVG(file2, crop, markup, {background}).then((text2) => {
      resolve(createBlob2(text2, "image/svg+xml"));
    });
  }
  const url = URL.createObjectURL(file2);
  loadImage3(url).then((image) => {
    URL.revokeObjectURL(url);
    const imageData = imageToImageData(image, orientation, crop, {
      canvasMemoryLimit,
      background
    });
    const outputFormat = {
      quality,
      type: type || file2.type
    };
    if (!transforms2.length) {
      return toBlob(imageData, outputFormat);
    }
    const worker = createWorker2(TransformWorker);
    worker.post({
      transforms: transforms2,
      imageData
    }, (response) => {
      toBlob(objectToImageData(response), outputFormat);
      worker.terminate();
    }, [imageData.data.buffer]);
  }).catch(reject);
});
var MARKUP_RECT2 = ["x", "y", "left", "top", "right", "bottom", "width", "height"];
var toOptionalFraction2 = (value) => typeof value === "string" && /%/.test(value) ? parseFloat(value) / 100 : value;
var prepareMarkup2 = (markup) => {
  const [type, props] = markup;
  const rect = props.points ? {} : MARKUP_RECT2.reduce((prev, curr) => {
    prev[curr] = toOptionalFraction2(props[curr]);
    return prev;
  }, {});
  return [
    type,
    {
      zIndex: 0,
      ...props,
      ...rect
    }
  ];
};
var getImageSize3 = (file2) => new Promise((resolve, reject) => {
  const imageElement = new Image();
  imageElement.src = URL.createObjectURL(file2);
  const measure = () => {
    const width = imageElement.naturalWidth;
    const height = imageElement.naturalHeight;
    const hasSize = width && height;
    if (!hasSize)
      return;
    URL.revokeObjectURL(imageElement.src);
    clearInterval(intervalId);
    resolve({width, height});
  };
  imageElement.onerror = (err) => {
    URL.revokeObjectURL(imageElement.src);
    clearInterval(intervalId);
    reject(err);
  };
  const intervalId = setInterval(measure, 1);
  measure();
});
if (typeof window !== "undefined" && typeof window.document !== "undefined") {
  if (!HTMLCanvasElement.prototype.toBlob) {
    Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
      value: function(cb, type, quality) {
        const canvas = this;
        setTimeout(() => {
          const dataURL = canvas.toDataURL(type, quality).split(",")[1];
          const binStr = atob(dataURL);
          let index2 = binStr.length;
          const data3 = new Uint8Array(index2);
          while (index2--) {
            data3[index2] = binStr.charCodeAt(index2);
          }
          cb(new Blob([data3], {type: type || "image/png"}));
        });
      }
    });
  }
}
var isBrowser8 = typeof window !== "undefined" && typeof window.document !== "undefined";
var isIOS = isBrowser8 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var plugin7 = ({addFilter: addFilter2, utils}) => {
  const {Type: Type2, forin: forin2, getFileFromBlob: getFileFromBlob2, isFile: isFile2} = utils;
  const TRANSFORM_LIST = ["crop", "resize", "filter", "markup", "output"];
  const createVariantCreator = (updateMetadata) => (transform, file2, metadata) => transform(file2, updateMetadata ? updateMetadata(metadata) : metadata);
  const isDefaultCrop = (crop) => crop.aspectRatio === null && crop.rotation === 0 && crop.zoom === 1 && crop.center && crop.center.x === 0.5 && crop.center.y === 0.5 && crop.flip && crop.flip.horizontal === false && crop.flip.vertical === false;
  addFilter2("SHOULD_PREPARE_OUTPUT", (shouldPrepareOutput, {query}) => new Promise((resolve) => {
    resolve(!query("IS_ASYNC"));
  }));
  const shouldTransformFile = (query, file2, item2) => new Promise((resolve) => {
    if (!query("GET_ALLOW_IMAGE_TRANSFORM") || item2.archived || !isFile2(file2) || !isImage3(file2)) {
      return resolve(false);
    }
    getImageSize3(file2).then(() => {
      const fn2 = query("GET_IMAGE_TRANSFORM_IMAGE_FILTER");
      if (fn2) {
        const filterResult = fn2(file2);
        if (filterResult == null) {
          return handleRevert(true);
        }
        if (typeof filterResult === "boolean") {
          return resolve(filterResult);
        }
        if (typeof filterResult.then === "function") {
          return filterResult.then(resolve);
        }
      }
      resolve(true);
    }).catch((err) => {
      resolve(false);
    });
  });
  addFilter2("DID_CREATE_ITEM", (item2, {query, dispatch: dispatch2}) => {
    if (!query("GET_ALLOW_IMAGE_TRANSFORM"))
      return;
    item2.extend("requestPrepare", () => new Promise((resolve, reject) => {
      dispatch2("REQUEST_PREPARE_OUTPUT", {
        query: item2.id,
        item: item2,
        success: resolve,
        failure: reject
      }, true);
    }));
  });
  addFilter2("PREPARE_OUTPUT", (file2, {query, item: item2}) => new Promise((resolve) => {
    shouldTransformFile(query, file2, item2).then((shouldTransform) => {
      if (!shouldTransform)
        return resolve(file2);
      const variants = [];
      if (query("GET_IMAGE_TRANSFORM_VARIANTS_INCLUDE_ORIGINAL")) {
        variants.push(() => new Promise((resolve2) => {
          resolve2({
            name: query("GET_IMAGE_TRANSFORM_VARIANTS_ORIGINAL_NAME"),
            file: file2
          });
        }));
      }
      if (query("GET_IMAGE_TRANSFORM_VARIANTS_INCLUDE_DEFAULT")) {
        variants.push((transform2, file3, metadata) => new Promise((resolve2) => {
          transform2(file3, metadata).then((file4) => resolve2({
            name: query("GET_IMAGE_TRANSFORM_VARIANTS_DEFAULT_NAME"),
            file: file4
          }));
        }));
      }
      const variantsDefinition = query("GET_IMAGE_TRANSFORM_VARIANTS") || {};
      forin2(variantsDefinition, (key, fn2) => {
        const createVariant = createVariantCreator(fn2);
        variants.push((transform2, file3, metadata) => new Promise((resolve2) => {
          createVariant(transform2, file3, metadata).then((file4) => resolve2({name: key, file: file4}));
        }));
      });
      const qualityAsPercentage = query("GET_IMAGE_TRANSFORM_OUTPUT_QUALITY");
      const qualityMode = query("GET_IMAGE_TRANSFORM_OUTPUT_QUALITY_MODE");
      const quality = qualityAsPercentage === null ? null : qualityAsPercentage / 100;
      const type = query("GET_IMAGE_TRANSFORM_OUTPUT_MIME_TYPE");
      const clientTransforms = query("GET_IMAGE_TRANSFORM_CLIENT_TRANSFORMS") || TRANSFORM_LIST;
      item2.setMetadata("output", {
        type,
        quality,
        client: clientTransforms
      }, true);
      const transform = (file3, metadata) => new Promise((resolve2, reject) => {
        const filteredMetadata = {...metadata};
        Object.keys(filteredMetadata).filter((instruction) => instruction !== "exif").forEach((instruction) => {
          if (clientTransforms.indexOf(instruction) === -1) {
            delete filteredMetadata[instruction];
          }
        });
        const {resize, exif, output, crop, filter, markup} = filteredMetadata;
        const instructions = {
          image: {
            orientation: exif ? exif.orientation : null
          },
          output: output && (output.type || typeof output.quality === "number" || output.background) ? {
            type: output.type,
            quality: typeof output.quality === "number" ? output.quality * 100 : null,
            background: output.background || query("GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR") || null
          } : void 0,
          size: resize && (resize.size.width || resize.size.height) ? {
            mode: resize.mode,
            upscale: resize.upscale,
            ...resize.size
          } : void 0,
          crop: crop && !isDefaultCrop(crop) ? {
            ...crop
          } : void 0,
          markup: markup && markup.length ? markup.map(prepareMarkup2) : [],
          filter
        };
        if (instructions.output) {
          const willChangeType = output.type ? output.type !== file3.type : false;
          const canChangeQuality = /\/jpe?g$/.test(file3.type);
          const willChangeQuality = output.quality !== null ? canChangeQuality && qualityMode === "always" : false;
          const willModifyImageData = !!(instructions.size || instructions.crop || instructions.filter || willChangeType || willChangeQuality);
          if (!willModifyImageData)
            return resolve2(file3);
        }
        const options = {
          beforeCreateBlob: query("GET_IMAGE_TRANSFORM_BEFORE_CREATE_BLOB"),
          afterCreateBlob: query("GET_IMAGE_TRANSFORM_AFTER_CREATE_BLOB"),
          canvasMemoryLimit: query("GET_IMAGE_TRANSFORM_CANVAS_MEMORY_LIMIT"),
          stripImageHead: query("GET_IMAGE_TRANSFORM_OUTPUT_STRIP_IMAGE_HEAD")
        };
        transformImage(file3, instructions, options).then((blob2) => {
          const out = getFileFromBlob2(blob2, renameFileToMatchMimeType(file3.name, getValidOutputMimeType(blob2.type)));
          resolve2(out);
        }).catch(reject);
      });
      const variantPromises = variants.map((create2) => create2(transform, file2, item2.getMetadata()));
      Promise.all(variantPromises).then((files) => {
        resolve(files.length === 1 && files[0].name === null ? files[0].file : files);
      });
    });
  }));
  return {
    options: {
      allowImageTransform: [true, Type2.BOOLEAN],
      imageTransformImageFilter: [null, Type2.FUNCTION],
      imageTransformOutputMimeType: [null, Type2.STRING],
      imageTransformOutputQuality: [null, Type2.INT],
      imageTransformOutputStripImageHead: [true, Type2.BOOLEAN],
      imageTransformClientTransforms: [null, Type2.ARRAY],
      imageTransformOutputQualityMode: ["always", Type2.STRING],
      imageTransformVariants: [null, Type2.OBJECT],
      imageTransformVariantsIncludeDefault: [true, Type2.BOOLEAN],
      imageTransformVariantsDefaultName: [null, Type2.STRING],
      imageTransformVariantsIncludeOriginal: [false, Type2.BOOLEAN],
      imageTransformVariantsOriginalName: ["original_", Type2.STRING],
      imageTransformBeforeCreateBlob: [null, Type2.FUNCTION],
      imageTransformAfterCreateBlob: [null, Type2.FUNCTION],
      imageTransformCanvasMemoryLimit: [isBrowser8 && isIOS ? 4096 * 4096 : null, Type2.INT],
      imageTransformCanvasBackgroundColor: [null, Type2.STRING]
    }
  };
};
if (isBrowser8) {
  document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", {detail: plugin7}));
}
var filepond_plugin_image_transform_esm_default = plugin7;

// node_modules/filepond-plugin-media-preview/dist/filepond-plugin-media-preview.esm.js
/*!
 * FilePondPluginMediaPreview 1.0.11
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit undefined for details.
 */
var isPreviewableVideo = (file2) => /^video/.test(file2.type);
var isPreviewableAudio = (file2) => /^audio/.test(file2.type);
var AudioPlayer = class {
  constructor(mediaEl, audioElems) {
    this.mediaEl = mediaEl;
    this.audioElems = audioElems;
    this.onplayhead = false;
    this.duration = 0;
    this.timelineWidth = this.audioElems.timeline.offsetWidth - this.audioElems.playhead.offsetWidth;
    this.moveplayheadFn = this.moveplayhead.bind(this);
    this.registerListeners();
  }
  registerListeners() {
    this.mediaEl.addEventListener("timeupdate", this.timeUpdate.bind(this), false);
    this.mediaEl.addEventListener("canplaythrough", () => this.duration = this.mediaEl.duration, false);
    this.audioElems.timeline.addEventListener("click", this.timelineClicked.bind(this), false);
    this.audioElems.button.addEventListener("click", this.play.bind(this));
    this.audioElems.playhead.addEventListener("mousedown", this.mouseDown.bind(this), false);
    window.addEventListener("mouseup", this.mouseUp.bind(this), false);
  }
  play() {
    if (this.mediaEl.paused) {
      this.mediaEl.play();
    } else {
      this.mediaEl.pause();
    }
    this.audioElems.button.classList.toggle("play");
    this.audioElems.button.classList.toggle("pause");
  }
  timeUpdate() {
    let playPercent = this.mediaEl.currentTime / this.duration * 100;
    this.audioElems.playhead.style.marginLeft = playPercent + "%";
    if (this.mediaEl.currentTime === this.duration) {
      this.audioElems.button.classList.toggle("play");
      this.audioElems.button.classList.toggle("pause");
    }
  }
  moveplayhead(event) {
    let newMargLeft = event.clientX - this.getPosition(this.audioElems.timeline);
    if (newMargLeft >= 0 && newMargLeft <= this.timelineWidth) {
      this.audioElems.playhead.style.marginLeft = newMargLeft + "px";
    }
    if (newMargLeft < 0) {
      this.audioElems.playhead.style.marginLeft = "0px";
    }
    if (newMargLeft > this.timelineWidth) {
      this.audioElems.playhead.style.marginLeft = this.timelineWidth - 4 + "px";
    }
  }
  timelineClicked(event) {
    this.moveplayhead(event);
    this.mediaEl.currentTime = this.duration * this.clickPercent(event);
  }
  mouseDown() {
    this.onplayhead = true;
    window.addEventListener("mousemove", this.moveplayheadFn, true);
    this.mediaEl.removeEventListener("timeupdate", this.timeUpdate.bind(this), false);
  }
  mouseUp(event) {
    window.removeEventListener("mousemove", this.moveplayheadFn, true);
    if (this.onplayhead == true) {
      this.moveplayhead(event);
      this.mediaEl.currentTime = this.duration * this.clickPercent(event);
      this.mediaEl.addEventListener("timeupdate", this.timeUpdate.bind(this), false);
    }
    this.onplayhead = false;
  }
  clickPercent(event) {
    return (event.clientX - this.getPosition(this.audioElems.timeline)) / this.timelineWidth;
  }
  getPosition(el) {
    return el.getBoundingClientRect().left;
  }
};
var createMediaView = (_) => _.utils.createView({
  name: "media-preview",
  tag: "div",
  ignoreRect: true,
  create: ({root: root2, props}) => {
    const {id} = props;
    const item2 = root2.query("GET_ITEM", {id: props.id});
    let tagName = isPreviewableAudio(item2.file) ? "audio" : "video";
    root2.ref.media = document.createElement(tagName);
    root2.ref.media.setAttribute("controls", true);
    root2.element.appendChild(root2.ref.media);
    if (isPreviewableAudio(item2.file)) {
      let docfrag = document.createDocumentFragment();
      root2.ref.audio = [];
      root2.ref.audio.container = document.createElement("div"), root2.ref.audio.button = document.createElement("span"), root2.ref.audio.timeline = document.createElement("div"), root2.ref.audio.playhead = document.createElement("div");
      root2.ref.audio.container.className = "audioplayer";
      root2.ref.audio.button.className = "playpausebtn play";
      root2.ref.audio.timeline.className = "timeline";
      root2.ref.audio.playhead.className = "playhead";
      root2.ref.audio.timeline.appendChild(root2.ref.audio.playhead);
      root2.ref.audio.container.appendChild(root2.ref.audio.button);
      root2.ref.audio.container.appendChild(root2.ref.audio.timeline);
      docfrag.appendChild(root2.ref.audio.container);
      root2.element.appendChild(docfrag);
    }
  },
  write: _.utils.createRoute({
    DID_MEDIA_PREVIEW_LOAD: ({root: root2, props}) => {
      const {id} = props;
      const item2 = root2.query("GET_ITEM", {id: props.id});
      if (!item2)
        return;
      let URL2 = window.URL || window.webkitURL;
      let blob2 = new Blob([item2.file], {type: item2.file.type});
      root2.ref.media.type = item2.file.type;
      root2.ref.media.src = item2.file.mock && item2.file.url || URL2.createObjectURL(blob2);
      if (isPreviewableAudio(item2.file)) {
        new AudioPlayer(root2.ref.media, root2.ref.audio);
      }
      root2.ref.media.addEventListener("loadeddata", () => {
        let height = 75;
        if (isPreviewableVideo(item2.file)) {
          let containerWidth = root2.ref.media.offsetWidth;
          let factor = root2.ref.media.videoWidth / containerWidth;
          height = root2.ref.media.videoHeight / factor;
        }
        root2.dispatch("DID_UPDATE_PANEL_HEIGHT", {
          id: props.id,
          height
        });
      }, false);
    }
  })
});
var createMediaWrapperView = (_) => {
  const didCreatePreviewContainer = ({root: root2, props}) => {
    const {id} = props;
    const item2 = root2.query("GET_ITEM", id);
    if (!item2)
      return;
    root2.dispatch("DID_MEDIA_PREVIEW_LOAD", {
      id
    });
  };
  const create2 = ({root: root2, props}) => {
    const media = createMediaView(_);
    root2.ref.media = root2.appendChildView(root2.createChildView(media, {
      id: props.id
    }));
  };
  return _.utils.createView({
    name: "media-preview-wrapper",
    create: create2,
    write: _.utils.createRoute({
      DID_MEDIA_PREVIEW_CONTAINER_CREATE: didCreatePreviewContainer
    })
  });
};
var plugin8 = (fpAPI) => {
  const {addFilter: addFilter2, utils} = fpAPI;
  const {Type: Type2, createRoute: createRoute2} = utils;
  const mediaWrapperView = createMediaWrapperView(fpAPI);
  addFilter2("CREATE_VIEW", (viewAPI) => {
    const {is: is2, view, query} = viewAPI;
    if (!is2("file")) {
      return;
    }
    const didLoadItem2 = ({root: root2, props}) => {
      const {id} = props;
      const item2 = query("GET_ITEM", id);
      const allowVideoPreview = query("GET_ALLOW_VIDEO_PREVIEW");
      const allowAudioPreview = query("GET_ALLOW_AUDIO_PREVIEW");
      if (!item2 || item2.archived || (!isPreviewableVideo(item2.file) || !allowVideoPreview) && (!isPreviewableAudio(item2.file) || !allowAudioPreview)) {
        return;
      }
      root2.ref.mediaPreview = view.appendChildView(view.createChildView(mediaWrapperView, {id}));
      root2.dispatch("DID_MEDIA_PREVIEW_CONTAINER_CREATE", {id});
    };
    view.registerWriter(createRoute2({
      DID_LOAD_ITEM: didLoadItem2
    }, ({root: root2, props}) => {
      const {id} = props;
      const item2 = query("GET_ITEM", id);
      const allowVideoPreview = root2.query("GET_ALLOW_VIDEO_PREVIEW");
      const allowAudioPreview = root2.query("GET_ALLOW_AUDIO_PREVIEW");
      if (!item2 || (!isPreviewableVideo(item2.file) || !allowVideoPreview) && (!isPreviewableAudio(item2.file) || !allowAudioPreview) || root2.rect.element.hidden)
        return;
    }));
  });
  return {
    options: {
      allowVideoPreview: [true, Type2.BOOLEAN],
      allowAudioPreview: [true, Type2.BOOLEAN]
    }
  };
};
var isBrowser9 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser9) {
  document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", {detail: plugin8}));
}

// packages/forms/resources/js/components/file-upload.js
registerPlugin(filepond_plugin_file_validate_size_esm_default);
registerPlugin(filepond_plugin_file_validate_type_esm_default);
registerPlugin(filepond_plugin_image_crop_esm_default);
registerPlugin(filepond_plugin_image_exif_orientation_esm_default);
registerPlugin(filepond_plugin_image_preview_esm_default);
registerPlugin(filepond_plugin_image_resize_esm_default);
registerPlugin(filepond_plugin_image_transform_esm_default);
registerPlugin(plugin8);
window.FilePond = filepond_esm_exports;
var file_upload_default = (Alpine) => {
  Alpine.data("fileUploadFormComponent", ({
    acceptedFileTypes,
    canReorder,
    canPreview,
    deleteUploadedFileUsing,
    getUploadedFileUrlsUsing,
    imageCropAspectRatio,
    imagePreviewHeight,
    imageResizeTargetHeight,
    imageResizeTargetWidth,
    loadingIndicatorPosition,
    panelAspectRatio,
    panelLayout,
    placeholder,
    maxSize,
    minSize,
    removeUploadedFileButtonPosition,
    removeUploadedFileUsing,
    reorderUploadedFilesUsing,
    shouldAppendFiles,
    shouldTransformImage,
    state: state2,
    uploadButtonPosition,
    uploadProgressIndicatorPosition,
    uploadUsing
  }) => {
    return {
      fileKeyIndex: {},
      pond: null,
      shouldUpdateState: true,
      state: state2,
      uploadedFileUrlIndex: {},
      init: async function() {
        this.pond = create$f(this.$refs.input, {
          acceptedFileTypes,
          allowReorder: canReorder,
          allowImagePreview: canPreview,
          allowVideoPreview: canPreview,
          allowAudioPreview: canPreview,
          allowImageTransform: shouldTransformImage,
          credits: false,
          files: await this.getFiles(),
          imageCropAspectRatio,
          imagePreviewHeight,
          imageResizeTargetHeight,
          imageResizeTargetWidth,
          itemInsertLocation: shouldAppendFiles ? "after" : "before",
          ...placeholder && {labelIdle: placeholder},
          maxFileSize: maxSize,
          minFileSize: minSize,
          styleButtonProcessItemPosition: uploadButtonPosition,
          styleButtonRemoveItemPosition: removeUploadedFileButtonPosition,
          styleLoadIndicatorPosition: loadingIndicatorPosition,
          stylePanelAspectRatio: panelAspectRatio,
          stylePanelLayout: panelLayout,
          styleProgressIndicatorPosition: uploadProgressIndicatorPosition,
          server: {
            load: async (source, load) => {
              let response = await fetch(source);
              let blob2 = await response.blob();
              load(blob2);
            },
            process: (fieldName, file2, metadata, load, error2, progress) => {
              this.shouldUpdateState = false;
              let fileKey = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
              uploadUsing(fileKey, file2, (fileKey2) => {
                this.shouldUpdateState = true;
                load(fileKey2);
              }, error2, progress);
            },
            remove: async (source, load) => {
              let fileKey = this.uploadedFileUrlIndex[source] ?? null;
              if (!fileKey) {
                return;
              }
              await deleteUploadedFileUsing(fileKey);
              load();
            },
            revert: async (uniqueFileId, load) => {
              await removeUploadedFileUsing(uniqueFileId);
              load();
            }
          }
        });
        this.$watch("state", async () => {
          if (!this.shouldUpdateState) {
            return;
          }
          if (Object.values(this.state).filter((file2) => file2.startsWith("livewire-file:")).length) {
            return;
          }
          this.pond.files = await this.getFiles();
        });
        this.pond.on("reorderfiles", async (files) => {
          const orderedFileKeys = files.map((file2) => file2.source instanceof File ? file2.serverId : this.uploadedFileUrlIndex[file2.source] ?? null).filter((fileKey) => fileKey);
          await reorderUploadedFilesUsing(shouldAppendFiles ? orderedFileKeys : orderedFileKeys.reverse());
        });
        this.pond.on("processfilestart", async () => {
          this.dispatchFormEvent("file-upload-started");
        });
        this.pond.on("processfileprogress", async () => {
          this.dispatchFormEvent("file-upload-started");
        });
        this.pond.on("processfile", async () => {
          this.dispatchFormEvent("file-upload-finished");
        });
        this.pond.on("processfiles", async () => {
          this.dispatchFormEvent("file-upload-finished");
        });
        this.pond.on("processfileabort", async () => {
          this.dispatchFormEvent("file-upload-finished");
        });
        this.pond.on("processfilerevert", async () => {
          this.dispatchFormEvent("file-upload-finished");
        });
      },
      dispatchFormEvent: function(name2) {
        this.$el.closest("form")?.dispatchEvent(new CustomEvent(name2, {
          composed: true,
          cancelable: true
        }));
      },
      getUploadedFileUrls: async function() {
        const uploadedFileUrls = await getUploadedFileUrlsUsing();
        this.fileKeyIndex = uploadedFileUrls ?? {};
        this.uploadedFileUrlIndex = Object.entries(this.fileKeyIndex).filter((value) => value).reduce((obj, [key, value]) => {
          obj[value] = key;
          return obj;
        }, {});
      },
      getFiles: async function() {
        await this.getUploadedFileUrls();
        let files = [];
        for (const uploadedFileUrl of Object.values(this.fileKeyIndex)) {
          if (!uploadedFileUrl) {
            continue;
          }
          files.push({
            source: uploadedFileUrl,
            options: {
              type: "local"
            }
          });
        }
        return shouldAppendFiles ? files : files.reverse();
      }
    };
  });
};

// packages/forms/resources/js/components/key-value.js
var key_value_default = (Alpine) => {
  Alpine.data("keyValueFormComponent", ({
    state: state2
  }) => ({
    state: state2,
    rows: [],
    shouldUpdateRows: true,
    init: function() {
      this.updateRows();
      if (this.rows.length <= 0) {
        this.addRow();
      }
      this.$watch("state", () => {
        if (!this.shouldUpdateRows) {
          this.shouldUpdateRows = true;
          return;
        }
        this.updateRows();
      });
    },
    addRow: function() {
      this.rows.push({key: "", value: ""});
      this.updateState();
    },
    deleteRow: function(index2) {
      this.rows.splice(index2, 1);
      if (this.rows.length <= 0) {
        this.addRow();
      }
      this.updateState();
      this.shouldUpdateRows = true;
    },
    updateRows: function() {
      let rows = [];
      for (let [key, value] of Object.entries(this.state ?? {})) {
        rows.push({
          key,
          value
        });
      }
      this.rows = rows;
    },
    updateState: function() {
      let state3 = {};
      this.rows.forEach((row) => {
        if (row.key === "" || row.key === null) {
          return;
        }
        state3[row.key] = row.value;
      });
      this.shouldUpdateRows = false;
      this.state = state3;
    }
  }));
};

// packages/forms/resources/js/components/markdown-editor.js
var import_easymde = __toModule(require_easymde());
var markdown_editor_default = (Alpine) => {
  Alpine.data("markdownEditorFormComponent", ({
    state: state2,
    statePath,
    tab,
    darkMode
  }) => {
    return {
      state: state2,
      tab,
      editor: null,
      isStateBeingUpdated: false,
      init: function() {
        this.editor = new import_easymde.default({
          element: this.$refs.textarea,
          spellChecker: false,
          status: false,
          initialValue: this.state,
          toolbar: ["upload-image", "preview"],
          styleSelectedText: false,
          blockStyles: {
            italic: "_"
          },
          unorderedListStyle: "-",
          previewClass: `prose w-full h-full max-w-none bg-white p-3 min-h-[150px] ${darkMode ? "dark:prose-invert dark:bg-gray-700" : ""}`.trim(),
          minHeight: "150px",
          uploadImage: true,
          direction: document.documentElement.dir,
          imageUploadFunction: (file2, onSuccess, onError) => {
            if (!file2)
              return;
            this.$wire.upload(`componentFileAttachments.${statePath}`, file2, () => {
              this.$wire.getComponentFileAttachmentUrl(statePath).then((url) => {
                onSuccess(url);
              });
            }, () => {
              onError("Failed to upload file.");
            });
          }
        });
        if (this.tab === "preview") {
          this.editor.togglePreview();
        }
        this.editor.codemirror.on("change", () => {
          this.isStateBeingUpdated = true;
          this.state = this.editor.value();
          this.$nextTick(() => this.isStateBeingUpdated = false);
        });
        this.$watch("tab", () => {
          if (this.tab === "preview" && this.editor.isPreviewActive() || this.tab === "write" && !this.editor.isPreviewActive()) {
            return;
          }
          this.editor.togglePreview();
        });
        this.$watch("state", () => {
          if (this.isStateBeingUpdated) {
            return;
          }
          this.editor.value(this.state);
        });
      }
    };
  });
};

// packages/forms/resources/js/components/rich-editor.js
var import_trix = __toModule(require_trix());
import_trix.default.config.blockAttributes.default.tagName = "p";
import_trix.default.config.blockAttributes.default.breakOnReturn = true;
import_trix.default.config.blockAttributes.heading = {
  tagName: "h2",
  terminal: true,
  breakOnReturn: true,
  group: false
};
import_trix.default.config.blockAttributes.subHeading = {
  tagName: "h3",
  terminal: true,
  breakOnReturn: true,
  group: false
};
import_trix.default.Block.prototype.breaksOnReturn = function() {
  const lastAttribute = this.getLastAttribute();
  const blockConfig = import_trix.default.getBlockConfig(lastAttribute ? lastAttribute : "default");
  return blockConfig?.breakOnReturn ?? false;
};
import_trix.default.LineBreakInsertion.prototype.shouldInsertBlockBreak = function() {
  if (this.block.hasAttributes() && this.block.isListItem() && !this.block.isEmpty()) {
    return this.startLocation.offset > 0;
  } else {
    return !this.shouldBreakFormattedBlock() ? this.breaksOnReturn : false;
  }
};
var rich_editor_default = (Alpine) => {
  Alpine.data("richEditorFormComponent", ({
    state: state2
  }) => {
    return {
      state: state2,
      init: function() {
        this.$refs.trix?.editor?.loadHTML(this.state);
        this.$watch("state", () => {
          if (document.activeElement === this.$refs.trix) {
            return;
          }
          this.$refs.trix?.editor?.loadHTML(this.state);
        });
      }
    };
  });
};

// packages/forms/resources/js/components/select.js
var import_choices = __toModule(require_choices());
var select_default = (Alpine) => {
  Alpine.data("selectFormComponent", ({
    getOptionLabelUsing,
    getOptionLabelsUsing,
    getOptionsUsing,
    getSearchResultsUsing,
    isAutofocused,
    isMultiple,
    hasDynamicOptions,
    hasDynamicSearchResults,
    loadingMessage,
    maxItems,
    noSearchResultsMessage,
    options,
    placeholder,
    searchingMessage,
    searchPrompt,
    state: state2
  }) => {
    return {
      isSearching: false,
      select: null,
      selectedOptions: [],
      isStateBeingUpdated: false,
      state: state2,
      init: async function() {
        this.select = new import_choices.default(this.$refs.input, {
          allowHTML: false,
          duplicateItemsAllowed: false,
          itemSelectText: "",
          loadingText: loadingMessage,
          maxItemCount: maxItems ?? -1,
          noChoicesText: searchPrompt,
          noResultsText: noSearchResultsMessage,
          placeholderValue: placeholder,
          removeItemButton: true,
          renderChoiceLimit: 50,
          searchChoices: !hasDynamicSearchResults,
          searchFields: ["label"],
          searchResultLimit: 50,
          shouldSort: false
        });
        await this.refreshChoices({withInitialOptions: true});
        if (![null, void 0, ""].includes(this.state)) {
          this.select.setChoiceByValue(this.formatState(this.state));
        }
        this.refreshPlaceholder();
        if (isAutofocused) {
          this.select.showDropdown();
        }
        this.$refs.input.addEventListener("change", () => {
          this.refreshPlaceholder();
          if (this.isStateBeingUpdated) {
            return;
          }
          this.isStateBeingUpdated = true;
          this.state = this.select.getValue(true) ?? null;
          this.$nextTick(() => this.isStateBeingUpdated = false);
        });
        if (hasDynamicOptions) {
          this.$refs.input.addEventListener("showDropdown", async () => {
            this.select.clearChoices();
            await this.select.setChoices([{value: "", label: loadingMessage, disabled: true}]);
            await this.refreshChoices();
          });
        }
        if (hasDynamicSearchResults) {
          this.$refs.input.addEventListener("search", async (event) => {
            let search = event.detail.value?.trim();
            if ([null, void 0, ""].includes(search)) {
              return;
            }
            this.isSearching = true;
            this.select.clearChoices();
            await this.select.setChoices([{value: "", label: searchingMessage, disabled: true}]);
          });
          this.$refs.input.addEventListener("search", Alpine.debounce(async (event) => {
            await this.refreshChoices({
              search: event.detail.value?.trim()
            });
            this.isSearching = false;
          }, 1e3));
        }
        this.$watch("state", async () => {
          this.refreshPlaceholder();
          if (this.isStateBeingUpdated) {
            return;
          }
          const choices = await this.getChoices({
            withInitialOptions: !hasDynamicOptions
          });
          this.select.clearStore();
          this.setChoices(choices);
          if (![null, void 0, ""].includes(this.state)) {
            this.select.setChoiceByValue(this.formatState(this.state));
          }
        });
      },
      refreshChoices: async function(config = {}) {
        this.setChoices(await this.getChoices(config));
      },
      setChoices: function(choices) {
        this.select.setChoices(choices, "value", "label", true);
      },
      getChoices: async function(config = {}) {
        const options2 = await this.getOptions(config);
        return this.transformOptionsIntoChoices({
          ...options2,
          ...await this.getMissingOptions(options2)
        });
      },
      getOptions: async function({search, withInitialOptions}) {
        if (withInitialOptions) {
          return options;
        }
        if (search !== "" && search !== null && search !== void 0) {
          return await getSearchResultsUsing(search);
        }
        return await getOptionsUsing();
      },
      transformOptionsIntoChoices: function(options2) {
        return Object.entries(options2).map(([value, label]) => ({
          label,
          value
        }));
      },
      refreshPlaceholder: function() {
        if (isMultiple) {
          return;
        }
        this.select._renderItems();
        if (![null, void 0, ""].includes(this.state)) {
          return;
        }
        this.$el.querySelector(".choices__list--single").innerHTML = `<div class="choices__placeholder choices__item">${placeholder}</div>`;
      },
      formatState: function(state3) {
        if (isMultiple) {
          return (state3 ?? []).map((item2) => item2?.toString());
        }
        return state3?.toString();
      },
      getMissingOptions: async function(options2) {
        if ([null, void 0, "", [], {}].includes(this.state)) {
          return {};
        }
        if (!options2.length) {
          options2 = {};
        }
        if (isMultiple) {
          if (this.state.every((value) => value in options2)) {
            return {};
          }
          return await getOptionLabelsUsing();
        }
        if (this.state in options2) {
          return options2;
        }
        let missingOptions = {};
        missingOptions[this.state] = await getOptionLabelUsing();
        return missingOptions;
      }
    };
  });
};

// packages/forms/resources/js/components/tags-input.js
var tags_input_default = (Alpine) => {
  Alpine.data("tagsInputFormComponent", ({
    state: state2
  }) => {
    return {
      newTag: "",
      state: state2,
      createTag: function() {
        this.newTag = this.newTag.trim();
        if (this.newTag === "") {
          return;
        }
        if (this.state.includes(this.newTag)) {
          this.newTag = "";
          return;
        }
        this.state.push(this.newTag);
        this.newTag = "";
      },
      deleteTag: function(tagToDelete) {
        this.state = this.state.filter((tag) => tag !== tagToDelete);
      }
    };
  });
};

// node_modules/imask/esm/_rollupPluginBabelHelpers-b054ecd2.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set2(target2, property2, value2, receiver2) {
      var base = _superPropBase(target2, property2);
      var desc;
      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property2);
        if (desc.set) {
          desc.set.call(receiver2, value2);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }
      desc = Object.getOwnPropertyDescriptor(receiver2, property2);
      if (desc) {
        if (!desc.writable) {
          return false;
        }
        desc.value = value2;
        Object.defineProperty(receiver2, property2, desc);
      } else {
        _defineProperty(receiver2, property2, value2);
      }
      return true;
    };
  }
  return set(target, property, value, receiver);
}
function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);
  if (!s && isStrict) {
    throw new Error("failed to set property");
  }
  return value;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/imask/esm/core/change-details.js
var ChangeDetails = /* @__PURE__ */ function() {
  function ChangeDetails2(details) {
    _classCallCheck(this, ChangeDetails2);
    Object.assign(this, {
      inserted: "",
      rawInserted: "",
      skip: false,
      tailShift: 0
    }, details);
  }
  _createClass(ChangeDetails2, [{
    key: "aggregate",
    value: function aggregate(details) {
      this.rawInserted += details.rawInserted;
      this.skip = this.skip || details.skip;
      this.inserted += details.inserted;
      this.tailShift += details.tailShift;
      return this;
    }
  }, {
    key: "offset",
    get: function get() {
      return this.tailShift + this.inserted.length;
    }
  }]);
  return ChangeDetails2;
}();

// node_modules/imask/esm/core/utils.js
function isString2(str) {
  return typeof str === "string" || str instanceof String;
}
var DIRECTION = {
  NONE: "NONE",
  LEFT: "LEFT",
  FORCE_LEFT: "FORCE_LEFT",
  RIGHT: "RIGHT",
  FORCE_RIGHT: "FORCE_RIGHT"
};
function forceDirection(direction) {
  switch (direction) {
    case DIRECTION.LEFT:
      return DIRECTION.FORCE_LEFT;
    case DIRECTION.RIGHT:
      return DIRECTION.FORCE_RIGHT;
    default:
      return direction;
  }
}
function escapeRegExp(str) {
  return str.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
}
function normalizePrepare(prep) {
  return Array.isArray(prep) ? prep : [prep, new ChangeDetails()];
}
function objectIncludes(b, a) {
  if (a === b)
    return true;
  var arrA = Array.isArray(a), arrB = Array.isArray(b), i;
  if (arrA && arrB) {
    if (a.length != b.length)
      return false;
    for (i = 0; i < a.length; i++) {
      if (!objectIncludes(a[i], b[i]))
        return false;
    }
    return true;
  }
  if (arrA != arrB)
    return false;
  if (a && b && _typeof(a) === "object" && _typeof(b) === "object") {
    var dateA = a instanceof Date, dateB = b instanceof Date;
    if (dateA && dateB)
      return a.getTime() == b.getTime();
    if (dateA != dateB)
      return false;
    var regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;
    if (regexpA && regexpB)
      return a.toString() == b.toString();
    if (regexpA != regexpB)
      return false;
    var keys = Object.keys(a);
    for (i = 0; i < keys.length; i++) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    }
    for (i = 0; i < keys.length; i++) {
      if (!objectIncludes(b[keys[i]], a[keys[i]]))
        return false;
    }
    return true;
  } else if (a && b && typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  return false;
}

// node_modules/imask/esm/core/action-details.js
var ActionDetails = /* @__PURE__ */ function() {
  function ActionDetails2(value, cursorPos, oldValue, oldSelection) {
    _classCallCheck(this, ActionDetails2);
    this.value = value;
    this.cursorPos = cursorPos;
    this.oldValue = oldValue;
    this.oldSelection = oldSelection;
    while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {
      --this.oldSelection.start;
    }
  }
  _createClass(ActionDetails2, [{
    key: "startChangePos",
    get: function get() {
      return Math.min(this.cursorPos, this.oldSelection.start);
    }
  }, {
    key: "insertedCount",
    get: function get() {
      return this.cursorPos - this.startChangePos;
    }
  }, {
    key: "inserted",
    get: function get() {
      return this.value.substr(this.startChangePos, this.insertedCount);
    }
  }, {
    key: "removedCount",
    get: function get() {
      return Math.max(this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length, 0);
    }
  }, {
    key: "removed",
    get: function get() {
      return this.oldValue.substr(this.startChangePos, this.removedCount);
    }
  }, {
    key: "head",
    get: function get() {
      return this.value.substring(0, this.startChangePos);
    }
  }, {
    key: "tail",
    get: function get() {
      return this.value.substring(this.startChangePos + this.insertedCount);
    }
  }, {
    key: "removeDirection",
    get: function get() {
      if (!this.removedCount || this.insertedCount)
        return DIRECTION.NONE;
      return (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) && this.oldSelection.end === this.oldSelection.start ? DIRECTION.RIGHT : DIRECTION.LEFT;
    }
  }]);
  return ActionDetails2;
}();

// node_modules/imask/esm/core/continuous-tail-details.js
var ContinuousTailDetails = /* @__PURE__ */ function() {
  function ContinuousTailDetails2() {
    var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var stop = arguments.length > 2 ? arguments[2] : void 0;
    _classCallCheck(this, ContinuousTailDetails2);
    this.value = value;
    this.from = from;
    this.stop = stop;
  }
  _createClass(ContinuousTailDetails2, [{
    key: "toString",
    value: function toString2() {
      return this.value;
    }
  }, {
    key: "extend",
    value: function extend2(tail) {
      this.value += String(tail);
    }
  }, {
    key: "appendTo",
    value: function appendTo(masked) {
      return masked.append(this.toString(), {
        tail: true
      }).aggregate(masked._appendPlaceholder());
    }
  }, {
    key: "state",
    get: function get() {
      return {
        value: this.value,
        from: this.from,
        stop: this.stop
      };
    },
    set: function set2(state2) {
      Object.assign(this, state2);
    }
  }, {
    key: "unshift",
    value: function unshift(beforePos) {
      if (!this.value.length || beforePos != null && this.from >= beforePos)
        return "";
      var shiftChar = this.value[0];
      this.value = this.value.slice(1);
      return shiftChar;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (!this.value.length)
        return "";
      var shiftChar = this.value[this.value.length - 1];
      this.value = this.value.slice(0, -1);
      return shiftChar;
    }
  }]);
  return ContinuousTailDetails2;
}();

// node_modules/imask/esm/core/holder.js
function IMask(el) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new IMask.InputMask(el, opts);
}

// node_modules/imask/esm/masked/base.js
var Masked = /* @__PURE__ */ function() {
  function Masked2(opts) {
    _classCallCheck(this, Masked2);
    this._value = "";
    this._update(Object.assign({}, Masked2.DEFAULTS, opts));
    this.isInitialized = true;
  }
  _createClass(Masked2, [{
    key: "updateOptions",
    value: function updateOptions(opts) {
      if (!Object.keys(opts).length)
        return;
      this.withValueRefresh(this._update.bind(this, opts));
    }
  }, {
    key: "_update",
    value: function _update(opts) {
      Object.assign(this, opts);
    }
  }, {
    key: "state",
    get: function get() {
      return {
        _value: this.value
      };
    },
    set: function set2(state2) {
      this._value = state2._value;
    }
  }, {
    key: "reset",
    value: function reset() {
      this._value = "";
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    },
    set: function set2(value) {
      this.resolve(value);
    }
  }, {
    key: "resolve",
    value: function resolve(value) {
      this.reset();
      this.append(value, {
        input: true
      }, "");
      this.doCommit();
      return this.value;
    }
  }, {
    key: "unmaskedValue",
    get: function get() {
      return this.value;
    },
    set: function set2(value) {
      this.reset();
      this.append(value, {}, "");
      this.doCommit();
    }
  }, {
    key: "typedValue",
    get: function get() {
      return this.doParse(this.value);
    },
    set: function set2(value) {
      this.value = this.doFormat(value);
    }
  }, {
    key: "rawInputValue",
    get: function get() {
      return this.extractInput(0, this.value.length, {
        raw: true
      });
    },
    set: function set2(value) {
      this.reset();
      this.append(value, {
        raw: true
      }, "");
      this.doCommit();
    }
  }, {
    key: "isComplete",
    get: function get() {
      return true;
    }
  }, {
    key: "isFilled",
    get: function get() {
      return this.isComplete;
    }
  }, {
    key: "nearestInputPos",
    value: function nearestInputPos(cursorPos, direction) {
      return cursorPos;
    }
  }, {
    key: "extractInput",
    value: function extractInput() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      return this.value.slice(fromPos, toPos);
    }
  }, {
    key: "extractTail",
    value: function extractTail() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);
    }
  }, {
    key: "appendTail",
    value: function appendTail(tail) {
      if (isString2(tail))
        tail = new ContinuousTailDetails(String(tail));
      return tail.appendTo(this);
    }
  }, {
    key: "_appendCharRaw",
    value: function _appendCharRaw(ch) {
      if (!ch)
        return new ChangeDetails();
      this._value += ch;
      return new ChangeDetails({
        inserted: ch,
        rawInserted: ch
      });
    }
  }, {
    key: "_appendChar",
    value: function _appendChar(ch) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var checkTail = arguments.length > 2 ? arguments[2] : void 0;
      var consistentState = this.state;
      var details;
      var _normalizePrepare = normalizePrepare(this.doPrepare(ch, flags));
      var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);
      ch = _normalizePrepare2[0];
      details = _normalizePrepare2[1];
      details = details.aggregate(this._appendCharRaw(ch, flags));
      if (details.inserted) {
        var consistentTail;
        var appended = this.doValidate(flags) !== false;
        if (appended && checkTail != null) {
          var beforeTailState = this.state;
          if (this.overwrite === true) {
            consistentTail = checkTail.state;
            checkTail.unshift(this.value.length);
          }
          var tailDetails = this.appendTail(checkTail);
          appended = tailDetails.rawInserted === checkTail.toString();
          if (!(appended && tailDetails.inserted) && this.overwrite === "shift") {
            this.state = beforeTailState;
            consistentTail = checkTail.state;
            checkTail.shift();
            tailDetails = this.appendTail(checkTail);
            appended = tailDetails.rawInserted === checkTail.toString();
          }
          if (appended && tailDetails.inserted)
            this.state = beforeTailState;
        }
        if (!appended) {
          details = new ChangeDetails();
          this.state = consistentState;
          if (checkTail && consistentTail)
            checkTail.state = consistentTail;
        }
      }
      return details;
    }
  }, {
    key: "_appendPlaceholder",
    value: function _appendPlaceholder() {
      return new ChangeDetails();
    }
  }, {
    key: "_appendEager",
    value: function _appendEager() {
      return new ChangeDetails();
    }
  }, {
    key: "append",
    value: function append(str, flags, tail) {
      if (!isString2(str))
        throw new Error("value should be string");
      var details = new ChangeDetails();
      var checkTail = isString2(tail) ? new ContinuousTailDetails(String(tail)) : tail;
      if (flags && flags.tail)
        flags._beforeTailState = this.state;
      for (var ci = 0; ci < str.length; ++ci) {
        details.aggregate(this._appendChar(str[ci], flags, checkTail));
      }
      if (checkTail != null) {
        details.tailShift += this.appendTail(checkTail).tailShift;
      }
      if (this.eager && flags !== null && flags !== void 0 && flags.input && str) {
        details.aggregate(this._appendEager());
      }
      return details;
    }
  }, {
    key: "remove",
    value: function remove() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);
      return new ChangeDetails();
    }
  }, {
    key: "withValueRefresh",
    value: function withValueRefresh(fn2) {
      if (this._refreshing || !this.isInitialized)
        return fn2();
      this._refreshing = true;
      var rawInput = this.rawInputValue;
      var value = this.value;
      var ret = fn2();
      this.rawInputValue = rawInput;
      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {
        this.append(value.slice(this.value.length), {}, "");
      }
      delete this._refreshing;
      return ret;
    }
  }, {
    key: "runIsolated",
    value: function runIsolated(fn2) {
      if (this._isolated || !this.isInitialized)
        return fn2(this);
      this._isolated = true;
      var state2 = this.state;
      var ret = fn2(this);
      this.state = state2;
      delete this._isolated;
      return ret;
    }
  }, {
    key: "doPrepare",
    value: function doPrepare(str) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this.prepare ? this.prepare(str, this, flags) : str;
    }
  }, {
    key: "doValidate",
    value: function doValidate(flags) {
      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));
    }
  }, {
    key: "doCommit",
    value: function doCommit() {
      if (this.commit)
        this.commit(this.value, this);
    }
  }, {
    key: "doFormat",
    value: function doFormat(value) {
      return this.format ? this.format(value, this) : value;
    }
  }, {
    key: "doParse",
    value: function doParse(str) {
      return this.parse ? this.parse(str, this) : str;
    }
  }, {
    key: "splice",
    value: function splice(start, deleteCount, inserted, removeDirection) {
      var tailPos = start + deleteCount;
      var tail = this.extractTail(tailPos);
      var oldRawValue;
      if (this.eager) {
        removeDirection = forceDirection(removeDirection);
        oldRawValue = this.extractInput(0, tailPos, {
          raw: true
        });
      }
      var startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !this.eager ? DIRECTION.NONE : removeDirection);
      var details = new ChangeDetails({
        tailShift: startChangePos - start
      }).aggregate(this.remove(startChangePos));
      if (this.eager && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {
        if (removeDirection === DIRECTION.FORCE_LEFT) {
          var valLength;
          while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {
            details.aggregate(new ChangeDetails({
              tailShift: -1
            })).aggregate(this.remove(valLength - 1));
          }
        } else if (removeDirection === DIRECTION.FORCE_RIGHT) {
          tail.unshift();
        }
      }
      return details.aggregate(this.append(inserted, {
        input: true
      }, tail));
    }
  }, {
    key: "maskEquals",
    value: function maskEquals(mask) {
      return this.mask === mask;
    }
  }]);
  return Masked2;
}();
Masked.DEFAULTS = {
  format: function format2(v) {
    return v;
  },
  parse: function parse2(v) {
    return v;
  }
};
IMask.Masked = Masked;

// node_modules/imask/esm/masked/factory.js
function maskedClass(mask) {
  if (mask == null) {
    throw new Error("mask property should be defined");
  }
  if (mask instanceof RegExp)
    return IMask.MaskedRegExp;
  if (isString2(mask))
    return IMask.MaskedPattern;
  if (mask instanceof Date || mask === Date)
    return IMask.MaskedDate;
  if (mask instanceof Number || typeof mask === "number" || mask === Number)
    return IMask.MaskedNumber;
  if (Array.isArray(mask) || mask === Array)
    return IMask.MaskedDynamic;
  if (IMask.Masked && mask.prototype instanceof IMask.Masked)
    return mask;
  if (mask instanceof IMask.Masked)
    return mask.constructor;
  if (mask instanceof Function)
    return IMask.MaskedFunction;
  console.warn("Mask not found for mask", mask);
  return IMask.Masked;
}
function createMask(opts) {
  if (IMask.Masked && opts instanceof IMask.Masked)
    return opts;
  opts = Object.assign({}, opts);
  var mask = opts.mask;
  if (IMask.Masked && mask instanceof IMask.Masked)
    return mask;
  var MaskedClass = maskedClass(mask);
  if (!MaskedClass)
    throw new Error("Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask.");
  return new MaskedClass(opts);
}
IMask.createMask = createMask;

// node_modules/imask/esm/masked/pattern/input-definition.js
var _excluded = ["mask"];
var DEFAULT_INPUT_DEFINITIONS = {
  "0": /\d/,
  a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
  "*": /./
};
var PatternInputDefinition = /* @__PURE__ */ function() {
  function PatternInputDefinition2(opts) {
    _classCallCheck(this, PatternInputDefinition2);
    var mask = opts.mask, blockOpts = _objectWithoutProperties(opts, _excluded);
    this.masked = createMask({
      mask
    });
    Object.assign(this, blockOpts);
  }
  _createClass(PatternInputDefinition2, [{
    key: "reset",
    value: function reset() {
      this.isFilled = false;
      this.masked.reset();
    }
  }, {
    key: "remove",
    value: function remove() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      if (fromPos === 0 && toPos >= 1) {
        this.isFilled = false;
        return this.masked.remove(fromPos, toPos);
      }
      return new ChangeDetails();
    }
  }, {
    key: "value",
    get: function get() {
      return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : "");
    }
  }, {
    key: "unmaskedValue",
    get: function get() {
      return this.masked.unmaskedValue;
    }
  }, {
    key: "isComplete",
    get: function get() {
      return Boolean(this.masked.value) || this.isOptional;
    }
  }, {
    key: "_appendChar",
    value: function _appendChar(ch) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.isFilled)
        return new ChangeDetails();
      var state2 = this.masked.state;
      var details = this.masked._appendChar(ch, flags);
      if (details.inserted && this.doValidate(flags) === false) {
        details.inserted = details.rawInserted = "";
        this.masked.state = state2;
      }
      if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) {
        details.inserted = this.placeholderChar;
      }
      details.skip = !details.inserted && !this.isOptional;
      this.isFilled = Boolean(details.inserted);
      return details;
    }
  }, {
    key: "append",
    value: function append() {
      var _this$masked;
      return (_this$masked = this.masked).append.apply(_this$masked, arguments);
    }
  }, {
    key: "_appendPlaceholder",
    value: function _appendPlaceholder() {
      var details = new ChangeDetails();
      if (this.isFilled || this.isOptional)
        return details;
      this.isFilled = true;
      details.inserted = this.placeholderChar;
      return details;
    }
  }, {
    key: "_appendEager",
    value: function _appendEager() {
      return new ChangeDetails();
    }
  }, {
    key: "extractTail",
    value: function extractTail() {
      var _this$masked2;
      return (_this$masked2 = this.masked).extractTail.apply(_this$masked2, arguments);
    }
  }, {
    key: "appendTail",
    value: function appendTail() {
      var _this$masked3;
      return (_this$masked3 = this.masked).appendTail.apply(_this$masked3, arguments);
    }
  }, {
    key: "extractInput",
    value: function extractInput() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      var flags = arguments.length > 2 ? arguments[2] : void 0;
      return this.masked.extractInput(fromPos, toPos, flags);
    }
  }, {
    key: "nearestInputPos",
    value: function nearestInputPos(cursorPos) {
      var direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DIRECTION.NONE;
      var minPos = 0;
      var maxPos = this.value.length;
      var boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);
      switch (direction) {
        case DIRECTION.LEFT:
        case DIRECTION.FORCE_LEFT:
          return this.isComplete ? boundPos : minPos;
        case DIRECTION.RIGHT:
        case DIRECTION.FORCE_RIGHT:
          return this.isComplete ? boundPos : maxPos;
        case DIRECTION.NONE:
        default:
          return boundPos;
      }
    }
  }, {
    key: "doValidate",
    value: function doValidate() {
      var _this$masked4, _this$parent;
      return (_this$masked4 = this.masked).doValidate.apply(_this$masked4, arguments) && (!this.parent || (_this$parent = this.parent).doValidate.apply(_this$parent, arguments));
    }
  }, {
    key: "doCommit",
    value: function doCommit() {
      this.masked.doCommit();
    }
  }, {
    key: "state",
    get: function get() {
      return {
        masked: this.masked.state,
        isFilled: this.isFilled
      };
    },
    set: function set2(state2) {
      this.masked.state = state2.masked;
      this.isFilled = state2.isFilled;
    }
  }]);
  return PatternInputDefinition2;
}();

// node_modules/imask/esm/masked/pattern/fixed-definition.js
var PatternFixedDefinition = /* @__PURE__ */ function() {
  function PatternFixedDefinition2(opts) {
    _classCallCheck(this, PatternFixedDefinition2);
    Object.assign(this, opts);
    this._value = "";
    this.isFixed = true;
  }
  _createClass(PatternFixedDefinition2, [{
    key: "value",
    get: function get() {
      return this._value;
    }
  }, {
    key: "unmaskedValue",
    get: function get() {
      return this.isUnmasking ? this.value : "";
    }
  }, {
    key: "reset",
    value: function reset() {
      this._isRawInput = false;
      this._value = "";
    }
  }, {
    key: "remove",
    value: function remove() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._value.length;
      this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);
      if (!this._value)
        this._isRawInput = false;
      return new ChangeDetails();
    }
  }, {
    key: "nearestInputPos",
    value: function nearestInputPos(cursorPos) {
      var direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DIRECTION.NONE;
      var minPos = 0;
      var maxPos = this._value.length;
      switch (direction) {
        case DIRECTION.LEFT:
        case DIRECTION.FORCE_LEFT:
          return minPos;
        case DIRECTION.NONE:
        case DIRECTION.RIGHT:
        case DIRECTION.FORCE_RIGHT:
        default:
          return maxPos;
      }
    }
  }, {
    key: "extractInput",
    value: function extractInput() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._value.length;
      var flags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || "";
    }
  }, {
    key: "isComplete",
    get: function get() {
      return true;
    }
  }, {
    key: "isFilled",
    get: function get() {
      return Boolean(this._value);
    }
  }, {
    key: "_appendChar",
    value: function _appendChar(ch) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var details = new ChangeDetails();
      if (this._value)
        return details;
      var appended = this.char === ch;
      var isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && !this.eager && !flags.tail;
      if (isResolved)
        details.rawInserted = this.char;
      this._value = details.inserted = this.char;
      this._isRawInput = isResolved && (flags.raw || flags.input);
      return details;
    }
  }, {
    key: "_appendEager",
    value: function _appendEager() {
      return this._appendChar(this.char);
    }
  }, {
    key: "_appendPlaceholder",
    value: function _appendPlaceholder() {
      var details = new ChangeDetails();
      if (this._value)
        return details;
      this._value = details.inserted = this.char;
      return details;
    }
  }, {
    key: "extractTail",
    value: function extractTail() {
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      return new ContinuousTailDetails("");
    }
  }, {
    key: "appendTail",
    value: function appendTail(tail) {
      if (isString2(tail))
        tail = new ContinuousTailDetails(String(tail));
      return tail.appendTo(this);
    }
  }, {
    key: "append",
    value: function append(str, flags, tail) {
      var details = this._appendChar(str[0], flags);
      if (tail != null) {
        details.tailShift += this.appendTail(tail).tailShift;
      }
      return details;
    }
  }, {
    key: "doCommit",
    value: function doCommit() {
    }
  }, {
    key: "state",
    get: function get() {
      return {
        _value: this._value,
        _isRawInput: this._isRawInput
      };
    },
    set: function set2(state2) {
      Object.assign(this, state2);
    }
  }]);
  return PatternFixedDefinition2;
}();

// node_modules/imask/esm/masked/pattern/chunk-tail-details.js
var _excluded2 = ["chunks"];
var ChunksTailDetails = /* @__PURE__ */ function() {
  function ChunksTailDetails2() {
    var chunks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    _classCallCheck(this, ChunksTailDetails2);
    this.chunks = chunks;
    this.from = from;
  }
  _createClass(ChunksTailDetails2, [{
    key: "toString",
    value: function toString2() {
      return this.chunks.map(String).join("");
    }
  }, {
    key: "extend",
    value: function extend2(tailChunk) {
      if (!String(tailChunk))
        return;
      if (isString2(tailChunk))
        tailChunk = new ContinuousTailDetails(String(tailChunk));
      var lastChunk = this.chunks[this.chunks.length - 1];
      var extendLast = lastChunk && (lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && tailChunk.from === lastChunk.from + lastChunk.toString().length;
      if (tailChunk instanceof ContinuousTailDetails) {
        if (extendLast) {
          lastChunk.extend(tailChunk.toString());
        } else {
          this.chunks.push(tailChunk);
        }
      } else if (tailChunk instanceof ChunksTailDetails2) {
        if (tailChunk.stop == null) {
          var firstTailChunk;
          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {
            firstTailChunk = tailChunk.chunks.shift();
            firstTailChunk.from += tailChunk.from;
            this.extend(firstTailChunk);
          }
        }
        if (tailChunk.toString()) {
          tailChunk.stop = tailChunk.blockIndex;
          this.chunks.push(tailChunk);
        }
      }
    }
  }, {
    key: "appendTo",
    value: function appendTo(masked) {
      if (!(masked instanceof IMask.MaskedPattern)) {
        var tail = new ContinuousTailDetails(this.toString());
        return tail.appendTo(masked);
      }
      var details = new ChangeDetails();
      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {
        var chunk = this.chunks[ci];
        var lastBlockIter = masked._mapPosToBlock(masked.value.length);
        var stop = chunk.stop;
        var chunkBlock = void 0;
        if (stop != null && (!lastBlockIter || lastBlockIter.index <= stop)) {
          if (chunk instanceof ChunksTailDetails2 || masked._stops.indexOf(stop) >= 0) {
            details.aggregate(masked._appendPlaceholder(stop));
          }
          chunkBlock = chunk instanceof ChunksTailDetails2 && masked._blocks[stop];
        }
        if (chunkBlock) {
          var tailDetails = chunkBlock.appendTail(chunk);
          tailDetails.skip = false;
          details.aggregate(tailDetails);
          masked._value += tailDetails.inserted;
          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);
          if (remainChars)
            details.aggregate(masked.append(remainChars, {
              tail: true
            }));
        } else {
          details.aggregate(masked.append(chunk.toString(), {
            tail: true
          }));
        }
      }
      return details;
    }
  }, {
    key: "state",
    get: function get() {
      return {
        chunks: this.chunks.map(function(c) {
          return c.state;
        }),
        from: this.from,
        stop: this.stop,
        blockIndex: this.blockIndex
      };
    },
    set: function set2(state2) {
      var chunks = state2.chunks, props = _objectWithoutProperties(state2, _excluded2);
      Object.assign(this, props);
      this.chunks = chunks.map(function(cstate) {
        var chunk = "chunks" in cstate ? new ChunksTailDetails2() : new ContinuousTailDetails();
        chunk.state = cstate;
        return chunk;
      });
    }
  }, {
    key: "unshift",
    value: function unshift(beforePos) {
      if (!this.chunks.length || beforePos != null && this.from >= beforePos)
        return "";
      var chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;
      var ci = 0;
      while (ci < this.chunks.length) {
        var chunk = this.chunks[ci];
        var shiftChar = chunk.unshift(chunkShiftPos);
        if (chunk.toString()) {
          if (!shiftChar)
            break;
          ++ci;
        } else {
          this.chunks.splice(ci, 1);
        }
        if (shiftChar)
          return shiftChar;
      }
      return "";
    }
  }, {
    key: "shift",
    value: function shift() {
      if (!this.chunks.length)
        return "";
      var ci = this.chunks.length - 1;
      while (0 <= ci) {
        var chunk = this.chunks[ci];
        var shiftChar = chunk.shift();
        if (chunk.toString()) {
          if (!shiftChar)
            break;
          --ci;
        } else {
          this.chunks.splice(ci, 1);
        }
        if (shiftChar)
          return shiftChar;
      }
      return "";
    }
  }]);
  return ChunksTailDetails2;
}();

// node_modules/imask/esm/masked/pattern/cursor.js
var PatternCursor = /* @__PURE__ */ function() {
  function PatternCursor2(masked, pos) {
    _classCallCheck(this, PatternCursor2);
    this.masked = masked;
    this._log = [];
    var _ref = masked._mapPosToBlock(pos) || (pos < 0 ? {
      index: 0,
      offset: 0
    } : {
      index: this.masked._blocks.length,
      offset: 0
    }), offset = _ref.offset, index2 = _ref.index;
    this.offset = offset;
    this.index = index2;
    this.ok = false;
  }
  _createClass(PatternCursor2, [{
    key: "block",
    get: function get() {
      return this.masked._blocks[this.index];
    }
  }, {
    key: "pos",
    get: function get() {
      return this.masked._blockStartPos(this.index) + this.offset;
    }
  }, {
    key: "state",
    get: function get() {
      return {
        index: this.index,
        offset: this.offset,
        ok: this.ok
      };
    },
    set: function set2(s) {
      Object.assign(this, s);
    }
  }, {
    key: "pushState",
    value: function pushState() {
      this._log.push(this.state);
    }
  }, {
    key: "popState",
    value: function popState() {
      var s = this._log.pop();
      this.state = s;
      return s;
    }
  }, {
    key: "bindBlock",
    value: function bindBlock() {
      if (this.block)
        return;
      if (this.index < 0) {
        this.index = 0;
        this.offset = 0;
      }
      if (this.index >= this.masked._blocks.length) {
        this.index = this.masked._blocks.length - 1;
        this.offset = this.block.value.length;
      }
    }
  }, {
    key: "_pushLeft",
    value: function _pushLeft(fn2) {
      this.pushState();
      for (this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((_this$block = this.block) === null || _this$block === void 0 ? void 0 : _this$block.value.length) || 0) {
        var _this$block;
        if (fn2())
          return this.ok = true;
      }
      return this.ok = false;
    }
  }, {
    key: "_pushRight",
    value: function _pushRight(fn2) {
      this.pushState();
      for (this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0) {
        if (fn2())
          return this.ok = true;
      }
      return this.ok = false;
    }
  }, {
    key: "pushLeftBeforeFilled",
    value: function pushLeftBeforeFilled() {
      var _this = this;
      return this._pushLeft(function() {
        if (_this.block.isFixed || !_this.block.value)
          return;
        _this.offset = _this.block.nearestInputPos(_this.offset, DIRECTION.FORCE_LEFT);
        if (_this.offset !== 0)
          return true;
      });
    }
  }, {
    key: "pushLeftBeforeInput",
    value: function pushLeftBeforeInput() {
      var _this2 = this;
      return this._pushLeft(function() {
        if (_this2.block.isFixed)
          return;
        _this2.offset = _this2.block.nearestInputPos(_this2.offset, DIRECTION.LEFT);
        return true;
      });
    }
  }, {
    key: "pushLeftBeforeRequired",
    value: function pushLeftBeforeRequired() {
      var _this3 = this;
      return this._pushLeft(function() {
        if (_this3.block.isFixed || _this3.block.isOptional && !_this3.block.value)
          return;
        _this3.offset = _this3.block.nearestInputPos(_this3.offset, DIRECTION.LEFT);
        return true;
      });
    }
  }, {
    key: "pushRightBeforeFilled",
    value: function pushRightBeforeFilled() {
      var _this4 = this;
      return this._pushRight(function() {
        if (_this4.block.isFixed || !_this4.block.value)
          return;
        _this4.offset = _this4.block.nearestInputPos(_this4.offset, DIRECTION.FORCE_RIGHT);
        if (_this4.offset !== _this4.block.value.length)
          return true;
      });
    }
  }, {
    key: "pushRightBeforeInput",
    value: function pushRightBeforeInput() {
      var _this5 = this;
      return this._pushRight(function() {
        if (_this5.block.isFixed)
          return;
        _this5.offset = _this5.block.nearestInputPos(_this5.offset, DIRECTION.NONE);
        return true;
      });
    }
  }, {
    key: "pushRightBeforeRequired",
    value: function pushRightBeforeRequired() {
      var _this6 = this;
      return this._pushRight(function() {
        if (_this6.block.isFixed || _this6.block.isOptional && !_this6.block.value)
          return;
        _this6.offset = _this6.block.nearestInputPos(_this6.offset, DIRECTION.NONE);
        return true;
      });
    }
  }]);
  return PatternCursor2;
}();

// node_modules/imask/esm/masked/regexp.js
var MaskedRegExp = /* @__PURE__ */ function(_Masked) {
  _inherits(MaskedRegExp2, _Masked);
  var _super = _createSuper(MaskedRegExp2);
  function MaskedRegExp2() {
    _classCallCheck(this, MaskedRegExp2);
    return _super.apply(this, arguments);
  }
  _createClass(MaskedRegExp2, [{
    key: "_update",
    value: function _update(opts) {
      if (opts.mask)
        opts.validate = function(value) {
          return value.search(opts.mask) >= 0;
        };
      _get(_getPrototypeOf(MaskedRegExp2.prototype), "_update", this).call(this, opts);
    }
  }]);
  return MaskedRegExp2;
}(Masked);
IMask.MaskedRegExp = MaskedRegExp;

// node_modules/imask/esm/masked/pattern.js
var _excluded3 = ["_blocks"];
var MaskedPattern = /* @__PURE__ */ function(_Masked) {
  _inherits(MaskedPattern2, _Masked);
  var _super = _createSuper(MaskedPattern2);
  function MaskedPattern2() {
    var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, MaskedPattern2);
    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);
    return _super.call(this, Object.assign({}, MaskedPattern2.DEFAULTS, opts));
  }
  _createClass(MaskedPattern2, [{
    key: "_update",
    value: function _update() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      opts.definitions = Object.assign({}, this.definitions, opts.definitions);
      _get(_getPrototypeOf(MaskedPattern2.prototype), "_update", this).call(this, opts);
      this._rebuildMask();
    }
  }, {
    key: "_rebuildMask",
    value: function _rebuildMask() {
      var _this = this;
      var defs = this.definitions;
      this._blocks = [];
      this._stops = [];
      this._maskedBlocks = {};
      var pattern = this.mask;
      if (!pattern || !defs)
        return;
      var unmaskingBlock = false;
      var optionalBlock = false;
      for (var i = 0; i < pattern.length; ++i) {
        if (this.blocks) {
          var _ret = function() {
            var p = pattern.slice(i);
            var bNames = Object.keys(_this.blocks).filter(function(bName2) {
              return p.indexOf(bName2) === 0;
            });
            bNames.sort(function(a, b) {
              return b.length - a.length;
            });
            var bName = bNames[0];
            if (bName) {
              var maskedBlock = createMask(Object.assign({
                parent: _this,
                lazy: _this.lazy,
                eager: _this.eager,
                placeholderChar: _this.placeholderChar,
                overwrite: _this.overwrite
              }, _this.blocks[bName]));
              if (maskedBlock) {
                _this._blocks.push(maskedBlock);
                if (!_this._maskedBlocks[bName])
                  _this._maskedBlocks[bName] = [];
                _this._maskedBlocks[bName].push(_this._blocks.length - 1);
              }
              i += bName.length - 1;
              return "continue";
            }
          }();
          if (_ret === "continue")
            continue;
        }
        var char = pattern[i];
        var isInput = char in defs;
        if (char === MaskedPattern2.STOP_CHAR) {
          this._stops.push(this._blocks.length);
          continue;
        }
        if (char === "{" || char === "}") {
          unmaskingBlock = !unmaskingBlock;
          continue;
        }
        if (char === "[" || char === "]") {
          optionalBlock = !optionalBlock;
          continue;
        }
        if (char === MaskedPattern2.ESCAPE_CHAR) {
          ++i;
          char = pattern[i];
          if (!char)
            break;
          isInput = false;
        }
        var def = isInput ? new PatternInputDefinition({
          parent: this,
          lazy: this.lazy,
          eager: this.eager,
          placeholderChar: this.placeholderChar,
          mask: defs[char],
          isOptional: optionalBlock
        }) : new PatternFixedDefinition({
          char,
          eager: this.eager,
          isUnmasking: unmaskingBlock
        });
        this._blocks.push(def);
      }
    }
  }, {
    key: "state",
    get: function get() {
      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern2.prototype), "state", this), {
        _blocks: this._blocks.map(function(b) {
          return b.state;
        })
      });
    },
    set: function set2(state2) {
      var _blocks = state2._blocks, maskedState = _objectWithoutProperties(state2, _excluded3);
      this._blocks.forEach(function(b, bi) {
        return b.state = _blocks[bi];
      });
      _set(_getPrototypeOf(MaskedPattern2.prototype), "state", maskedState, this, true);
    }
  }, {
    key: "reset",
    value: function reset() {
      _get(_getPrototypeOf(MaskedPattern2.prototype), "reset", this).call(this);
      this._blocks.forEach(function(b) {
        return b.reset();
      });
    }
  }, {
    key: "isComplete",
    get: function get() {
      return this._blocks.every(function(b) {
        return b.isComplete;
      });
    }
  }, {
    key: "isFilled",
    get: function get() {
      return this._blocks.every(function(b) {
        return b.isFilled;
      });
    }
  }, {
    key: "isFixed",
    get: function get() {
      return this._blocks.every(function(b) {
        return b.isFixed;
      });
    }
  }, {
    key: "isOptional",
    get: function get() {
      return this._blocks.every(function(b) {
        return b.isOptional;
      });
    }
  }, {
    key: "doCommit",
    value: function doCommit() {
      this._blocks.forEach(function(b) {
        return b.doCommit();
      });
      _get(_getPrototypeOf(MaskedPattern2.prototype), "doCommit", this).call(this);
    }
  }, {
    key: "unmaskedValue",
    get: function get() {
      return this._blocks.reduce(function(str, b) {
        return str += b.unmaskedValue;
      }, "");
    },
    set: function set2(unmaskedValue) {
      _set(_getPrototypeOf(MaskedPattern2.prototype), "unmaskedValue", unmaskedValue, this, true);
    }
  }, {
    key: "value",
    get: function get() {
      return this._blocks.reduce(function(str, b) {
        return str += b.value;
      }, "");
    },
    set: function set2(value) {
      _set(_getPrototypeOf(MaskedPattern2.prototype), "value", value, this, true);
    }
  }, {
    key: "appendTail",
    value: function appendTail(tail) {
      return _get(_getPrototypeOf(MaskedPattern2.prototype), "appendTail", this).call(this, tail).aggregate(this._appendPlaceholder());
    }
  }, {
    key: "_appendEager",
    value: function _appendEager() {
      var _this$_mapPosToBlock;
      var details = new ChangeDetails();
      var startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;
      if (startBlockIndex == null)
        return details;
      if (this._blocks[startBlockIndex].isFilled)
        ++startBlockIndex;
      for (var bi = startBlockIndex; bi < this._blocks.length; ++bi) {
        var d = this._blocks[bi]._appendEager();
        if (!d.inserted)
          break;
        details.aggregate(d);
      }
      return details;
    }
  }, {
    key: "_appendCharRaw",
    value: function _appendCharRaw(ch) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var blockIter = this._mapPosToBlock(this.value.length);
      var details = new ChangeDetails();
      if (!blockIter)
        return details;
      for (var bi = blockIter.index; ; ++bi) {
        var _flags$_beforeTailSta;
        var _block = this._blocks[bi];
        if (!_block)
          break;
        var blockDetails = _block._appendChar(ch, Object.assign({}, flags, {
          _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta._blocks[bi]
        }));
        var skip = blockDetails.skip;
        details.aggregate(blockDetails);
        if (skip || blockDetails.rawInserted)
          break;
      }
      return details;
    }
  }, {
    key: "extractTail",
    value: function extractTail() {
      var _this2 = this;
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      var chunkTail = new ChunksTailDetails();
      if (fromPos === toPos)
        return chunkTail;
      this._forEachBlocksInRange(fromPos, toPos, function(b, bi, bFromPos, bToPos) {
        var blockChunk = b.extractTail(bFromPos, bToPos);
        blockChunk.stop = _this2._findStopBefore(bi);
        blockChunk.from = _this2._blockStartPos(bi);
        if (blockChunk instanceof ChunksTailDetails)
          blockChunk.blockIndex = bi;
        chunkTail.extend(blockChunk);
      });
      return chunkTail;
    }
  }, {
    key: "extractInput",
    value: function extractInput() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      var flags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (fromPos === toPos)
        return "";
      var input = "";
      this._forEachBlocksInRange(fromPos, toPos, function(b, _, fromPos2, toPos2) {
        input += b.extractInput(fromPos2, toPos2, flags);
      });
      return input;
    }
  }, {
    key: "_findStopBefore",
    value: function _findStopBefore(blockIndex) {
      var stopBefore;
      for (var si = 0; si < this._stops.length; ++si) {
        var stop = this._stops[si];
        if (stop <= blockIndex)
          stopBefore = stop;
        else
          break;
      }
      return stopBefore;
    }
  }, {
    key: "_appendPlaceholder",
    value: function _appendPlaceholder(toBlockIndex) {
      var _this3 = this;
      var details = new ChangeDetails();
      if (this.lazy && toBlockIndex == null)
        return details;
      var startBlockIter = this._mapPosToBlock(this.value.length);
      if (!startBlockIter)
        return details;
      var startBlockIndex = startBlockIter.index;
      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;
      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function(b) {
        if (!b.lazy || toBlockIndex != null) {
          var args = b._blocks != null ? [b._blocks.length] : [];
          var bDetails = b._appendPlaceholder.apply(b, args);
          _this3._value += bDetails.inserted;
          details.aggregate(bDetails);
        }
      });
      return details;
    }
  }, {
    key: "_mapPosToBlock",
    value: function _mapPosToBlock(pos) {
      var accVal = "";
      for (var bi = 0; bi < this._blocks.length; ++bi) {
        var _block2 = this._blocks[bi];
        var blockStartPos = accVal.length;
        accVal += _block2.value;
        if (pos <= accVal.length) {
          return {
            index: bi,
            offset: pos - blockStartPos
          };
        }
      }
    }
  }, {
    key: "_blockStartPos",
    value: function _blockStartPos(blockIndex) {
      return this._blocks.slice(0, blockIndex).reduce(function(pos, b) {
        return pos += b.value.length;
      }, 0);
    }
  }, {
    key: "_forEachBlocksInRange",
    value: function _forEachBlocksInRange(fromPos) {
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      var fn2 = arguments.length > 2 ? arguments[2] : void 0;
      var fromBlockIter = this._mapPosToBlock(fromPos);
      if (fromBlockIter) {
        var toBlockIter = this._mapPosToBlock(toPos);
        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;
        var fromBlockStartPos = fromBlockIter.offset;
        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;
        fn2(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);
        if (toBlockIter && !isSameBlock) {
          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {
            fn2(this._blocks[bi], bi, 0, this._blocks[bi].value.length);
          }
          fn2(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);
        }
      }
    }
  }, {
    key: "remove",
    value: function remove() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      var removeDetails = _get(_getPrototypeOf(MaskedPattern2.prototype), "remove", this).call(this, fromPos, toPos);
      this._forEachBlocksInRange(fromPos, toPos, function(b, _, bFromPos, bToPos) {
        removeDetails.aggregate(b.remove(bFromPos, bToPos));
      });
      return removeDetails;
    }
  }, {
    key: "nearestInputPos",
    value: function nearestInputPos(cursorPos) {
      var direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DIRECTION.NONE;
      if (!this._blocks.length)
        return 0;
      var cursor = new PatternCursor(this, cursorPos);
      if (direction === DIRECTION.NONE) {
        if (cursor.pushRightBeforeInput())
          return cursor.pos;
        cursor.popState();
        if (cursor.pushLeftBeforeInput())
          return cursor.pos;
        return this.value.length;
      }
      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {
        if (direction === DIRECTION.LEFT) {
          cursor.pushRightBeforeFilled();
          if (cursor.ok && cursor.pos === cursorPos)
            return cursorPos;
          cursor.popState();
        }
        cursor.pushLeftBeforeInput();
        cursor.pushLeftBeforeRequired();
        cursor.pushLeftBeforeFilled();
        if (direction === DIRECTION.LEFT) {
          cursor.pushRightBeforeInput();
          cursor.pushRightBeforeRequired();
          if (cursor.ok && cursor.pos <= cursorPos)
            return cursor.pos;
          cursor.popState();
          if (cursor.ok && cursor.pos <= cursorPos)
            return cursor.pos;
          cursor.popState();
        }
        if (cursor.ok)
          return cursor.pos;
        if (direction === DIRECTION.FORCE_LEFT)
          return 0;
        cursor.popState();
        if (cursor.ok)
          return cursor.pos;
        cursor.popState();
        if (cursor.ok)
          return cursor.pos;
        return 0;
      }
      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {
        cursor.pushRightBeforeInput();
        cursor.pushRightBeforeRequired();
        if (cursor.pushRightBeforeFilled())
          return cursor.pos;
        if (direction === DIRECTION.FORCE_RIGHT)
          return this.value.length;
        cursor.popState();
        if (cursor.ok)
          return cursor.pos;
        cursor.popState();
        if (cursor.ok)
          return cursor.pos;
        return this.nearestInputPos(cursorPos, DIRECTION.LEFT);
      }
      return cursorPos;
    }
  }, {
    key: "maskedBlock",
    value: function maskedBlock(name2) {
      return this.maskedBlocks(name2)[0];
    }
  }, {
    key: "maskedBlocks",
    value: function maskedBlocks(name2) {
      var _this4 = this;
      var indices = this._maskedBlocks[name2];
      if (!indices)
        return [];
      return indices.map(function(gi) {
        return _this4._blocks[gi];
      });
    }
  }]);
  return MaskedPattern2;
}(Masked);
MaskedPattern.DEFAULTS = {
  lazy: true,
  placeholderChar: "_"
};
MaskedPattern.STOP_CHAR = "`";
MaskedPattern.ESCAPE_CHAR = "\\";
MaskedPattern.InputDefinition = PatternInputDefinition;
MaskedPattern.FixedDefinition = PatternFixedDefinition;
IMask.MaskedPattern = MaskedPattern;

// node_modules/imask/esm/masked/range.js
var MaskedRange = /* @__PURE__ */ function(_MaskedPattern) {
  _inherits(MaskedRange2, _MaskedPattern);
  var _super = _createSuper(MaskedRange2);
  function MaskedRange2() {
    _classCallCheck(this, MaskedRange2);
    return _super.apply(this, arguments);
  }
  _createClass(MaskedRange2, [{
    key: "_matchFrom",
    get: function get() {
      return this.maxLength - String(this.from).length;
    }
  }, {
    key: "_update",
    value: function _update(opts) {
      opts = Object.assign({
        to: this.to || 0,
        from: this.from || 0,
        maxLength: this.maxLength || 0
      }, opts);
      var maxLength = String(opts.to).length;
      if (opts.maxLength != null)
        maxLength = Math.max(maxLength, opts.maxLength);
      opts.maxLength = maxLength;
      var fromStr = String(opts.from).padStart(maxLength, "0");
      var toStr = String(opts.to).padStart(maxLength, "0");
      var sameCharsCount = 0;
      while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) {
        ++sameCharsCount;
      }
      opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, "\\0") + "0".repeat(maxLength - sameCharsCount);
      _get(_getPrototypeOf(MaskedRange2.prototype), "_update", this).call(this, opts);
    }
  }, {
    key: "isComplete",
    get: function get() {
      return _get(_getPrototypeOf(MaskedRange2.prototype), "isComplete", this) && Boolean(this.value);
    }
  }, {
    key: "boundaries",
    value: function boundaries(str) {
      var minstr = "";
      var maxstr = "";
      var _ref = str.match(/^(\D*)(\d*)(\D*)/) || [], _ref2 = _slicedToArray(_ref, 3), placeholder = _ref2[1], num = _ref2[2];
      if (num) {
        minstr = "0".repeat(placeholder.length) + num;
        maxstr = "9".repeat(placeholder.length) + num;
      }
      minstr = minstr.padEnd(this.maxLength, "0");
      maxstr = maxstr.padEnd(this.maxLength, "9");
      return [minstr, maxstr];
    }
  }, {
    key: "doPrepare",
    value: function doPrepare(ch) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var details;
      var _normalizePrepare = normalizePrepare(_get(_getPrototypeOf(MaskedRange2.prototype), "doPrepare", this).call(this, ch.replace(/\D/g, ""), flags));
      var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);
      ch = _normalizePrepare2[0];
      details = _normalizePrepare2[1];
      if (!this.autofix || !ch)
        return ch;
      var fromStr = String(this.from).padStart(this.maxLength, "0");
      var toStr = String(this.to).padStart(this.maxLength, "0");
      var nextVal = this.value + ch;
      if (nextVal.length > this.maxLength)
        return "";
      var _this$boundaries = this.boundaries(nextVal), _this$boundaries2 = _slicedToArray(_this$boundaries, 2), minstr = _this$boundaries2[0], maxstr = _this$boundaries2[1];
      if (Number(maxstr) < this.from)
        return fromStr[nextVal.length - 1];
      if (Number(minstr) > this.to) {
        if (this.autofix === "pad" && nextVal.length < this.maxLength) {
          return ["", details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags))];
        }
        return toStr[nextVal.length - 1];
      }
      return ch;
    }
  }, {
    key: "doValidate",
    value: function doValidate() {
      var _get2;
      var str = this.value;
      var firstNonZero = str.search(/[^0]/);
      if (firstNonZero === -1 && str.length <= this._matchFrom)
        return true;
      var _this$boundaries3 = this.boundaries(str), _this$boundaries4 = _slicedToArray(_this$boundaries3, 2), minstr = _this$boundaries4[0], maxstr = _this$boundaries4[1];
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.from <= Number(maxstr) && Number(minstr) <= this.to && (_get2 = _get(_getPrototypeOf(MaskedRange2.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));
    }
  }]);
  return MaskedRange2;
}(MaskedPattern);
IMask.MaskedRange = MaskedRange;

// node_modules/imask/esm/masked/date.js
var MaskedDate = /* @__PURE__ */ function(_MaskedPattern) {
  _inherits(MaskedDate2, _MaskedPattern);
  var _super = _createSuper(MaskedDate2);
  function MaskedDate2(opts) {
    _classCallCheck(this, MaskedDate2);
    return _super.call(this, Object.assign({}, MaskedDate2.DEFAULTS, opts));
  }
  _createClass(MaskedDate2, [{
    key: "_update",
    value: function _update(opts) {
      if (opts.mask === Date)
        delete opts.mask;
      if (opts.pattern)
        opts.mask = opts.pattern;
      var blocks = opts.blocks;
      opts.blocks = Object.assign({}, MaskedDate2.GET_DEFAULT_BLOCKS());
      if (opts.min)
        opts.blocks.Y.from = opts.min.getFullYear();
      if (opts.max)
        opts.blocks.Y.to = opts.max.getFullYear();
      if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {
        opts.blocks.m.from = opts.min.getMonth() + 1;
        opts.blocks.m.to = opts.max.getMonth() + 1;
        if (opts.blocks.m.from === opts.blocks.m.to) {
          opts.blocks.d.from = opts.min.getDate();
          opts.blocks.d.to = opts.max.getDate();
        }
      }
      Object.assign(opts.blocks, this.blocks, blocks);
      Object.keys(opts.blocks).forEach(function(bk) {
        var b = opts.blocks[bk];
        if (!("autofix" in b) && "autofix" in opts)
          b.autofix = opts.autofix;
      });
      _get(_getPrototypeOf(MaskedDate2.prototype), "_update", this).call(this, opts);
    }
  }, {
    key: "doValidate",
    value: function doValidate() {
      var _get2;
      var date = this.date;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return (_get2 = _get(_getPrototypeOf(MaskedDate2.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));
    }
  }, {
    key: "isDateExist",
    value: function isDateExist(str) {
      return this.format(this.parse(str, this), this).indexOf(str) >= 0;
    }
  }, {
    key: "date",
    get: function get() {
      return this.typedValue;
    },
    set: function set2(date) {
      this.typedValue = date;
    }
  }, {
    key: "typedValue",
    get: function get() {
      return this.isComplete ? _get(_getPrototypeOf(MaskedDate2.prototype), "typedValue", this) : null;
    },
    set: function set2(value) {
      _set(_getPrototypeOf(MaskedDate2.prototype), "typedValue", value, this, true);
    }
  }, {
    key: "maskEquals",
    value: function maskEquals(mask) {
      return mask === Date || _get(_getPrototypeOf(MaskedDate2.prototype), "maskEquals", this).call(this, mask);
    }
  }]);
  return MaskedDate2;
}(MaskedPattern);
MaskedDate.DEFAULTS = {
  pattern: "d{.}`m{.}`Y",
  format: function format3(date) {
    if (!date)
      return "";
    var day = String(date.getDate()).padStart(2, "0");
    var month = String(date.getMonth() + 1).padStart(2, "0");
    var year = date.getFullYear();
    return [day, month, year].join(".");
  },
  parse: function parse3(str) {
    var _str$split = str.split("."), _str$split2 = _slicedToArray(_str$split, 3), day = _str$split2[0], month = _str$split2[1], year = _str$split2[2];
    return new Date(year, month - 1, day);
  }
};
MaskedDate.GET_DEFAULT_BLOCKS = function() {
  return {
    d: {
      mask: MaskedRange,
      from: 1,
      to: 31,
      maxLength: 2
    },
    m: {
      mask: MaskedRange,
      from: 1,
      to: 12,
      maxLength: 2
    },
    Y: {
      mask: MaskedRange,
      from: 1900,
      to: 9999
    }
  };
};
IMask.MaskedDate = MaskedDate;

// node_modules/imask/esm/controls/mask-element.js
var MaskElement = /* @__PURE__ */ function() {
  function MaskElement2() {
    _classCallCheck(this, MaskElement2);
  }
  _createClass(MaskElement2, [{
    key: "selectionStart",
    get: function get() {
      var start;
      try {
        start = this._unsafeSelectionStart;
      } catch (e) {
      }
      return start != null ? start : this.value.length;
    }
  }, {
    key: "selectionEnd",
    get: function get() {
      var end;
      try {
        end = this._unsafeSelectionEnd;
      } catch (e) {
      }
      return end != null ? end : this.value.length;
    }
  }, {
    key: "select",
    value: function select(start, end) {
      if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd)
        return;
      try {
        this._unsafeSelect(start, end);
      } catch (e) {
      }
    }
  }, {
    key: "_unsafeSelect",
    value: function _unsafeSelect(start, end) {
    }
  }, {
    key: "isActive",
    get: function get() {
      return false;
    }
  }, {
    key: "bindEvents",
    value: function bindEvents(handlers) {
    }
  }, {
    key: "unbindEvents",
    value: function unbindEvents() {
    }
  }]);
  return MaskElement2;
}();
IMask.MaskElement = MaskElement;

// node_modules/imask/esm/controls/html-mask-element.js
var HTMLMaskElement = /* @__PURE__ */ function(_MaskElement) {
  _inherits(HTMLMaskElement2, _MaskElement);
  var _super = _createSuper(HTMLMaskElement2);
  function HTMLMaskElement2(input) {
    var _this;
    _classCallCheck(this, HTMLMaskElement2);
    _this = _super.call(this);
    _this.input = input;
    _this._handlers = {};
    return _this;
  }
  _createClass(HTMLMaskElement2, [{
    key: "rootElement",
    get: function get() {
      var _this$input$getRootNo, _this$input$getRootNo2, _this$input;
      return (_this$input$getRootNo = (_this$input$getRootNo2 = (_this$input = this.input).getRootNode) === null || _this$input$getRootNo2 === void 0 ? void 0 : _this$input$getRootNo2.call(_this$input)) !== null && _this$input$getRootNo !== void 0 ? _this$input$getRootNo : document;
    }
  }, {
    key: "isActive",
    get: function get() {
      return this.input === this.rootElement.activeElement;
    }
  }, {
    key: "_unsafeSelectionStart",
    get: function get() {
      return this.input.selectionStart;
    }
  }, {
    key: "_unsafeSelectionEnd",
    get: function get() {
      return this.input.selectionEnd;
    }
  }, {
    key: "_unsafeSelect",
    value: function _unsafeSelect(start, end) {
      this.input.setSelectionRange(start, end);
    }
  }, {
    key: "value",
    get: function get() {
      return this.input.value;
    },
    set: function set2(value) {
      this.input.value = value;
    }
  }, {
    key: "bindEvents",
    value: function bindEvents(handlers) {
      var _this2 = this;
      Object.keys(handlers).forEach(function(event) {
        return _this2._toggleEventHandler(HTMLMaskElement2.EVENTS_MAP[event], handlers[event]);
      });
    }
  }, {
    key: "unbindEvents",
    value: function unbindEvents() {
      var _this3 = this;
      Object.keys(this._handlers).forEach(function(event) {
        return _this3._toggleEventHandler(event);
      });
    }
  }, {
    key: "_toggleEventHandler",
    value: function _toggleEventHandler(event, handler) {
      if (this._handlers[event]) {
        this.input.removeEventListener(event, this._handlers[event]);
        delete this._handlers[event];
      }
      if (handler) {
        this.input.addEventListener(event, handler);
        this._handlers[event] = handler;
      }
    }
  }]);
  return HTMLMaskElement2;
}(MaskElement);
HTMLMaskElement.EVENTS_MAP = {
  selectionChange: "keydown",
  input: "input",
  drop: "drop",
  click: "click",
  focus: "focus",
  commit: "blur"
};
IMask.HTMLMaskElement = HTMLMaskElement;

// node_modules/imask/esm/controls/html-contenteditable-mask-element.js
var HTMLContenteditableMaskElement = /* @__PURE__ */ function(_HTMLMaskElement) {
  _inherits(HTMLContenteditableMaskElement2, _HTMLMaskElement);
  var _super = _createSuper(HTMLContenteditableMaskElement2);
  function HTMLContenteditableMaskElement2() {
    _classCallCheck(this, HTMLContenteditableMaskElement2);
    return _super.apply(this, arguments);
  }
  _createClass(HTMLContenteditableMaskElement2, [{
    key: "_unsafeSelectionStart",
    get: function get() {
      var root2 = this.rootElement;
      var selection = root2.getSelection && root2.getSelection();
      var anchorOffset = selection && selection.anchorOffset;
      var focusOffset = selection && selection.focusOffset;
      if (focusOffset == null || anchorOffset == null || anchorOffset < focusOffset) {
        return anchorOffset;
      }
      return focusOffset;
    }
  }, {
    key: "_unsafeSelectionEnd",
    get: function get() {
      var root2 = this.rootElement;
      var selection = root2.getSelection && root2.getSelection();
      var anchorOffset = selection && selection.anchorOffset;
      var focusOffset = selection && selection.focusOffset;
      if (focusOffset == null || anchorOffset == null || anchorOffset > focusOffset) {
        return anchorOffset;
      }
      return focusOffset;
    }
  }, {
    key: "_unsafeSelect",
    value: function _unsafeSelect(start, end) {
      if (!this.rootElement.createRange)
        return;
      var range = this.rootElement.createRange();
      range.setStart(this.input.firstChild || this.input, start);
      range.setEnd(this.input.lastChild || this.input, end);
      var root2 = this.rootElement;
      var selection = root2.getSelection && root2.getSelection();
      if (selection) {
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }
  }, {
    key: "value",
    get: function get() {
      return this.input.textContent;
    },
    set: function set2(value) {
      this.input.textContent = value;
    }
  }]);
  return HTMLContenteditableMaskElement2;
}(HTMLMaskElement);
IMask.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;

// node_modules/imask/esm/controls/input.js
var _excluded4 = ["mask"];
var InputMask = /* @__PURE__ */ function() {
  function InputMask2(el, opts) {
    _classCallCheck(this, InputMask2);
    this.el = el instanceof MaskElement ? el : el.isContentEditable && el.tagName !== "INPUT" && el.tagName !== "TEXTAREA" ? new HTMLContenteditableMaskElement(el) : new HTMLMaskElement(el);
    this.masked = createMask(opts);
    this._listeners = {};
    this._value = "";
    this._unmaskedValue = "";
    this._saveSelection = this._saveSelection.bind(this);
    this._onInput = this._onInput.bind(this);
    this._onChange = this._onChange.bind(this);
    this._onDrop = this._onDrop.bind(this);
    this._onFocus = this._onFocus.bind(this);
    this._onClick = this._onClick.bind(this);
    this.alignCursor = this.alignCursor.bind(this);
    this.alignCursorFriendly = this.alignCursorFriendly.bind(this);
    this._bindEvents();
    this.updateValue();
    this._onChange();
  }
  _createClass(InputMask2, [{
    key: "mask",
    get: function get() {
      return this.masked.mask;
    },
    set: function set2(mask) {
      if (this.maskEquals(mask))
        return;
      if (!(mask instanceof IMask.Masked) && this.masked.constructor === maskedClass(mask)) {
        this.masked.updateOptions({
          mask
        });
        return;
      }
      var masked = createMask({
        mask
      });
      masked.unmaskedValue = this.masked.unmaskedValue;
      this.masked = masked;
    }
  }, {
    key: "maskEquals",
    value: function maskEquals(mask) {
      var _this$masked;
      return mask == null || ((_this$masked = this.masked) === null || _this$masked === void 0 ? void 0 : _this$masked.maskEquals(mask));
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    },
    set: function set2(str) {
      this.masked.value = str;
      this.updateControl();
      this.alignCursor();
    }
  }, {
    key: "unmaskedValue",
    get: function get() {
      return this._unmaskedValue;
    },
    set: function set2(str) {
      this.masked.unmaskedValue = str;
      this.updateControl();
      this.alignCursor();
    }
  }, {
    key: "typedValue",
    get: function get() {
      return this.masked.typedValue;
    },
    set: function set2(val) {
      this.masked.typedValue = val;
      this.updateControl();
      this.alignCursor();
    }
  }, {
    key: "_bindEvents",
    value: function _bindEvents() {
      this.el.bindEvents({
        selectionChange: this._saveSelection,
        input: this._onInput,
        drop: this._onDrop,
        click: this._onClick,
        focus: this._onFocus,
        commit: this._onChange
      });
    }
  }, {
    key: "_unbindEvents",
    value: function _unbindEvents() {
      if (this.el)
        this.el.unbindEvents();
    }
  }, {
    key: "_fireEvent",
    value: function _fireEvent(ev) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var listeners2 = this._listeners[ev];
      if (!listeners2)
        return;
      listeners2.forEach(function(l) {
        return l.apply(void 0, args);
      });
    }
  }, {
    key: "selectionStart",
    get: function get() {
      return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
    }
  }, {
    key: "cursorPos",
    get: function get() {
      return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
    },
    set: function set2(pos) {
      if (!this.el || !this.el.isActive)
        return;
      this.el.select(pos, pos);
      this._saveSelection();
    }
  }, {
    key: "_saveSelection",
    value: function _saveSelection() {
      if (this.value !== this.el.value) {
        console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.");
      }
      this._selection = {
        start: this.selectionStart,
        end: this.cursorPos
      };
    }
  }, {
    key: "updateValue",
    value: function updateValue() {
      this.masked.value = this.el.value;
      this._value = this.masked.value;
    }
  }, {
    key: "updateControl",
    value: function updateControl() {
      var newUnmaskedValue = this.masked.unmaskedValue;
      var newValue = this.masked.value;
      var isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue;
      this._unmaskedValue = newUnmaskedValue;
      this._value = newValue;
      if (this.el.value !== newValue)
        this.el.value = newValue;
      if (isChanged)
        this._fireChangeEvents();
    }
  }, {
    key: "updateOptions",
    value: function updateOptions(opts) {
      var mask = opts.mask, restOpts = _objectWithoutProperties(opts, _excluded4);
      var updateMask = !this.maskEquals(mask);
      var updateOpts = !objectIncludes(this.masked, restOpts);
      if (updateMask)
        this.mask = mask;
      if (updateOpts)
        this.masked.updateOptions(restOpts);
      if (updateMask || updateOpts)
        this.updateControl();
    }
  }, {
    key: "updateCursor",
    value: function updateCursor(cursorPos) {
      if (cursorPos == null)
        return;
      this.cursorPos = cursorPos;
      this._delayUpdateCursor(cursorPos);
    }
  }, {
    key: "_delayUpdateCursor",
    value: function _delayUpdateCursor(cursorPos) {
      var _this = this;
      this._abortUpdateCursor();
      this._changingCursorPos = cursorPos;
      this._cursorChanging = setTimeout(function() {
        if (!_this.el)
          return;
        _this.cursorPos = _this._changingCursorPos;
        _this._abortUpdateCursor();
      }, 10);
    }
  }, {
    key: "_fireChangeEvents",
    value: function _fireChangeEvents() {
      this._fireEvent("accept", this._inputEvent);
      if (this.masked.isComplete)
        this._fireEvent("complete", this._inputEvent);
    }
  }, {
    key: "_abortUpdateCursor",
    value: function _abortUpdateCursor() {
      if (this._cursorChanging) {
        clearTimeout(this._cursorChanging);
        delete this._cursorChanging;
      }
    }
  }, {
    key: "alignCursor",
    value: function alignCursor() {
      this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT));
    }
  }, {
    key: "alignCursorFriendly",
    value: function alignCursorFriendly() {
      if (this.selectionStart !== this.cursorPos)
        return;
      this.alignCursor();
    }
  }, {
    key: "on",
    value: function on3(ev, handler) {
      if (!this._listeners[ev])
        this._listeners[ev] = [];
      this._listeners[ev].push(handler);
      return this;
    }
  }, {
    key: "off",
    value: function off2(ev, handler) {
      if (!this._listeners[ev])
        return this;
      if (!handler) {
        delete this._listeners[ev];
        return this;
      }
      var hIndex = this._listeners[ev].indexOf(handler);
      if (hIndex >= 0)
        this._listeners[ev].splice(hIndex, 1);
      return this;
    }
  }, {
    key: "_onInput",
    value: function _onInput(e) {
      this._inputEvent = e;
      this._abortUpdateCursor();
      if (!this._selection)
        return this.updateValue();
      var details = new ActionDetails(this.el.value, this.cursorPos, this.value, this._selection);
      var oldRawValue = this.masked.rawInputValue;
      var offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection).offset;
      var removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;
      var cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);
      if (removeDirection !== DIRECTION.NONE)
        cursorPos = this.masked.nearestInputPos(cursorPos, DIRECTION.NONE);
      this.updateControl();
      this.updateCursor(cursorPos);
      delete this._inputEvent;
    }
  }, {
    key: "_onChange",
    value: function _onChange() {
      if (this.value !== this.el.value) {
        this.updateValue();
      }
      this.masked.doCommit();
      this.updateControl();
      this._saveSelection();
    }
  }, {
    key: "_onDrop",
    value: function _onDrop2(ev) {
      ev.preventDefault();
      ev.stopPropagation();
    }
  }, {
    key: "_onFocus",
    value: function _onFocus(ev) {
      this.alignCursorFriendly();
    }
  }, {
    key: "_onClick",
    value: function _onClick(ev) {
      this.alignCursorFriendly();
    }
  }, {
    key: "destroy",
    value: function destroy3() {
      this._unbindEvents();
      this._listeners.length = 0;
      delete this.el;
    }
  }]);
  return InputMask2;
}();
IMask.InputMask = InputMask;

// node_modules/imask/esm/masked/enum.js
var MaskedEnum = /* @__PURE__ */ function(_MaskedPattern) {
  _inherits(MaskedEnum2, _MaskedPattern);
  var _super = _createSuper(MaskedEnum2);
  function MaskedEnum2() {
    _classCallCheck(this, MaskedEnum2);
    return _super.apply(this, arguments);
  }
  _createClass(MaskedEnum2, [{
    key: "_update",
    value: function _update(opts) {
      if (opts.enum)
        opts.mask = "*".repeat(opts.enum[0].length);
      _get(_getPrototypeOf(MaskedEnum2.prototype), "_update", this).call(this, opts);
    }
  }, {
    key: "doValidate",
    value: function doValidate() {
      var _this = this, _get2;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.enum.some(function(e) {
        return e.indexOf(_this.unmaskedValue) >= 0;
      }) && (_get2 = _get(_getPrototypeOf(MaskedEnum2.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));
    }
  }]);
  return MaskedEnum2;
}(MaskedPattern);
IMask.MaskedEnum = MaskedEnum;

// node_modules/imask/esm/masked/number.js
var MaskedNumber = /* @__PURE__ */ function(_Masked) {
  _inherits(MaskedNumber2, _Masked);
  var _super = _createSuper(MaskedNumber2);
  function MaskedNumber2(opts) {
    _classCallCheck(this, MaskedNumber2);
    return _super.call(this, Object.assign({}, MaskedNumber2.DEFAULTS, opts));
  }
  _createClass(MaskedNumber2, [{
    key: "_update",
    value: function _update(opts) {
      _get(_getPrototypeOf(MaskedNumber2.prototype), "_update", this).call(this, opts);
      this._updateRegExps();
    }
  }, {
    key: "_updateRegExps",
    value: function _updateRegExps() {
      var start = "^" + (this.allowNegative ? "[+|\\-]?" : "");
      var midInput = "(0|([1-9]+\\d*))?";
      var mid = "\\d*";
      var end = (this.scale ? "(" + escapeRegExp(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$";
      this._numberRegExpInput = new RegExp(start + midInput + end);
      this._numberRegExp = new RegExp(start + mid + end);
      this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(escapeRegExp).join("") + "]", "g");
      this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), "g");
    }
  }, {
    key: "_removeThousandsSeparators",
    value: function _removeThousandsSeparators(value) {
      return value.replace(this._thousandsSeparatorRegExp, "");
    }
  }, {
    key: "_insertThousandsSeparators",
    value: function _insertThousandsSeparators(value) {
      var parts = value.split(this.radix);
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator);
      return parts.join(this.radix);
    }
  }, {
    key: "doPrepare",
    value: function doPrepare(ch) {
      var _get2;
      ch = ch.replace(this._mapToRadixRegExp, this.radix);
      var noSepCh = this._removeThousandsSeparators(ch);
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var _normalizePrepare = normalizePrepare((_get2 = _get(_getPrototypeOf(MaskedNumber2.prototype), "doPrepare", this)).call.apply(_get2, [this, noSepCh].concat(args))), _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2), prepCh = _normalizePrepare2[0], details = _normalizePrepare2[1];
      if (ch && !noSepCh)
        details.skip = true;
      return [prepCh, details];
    }
  }, {
    key: "_separatorsCount",
    value: function _separatorsCount(to) {
      var extendOnSeparators = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var count = 0;
      for (var pos = 0; pos < to; ++pos) {
        if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {
          ++count;
          if (extendOnSeparators)
            to += this.thousandsSeparator.length;
        }
      }
      return count;
    }
  }, {
    key: "_separatorsCountFromSlice",
    value: function _separatorsCountFromSlice() {
      var slice = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._value;
      return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);
    }
  }, {
    key: "extractInput",
    value: function extractInput() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      var flags = arguments.length > 2 ? arguments[2] : void 0;
      var _this$_adjustRangeWit = this._adjustRangeWithSeparators(fromPos, toPos);
      var _this$_adjustRangeWit2 = _slicedToArray(_this$_adjustRangeWit, 2);
      fromPos = _this$_adjustRangeWit2[0];
      toPos = _this$_adjustRangeWit2[1];
      return this._removeThousandsSeparators(_get(_getPrototypeOf(MaskedNumber2.prototype), "extractInput", this).call(this, fromPos, toPos, flags));
    }
  }, {
    key: "_appendCharRaw",
    value: function _appendCharRaw(ch) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.thousandsSeparator)
        return _get(_getPrototypeOf(MaskedNumber2.prototype), "_appendCharRaw", this).call(this, ch, flags);
      var prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;
      var prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);
      this._value = this._removeThousandsSeparators(this.value);
      var appendDetails = _get(_getPrototypeOf(MaskedNumber2.prototype), "_appendCharRaw", this).call(this, ch, flags);
      this._value = this._insertThousandsSeparators(this._value);
      var beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;
      var beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);
      appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;
      appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;
      return appendDetails;
    }
  }, {
    key: "_findSeparatorAround",
    value: function _findSeparatorAround(pos) {
      if (this.thousandsSeparator) {
        var searchFrom = pos - this.thousandsSeparator.length + 1;
        var separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);
        if (separatorPos <= pos)
          return separatorPos;
      }
      return -1;
    }
  }, {
    key: "_adjustRangeWithSeparators",
    value: function _adjustRangeWithSeparators(from, to) {
      var separatorAroundFromPos = this._findSeparatorAround(from);
      if (separatorAroundFromPos >= 0)
        from = separatorAroundFromPos;
      var separatorAroundToPos = this._findSeparatorAround(to);
      if (separatorAroundToPos >= 0)
        to = separatorAroundToPos + this.thousandsSeparator.length;
      return [from, to];
    }
  }, {
    key: "remove",
    value: function remove() {
      var fromPos = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.value.length;
      var _this$_adjustRangeWit3 = this._adjustRangeWithSeparators(fromPos, toPos);
      var _this$_adjustRangeWit4 = _slicedToArray(_this$_adjustRangeWit3, 2);
      fromPos = _this$_adjustRangeWit4[0];
      toPos = _this$_adjustRangeWit4[1];
      var valueBeforePos = this.value.slice(0, fromPos);
      var valueAfterPos = this.value.slice(toPos);
      var prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);
      this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));
      var beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);
      return new ChangeDetails({
        tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length
      });
    }
  }, {
    key: "nearestInputPos",
    value: function nearestInputPos(cursorPos, direction) {
      if (!this.thousandsSeparator)
        return cursorPos;
      switch (direction) {
        case DIRECTION.NONE:
        case DIRECTION.LEFT:
        case DIRECTION.FORCE_LEFT: {
          var separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);
          if (separatorAtLeftPos >= 0) {
            var separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;
            if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {
              return separatorAtLeftPos;
            }
          }
          break;
        }
        case DIRECTION.RIGHT:
        case DIRECTION.FORCE_RIGHT: {
          var separatorAtRightPos = this._findSeparatorAround(cursorPos);
          if (separatorAtRightPos >= 0) {
            return separatorAtRightPos + this.thousandsSeparator.length;
          }
        }
      }
      return cursorPos;
    }
  }, {
    key: "doValidate",
    value: function doValidate(flags) {
      var regexp = flags.input ? this._numberRegExpInput : this._numberRegExp;
      var valid = regexp.test(this._removeThousandsSeparators(this.value));
      if (valid) {
        var number = this.number;
        valid = valid && !isNaN(number) && (this.min == null || this.min >= 0 || this.min <= this.number) && (this.max == null || this.max <= 0 || this.number <= this.max);
      }
      return valid && _get(_getPrototypeOf(MaskedNumber2.prototype), "doValidate", this).call(this, flags);
    }
  }, {
    key: "doCommit",
    value: function doCommit() {
      if (this.value) {
        var number = this.number;
        var validnum = number;
        if (this.min != null)
          validnum = Math.max(validnum, this.min);
        if (this.max != null)
          validnum = Math.min(validnum, this.max);
        if (validnum !== number)
          this.unmaskedValue = String(validnum);
        var formatted = this.value;
        if (this.normalizeZeros)
          formatted = this._normalizeZeros(formatted);
        if (this.padFractionalZeros && this.scale > 0)
          formatted = this._padFractionalZeros(formatted);
        this._value = formatted;
      }
      _get(_getPrototypeOf(MaskedNumber2.prototype), "doCommit", this).call(this);
    }
  }, {
    key: "_normalizeZeros",
    value: function _normalizeZeros(value) {
      var parts = this._removeThousandsSeparators(value).split(this.radix);
      parts[0] = parts[0].replace(/^(\D*)(0*)(\d*)/, function(match, sign, zeros, num) {
        return sign + num;
      });
      if (value.length && !/\d$/.test(parts[0]))
        parts[0] = parts[0] + "0";
      if (parts.length > 1) {
        parts[1] = parts[1].replace(/0*$/, "");
        if (!parts[1].length)
          parts.length = 1;
      }
      return this._insertThousandsSeparators(parts.join(this.radix));
    }
  }, {
    key: "_padFractionalZeros",
    value: function _padFractionalZeros(value) {
      if (!value)
        return value;
      var parts = value.split(this.radix);
      if (parts.length < 2)
        parts.push("");
      parts[1] = parts[1].padEnd(this.scale, "0");
      return parts.join(this.radix);
    }
  }, {
    key: "unmaskedValue",
    get: function get() {
      return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, ".");
    },
    set: function set2(unmaskedValue) {
      _set(_getPrototypeOf(MaskedNumber2.prototype), "unmaskedValue", unmaskedValue.replace(".", this.radix), this, true);
    }
  }, {
    key: "typedValue",
    get: function get() {
      return Number(this.unmaskedValue);
    },
    set: function set2(n) {
      _set(_getPrototypeOf(MaskedNumber2.prototype), "unmaskedValue", String(n), this, true);
    }
  }, {
    key: "number",
    get: function get() {
      return this.typedValue;
    },
    set: function set2(number) {
      this.typedValue = number;
    }
  }, {
    key: "allowNegative",
    get: function get() {
      return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0;
    }
  }]);
  return MaskedNumber2;
}(Masked);
MaskedNumber.DEFAULTS = {
  radix: ",",
  thousandsSeparator: "",
  mapToRadix: ["."],
  scale: 2,
  signed: false,
  normalizeZeros: true,
  padFractionalZeros: false
};
IMask.MaskedNumber = MaskedNumber;

// node_modules/imask/esm/masked/function.js
var MaskedFunction = /* @__PURE__ */ function(_Masked) {
  _inherits(MaskedFunction2, _Masked);
  var _super = _createSuper(MaskedFunction2);
  function MaskedFunction2() {
    _classCallCheck(this, MaskedFunction2);
    return _super.apply(this, arguments);
  }
  _createClass(MaskedFunction2, [{
    key: "_update",
    value: function _update(opts) {
      if (opts.mask)
        opts.validate = opts.mask;
      _get(_getPrototypeOf(MaskedFunction2.prototype), "_update", this).call(this, opts);
    }
  }]);
  return MaskedFunction2;
}(Masked);
IMask.MaskedFunction = MaskedFunction;

// node_modules/imask/esm/masked/dynamic.js
var _excluded5 = ["compiledMasks", "currentMaskRef", "currentMask"];
var MaskedDynamic = /* @__PURE__ */ function(_Masked) {
  _inherits(MaskedDynamic2, _Masked);
  var _super = _createSuper(MaskedDynamic2);
  function MaskedDynamic2(opts) {
    var _this;
    _classCallCheck(this, MaskedDynamic2);
    _this = _super.call(this, Object.assign({}, MaskedDynamic2.DEFAULTS, opts));
    _this.currentMask = null;
    return _this;
  }
  _createClass(MaskedDynamic2, [{
    key: "_update",
    value: function _update(opts) {
      _get(_getPrototypeOf(MaskedDynamic2.prototype), "_update", this).call(this, opts);
      if ("mask" in opts) {
        this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function(m) {
          return createMask(m);
        }) : [];
      }
    }
  }, {
    key: "_appendCharRaw",
    value: function _appendCharRaw(ch) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var details = this._applyDispatch(ch, flags);
      if (this.currentMask) {
        details.aggregate(this.currentMask._appendChar(ch, flags));
      }
      return details;
    }
  }, {
    key: "_applyDispatch",
    value: function _applyDispatch() {
      var appended = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;
      var inputValue = this.rawInputValue;
      var insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;
      var tailValue = inputValue.slice(insertValue.length);
      var prevMask = this.currentMask;
      var details = new ChangeDetails();
      var prevMaskState = prevMask && prevMask.state;
      this.currentMask = this.doDispatch(appended, Object.assign({}, flags));
      if (this.currentMask) {
        if (this.currentMask !== prevMask) {
          this.currentMask.reset();
          if (insertValue) {
            var d = this.currentMask.append(insertValue, {
              raw: true
            });
            details.tailShift = d.inserted.length - prevValueBeforeTail.length;
          }
          if (tailValue) {
            details.tailShift += this.currentMask.append(tailValue, {
              raw: true,
              tail: true
            }).tailShift;
          }
        } else {
          this.currentMask.state = prevMaskState;
        }
      }
      return details;
    }
  }, {
    key: "_appendPlaceholder",
    value: function _appendPlaceholder() {
      var details = this._applyDispatch.apply(this, arguments);
      if (this.currentMask) {
        details.aggregate(this.currentMask._appendPlaceholder());
      }
      return details;
    }
  }, {
    key: "_appendEager",
    value: function _appendEager() {
      var details = this._applyDispatch.apply(this, arguments);
      if (this.currentMask) {
        details.aggregate(this.currentMask._appendEager());
      }
      return details;
    }
  }, {
    key: "doDispatch",
    value: function doDispatch(appended) {
      var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this.dispatch(appended, this, flags);
    }
  }, {
    key: "doValidate",
    value: function doValidate() {
      var _get2, _this$currentMask;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return (_get2 = _get(_getPrototypeOf(MaskedDynamic2.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.currentMask || (_this$currentMask = this.currentMask).doValidate.apply(_this$currentMask, args));
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this$currentMask2;
      (_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.reset();
      this.compiledMasks.forEach(function(m) {
        return m.reset();
      });
    }
  }, {
    key: "value",
    get: function get() {
      return this.currentMask ? this.currentMask.value : "";
    },
    set: function set2(value) {
      _set(_getPrototypeOf(MaskedDynamic2.prototype), "value", value, this, true);
    }
  }, {
    key: "unmaskedValue",
    get: function get() {
      return this.currentMask ? this.currentMask.unmaskedValue : "";
    },
    set: function set2(unmaskedValue) {
      _set(_getPrototypeOf(MaskedDynamic2.prototype), "unmaskedValue", unmaskedValue, this, true);
    }
  }, {
    key: "typedValue",
    get: function get() {
      return this.currentMask ? this.currentMask.typedValue : "";
    },
    set: function set2(value) {
      var unmaskedValue = String(value);
      if (this.currentMask) {
        this.currentMask.typedValue = value;
        unmaskedValue = this.currentMask.unmaskedValue;
      }
      this.unmaskedValue = unmaskedValue;
    }
  }, {
    key: "isComplete",
    get: function get() {
      var _this$currentMask3;
      return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isComplete);
    }
  }, {
    key: "isFilled",
    get: function get() {
      var _this$currentMask4;
      return Boolean((_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.isFilled);
    }
  }, {
    key: "remove",
    value: function remove() {
      var details = new ChangeDetails();
      if (this.currentMask) {
        var _this$currentMask5;
        details.aggregate((_this$currentMask5 = this.currentMask).remove.apply(_this$currentMask5, arguments)).aggregate(this._applyDispatch());
      }
      return details;
    }
  }, {
    key: "state",
    get: function get() {
      return Object.assign({}, _get(_getPrototypeOf(MaskedDynamic2.prototype), "state", this), {
        _rawInputValue: this.rawInputValue,
        compiledMasks: this.compiledMasks.map(function(m) {
          return m.state;
        }),
        currentMaskRef: this.currentMask,
        currentMask: this.currentMask && this.currentMask.state
      });
    },
    set: function set2(state2) {
      var compiledMasks = state2.compiledMasks, currentMaskRef = state2.currentMaskRef, currentMask = state2.currentMask, maskedState = _objectWithoutProperties(state2, _excluded5);
      this.compiledMasks.forEach(function(m, mi) {
        return m.state = compiledMasks[mi];
      });
      if (currentMaskRef != null) {
        this.currentMask = currentMaskRef;
        this.currentMask.state = currentMask;
      }
      _set(_getPrototypeOf(MaskedDynamic2.prototype), "state", maskedState, this, true);
    }
  }, {
    key: "extractInput",
    value: function extractInput() {
      var _this$currentMask6;
      return this.currentMask ? (_this$currentMask6 = this.currentMask).extractInput.apply(_this$currentMask6, arguments) : "";
    }
  }, {
    key: "extractTail",
    value: function extractTail() {
      var _this$currentMask7, _get3;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.currentMask ? (_this$currentMask7 = this.currentMask).extractTail.apply(_this$currentMask7, args) : (_get3 = _get(_getPrototypeOf(MaskedDynamic2.prototype), "extractTail", this)).call.apply(_get3, [this].concat(args));
    }
  }, {
    key: "doCommit",
    value: function doCommit() {
      if (this.currentMask)
        this.currentMask.doCommit();
      _get(_getPrototypeOf(MaskedDynamic2.prototype), "doCommit", this).call(this);
    }
  }, {
    key: "nearestInputPos",
    value: function nearestInputPos() {
      var _this$currentMask8, _get4;
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.currentMask ? (_this$currentMask8 = this.currentMask).nearestInputPos.apply(_this$currentMask8, args) : (_get4 = _get(_getPrototypeOf(MaskedDynamic2.prototype), "nearestInputPos", this)).call.apply(_get4, [this].concat(args));
    }
  }, {
    key: "overwrite",
    get: function get() {
      return this.currentMask ? this.currentMask.overwrite : _get(_getPrototypeOf(MaskedDynamic2.prototype), "overwrite", this);
    },
    set: function set2(overwrite) {
      console.warn('"overwrite" option is not available in dynamic mask, use this option in siblings');
    }
  }, {
    key: "eager",
    get: function get() {
      return this.currentMask ? this.currentMask.eager : _get(_getPrototypeOf(MaskedDynamic2.prototype), "eager", this);
    },
    set: function set2(eager) {
      console.warn('"eager" option is not available in dynamic mask, use this option in siblings');
    }
  }, {
    key: "maskEquals",
    value: function maskEquals(mask) {
      return Array.isArray(mask) && this.compiledMasks.every(function(m, mi) {
        var _mask$mi;
        return m.maskEquals((_mask$mi = mask[mi]) === null || _mask$mi === void 0 ? void 0 : _mask$mi.mask);
      });
    }
  }]);
  return MaskedDynamic2;
}(Masked);
MaskedDynamic.DEFAULTS = {
  dispatch: function dispatch(appended, masked, flags) {
    if (!masked.compiledMasks.length)
      return;
    var inputValue = masked.rawInputValue;
    var inputs = masked.compiledMasks.map(function(m, index2) {
      m.reset();
      m.append(inputValue, {
        raw: true
      });
      m.append(appended, flags);
      var weight = m.rawInputValue.length;
      return {
        weight,
        index: index2
      };
    });
    inputs.sort(function(i1, i2) {
      return i2.weight - i1.weight;
    });
    return masked.compiledMasks[inputs[0].index];
  }
};
IMask.MaskedDynamic = MaskedDynamic;

// node_modules/imask/esm/masked/pipe.js
var PIPE_TYPE = {
  MASKED: "value",
  UNMASKED: "unmaskedValue",
  TYPED: "typedValue"
};
function createPipe(mask) {
  var from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : PIPE_TYPE.MASKED;
  var to = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : PIPE_TYPE.MASKED;
  var masked = createMask(mask);
  return function(value) {
    return masked.runIsolated(function(m) {
      m[from] = value;
      return m[to];
    });
  };
}
function pipe(value) {
  for (var _len = arguments.length, pipeArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    pipeArgs[_key - 1] = arguments[_key];
  }
  return createPipe.apply(void 0, pipeArgs)(value);
}
IMask.PIPE_TYPE = PIPE_TYPE;
IMask.createPipe = createPipe;
IMask.pipe = pipe;

// node_modules/imask/esm/index.js
try {
  globalThis.IMask = IMask;
} catch (e) {
}

// packages/forms/resources/js/components/text-input.js
var text_input_default = (Alpine) => {
  Alpine.data("textInputFormComponent", ({
    getMaskOptionsUsing,
    state: state2
  }) => {
    return {
      mask: null,
      state: state2,
      init: function() {
        if (!getMaskOptionsUsing) {
          return;
        }
        if (this.state) {
          this.$el.value = this.state?.valueOf();
        }
        this.mask = IMask(this.$el, getMaskOptionsUsing(IMask)).on("accept", () => {
          this.state = this.mask.unmaskedValue;
        });
        this.$watch("state", () => {
          this.mask.unmaskedValue = this.state?.valueOf() ?? "";
        });
      }
    };
  });
};

// packages/forms/resources/js/components/textarea.js
var textarea_default = (Alpine) => {
  Alpine.data("textareaFormComponent", () => ({
    init: function() {
      this.$nextTick(() => {
        this.render();
      });
    },
    render: function() {
      if (this.$el.scrollHeight > 0) {
        this.$el.style.height = "150px";
        this.$el.style.height = this.$el.scrollHeight + 2 + "px";
      }
    }
  }));
};

// node_modules/sortablejs/modular/sortable.esm.js
/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on2(el, event, fn2) {
  el.addEventListener(event, fn2, !IE11OrLess && captureMode);
}
function off(el, event, fn2) {
  el.removeEventListener(event, fn2, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name2, state2) {
  if (el && name2) {
    if (el.classList) {
      el.classList[state2 ? "add" : "remove"](name2);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
      el.className = (className + (state2 ? " " + name2 : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find2(ctx, tagName, iterator) {
  if (ctx) {
    var list2 = ctx.getElementsByTagName(tagName), i = 0, n = list2.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list2[i], i);
      }
    }
    return list2;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state2) {
      animationStates.push(state2);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state2) {
        var time = 0, target = state2.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state2.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults2 = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin9) {
    for (var option3 in defaults2) {
      if (defaults2.hasOwnProperty(option3) && !(option3 in plugin9)) {
        plugin9[option3] = defaults2[option3];
      }
    }
    plugins.forEach(function(p) {
      if (p.pluginName === plugin9.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin9.pluginName, " more than once");
      }
    });
    plugins.push(plugin9);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin9) {
      if (!sortable[plugin9.pluginName])
        return;
      if (sortable[plugin9.pluginName][eventNameGlobal]) {
        sortable[plugin9.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin9.pluginName] && sortable[plugin9.pluginName][eventName]) {
        sortable[plugin9.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults3, options) {
    plugins.forEach(function(plugin9) {
      var pluginName = plugin9.pluginName;
      if (!sortable.options[pluginName] && !plugin9.initializeByDefault)
        return;
      var initialized = new plugin9(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults3, initialized.defaults);
    });
    for (var option3 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option3))
        continue;
      var modified = this.modifyOption(sortable, option3, sortable.options[option3]);
      if (typeof modified !== "undefined") {
        sortable.options[option3] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name2, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin9) {
      if (typeof plugin9.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin9.eventProperties.call(sortable[plugin9.pluginName], name2));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name2, value) {
    var modifiedValue;
    plugins.forEach(function(plugin9) {
      if (!sortable[plugin9.pluginName])
        return;
      if (plugin9.optionListeners && typeof plugin9.optionListeners[name2] === "function") {
        modifiedValue = plugin9.optionListeners[name2].call(sortable[plugin9.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name2, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name2, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
  for (var option3 in allEventProperties) {
    evt[option3] = allEventProperties[option3];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded6 = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data3 = _objectWithoutProperties2(_ref, _excluded6);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name2) {
      _dispatchEvent({
        sortable,
        name: name2,
        originalEvent
      });
    }
  }, data3));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}();
var _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof2(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults3 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults3);
  for (var name2 in defaults3) {
    !(name2 in options) && (options[name2] = defaults3[name2]);
  }
  _prepareGroup(options);
  for (var fn2 in this) {
    if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
      this[fn2] = this[fn2].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on2(el, "pointerdown", this._onTapStart);
  } else {
    on2(el, "mousedown", this._onTapStart);
    on2(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on2(el, "dragover", this);
    on2(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find2(dragEl, criteria.trim(), _disableDraggable);
      });
      on2(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on2(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on2(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on2(ownerDocument, "mouseup", _this._onDrop);
      on2(ownerDocument, "touchend", _this._onDrop);
      on2(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on2(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on2(ownerDocument, "touchend", _this._disableDelayedDrag);
        on2(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on2(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on2(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on2(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on2(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on2(document, "touchmove", this._onTouchMove);
      } else {
        on2(document, "mousemove", this._onTouchMove);
      }
    } else {
      on2(dragEl, "dragend", this);
      on2(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on2(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on2(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on2(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name2, extra) {
      pluginEvent2(name2, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray2() {
    var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  option: function option2(name2, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name2];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name2, value);
      if (typeof modifiedValue !== "undefined") {
        options[name2] = modifiedValue;
      } else {
        options[name2] = value;
      }
      if (name2 === "group") {
        _prepareGroup(options);
      }
    }
  },
  destroy: function destroy2() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs = root2.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn2) {
  return setTimeout(fn2, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on2(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on: on2,
  off,
  css,
  find: find2,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin9) {
    if (!plugin9.prototype || !plugin9.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin9));
    }
    if (plugin9.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin9.utils);
    PluginManager.mount(plugin9);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on2(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on2(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on2(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on2(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop4() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop2 = function drop3(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop: drop2
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop: drop2
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var sortable_esm_default = Sortable;

// packages/forms/resources/js/sortable.js
window.Livewire.directive("sortable", (el) => {
  el.sortable = sortable_esm_default.create(el, {
    draggable: "[wire\\:sortable\\.item]",
    handle: "[wire\\:sortable\\.handle]",
    dataIdAttr: "wire:sortable.item"
  });
});

// packages/forms/resources/js/index.js
var js_default = (Alpine) => {
  Alpine.plugin(color_picker_default2);
  Alpine.plugin(date_time_picker_default);
  Alpine.plugin(file_upload_default);
  Alpine.plugin(key_value_default);
  Alpine.plugin(markdown_editor_default);
  Alpine.plugin(rich_editor_default);
  Alpine.plugin(select_default);
  Alpine.plugin(tags_input_default);
  Alpine.plugin(text_input_default);
  Alpine.plugin(textarea_default);
};
export {
  color_picker_default2 as ColorPickerFormComponentAlpinePlugin,
  date_time_picker_default as DateTimePickerFormComponentAlpinePlugin,
  file_upload_default as FileUploadFormComponentAlpinePlugin,
  key_value_default as KeyValueFormComponentAlpinePlugin,
  markdown_editor_default as MarkdownEditorFormComponentAlpinePlugin,
  rich_editor_default as RichEditorFormComponentAlpinePlugin,
  select_default as SelectFormComponentAlpinePlugin,
  tags_input_default as TagsInputFormComponentAlpinePlugin,
  text_input_default as TextInputFormComponentAlpinePlugin,
  textarea_default as TextareaFormComponentAlpinePlugin,
  js_default as default
};
