{"version":3,"sources":["webpack:///./node_modules/alpinejs/dist/alpine.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getWindow.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js","webpack:///./node_modules/@popperjs/core/lib/enums.js","webpack:///./node_modules/@popperjs/core/lib/utils/orderModifiers.js","webpack:///./node_modules/@popperjs/core/lib/createPopper.js","webpack:///./node_modules/@popperjs/core/lib/utils/debounce.js","webpack:///./node_modules/@popperjs/core/lib/utils/mergeByName.js","webpack:///./node_modules/@popperjs/core/lib/modifiers/eventListeners.js","webpack:///./node_modules/@popperjs/core/lib/utils/getBasePlacement.js","webpack:///./node_modules/@popperjs/core/lib/utils/getVariation.js","webpack:///./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js","webpack:///./node_modules/@popperjs/core/lib/utils/computeOffsets.js","webpack:///./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js","webpack:///./node_modules/@popperjs/core/lib/modifiers/computeStyles.js","webpack:///./node_modules/@popperjs/core/lib/popper-lite.js","webpack:///./node_modules/@popperjs/core/lib/modifiers/applyStyles.js","webpack:///./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js","webpack:///./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/contains.js","webpack:///./node_modules/@popperjs/core/lib/utils/rectToClientRect.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js","webpack:///./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js","webpack:///./node_modules/@popperjs/core/lib/utils/detectOverflow.js","webpack:///./node_modules/@popperjs/core/lib/utils/expandToHashMap.js","webpack:///./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js","webpack:///./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js","webpack:///./node_modules/@popperjs/core/lib/modifiers/flip.js","webpack:///./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js","webpack:///./node_modules/@popperjs/core/lib/utils/within.js","webpack:///./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js","webpack:///./node_modules/@popperjs/core/lib/utils/getAltAxis.js","webpack:///./resources/js/filament.js","webpack:///./node_modules/focus-visible/dist/focus-visible.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/jsonp chunk loading","webpack:///webpack/startup"],"names":["module","exports","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","domReady","Promise","resolve","document","readyState","addEventListener","arrayUnique","array","Array","from","Set","isTesting","navigator","userAgent","includes","checkedAttrLooseCompare","valueA","valueB","warnIfMalformedTemplate","el","directive","tagName","toLowerCase","console","warn","content","childElementCount","kebabCase","subject","replace","camelCase","match","char","toUpperCase","walk","callback","node","firstElementChild","nextElementSibling","debounce","func","wait","timeout","context","this","args","later","clearTimeout","setTimeout","handleError","expression","error","tryCatch","cb","catch","e","saferEval","dataContext","additionalHelperVariables","call","Function","values","saferEvalNoReturn","AsyncFunction","getPrototypeOf","async","constructor","methodReference","xAttrRE","isXAttr","attr","name","replaceAtAndColonWithStandardSyntax","test","getXAttrs","component","type","directives","attributes","map","parseHtmlAttribute","spreadDirective","spreadObject","$data","concat","entries","sortDirectives","directiveOrder","sort","a","b","typeA","indexOf","typeB","normalizedName","typeMatch","valueMatch","modifiers","isBooleanAttr","attrName","startsWith","convertClassStringToArray","classList","filterFn","Boolean","split","TRANSITION_TYPE_IN","TRANSITION_TYPE_OUT","TRANSITION_CANCELLED","transitionIn","show","reject","forceSkip","__x_transition","attrs","showAttr","settingBothSidesOfTransition","index","transitionHelperIn","some","transitionClassesIn","transitionOut","hide","transitionHelperOut","transitionClassesOut","showCallback","transitionHelper","duration","modifierValue","origin","first","opacity","scale","second","hideCallback","fallback","rawValue","isNumeric","join","hook1","hook2","styleValues","cancel","opacityCache","style","transformCache","transform","transformOriginCache","transformOrigin","noModifiers","transitionOpacity","transitionScale","stages","transitionProperty","trim","transitionDuration","transitionTimingFunction","transition","ensureStringExpression","evaluateReturnExpression","transitionClasses","find","classesDuring","classesStart","classesEnd","originalClasses","__x_original_classes","add","remove","finish","once","isConnected","cleanup","nextFrame","start","during","requestAnimationFrame","Number","getComputedStyle","animationDuration","end","isArray","isNaN","called","handleForDirective","templateEl","initialUpdate","extraVars","iteratorNames","parseForExpression","items","evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement","currentEl","item","iterationScopeVariables","getIterationScopeVariables","currentKey","generateKeyForIteration","nextEl","lookAheadForMatchingKeyedElementAndMoveItIfFound","__x_for_key","__x_for","updateElements","addElementInLoopAfterCurrentEl","initializeElements","removeAnyLeftOverElementsFromPreviousUpdate","forIteratorRE","stripParensRE","forAliasRE","inMatch","res","iteratorMatch","collection","scopeVariables","bindKeyAttribute","ifAttribute","clone","importNode","parentElement","insertBefore","undefined","tmpNextEl","nextElementFromOldLoop","nextElementFromOldLoopImmutable","nextSibling","handleAttributeBindingDirective","attrType","Alpine","ignoreFocusedForValueBinding","activeElement","isSameNode","checked","val","String","updateSelect","setAttribute","classNames","className","newClasses","removeAttribute","setIfChanged","getAttribute","arrayWrappedValue","options","option","selected","text","handleTextDirective","output","textContent","handleHtmlDirective","innerHTML","handleShowDirective","display","__x_is_shown","removeProperty","handle","showDirectiveLastElement","contains","executeAndClearRemainingShowDirectiveStack","showDirectiveStack","handleIfDirective","expressionResult","elementHasAlreadyBeenAdded","__x_inserted_me","registerListener","event","passive","handler","offsetWidth","offsetHeight","runListenerHandler","removeEventListener","listenerTarget","window","body","isKeyEvent","isListeningForASpecificKeyThatHasntBeenPressed","preventDefault","stopPropagation","then","nextModifier","evaluateCommandExpression","keyModifiers","debounceIndex","splice","keyToModifier","selectedSystemKeyModifiers","modifier","registerModelListener","rightSideOfExpression","generateModelAssignmentFunction","hasAttribute","currentValue","CustomEvent","detail","newValue","safeParseNumber","multiple","selectedOptions","number","parseFloat","create","ObjectCreate","ObjectDefineProperty","ObjectDefineProperties","isExtensible","getOwnPropertyNames","preventExtensions","hasOwnProperty","ArrayPush","ArrayConcat","ArrayMap","prototype","isUndefined","isFunction","isObject","proxyToValueMap","WeakMap","registerProxy","proxy","set","unwrap","replicaOrAny","get","wrapValue","membrane","valueIsObservable","getProxy","unwrapDescriptor","descriptor","lockShadowTarget","shadowTarget","originalTarget","wrapDescriptor","ReactiveProxyHandler","valueObserved","valueMutated","thisArg","argArray","newTarget","shadowIsExtensible","targetIsExtensible","desc","shadowDescriptor","originalDescriptor","wrapReadOnlyValue","getReadOnlyProxy","ReadOnlyHandler","createShadowTarget","ObjectDotPrototype","defaultValueIsObservable","proto","defaultValueObserved","defaultValueMutated","defaultValueDistortion","getValue","unwrapProxy","ReactiveMembrane","valueDistortion","objectGraph","unwrappedValue","distorted","o","getReactiveState","readOnly","reactive","p","distortedValue","reactiveState","reactiveHandler","Proxy","readOnlyHandler","wrap","data","mutationCallback","unwrap$1","observable","unwrappedData","copy","Component","componentForClone","$el","dataAttr","dataExpression","initExpression","dataExtras","canonicalComponentElementReference","magicProperties","unobservedData","getUnobservedData","wrapDataInObservable","initReturnedCallback","$refs","getRefsProxy","nextTickStack","$nextTick","watchers","$watch","property","onBeforeComponentInitializeds","pauseReactivity","listenForNewElementsToInitialize","onComponentInitializeds","self","updateDom","fullDotNotationKey","dotNotationParts","reduce","comparisonData","part","is","initializeComponentCallback","__x","rootEl","walkAndSkipNestedComponents","initializeElement","executeAndClearNextTickStack","registerListeners","resolveBoundAttributes","updateElement","shift","reverse","promiseChain","promise","finishElement","$dispatch","getDispatchFunction","dispatchEvent","bubbles","targetNode","observerOptions","childList","subtree","MutationObserver","mutations","closestParentComponent","closest","attributeName","xAttr","rawData","addedNodes","nodeType","matches","observe","ref","version","pauseMutationObserver","discoverComponents","initializeComponent","discoverUninitializedComponents","listenForNewUninitializedComponentsAtRunTime","querySelectorAll","rootEls","querySelector","newEl","addMagicProperty","onComponentInitialized","onBeforeComponentInitialized","deferLoadingAlpine","factory","getBoundingClientRect","element","rect","width","height","top","right","bottom","left","x","y","getWindow","toString","ownerDocument","defaultView","getWindowScroll","win","scrollLeft","pageXOffset","scrollTop","pageYOffset","isElement","Element","isHTMLElement","HTMLElement","getNodeName","nodeName","getDocumentElement","documentElement","getWindowScrollBarX","isScrollParent","_getComputedStyle","overflow","overflowX","overflowY","getCompositeRect","elementOrVirtualElement","offsetParent","isFixed","isOffsetParentAnElement","scroll","offsets","clientLeft","clientTop","getLayoutRect","offsetLeft","offsetTop","getParentNode","assignedSlot","parentNode","host","getScrollParent","listScrollParents","list","scrollParent","isBody","visualViewport","updatedList","isTableElement","getTrueOffsetParent","position","html","getOffsetParent","currentNode","css","perspective","willChange","getContainingBlock","auto","basePlacements","viewport","popper","variationPlacements","acc","placement","modifierPhases","order","Map","visited","result","requires","requiresIfExists","dep","has","depModifier","DEFAULT_OPTIONS","strategy","areValidElements","_len","_key","popperGenerator","generatorOptions","_generatorOptions","_generatorOptions$def","defaultModifiers","_generatorOptions$def2","defaultOptions","reference","fn","pending","state","orderedModifiers","assign","modifiersData","elements","styles","effectCleanupFns","isDestroyed","instance","setOptions","cleanupModifierEffects","scrollParents","contextElement","phase","orderModifiers","merged","current","existing","mergeByName","m","enabled","_ref3","_ref3$options","effect","cleanupFn","noopFn","update","forceUpdate","_state$elements","rects","reset","_state$orderedModifie","_state$orderedModifie2","_options","destroy","onFirstUpdate","_ref","_options$scroll","_options$resize","resize","getBasePlacement","getVariation","getMainAxisFromPlacement","computeOffsets","basePlacement","variation","commonX","commonY","mainAxis","len","round","Math","unsetSides","mapToStyles","_ref2","_Object$assign2","popperRect","gpuAcceleration","adaptive","roundOffsets","dpr","devicePixelRatio","roundOffsetsByDPR","_ref3$x","_ref3$y","hasX","hasY","sideX","sideY","clientHeight","clientWidth","_Object$assign","commonStyles","eventListeners","_ref4","_options$gpuAccelerat","_options$adaptive","_options$roundOffsets","popperOffsets","arrow","initialStyles","margin","attribute","hash","getOppositePlacement","matched","getOppositeVariationPlacement","parent","child","rootNode","getRootNode","ShadowRoot","next","rectToClientRect","getClientRectFromMixedType","clippingParent","getViewportRect","getInnerBoundingClientRect","winScroll","max","scrollWidth","scrollHeight","direction","getDocumentRect","getClippingRect","boundary","rootBoundary","mainClippingParents","clippingParents","clipperElement","getClippingParents","firstClippingParent","clippingRect","accRect","min","detectOverflow","_options$placement","_options$boundary","_options$rootBoundary","_options$elementConte","elementContext","_options$altBoundary","altBoundary","_options$padding","padding","paddingObject","mergePaddingObject","hashMap","altContext","referenceElement","clippingClientRect","referenceClientRect","popperClientRect","elementClientRect","overflowOffsets","offsetData","offset","multiply","axis","_skip","_options$mainAxis","checkMainAxis","_options$altAxis","altAxis","checkAltAxis","specifiedFallbackPlacements","fallbackPlacements","_options$flipVariatio","flipVariations","allowedAutoPlacements","preferredPlacement","oppositePlacement","getExpandedFallbackPlacements","placements","_options$allowedAutoP","allowedPlacements","overflows","computeAutoPlacement","referenceRect","checksMap","makeFallbackChecks","firstFittingPlacement","_basePlacement","isStartVariation","isVertical","mainVariationSide","altVariationSide","checks","every","check","_loop","_i","fittingPlacement","slice","within","_options$tether","tether","_options$tetherOffset","tetherOffset","isBasePlacement","tetherOffsetValue","mainSide","altSide","additive","minLen","maxLen","arrowElement","arrowRect","arrowPaddingObject","arrowPaddingMin","arrowPaddingMax","arrowLen","minOffset","maxOffset","arrowOffsetParent","clientOffset","offsetModifierValue","tetherMin","tetherMax","preventedOffset","_mainSide","_altSide","_offset","_preventedOffset","createPopper","flip","preventOverflow","applyFocusVisiblePolyfill","scope","hadKeyboardEvent","hadFocusVisibleRecently","hadFocusVisibleRecentlyTimeout","inputTypesAllowlist","search","url","tel","email","password","date","month","week","time","datetime","isValidFocusTarget","focusTriggersKeyboardModality","isContentEditable","addFocusVisibleClass","removeFocusVisibleClass","onKeyDown","metaKey","altKey","ctrlKey","onPointerDown","onFocus","onBlur","onVisibilityChange","visibilityState","addInitialPointerMoveListeners","onInitialPointerMove","removeInitialPointerMoveListeners","Node","DOCUMENT_FRAGMENT_NODE","DOCUMENT_NODE","createEvent","initCustomEvent","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","prop","installedChunks","731","deferredModules","checkDeferredModules","webpackJsonpCallback","parentChunkLoadingFunction","chunkId","chunkIds","moreModules","runtime","executeModules","resolves","chunkLoadingGlobal","checkDeferredModulesImpl","deferredModule","fulfilled","j","depId","s","bind","startup"],"mappings":"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","file":"/js/filament.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.Alpine = factory());\n}(this, (function () { 'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  // Thanks @stimulus:\n  // https://github.com/stimulusjs/stimulus/blob/master/packages/%40stimulus/core/src/application.ts\n  function domReady() {\n    return new Promise(resolve => {\n      if (document.readyState == \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n  function arrayUnique(array) {\n    return Array.from(new Set(array));\n  }\n  function isTesting() {\n    return navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\");\n  }\n  function checkedAttrLooseCompare(valueA, valueB) {\n    return valueA == valueB;\n  }\n  function warnIfMalformedTemplate(el, directive) {\n    if (el.tagName.toLowerCase() !== 'template') {\n      console.warn(`Alpine: [${directive}] directive should only be added to <template> tags. See https://github.com/alpinejs/alpine#${directive}`);\n    } else if (el.content.childElementCount !== 1) {\n      console.warn(`Alpine: <template> tag with [${directive}] encountered with multiple element roots. Make sure <template> only has a single child element.`);\n    }\n  }\n  function kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\\s]/, '-').toLowerCase();\n  }\n  function camelCase(subject) {\n    return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n  }\n  function walk(el, callback) {\n    if (callback(el) === false) return;\n    let node = el.firstElementChild;\n\n    while (node) {\n      walk(node, callback);\n      node = node.nextElementSibling;\n    }\n  }\n  function debounce(func, wait) {\n    var timeout;\n    return function () {\n      var context = this,\n          args = arguments;\n\n      var later = function later() {\n        timeout = null;\n        func.apply(context, args);\n      };\n\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  }\n\n  const handleError = (el, expression, error) => {\n    console.warn(`Alpine Error: \"${error}\"\\n\\nExpression: \"${expression}\"\\nElement:`, el);\n\n    if (!isTesting()) {\n      throw error;\n    }\n  };\n\n  function tryCatch(cb, {\n    el,\n    expression\n  }) {\n    try {\n      const value = cb();\n      return value instanceof Promise ? value.catch(e => handleError(el, expression, e)) : value;\n    } catch (e) {\n      handleError(el, expression, e);\n    }\n  }\n\n  function saferEval(el, expression, dataContext, additionalHelperVariables = {}) {\n    return tryCatch(() => {\n      if (typeof expression === 'function') {\n        return expression.call(dataContext);\n      }\n\n      return new Function(['$data', ...Object.keys(additionalHelperVariables)], `var __alpine_result; with($data) { __alpine_result = ${expression} }; return __alpine_result`)(dataContext, ...Object.values(additionalHelperVariables));\n    }, {\n      el,\n      expression\n    });\n  }\n  function saferEvalNoReturn(el, expression, dataContext, additionalHelperVariables = {}) {\n    return tryCatch(() => {\n      if (typeof expression === 'function') {\n        return Promise.resolve(expression.call(dataContext, additionalHelperVariables['$event']));\n      }\n\n      let AsyncFunction = Function;\n      /* MODERN-ONLY:START */\n\n      AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\n      /* MODERN-ONLY:END */\n      // For the cases when users pass only a function reference to the caller: `x-on:click=\"foo\"`\n      // Where \"foo\" is a function. Also, we'll pass the function the event instance when we call it.\n\n      if (Object.keys(dataContext).includes(expression)) {\n        let methodReference = new Function(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { return ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables));\n\n        if (typeof methodReference === 'function') {\n          return Promise.resolve(methodReference.call(dataContext, additionalHelperVariables['$event']));\n        } else {\n          return Promise.resolve();\n        }\n      }\n\n      return Promise.resolve(new AsyncFunction(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables)));\n    }, {\n      el,\n      expression\n    });\n  }\n  const xAttrRE = /^x-(on|bind|data|text|html|model|if|for|show|cloak|transition|ref|spread)\\b/;\n  function isXAttr(attr) {\n    const name = replaceAtAndColonWithStandardSyntax(attr.name);\n    return xAttrRE.test(name);\n  }\n  function getXAttrs(el, component, type) {\n    let directives = Array.from(el.attributes).filter(isXAttr).map(parseHtmlAttribute); // Get an object of directives from x-spread.\n\n    let spreadDirective = directives.filter(directive => directive.type === 'spread')[0];\n\n    if (spreadDirective) {\n      let spreadObject = saferEval(el, spreadDirective.expression, component.$data); // Add x-spread directives to the pile of existing directives.\n\n      directives = directives.concat(Object.entries(spreadObject).map(([name, value]) => parseHtmlAttribute({\n        name,\n        value\n      })));\n    }\n\n    if (type) return directives.filter(i => i.type === type);\n    return sortDirectives(directives);\n  }\n\n  function sortDirectives(directives) {\n    let directiveOrder = ['bind', 'model', 'show', 'catch-all'];\n    return directives.sort((a, b) => {\n      let typeA = directiveOrder.indexOf(a.type) === -1 ? 'catch-all' : a.type;\n      let typeB = directiveOrder.indexOf(b.type) === -1 ? 'catch-all' : b.type;\n      return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n    });\n  }\n\n  function parseHtmlAttribute({\n    name,\n    value\n  }) {\n    const normalizedName = replaceAtAndColonWithStandardSyntax(name);\n    const typeMatch = normalizedName.match(xAttrRE);\n    const valueMatch = normalizedName.match(/:([a-zA-Z0-9\\-:]+)/);\n    const modifiers = normalizedName.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map(i => i.replace('.', '')),\n      expression: value\n    };\n  }\n  function isBooleanAttr(attrName) {\n    // As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute\n    // Array roughly ordered by estimated usage\n    const booleanAttributes = ['disabled', 'checked', 'required', 'readonly', 'hidden', 'open', 'selected', 'autofocus', 'itemscope', 'multiple', 'novalidate', 'allowfullscreen', 'allowpaymentrequest', 'formnovalidate', 'autoplay', 'controls', 'loop', 'muted', 'playsinline', 'default', 'ismap', 'reversed', 'async', 'defer', 'nomodule'];\n    return booleanAttributes.includes(attrName);\n  }\n  function replaceAtAndColonWithStandardSyntax(name) {\n    if (name.startsWith('@')) {\n      return name.replace('@', 'x-on:');\n    } else if (name.startsWith(':')) {\n      return name.replace(':', 'x-bind:');\n    }\n\n    return name;\n  }\n  function convertClassStringToArray(classList, filterFn = Boolean) {\n    return classList.split(' ').filter(filterFn);\n  }\n  const TRANSITION_TYPE_IN = 'in';\n  const TRANSITION_TYPE_OUT = 'out';\n  const TRANSITION_CANCELLED = 'cancelled';\n  function transitionIn(el, show, reject, component, forceSkip = false) {\n    // We don't want to transition on the initial page load.\n    if (forceSkip) return show();\n\n    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_IN) {\n      // there is already a similar transition going on, this was probably triggered by\n      // a change in a different property, let's just leave the previous one doing its job\n      return;\n    }\n\n    const attrs = getXAttrs(el, component, 'transition');\n    const showAttr = getXAttrs(el, component, 'show')[0]; // If this is triggered by a x-show.transition.\n\n    if (showAttr && showAttr.modifiers.includes('transition')) {\n      let modifiers = showAttr.modifiers; // If x-show.transition.out, we'll skip the \"in\" transition.\n\n      if (modifiers.includes('out') && !modifiers.includes('in')) return show();\n      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out'); // If x-show.transition.in...out... only use \"in\" related modifiers for this transition.\n\n      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index < modifiers.indexOf('out')) : modifiers;\n      transitionHelperIn(el, modifiers, show, reject); // Otherwise, we can assume x-transition:enter.\n    } else if (attrs.some(attr => ['enter', 'enter-start', 'enter-end'].includes(attr.value))) {\n      transitionClassesIn(el, component, attrs, show, reject);\n    } else {\n      // If neither, just show that damn thing.\n      show();\n    }\n  }\n  function transitionOut(el, hide, reject, component, forceSkip = false) {\n    // We don't want to transition on the initial page load.\n    if (forceSkip) return hide();\n\n    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_OUT) {\n      // there is already a similar transition going on, this was probably triggered by\n      // a change in a different property, let's just leave the previous one doing its job\n      return;\n    }\n\n    const attrs = getXAttrs(el, component, 'transition');\n    const showAttr = getXAttrs(el, component, 'show')[0];\n\n    if (showAttr && showAttr.modifiers.includes('transition')) {\n      let modifiers = showAttr.modifiers;\n      if (modifiers.includes('in') && !modifiers.includes('out')) return hide();\n      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out');\n      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index > modifiers.indexOf('out')) : modifiers;\n      transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hide, reject);\n    } else if (attrs.some(attr => ['leave', 'leave-start', 'leave-end'].includes(attr.value))) {\n      transitionClassesOut(el, component, attrs, hide, reject);\n    } else {\n      hide();\n    }\n  }\n  function transitionHelperIn(el, modifiers, showCallback, reject) {\n    // Default values inspired by: https://material.io/design/motion/speed.html#duration\n    const styleValues = {\n      duration: modifierValue(modifiers, 'duration', 150),\n      origin: modifierValue(modifiers, 'origin', 'center'),\n      first: {\n        opacity: 0,\n        scale: modifierValue(modifiers, 'scale', 95)\n      },\n      second: {\n        opacity: 1,\n        scale: 100\n      }\n    };\n    transitionHelper(el, modifiers, showCallback, () => {}, reject, styleValues, TRANSITION_TYPE_IN);\n  }\n  function transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hideCallback, reject) {\n    // Make the \"out\" transition .5x slower than the \"in\". (Visually better)\n    // HOWEVER, if they explicitly set a duration for the \"out\" transition,\n    // use that.\n    const duration = settingBothSidesOfTransition ? modifierValue(modifiers, 'duration', 150) : modifierValue(modifiers, 'duration', 150) / 2;\n    const styleValues = {\n      duration: duration,\n      origin: modifierValue(modifiers, 'origin', 'center'),\n      first: {\n        opacity: 1,\n        scale: 100\n      },\n      second: {\n        opacity: 0,\n        scale: modifierValue(modifiers, 'scale', 95)\n      }\n    };\n    transitionHelper(el, modifiers, () => {}, hideCallback, reject, styleValues, TRANSITION_TYPE_OUT);\n  }\n\n  function modifierValue(modifiers, key, fallback) {\n    // If the modifier isn't present, use the default.\n    if (modifiers.indexOf(key) === -1) return fallback; // If it IS present, grab the value after it: x-show.transition.duration.500ms\n\n    const rawValue = modifiers[modifiers.indexOf(key) + 1];\n    if (!rawValue) return fallback;\n\n    if (key === 'scale') {\n      // Check if the very next value is NOT a number and return the fallback.\n      // If x-show.transition.scale, we'll use the default scale value.\n      // That is how a user opts out of the opacity transition.\n      if (!isNumeric(rawValue)) return fallback;\n    }\n\n    if (key === 'duration') {\n      // Support x-show.transition.duration.500ms && duration.500\n      let match = rawValue.match(/([0-9]+)ms/);\n      if (match) return match[1];\n    }\n\n    if (key === 'origin') {\n      // Support chaining origin directions: x-show.transition.top.right\n      if (['top', 'right', 'left', 'center', 'bottom'].includes(modifiers[modifiers.indexOf(key) + 2])) {\n        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(' ');\n      }\n    }\n\n    return rawValue;\n  }\n\n  function transitionHelper(el, modifiers, hook1, hook2, reject, styleValues, type) {\n    // clear the previous transition if exists to avoid caching the wrong styles\n    if (el.__x_transition) {\n      el.__x_transition.cancel && el.__x_transition.cancel();\n    } // If the user set these style values, we'll put them back when we're done with them.\n\n\n    const opacityCache = el.style.opacity;\n    const transformCache = el.style.transform;\n    const transformOriginCache = el.style.transformOrigin; // If no modifiers are present: x-show.transition, we'll default to both opacity and scale.\n\n    const noModifiers = !modifiers.includes('opacity') && !modifiers.includes('scale');\n    const transitionOpacity = noModifiers || modifiers.includes('opacity');\n    const transitionScale = noModifiers || modifiers.includes('scale'); // These are the explicit stages of a transition (same stages for in and for out).\n    // This way you can get a birds eye view of the hooks, and the differences\n    // between them.\n\n    const stages = {\n      start() {\n        if (transitionOpacity) el.style.opacity = styleValues.first.opacity;\n        if (transitionScale) el.style.transform = `scale(${styleValues.first.scale / 100})`;\n      },\n\n      during() {\n        if (transitionScale) el.style.transformOrigin = styleValues.origin;\n        el.style.transitionProperty = [transitionOpacity ? `opacity` : ``, transitionScale ? `transform` : ``].join(' ').trim();\n        el.style.transitionDuration = `${styleValues.duration / 1000}s`;\n        el.style.transitionTimingFunction = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n      },\n\n      show() {\n        hook1();\n      },\n\n      end() {\n        if (transitionOpacity) el.style.opacity = styleValues.second.opacity;\n        if (transitionScale) el.style.transform = `scale(${styleValues.second.scale / 100})`;\n      },\n\n      hide() {\n        hook2();\n      },\n\n      cleanup() {\n        if (transitionOpacity) el.style.opacity = opacityCache;\n        if (transitionScale) el.style.transform = transformCache;\n        if (transitionScale) el.style.transformOrigin = transformOriginCache;\n        el.style.transitionProperty = null;\n        el.style.transitionDuration = null;\n        el.style.transitionTimingFunction = null;\n      }\n\n    };\n    transition(el, stages, type, reject);\n  }\n\n  const ensureStringExpression = (expression, el, component) => {\n    return typeof expression === 'function' ? component.evaluateReturnExpression(el, expression) : expression;\n  };\n\n  function transitionClassesIn(el, component, directives, showCallback, reject) {\n    const enter = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter') || {\n      expression: ''\n    }).expression, el, component));\n    const enterStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-start') || {\n      expression: ''\n    }).expression, el, component));\n    const enterEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-end') || {\n      expression: ''\n    }).expression, el, component));\n    transitionClasses(el, enter, enterStart, enterEnd, showCallback, () => {}, TRANSITION_TYPE_IN, reject);\n  }\n  function transitionClassesOut(el, component, directives, hideCallback, reject) {\n    const leave = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave') || {\n      expression: ''\n    }).expression, el, component));\n    const leaveStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-start') || {\n      expression: ''\n    }).expression, el, component));\n    const leaveEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-end') || {\n      expression: ''\n    }).expression, el, component));\n    transitionClasses(el, leave, leaveStart, leaveEnd, () => {}, hideCallback, TRANSITION_TYPE_OUT, reject);\n  }\n  function transitionClasses(el, classesDuring, classesStart, classesEnd, hook1, hook2, type, reject) {\n    // clear the previous transition if exists to avoid caching the wrong classes\n    if (el.__x_transition) {\n      el.__x_transition.cancel && el.__x_transition.cancel();\n    }\n\n    const originalClasses = el.__x_original_classes || [];\n    const stages = {\n      start() {\n        el.classList.add(...classesStart);\n      },\n\n      during() {\n        el.classList.add(...classesDuring);\n      },\n\n      show() {\n        hook1();\n      },\n\n      end() {\n        // Don't remove classes that were in the original class attribute.\n        el.classList.remove(...classesStart.filter(i => !originalClasses.includes(i)));\n        el.classList.add(...classesEnd);\n      },\n\n      hide() {\n        hook2();\n      },\n\n      cleanup() {\n        el.classList.remove(...classesDuring.filter(i => !originalClasses.includes(i)));\n        el.classList.remove(...classesEnd.filter(i => !originalClasses.includes(i)));\n      }\n\n    };\n    transition(el, stages, type, reject);\n  }\n  function transition(el, stages, type, reject) {\n    const finish = once(() => {\n      stages.hide(); // Adding an \"isConnected\" check, in case the callback\n      // removed the element from the DOM.\n\n      if (el.isConnected) {\n        stages.cleanup();\n      }\n\n      delete el.__x_transition;\n    });\n    el.__x_transition = {\n      // Set transition type so we can avoid clearing transition if the direction is the same\n      type: type,\n      // create a callback for the last stages of the transition so we can call it\n      // from different point and early terminate it. Once will ensure that function\n      // is only called one time.\n      cancel: once(() => {\n        reject(TRANSITION_CANCELLED);\n        finish();\n      }),\n      finish,\n      // This store the next animation frame so we can cancel it\n      nextFrame: null\n    };\n    stages.start();\n    stages.during();\n    el.__x_transition.nextFrame = requestAnimationFrame(() => {\n      // Note: Safari's transitionDuration property will list out comma separated transition durations\n      // for every single transition property. Let's grab the first one and call it a day.\n      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000;\n\n      if (duration === 0) {\n        duration = Number(getComputedStyle(el).animationDuration.replace('s', '')) * 1000;\n      }\n\n      stages.show();\n      el.__x_transition.nextFrame = requestAnimationFrame(() => {\n        stages.end();\n        setTimeout(el.__x_transition.finish, duration);\n      });\n    });\n  }\n  function isNumeric(subject) {\n    return !Array.isArray(subject) && !isNaN(subject);\n  } // Thanks @vuejs\n  // https://github.com/vuejs/vue/blob/4de4649d9637262a9b007720b59f80ac72a5620c/src/shared/util.js\n\n  function once(callback) {\n    let called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        callback.apply(this, arguments);\n      }\n    };\n  }\n\n  function handleForDirective(component, templateEl, expression, initialUpdate, extraVars) {\n    warnIfMalformedTemplate(templateEl, 'x-for');\n    let iteratorNames = typeof expression === 'function' ? parseForExpression(component.evaluateReturnExpression(templateEl, expression)) : parseForExpression(expression);\n    let items = evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, templateEl, iteratorNames, extraVars); // As we walk the array, we'll also walk the DOM (updating/creating as we go).\n\n    let currentEl = templateEl;\n    items.forEach((item, index) => {\n      let iterationScopeVariables = getIterationScopeVariables(iteratorNames, item, index, items, extraVars());\n      let currentKey = generateKeyForIteration(component, templateEl, index, iterationScopeVariables);\n      let nextEl = lookAheadForMatchingKeyedElementAndMoveItIfFound(currentEl.nextElementSibling, currentKey); // If we haven't found a matching key, insert the element at the current position.\n\n      if (!nextEl) {\n        nextEl = addElementInLoopAfterCurrentEl(templateEl, currentEl); // And transition it in if it's not the first page load.\n\n        transitionIn(nextEl, () => {}, () => {}, component, initialUpdate);\n        nextEl.__x_for = iterationScopeVariables;\n        component.initializeElements(nextEl, () => nextEl.__x_for); // Otherwise update the element we found.\n      } else {\n        // Temporarily remove the key indicator to allow the normal \"updateElements\" to work.\n        delete nextEl.__x_for_key;\n        nextEl.__x_for = iterationScopeVariables;\n        component.updateElements(nextEl, () => nextEl.__x_for);\n      }\n\n      currentEl = nextEl;\n      currentEl.__x_for_key = currentKey;\n    });\n    removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component);\n  } // This was taken from VueJS 2.* core. Thanks Vue!\n\n  function parseForExpression(expression) {\n    let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n    let stripParensRE = /^\\(|\\)$/g;\n    let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n    let inMatch = expression.match(forAliasRE);\n    if (!inMatch) return;\n    let res = {};\n    res.items = inMatch[2].trim();\n    let item = inMatch[1].trim().replace(stripParensRE, '');\n    let iteratorMatch = item.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.item = item.replace(forIteratorRE, '').trim();\n      res.index = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.collection = iteratorMatch[2].trim();\n      }\n    } else {\n      res.item = item;\n    }\n\n    return res;\n  }\n\n  function getIterationScopeVariables(iteratorNames, item, index, items, extraVars) {\n    // We must create a new object, so each iteration has a new scope\n    let scopeVariables = extraVars ? _objectSpread2({}, extraVars) : {};\n    scopeVariables[iteratorNames.item] = item;\n    if (iteratorNames.index) scopeVariables[iteratorNames.index] = index;\n    if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items;\n    return scopeVariables;\n  }\n\n  function generateKeyForIteration(component, el, index, iterationScopeVariables) {\n    let bindKeyAttribute = getXAttrs(el, component, 'bind').filter(attr => attr.value === 'key')[0]; // If the dev hasn't specified a key, just return the index of the iteration.\n\n    if (!bindKeyAttribute) return index;\n    return component.evaluateReturnExpression(el, bindKeyAttribute.expression, () => iterationScopeVariables);\n  }\n\n  function evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, el, iteratorNames, extraVars) {\n    let ifAttribute = getXAttrs(el, component, 'if')[0];\n\n    if (ifAttribute && !component.evaluateReturnExpression(el, ifAttribute.expression)) {\n      return [];\n    }\n\n    let items = component.evaluateReturnExpression(el, iteratorNames.items, extraVars); // This adds support for the `i in n` syntax.\n\n    if (isNumeric(items) && items > 0) {\n      items = Array.from(Array(items).keys(), i => i + 1);\n    }\n\n    return items;\n  }\n\n  function addElementInLoopAfterCurrentEl(templateEl, currentEl) {\n    let clone = document.importNode(templateEl.content, true);\n    currentEl.parentElement.insertBefore(clone, currentEl.nextElementSibling);\n    return currentEl.nextElementSibling;\n  }\n\n  function lookAheadForMatchingKeyedElementAndMoveItIfFound(nextEl, currentKey) {\n    if (!nextEl) return; // If we are already past the x-for generated elements, we don't need to look ahead.\n\n    if (nextEl.__x_for_key === undefined) return; // If the the key's DO match, no need to look ahead.\n\n    if (nextEl.__x_for_key === currentKey) return nextEl; // If they don't, we'll look ahead for a match.\n    // If we find it, we'll move it to the current position in the loop.\n\n    let tmpNextEl = nextEl;\n\n    while (tmpNextEl) {\n      if (tmpNextEl.__x_for_key === currentKey) {\n        return tmpNextEl.parentElement.insertBefore(tmpNextEl, nextEl);\n      }\n\n      tmpNextEl = tmpNextEl.nextElementSibling && tmpNextEl.nextElementSibling.__x_for_key !== undefined ? tmpNextEl.nextElementSibling : false;\n    }\n  }\n\n  function removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component) {\n    var nextElementFromOldLoop = currentEl.nextElementSibling && currentEl.nextElementSibling.__x_for_key !== undefined ? currentEl.nextElementSibling : false;\n\n    while (nextElementFromOldLoop) {\n      let nextElementFromOldLoopImmutable = nextElementFromOldLoop;\n      let nextSibling = nextElementFromOldLoop.nextElementSibling;\n      transitionOut(nextElementFromOldLoop, () => {\n        nextElementFromOldLoopImmutable.remove();\n      }, () => {}, component);\n      nextElementFromOldLoop = nextSibling && nextSibling.__x_for_key !== undefined ? nextSibling : false;\n    }\n  }\n\n  function handleAttributeBindingDirective(component, el, attrName, expression, extraVars, attrType, modifiers) {\n    var value = component.evaluateReturnExpression(el, expression, extraVars);\n\n    if (attrName === 'value') {\n      if (Alpine.ignoreFocusedForValueBinding && document.activeElement.isSameNode(el)) return; // If nested model key is undefined, set the default value to empty string.\n\n      if (value === undefined && expression.match(/\\./)) {\n        value = '';\n      }\n\n      if (el.type === 'radio') {\n        // Set radio value from x-bind:value, if no \"value\" attribute exists.\n        // If there are any initial state values, radio will have a correct\n        // \"checked\" value since x-bind:value is processed before x-model.\n        if (el.attributes.value === undefined && attrType === 'bind') {\n          el.value = value;\n        } else if (attrType !== 'bind') {\n          el.checked = checkedAttrLooseCompare(el.value, value);\n        }\n      } else if (el.type === 'checkbox') {\n        // If we are explicitly binding a string to the :value, set the string,\n        // If the value is a boolean, leave it alone, it will be set to \"on\"\n        // automatically.\n        if (typeof value !== 'boolean' && ![null, undefined].includes(value) && attrType === 'bind') {\n          el.value = String(value);\n        } else if (attrType !== 'bind') {\n          if (Array.isArray(value)) {\n            // I'm purposely not using Array.includes here because it's\n            // strict, and because of Numeric/String mis-casting, I\n            // want the \"includes\" to be \"fuzzy\".\n            el.checked = value.some(val => checkedAttrLooseCompare(val, el.value));\n          } else {\n            el.checked = !!value;\n          }\n        }\n      } else if (el.tagName === 'SELECT') {\n        updateSelect(el, value);\n      } else {\n        if (el.value === value) return;\n        el.value = value;\n      }\n    } else if (attrName === 'class') {\n      if (Array.isArray(value)) {\n        const originalClasses = el.__x_original_classes || [];\n        el.setAttribute('class', arrayUnique(originalClasses.concat(value)).join(' '));\n      } else if (typeof value === 'object') {\n        // Sorting the keys / class names by their boolean value will ensure that\n        // anything that evaluates to `false` and needs to remove classes is run first.\n        const keysSortedByBooleanValue = Object.keys(value).sort((a, b) => value[a] - value[b]);\n        keysSortedByBooleanValue.forEach(classNames => {\n          if (value[classNames]) {\n            convertClassStringToArray(classNames).forEach(className => el.classList.add(className));\n          } else {\n            convertClassStringToArray(classNames).forEach(className => el.classList.remove(className));\n          }\n        });\n      } else {\n        const originalClasses = el.__x_original_classes || [];\n        const newClasses = value ? convertClassStringToArray(value) : [];\n        el.setAttribute('class', arrayUnique(originalClasses.concat(newClasses)).join(' '));\n      }\n    } else {\n      attrName = modifiers.includes('camel') ? camelCase(attrName) : attrName; // If an attribute's bound value is null, undefined or false, remove the attribute\n\n      if ([null, undefined, false].includes(value)) {\n        el.removeAttribute(attrName);\n      } else {\n        isBooleanAttr(attrName) ? setIfChanged(el, attrName, attrName) : setIfChanged(el, attrName, value);\n      }\n    }\n  }\n\n  function setIfChanged(el, attrName, value) {\n    if (el.getAttribute(attrName) != value) {\n      el.setAttribute(attrName, value);\n    }\n  }\n\n  function updateSelect(el, value) {\n    const arrayWrappedValue = [].concat(value).map(value => {\n      return value + '';\n    });\n    Array.from(el.options).forEach(option => {\n      option.selected = arrayWrappedValue.includes(option.value || option.text);\n    });\n  }\n\n  function handleTextDirective(el, output, expression) {\n    // If nested model key is undefined, set the default value to empty string.\n    if (output === undefined && expression.match(/\\./)) {\n      output = '';\n    }\n\n    el.textContent = output;\n  }\n\n  function handleHtmlDirective(component, el, expression, extraVars) {\n    el.innerHTML = component.evaluateReturnExpression(el, expression, extraVars);\n  }\n\n  function handleShowDirective(component, el, value, modifiers, initialUpdate = false) {\n    const hide = () => {\n      el.style.display = 'none';\n      el.__x_is_shown = false;\n    };\n\n    const show = () => {\n      if (el.style.length === 1 && el.style.display === 'none') {\n        el.removeAttribute('style');\n      } else {\n        el.style.removeProperty('display');\n      }\n\n      el.__x_is_shown = true;\n    };\n\n    if (initialUpdate === true) {\n      if (value) {\n        show();\n      } else {\n        hide();\n      }\n\n      return;\n    }\n\n    const handle = (resolve, reject) => {\n      if (value) {\n        if (el.style.display === 'none' || el.__x_transition) {\n          transitionIn(el, () => {\n            show();\n          }, reject, component);\n        }\n\n        resolve(() => {});\n      } else {\n        if (el.style.display !== 'none') {\n          transitionOut(el, () => {\n            resolve(() => {\n              hide();\n            });\n          }, reject, component);\n        } else {\n          resolve(() => {});\n        }\n      }\n    }; // The working of x-show is a bit complex because we need to\n    // wait for any child transitions to finish before hiding\n    // some element. Also, this has to be done recursively.\n    // If x-show.immediate, foregoe the waiting.\n\n\n    if (modifiers.includes('immediate')) {\n      handle(finish => finish(), () => {});\n      return;\n    } // x-show is encountered during a DOM tree walk. If an element\n    // we encounter is NOT a child of another x-show element we\n    // can execute the previous x-show stack (if one exists).\n\n\n    if (component.showDirectiveLastElement && !component.showDirectiveLastElement.contains(el)) {\n      component.executeAndClearRemainingShowDirectiveStack();\n    }\n\n    component.showDirectiveStack.push(handle);\n    component.showDirectiveLastElement = el;\n  }\n\n  function handleIfDirective(component, el, expressionResult, initialUpdate, extraVars) {\n    warnIfMalformedTemplate(el, 'x-if');\n    const elementHasAlreadyBeenAdded = el.nextElementSibling && el.nextElementSibling.__x_inserted_me === true;\n\n    if (expressionResult && (!elementHasAlreadyBeenAdded || el.__x_transition)) {\n      const clone = document.importNode(el.content, true);\n      el.parentElement.insertBefore(clone, el.nextElementSibling);\n      transitionIn(el.nextElementSibling, () => {}, () => {}, component, initialUpdate);\n      component.initializeElements(el.nextElementSibling, extraVars);\n      el.nextElementSibling.__x_inserted_me = true;\n    } else if (!expressionResult && elementHasAlreadyBeenAdded) {\n      transitionOut(el.nextElementSibling, () => {\n        el.nextElementSibling.remove();\n      }, () => {}, component, initialUpdate);\n    }\n  }\n\n  function registerListener(component, el, event, modifiers, expression, extraVars = {}) {\n    const options = {\n      passive: modifiers.includes('passive')\n    };\n\n    if (modifiers.includes('camel')) {\n      event = camelCase(event);\n    }\n\n    if (modifiers.includes('away')) {\n      let handler = e => {\n        // Don't do anything if the click came from the element or within it.\n        if (el.contains(e.target)) return; // Don't do anything if this element isn't currently visible.\n\n        if (el.offsetWidth < 1 && el.offsetHeight < 1) return; // Now that we are sure the element is visible, AND the click\n        // is from outside it, let's run the expression.\n\n        runListenerHandler(component, expression, e, extraVars);\n\n        if (modifiers.includes('once')) {\n          document.removeEventListener(event, handler, options);\n        }\n      }; // Listen for this event at the root level.\n\n\n      document.addEventListener(event, handler, options);\n    } else {\n      let listenerTarget = modifiers.includes('window') ? window : modifiers.includes('document') ? document : el;\n\n      let handler = e => {\n        // Remove this global event handler if the element that declared it\n        // has been removed. It's now stale.\n        if (listenerTarget === window || listenerTarget === document) {\n          if (!document.body.contains(el)) {\n            listenerTarget.removeEventListener(event, handler, options);\n            return;\n          }\n        }\n\n        if (isKeyEvent(event)) {\n          if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n            return;\n          }\n        }\n\n        if (modifiers.includes('prevent')) e.preventDefault();\n        if (modifiers.includes('stop')) e.stopPropagation(); // If the .self modifier isn't present, or if it is present and\n        // the target element matches the element we are registering the\n        // event on, run the handler\n\n        if (!modifiers.includes('self') || e.target === el) {\n          const returnValue = runListenerHandler(component, expression, e, extraVars);\n          returnValue.then(value => {\n            if (value === false) {\n              e.preventDefault();\n            } else {\n              if (modifiers.includes('once')) {\n                listenerTarget.removeEventListener(event, handler, options);\n              }\n            }\n          });\n        }\n      };\n\n      if (modifiers.includes('debounce')) {\n        let nextModifier = modifiers[modifiers.indexOf('debounce') + 1] || 'invalid-wait';\n        let wait = isNumeric(nextModifier.split('ms')[0]) ? Number(nextModifier.split('ms')[0]) : 250;\n        handler = debounce(handler, wait);\n      }\n\n      listenerTarget.addEventListener(event, handler, options);\n    }\n  }\n\n  function runListenerHandler(component, expression, e, extraVars) {\n    return component.evaluateCommandExpression(e.target, expression, () => {\n      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        '$event': e\n      });\n    });\n  }\n\n  function isKeyEvent(event) {\n    return ['keydown', 'keyup'].includes(event);\n  }\n\n  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n    let keyModifiers = modifiers.filter(i => {\n      return !['window', 'document', 'prevent', 'stop'].includes(i);\n    });\n\n    if (keyModifiers.includes('debounce')) {\n      let debounceIndex = keyModifiers.indexOf('debounce');\n      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || 'invalid-wait').split('ms')[0]) ? 2 : 1);\n    } // If no modifier is specified, we'll call it a press.\n\n\n    if (keyModifiers.length === 0) return false; // If one is passed, AND it matches the key pressed, we'll call it a press.\n\n    if (keyModifiers.length === 1 && keyModifiers[0] === keyToModifier(e.key)) return false; // The user is listening for key combinations.\n\n    const systemKeyModifiers = ['ctrl', 'shift', 'alt', 'meta', 'cmd', 'super'];\n    const selectedSystemKeyModifiers = systemKeyModifiers.filter(modifier => keyModifiers.includes(modifier));\n    keyModifiers = keyModifiers.filter(i => !selectedSystemKeyModifiers.includes(i));\n\n    if (selectedSystemKeyModifiers.length > 0) {\n      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter(modifier => {\n        // Alias \"cmd\" and \"super\" to \"meta\"\n        if (modifier === 'cmd' || modifier === 'super') modifier = 'meta';\n        return e[`${modifier}Key`];\n      }); // If all the modifiers selected are pressed, ...\n\n      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n        // AND the remaining key is pressed as well. It's a press.\n        if (keyModifiers[0] === keyToModifier(e.key)) return false;\n      }\n    } // We'll call it NOT a valid keypress.\n\n\n    return true;\n  }\n\n  function keyToModifier(key) {\n    switch (key) {\n      case '/':\n        return 'slash';\n\n      case ' ':\n      case 'Spacebar':\n        return 'space';\n\n      default:\n        return key && kebabCase(key);\n    }\n  }\n\n  function registerModelListener(component, el, modifiers, expression, extraVars) {\n    // If the element we are binding to is a select, a radio, or checkbox\n    // we'll listen for the change event instead of the \"input\" event.\n    var event = el.tagName.toLowerCase() === 'select' || ['checkbox', 'radio'].includes(el.type) || modifiers.includes('lazy') ? 'change' : 'input';\n    const listenerExpression = `${expression} = rightSideOfExpression($event, ${expression})`;\n    registerListener(component, el, event, modifiers, listenerExpression, () => {\n      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        rightSideOfExpression: generateModelAssignmentFunction(el, modifiers, expression)\n      });\n    });\n  }\n\n  function generateModelAssignmentFunction(el, modifiers, expression) {\n    if (el.type === 'radio') {\n      // Radio buttons only work properly when they share a name attribute.\n      // People might assume we take care of that for them, because\n      // they already set a shared \"x-model\" attribute.\n      if (!el.hasAttribute('name')) el.setAttribute('name', expression);\n    }\n\n    return (event, currentValue) => {\n      // Check for event.detail due to an issue where IE11 handles other events as a CustomEvent.\n      if (event instanceof CustomEvent && event.detail) {\n        return event.detail;\n      } else if (el.type === 'checkbox') {\n        // If the data we are binding to is an array, toggle its value inside the array.\n        if (Array.isArray(currentValue)) {\n          const newValue = modifiers.includes('number') ? safeParseNumber(event.target.value) : event.target.value;\n          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter(el => !checkedAttrLooseCompare(el, newValue));\n        } else {\n          return event.target.checked;\n        }\n      } else if (el.tagName.toLowerCase() === 'select' && el.multiple) {\n        return modifiers.includes('number') ? Array.from(event.target.selectedOptions).map(option => {\n          const rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        }) : Array.from(event.target.selectedOptions).map(option => {\n          return option.value || option.text;\n        });\n      } else {\n        const rawValue = event.target.value;\n        return modifiers.includes('number') ? safeParseNumber(rawValue) : modifiers.includes('trim') ? rawValue.trim() : rawValue;\n      }\n    };\n  }\n\n  function safeParseNumber(rawValue) {\n    const number = rawValue ? parseFloat(rawValue) : null;\n    return isNumeric(number) ? number : rawValue;\n  }\n\n  /**\n   * Copyright (C) 2017 salesforce.com, inc.\n   */\n  const { isArray } = Array;\n  const { getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, defineProperties: ObjectDefineProperties, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty, } = Object;\n  const { push: ArrayPush, concat: ArrayConcat, map: ArrayMap, } = Array.prototype;\n  function isUndefined(obj) {\n      return obj === undefined;\n  }\n  function isFunction(obj) {\n      return typeof obj === 'function';\n  }\n  function isObject(obj) {\n      return typeof obj === 'object';\n  }\n  const proxyToValueMap = new WeakMap();\n  function registerProxy(proxy, value) {\n      proxyToValueMap.set(proxy, value);\n  }\n  const unwrap = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\n  function wrapValue(membrane, value) {\n      return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;\n  }\n  /**\n   * Unwrap property descriptors will set value on original descriptor\n   * We only need to unwrap if value is specified\n   * @param descriptor external descrpitor provided to define new property on original value\n   */\n  function unwrapDescriptor(descriptor) {\n      if (hasOwnProperty.call(descriptor, 'value')) {\n          descriptor.value = unwrap(descriptor.value);\n      }\n      return descriptor;\n  }\n  function lockShadowTarget(membrane, shadowTarget, originalTarget) {\n      const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      targetKeys.forEach((key) => {\n          let descriptor = getOwnPropertyDescriptor(originalTarget, key);\n          // We do not need to wrap the descriptor if configurable\n          // Because we can deal with wrapping it when user goes through\n          // Get own property descriptor. There is also a chance that this descriptor\n          // could change sometime in the future, so we can defer wrapping\n          // until we need to\n          if (!descriptor.configurable) {\n              descriptor = wrapDescriptor(membrane, descriptor, wrapValue);\n          }\n          ObjectDefineProperty(shadowTarget, key, descriptor);\n      });\n      preventExtensions(shadowTarget);\n  }\n  class ReactiveProxyHandler {\n      constructor(membrane, value) {\n          this.originalTarget = value;\n          this.membrane = membrane;\n      }\n      get(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const value = originalTarget[key];\n          const { valueObserved } = membrane;\n          valueObserved(originalTarget, key);\n          return membrane.getProxy(value);\n      }\n      set(shadowTarget, key, value) {\n          const { originalTarget, membrane: { valueMutated } } = this;\n          const oldValue = originalTarget[key];\n          if (oldValue !== value) {\n              originalTarget[key] = value;\n              valueMutated(originalTarget, key);\n          }\n          else if (key === 'length' && isArray(originalTarget)) {\n              // fix for issue #236: push will add the new index, and by the time length\n              // is updated, the internal length is already equal to the new length value\n              // therefore, the oldValue is equal to the value. This is the forking logic\n              // to support this use case.\n              valueMutated(originalTarget, key);\n          }\n          return true;\n      }\n      deleteProperty(shadowTarget, key) {\n          const { originalTarget, membrane: { valueMutated } } = this;\n          delete originalTarget[key];\n          valueMutated(originalTarget, key);\n          return true;\n      }\n      apply(shadowTarget, thisArg, argArray) {\n          /* No op */\n      }\n      construct(target, argArray, newTarget) {\n          /* No op */\n      }\n      has(shadowTarget, key) {\n          const { originalTarget, membrane: { valueObserved } } = this;\n          valueObserved(originalTarget, key);\n          return key in originalTarget;\n      }\n      ownKeys(shadowTarget) {\n          const { originalTarget } = this;\n          return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      }\n      isExtensible(shadowTarget) {\n          const shadowIsExtensible = isExtensible(shadowTarget);\n          if (!shadowIsExtensible) {\n              return shadowIsExtensible;\n          }\n          const { originalTarget, membrane } = this;\n          const targetIsExtensible = isExtensible(originalTarget);\n          if (!targetIsExtensible) {\n              lockShadowTarget(membrane, shadowTarget, originalTarget);\n          }\n          return targetIsExtensible;\n      }\n      setPrototypeOf(shadowTarget, prototype) {\n      }\n      getPrototypeOf(shadowTarget) {\n          const { originalTarget } = this;\n          return getPrototypeOf(originalTarget);\n      }\n      getOwnPropertyDescriptor(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const { valueObserved } = this.membrane;\n          // keys looked up via hasOwnProperty need to be reactive\n          valueObserved(originalTarget, key);\n          let desc = getOwnPropertyDescriptor(originalTarget, key);\n          if (isUndefined(desc)) {\n              return desc;\n          }\n          const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);\n          if (!isUndefined(shadowDescriptor)) {\n              return shadowDescriptor;\n          }\n          // Note: by accessing the descriptor, the key is marked as observed\n          // but access to the value, setter or getter (if available) cannot observe\n          // mutations, just like regular methods, in which case we just do nothing.\n          desc = wrapDescriptor(membrane, desc, wrapValue);\n          if (!desc.configurable) {\n              // If descriptor from original target is not configurable,\n              // We must copy the wrapped descriptor over to the shadow target.\n              // Otherwise, proxy will throw an invariant error.\n              // This is our last chance to lock the value.\n              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n              ObjectDefineProperty(shadowTarget, key, desc);\n          }\n          return desc;\n      }\n      preventExtensions(shadowTarget) {\n          const { originalTarget, membrane } = this;\n          lockShadowTarget(membrane, shadowTarget, originalTarget);\n          preventExtensions(originalTarget);\n          return true;\n      }\n      defineProperty(shadowTarget, key, descriptor) {\n          const { originalTarget, membrane } = this;\n          const { valueMutated } = membrane;\n          const { configurable } = descriptor;\n          // We have to check for value in descriptor\n          // because Object.freeze(proxy) calls this method\n          // with only { configurable: false, writeable: false }\n          // Additionally, method will only be called with writeable:false\n          // if the descriptor has a value, as opposed to getter/setter\n          // So we can just check if writable is present and then see if\n          // value is present. This eliminates getter and setter descriptors\n          if (hasOwnProperty.call(descriptor, 'writable') && !hasOwnProperty.call(descriptor, 'value')) {\n              const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);\n              descriptor.value = originalDescriptor.value;\n          }\n          ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));\n          if (configurable === false) {\n              ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));\n          }\n          valueMutated(originalTarget, key);\n          return true;\n      }\n  }\n\n  function wrapReadOnlyValue(membrane, value) {\n      return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;\n  }\n  class ReadOnlyHandler {\n      constructor(membrane, value) {\n          this.originalTarget = value;\n          this.membrane = membrane;\n      }\n      get(shadowTarget, key) {\n          const { membrane, originalTarget } = this;\n          const value = originalTarget[key];\n          const { valueObserved } = membrane;\n          valueObserved(originalTarget, key);\n          return membrane.getReadOnlyProxy(value);\n      }\n      set(shadowTarget, key, value) {\n          return false;\n      }\n      deleteProperty(shadowTarget, key) {\n          return false;\n      }\n      apply(shadowTarget, thisArg, argArray) {\n          /* No op */\n      }\n      construct(target, argArray, newTarget) {\n          /* No op */\n      }\n      has(shadowTarget, key) {\n          const { originalTarget, membrane: { valueObserved } } = this;\n          valueObserved(originalTarget, key);\n          return key in originalTarget;\n      }\n      ownKeys(shadowTarget) {\n          const { originalTarget } = this;\n          return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      }\n      setPrototypeOf(shadowTarget, prototype) {\n      }\n      getOwnPropertyDescriptor(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const { valueObserved } = membrane;\n          // keys looked up via hasOwnProperty need to be reactive\n          valueObserved(originalTarget, key);\n          let desc = getOwnPropertyDescriptor(originalTarget, key);\n          if (isUndefined(desc)) {\n              return desc;\n          }\n          const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);\n          if (!isUndefined(shadowDescriptor)) {\n              return shadowDescriptor;\n          }\n          // Note: by accessing the descriptor, the key is marked as observed\n          // but access to the value or getter (if available) cannot be observed,\n          // just like regular methods, in which case we just do nothing.\n          desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);\n          if (hasOwnProperty.call(desc, 'set')) {\n              desc.set = undefined; // readOnly membrane does not allow setters\n          }\n          if (!desc.configurable) {\n              // If descriptor from original target is not configurable,\n              // We must copy the wrapped descriptor over to the shadow target.\n              // Otherwise, proxy will throw an invariant error.\n              // This is our last chance to lock the value.\n              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n              ObjectDefineProperty(shadowTarget, key, desc);\n          }\n          return desc;\n      }\n      preventExtensions(shadowTarget) {\n          return false;\n      }\n      defineProperty(shadowTarget, key, descriptor) {\n          return false;\n      }\n  }\n  function createShadowTarget(value) {\n      let shadowTarget = undefined;\n      if (isArray(value)) {\n          shadowTarget = [];\n      }\n      else if (isObject(value)) {\n          shadowTarget = {};\n      }\n      return shadowTarget;\n  }\n  const ObjectDotPrototype = Object.prototype;\n  function defaultValueIsObservable(value) {\n      // intentionally checking for null\n      if (value === null) {\n          return false;\n      }\n      // treat all non-object types, including undefined, as non-observable values\n      if (typeof value !== 'object') {\n          return false;\n      }\n      if (isArray(value)) {\n          return true;\n      }\n      const proto = getPrototypeOf(value);\n      return (proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null);\n  }\n  const defaultValueObserved = (obj, key) => {\n      /* do nothing */\n  };\n  const defaultValueMutated = (obj, key) => {\n      /* do nothing */\n  };\n  const defaultValueDistortion = (value) => value;\n  function wrapDescriptor(membrane, descriptor, getValue) {\n      const { set, get } = descriptor;\n      if (hasOwnProperty.call(descriptor, 'value')) {\n          descriptor.value = getValue(membrane, descriptor.value);\n      }\n      else {\n          if (!isUndefined(get)) {\n              descriptor.get = function () {\n                  // invoking the original getter with the original target\n                  return getValue(membrane, get.call(unwrap(this)));\n              };\n          }\n          if (!isUndefined(set)) {\n              descriptor.set = function (value) {\n                  // At this point we don't have a clear indication of whether\n                  // or not a valid mutation will occur, we don't have the key,\n                  // and we are not sure why and how they are invoking this setter.\n                  // Nevertheless we preserve the original semantics by invoking the\n                  // original setter with the original target and the unwrapped value\n                  set.call(unwrap(this), membrane.unwrapProxy(value));\n              };\n          }\n      }\n      return descriptor;\n  }\n  class ReactiveMembrane {\n      constructor(options) {\n          this.valueDistortion = defaultValueDistortion;\n          this.valueMutated = defaultValueMutated;\n          this.valueObserved = defaultValueObserved;\n          this.valueIsObservable = defaultValueIsObservable;\n          this.objectGraph = new WeakMap();\n          if (!isUndefined(options)) {\n              const { valueDistortion, valueMutated, valueObserved, valueIsObservable } = options;\n              this.valueDistortion = isFunction(valueDistortion) ? valueDistortion : defaultValueDistortion;\n              this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;\n              this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;\n              this.valueIsObservable = isFunction(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;\n          }\n      }\n      getProxy(value) {\n          const unwrappedValue = unwrap(value);\n          const distorted = this.valueDistortion(unwrappedValue);\n          if (this.valueIsObservable(distorted)) {\n              const o = this.getReactiveState(unwrappedValue, distorted);\n              // when trying to extract the writable version of a readonly\n              // we return the readonly.\n              return o.readOnly === value ? value : o.reactive;\n          }\n          return distorted;\n      }\n      getReadOnlyProxy(value) {\n          value = unwrap(value);\n          const distorted = this.valueDistortion(value);\n          if (this.valueIsObservable(distorted)) {\n              return this.getReactiveState(value, distorted).readOnly;\n          }\n          return distorted;\n      }\n      unwrapProxy(p) {\n          return unwrap(p);\n      }\n      getReactiveState(value, distortedValue) {\n          const { objectGraph, } = this;\n          let reactiveState = objectGraph.get(distortedValue);\n          if (reactiveState) {\n              return reactiveState;\n          }\n          const membrane = this;\n          reactiveState = {\n              get reactive() {\n                  const reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue);\n                  // caching the reactive proxy after the first time it is accessed\n                  const proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);\n                  registerProxy(proxy, value);\n                  ObjectDefineProperty(this, 'reactive', { value: proxy });\n                  return proxy;\n              },\n              get readOnly() {\n                  const readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue);\n                  // caching the readOnly proxy after the first time it is accessed\n                  const proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);\n                  registerProxy(proxy, value);\n                  ObjectDefineProperty(this, 'readOnly', { value: proxy });\n                  return proxy;\n              }\n          };\n          objectGraph.set(distortedValue, reactiveState);\n          return reactiveState;\n      }\n  }\n  /** version: 0.26.0 */\n\n  function wrap(data, mutationCallback) {\n\n    let membrane = new ReactiveMembrane({\n      valueMutated(target, key) {\n        mutationCallback(target, key);\n      }\n\n    });\n    return {\n      data: membrane.getProxy(data),\n      membrane: membrane\n    };\n  }\n  function unwrap$1(membrane, observable) {\n    let unwrappedData = membrane.unwrapProxy(observable);\n    let copy = {};\n    Object.keys(unwrappedData).forEach(key => {\n      if (['$el', '$refs', '$nextTick', '$watch'].includes(key)) return;\n      copy[key] = unwrappedData[key];\n    });\n    return copy;\n  }\n\n  class Component {\n    constructor(el, componentForClone = null) {\n      this.$el = el;\n      const dataAttr = this.$el.getAttribute('x-data');\n      const dataExpression = dataAttr === '' ? '{}' : dataAttr;\n      const initExpression = this.$el.getAttribute('x-init');\n      let dataExtras = {\n        $el: this.$el\n      };\n      let canonicalComponentElementReference = componentForClone ? componentForClone.$el : this.$el;\n      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        Object.defineProperty(dataExtras, `$${name}`, {\n          get: function get() {\n            return callback(canonicalComponentElementReference);\n          }\n        });\n      });\n      this.unobservedData = componentForClone ? componentForClone.getUnobservedData() : saferEval(el, dataExpression, dataExtras);\n      // Construct a Proxy-based observable. This will be used to handle reactivity.\n\n      let {\n        membrane,\n        data\n      } = this.wrapDataInObservable(this.unobservedData);\n      this.$data = data;\n      this.membrane = membrane; // After making user-supplied data methods reactive, we can now add\n      // our magic properties to the original data for access.\n\n      this.unobservedData.$el = this.$el;\n      this.unobservedData.$refs = this.getRefsProxy();\n      this.nextTickStack = [];\n\n      this.unobservedData.$nextTick = callback => {\n        this.nextTickStack.push(callback);\n      };\n\n      this.watchers = {};\n\n      this.unobservedData.$watch = (property, callback) => {\n        if (!this.watchers[property]) this.watchers[property] = [];\n        this.watchers[property].push(callback);\n      };\n      /* MODERN-ONLY:START */\n      // We remove this piece of code from the legacy build.\n      // In IE11, we have already defined our helpers at this point.\n      // Register custom magic properties.\n\n\n      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        Object.defineProperty(this.unobservedData, `$${name}`, {\n          get: function get() {\n            return callback(canonicalComponentElementReference, this.$el);\n          }\n        });\n      });\n      /* MODERN-ONLY:END */\n\n      this.showDirectiveStack = [];\n      this.showDirectiveLastElement;\n      componentForClone || Alpine.onBeforeComponentInitializeds.forEach(callback => callback(this));\n      var initReturnedCallback; // If x-init is present AND we aren't cloning (skip x-init on clone)\n\n      if (initExpression && !componentForClone) {\n        // We want to allow data manipulation, but not trigger DOM updates just yet.\n        // We haven't even initialized the elements with their Alpine bindings. I mean c'mon.\n        this.pauseReactivity = true;\n        initReturnedCallback = this.evaluateReturnExpression(this.$el, initExpression);\n        this.pauseReactivity = false;\n      } // Register all our listeners and set all our attribute bindings.\n\n\n      this.initializeElements(this.$el); // Use mutation observer to detect new elements being added within this component at run-time.\n      // Alpine's just so darn flexible amirite?\n\n      this.listenForNewElementsToInitialize();\n\n      if (typeof initReturnedCallback === 'function') {\n        // Run the callback returned from the \"x-init\" hook to allow the user to do stuff after\n        // Alpine's got it's grubby little paws all over everything.\n        initReturnedCallback.call(this.$data);\n      }\n\n      componentForClone || setTimeout(() => {\n        Alpine.onComponentInitializeds.forEach(callback => callback(this));\n      }, 0);\n    }\n\n    getUnobservedData() {\n      return unwrap$1(this.membrane, this.$data);\n    }\n\n    wrapDataInObservable(data) {\n      var self = this;\n      let updateDom = debounce(function () {\n        self.updateElements(self.$el);\n      }, 0);\n      return wrap(data, (target, key) => {\n        if (self.watchers[key]) {\n          // If there's a watcher for this specific key, run it.\n          self.watchers[key].forEach(callback => callback(target[key]));\n        } else if (Array.isArray(target)) {\n          // Arrays are special cases, if any of the items change, we consider the array as mutated.\n          Object.keys(self.watchers).forEach(fullDotNotationKey => {\n            let dotNotationParts = fullDotNotationKey.split('.'); // Ignore length mutations since they would result in duplicate calls.\n            // For example, when calling push, we would get a mutation for the item's key\n            // and a second mutation for the length property.\n\n            if (key === 'length') return;\n            dotNotationParts.reduce((comparisonData, part) => {\n              if (Object.is(target, comparisonData[part])) {\n                self.watchers[fullDotNotationKey].forEach(callback => callback(target));\n              }\n\n              return comparisonData[part];\n            }, self.unobservedData);\n          });\n        } else {\n          // Let's walk through the watchers with \"dot-notation\" (foo.bar) and see\n          // if this mutation fits any of them.\n          Object.keys(self.watchers).filter(i => i.includes('.')).forEach(fullDotNotationKey => {\n            let dotNotationParts = fullDotNotationKey.split('.'); // If this dot-notation watcher's last \"part\" doesn't match the current\n            // key, then skip it early for performance reasons.\n\n            if (key !== dotNotationParts[dotNotationParts.length - 1]) return; // Now, walk through the dot-notation \"parts\" recursively to find\n            // a match, and call the watcher if one's found.\n\n            dotNotationParts.reduce((comparisonData, part) => {\n              if (Object.is(target, comparisonData)) {\n                // Run the watchers.\n                self.watchers[fullDotNotationKey].forEach(callback => callback(target[key]));\n              }\n\n              return comparisonData[part];\n            }, self.unobservedData);\n          });\n        } // Don't react to data changes for cases like the `x-created` hook.\n\n\n        if (self.pauseReactivity) return;\n        updateDom();\n      });\n    }\n\n    walkAndSkipNestedComponents(el, callback, initializeComponentCallback = () => {}) {\n      walk(el, el => {\n        // We've hit a component.\n        if (el.hasAttribute('x-data')) {\n          // If it's not the current one.\n          if (!el.isSameNode(this.$el)) {\n            // Initialize it if it's not.\n            if (!el.__x) initializeComponentCallback(el); // Now we'll let that sub-component deal with itself.\n\n            return false;\n          }\n        }\n\n        return callback(el);\n      });\n    }\n\n    initializeElements(rootEl, extraVars = () => {}) {\n      this.walkAndSkipNestedComponents(rootEl, el => {\n        // Don't touch spawns from for loop\n        if (el.__x_for_key !== undefined) return false; // Don't touch spawns from if directives\n\n        if (el.__x_inserted_me !== undefined) return false;\n        this.initializeElement(el, extraVars);\n      }, el => {\n        el.__x = new Component(el);\n      });\n      this.executeAndClearRemainingShowDirectiveStack();\n      this.executeAndClearNextTickStack(rootEl);\n    }\n\n    initializeElement(el, extraVars) {\n      // To support class attribute merging, we have to know what the element's\n      // original class attribute looked like for reference.\n      if (el.hasAttribute('class') && getXAttrs(el, this).length > 0) {\n        el.__x_original_classes = convertClassStringToArray(el.getAttribute('class'));\n      }\n\n      this.registerListeners(el, extraVars);\n      this.resolveBoundAttributes(el, true, extraVars);\n    }\n\n    updateElements(rootEl, extraVars = () => {}) {\n      this.walkAndSkipNestedComponents(rootEl, el => {\n        // Don't touch spawns from for loop (and check if the root is actually a for loop in a parent, don't skip it.)\n        if (el.__x_for_key !== undefined && !el.isSameNode(this.$el)) return false;\n        this.updateElement(el, extraVars);\n      }, el => {\n        el.__x = new Component(el);\n      });\n      this.executeAndClearRemainingShowDirectiveStack();\n      this.executeAndClearNextTickStack(rootEl);\n    }\n\n    executeAndClearNextTickStack(el) {\n      // Skip spawns from alpine directives\n      if (el === this.$el && this.nextTickStack.length > 0) {\n        // We run the tick stack after the next frame to allow any\n        // running transitions to pass the initial show stage.\n        requestAnimationFrame(() => {\n          while (this.nextTickStack.length > 0) {\n            this.nextTickStack.shift()();\n          }\n        });\n      }\n    }\n\n    executeAndClearRemainingShowDirectiveStack() {\n      // The goal here is to start all the x-show transitions\n      // and build a nested promise chain so that elements\n      // only hide when the children are finished hiding.\n      this.showDirectiveStack.reverse().map(handler => {\n        return new Promise((resolve, reject) => {\n          handler(resolve, reject);\n        });\n      }).reduce((promiseChain, promise) => {\n        return promiseChain.then(() => {\n          return promise.then(finishElement => {\n            finishElement();\n          });\n        });\n      }, Promise.resolve(() => {})).catch(e => {\n        if (e !== TRANSITION_CANCELLED) throw e;\n      }); // We've processed the handler stack. let's clear it.\n\n      this.showDirectiveStack = [];\n      this.showDirectiveLastElement = undefined;\n    }\n\n    updateElement(el, extraVars) {\n      this.resolveBoundAttributes(el, false, extraVars);\n    }\n\n    registerListeners(el, extraVars) {\n      getXAttrs(el, this).forEach(({\n        type,\n        value,\n        modifiers,\n        expression\n      }) => {\n        switch (type) {\n          case 'on':\n            registerListener(this, el, value, modifiers, expression, extraVars);\n            break;\n\n          case 'model':\n            registerModelListener(this, el, modifiers, expression, extraVars);\n            break;\n        }\n      });\n    }\n\n    resolveBoundAttributes(el, initialUpdate = false, extraVars) {\n      let attrs = getXAttrs(el, this);\n      attrs.forEach(({\n        type,\n        value,\n        modifiers,\n        expression\n      }) => {\n        switch (type) {\n          case 'model':\n            handleAttributeBindingDirective(this, el, 'value', expression, extraVars, type, modifiers);\n            break;\n\n          case 'bind':\n            // The :key binding on an x-for is special, ignore it.\n            if (el.tagName.toLowerCase() === 'template' && value === 'key') return;\n            handleAttributeBindingDirective(this, el, value, expression, extraVars, type, modifiers);\n            break;\n\n          case 'text':\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleTextDirective(el, output, expression);\n            break;\n\n          case 'html':\n            handleHtmlDirective(this, el, expression, extraVars);\n            break;\n\n          case 'show':\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleShowDirective(this, el, output, modifiers, initialUpdate);\n            break;\n\n          case 'if':\n            // If this element also has x-for on it, don't process x-if.\n            // We will let the \"x-for\" directive handle the \"if\"ing.\n            if (attrs.some(i => i.type === 'for')) return;\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleIfDirective(this, el, output, initialUpdate, extraVars);\n            break;\n\n          case 'for':\n            handleForDirective(this, el, expression, initialUpdate, extraVars);\n            break;\n\n          case 'cloak':\n            el.removeAttribute('x-cloak');\n            break;\n        }\n      });\n    }\n\n    evaluateReturnExpression(el, expression, extraVars = () => {}) {\n      return saferEval(el, expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        $dispatch: this.getDispatchFunction(el)\n      }));\n    }\n\n    evaluateCommandExpression(el, expression, extraVars = () => {}) {\n      return saferEvalNoReturn(el, expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        $dispatch: this.getDispatchFunction(el)\n      }));\n    }\n\n    getDispatchFunction(el) {\n      return (event, detail = {}) => {\n        el.dispatchEvent(new CustomEvent(event, {\n          detail,\n          bubbles: true\n        }));\n      };\n    }\n\n    listenForNewElementsToInitialize() {\n      const targetNode = this.$el;\n      const observerOptions = {\n        childList: true,\n        attributes: true,\n        subtree: true\n      };\n      const observer = new MutationObserver(mutations => {\n        for (let i = 0; i < mutations.length; i++) {\n          // Filter out mutations triggered from child components.\n          const closestParentComponent = mutations[i].target.closest('[x-data]');\n          if (!(closestParentComponent && closestParentComponent.isSameNode(this.$el))) continue;\n\n          if (mutations[i].type === 'attributes' && mutations[i].attributeName === 'x-data') {\n            const xAttr = mutations[i].target.getAttribute('x-data') || '{}';\n            const rawData = saferEval(this.$el, xAttr, {\n              $el: this.$el\n            });\n            Object.keys(rawData).forEach(key => {\n              if (this.$data[key] !== rawData[key]) {\n                this.$data[key] = rawData[key];\n              }\n            });\n          }\n\n          if (mutations[i].addedNodes.length > 0) {\n            mutations[i].addedNodes.forEach(node => {\n              if (node.nodeType !== 1 || node.__x_inserted_me) return;\n\n              if (node.matches('[x-data]') && !node.__x) {\n                node.__x = new Component(node);\n                return;\n              }\n\n              this.initializeElements(node);\n            });\n          }\n        }\n      });\n      observer.observe(targetNode, observerOptions);\n    }\n\n    getRefsProxy() {\n      var self = this;\n      var refObj = {};\n      // One of the goals of this is to not hold elements in memory, but rather re-evaluate\n      // the DOM when the system needs something from it. This way, the framework is flexible and\n      // friendly to outside DOM changes from libraries like Vue/Livewire.\n      // For this reason, I'm using an \"on-demand\" proxy to fake a \"$refs\" object.\n\n      return new Proxy(refObj, {\n        get(object, property) {\n          if (property === '$isAlpineProxy') return true;\n          var ref; // We can't just query the DOM because it's hard to filter out refs in\n          // nested components.\n\n          self.walkAndSkipNestedComponents(self.$el, el => {\n            if (el.hasAttribute('x-ref') && el.getAttribute('x-ref') === property) {\n              ref = el;\n            }\n          });\n          return ref;\n        }\n\n      });\n    }\n\n  }\n\n  const Alpine = {\n    version: \"2.8.0\",\n    pauseMutationObserver: false,\n    magicProperties: {},\n    onComponentInitializeds: [],\n    onBeforeComponentInitializeds: [],\n    ignoreFocusedForValueBinding: false,\n    start: async function start() {\n      if (!isTesting()) {\n        await domReady();\n      }\n\n      this.discoverComponents(el => {\n        this.initializeComponent(el);\n      }); // It's easier and more performant to just support Turbolinks than listen\n      // to MutationObserver mutations at the document level.\n\n      document.addEventListener(\"turbolinks:load\", () => {\n        this.discoverUninitializedComponents(el => {\n          this.initializeComponent(el);\n        });\n      });\n      this.listenForNewUninitializedComponentsAtRunTime();\n    },\n    discoverComponents: function discoverComponents(callback) {\n      const rootEls = document.querySelectorAll('[x-data]');\n      rootEls.forEach(rootEl => {\n        callback(rootEl);\n      });\n    },\n    discoverUninitializedComponents: function discoverUninitializedComponents(callback, el = null) {\n      const rootEls = (el || document).querySelectorAll('[x-data]');\n      Array.from(rootEls).filter(el => el.__x === undefined).forEach(rootEl => {\n        callback(rootEl);\n      });\n    },\n    listenForNewUninitializedComponentsAtRunTime: function listenForNewUninitializedComponentsAtRunTime() {\n      const targetNode = document.querySelector('body');\n      const observerOptions = {\n        childList: true,\n        attributes: true,\n        subtree: true\n      };\n      const observer = new MutationObserver(mutations => {\n        if (this.pauseMutationObserver) return;\n\n        for (let i = 0; i < mutations.length; i++) {\n          if (mutations[i].addedNodes.length > 0) {\n            mutations[i].addedNodes.forEach(node => {\n              // Discard non-element nodes (like line-breaks)\n              if (node.nodeType !== 1) return; // Discard any changes happening within an existing component.\n              // They will take care of themselves.\n\n              if (node.parentElement && node.parentElement.closest('[x-data]')) return;\n              this.discoverUninitializedComponents(el => {\n                this.initializeComponent(el);\n              }, node.parentElement);\n            });\n          }\n        }\n      });\n      observer.observe(targetNode, observerOptions);\n    },\n    initializeComponent: function initializeComponent(el) {\n      if (!el.__x) {\n        // Wrap in a try/catch so that we don't prevent other components\n        // from initializing when one component contains an error.\n        try {\n          el.__x = new Component(el);\n        } catch (error) {\n          setTimeout(() => {\n            throw error;\n          }, 0);\n        }\n      }\n    },\n    clone: function clone(component, newEl) {\n      if (!newEl.__x) {\n        newEl.__x = new Component(newEl, component);\n      }\n    },\n    addMagicProperty: function addMagicProperty(name, callback) {\n      this.magicProperties[name] = callback;\n    },\n    onComponentInitialized: function onComponentInitialized(callback) {\n      this.onComponentInitializeds.push(callback);\n    },\n    onBeforeComponentInitialized: function onBeforeComponentInitialized(callback) {\n      this.onBeforeComponentInitializeds.push(callback);\n    }\n  };\n\n  if (!isTesting()) {\n    window.Alpine = Alpine;\n\n    if (window.deferLoadingAlpine) {\n      window.deferLoadingAlpine(function () {\n        window.Alpine.start();\n      });\n    } else {\n      window.Alpine.start();\n    }\n  }\n\n  return Alpine;\n\n})));\n","export default function getBoundingClientRect(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    y: rect.top\n  };\n}","/*:: import type { Window } from '../types'; */\n\n/*:: declare function getWindow(node: Node | Window): Window; */\nexport default function getWindow(node) {\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}","import getWindow from \"./getWindow.js\";\nexport default function getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}","import getWindow from \"./getWindow.js\";\n/*:: declare function isElement(node: mixed): boolean %checks(node instanceof\n  Element); */\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n  HTMLElement); */\n\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n/*:: declare function isShadowRoot(node: mixed): boolean %checks(node instanceof\n  ShadowRoot); */\n\n\nfunction isShadowRoot(node) {\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nexport { isElement, isHTMLElement, isShadowRoot };","export default function getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}","import { isElement } from \"./instanceOf.js\";\nexport default function getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getWindowScroll from \"./getWindowScroll.js\";\nexport default function getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}","import getWindow from \"./getWindow.js\";\nexport default function getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}","import getComputedStyle from \"./getComputedStyle.js\";\nexport default function isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getNodeScroll from \"./getNodeScroll.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport isScrollParent from \"./isScrollParent.js\"; // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\nexport default function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement);\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}","import getWindowScroll from \"./getWindowScroll.js\";\nimport getWindow from \"./getWindow.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport getHTMLElementScroll from \"./getHTMLElementScroll.js\";\nexport default function getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}","export default function getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}","// Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\nexport default function getLayoutRect(element) {\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n}","import getNodeName from \"./getNodeName.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nexport default function getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe[incompatible-return]: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}","import getParentNode from \"./getParentNode.js\";\nimport isScrollParent from \"./isScrollParent.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nexport default function getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}","import getScrollParent from \"./getScrollParent.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport getWindow from \"./getWindow.js\";\nimport isScrollParent from \"./isScrollParent.js\";\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nexport default function listScrollParents(element, list) {\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === element.ownerDocument.body;\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}","import getNodeName from \"./getNodeName.js\";\nexport default function isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}","import getWindow from \"./getWindow.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport isTableElement from \"./isTableElement.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  var offsetParent = element.offsetParent;\n\n  if (offsetParent) {\n    var html = getDocumentElement(offsetParent);\n\n    if (getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && getComputedStyle(html).position !== 'static') {\n      return html;\n    }\n  }\n\n  return offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.willChange && css.willChange !== 'auto') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nexport default function getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static') {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}","export var top = 'top';\nexport var bottom = 'bottom';\nexport var right = 'right';\nexport var left = 'left';\nexport var auto = 'auto';\nexport var basePlacements = [top, bottom, right, left];\nexport var start = 'start';\nexport var end = 'end';\nexport var clippingParents = 'clippingParents';\nexport var viewport = 'viewport';\nexport var popper = 'popper';\nexport var reference = 'reference';\nexport var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nexport var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nexport var beforeRead = 'beforeRead';\nexport var read = 'read';\nexport var afterRead = 'afterRead'; // pure-logic modifiers\n\nexport var beforeMain = 'beforeMain';\nexport var main = 'main';\nexport var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nexport var beforeWrite = 'beforeWrite';\nexport var write = 'write';\nexport var afterWrite = 'afterWrite';\nexport var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];","import { modifierPhases } from \"../enums.js\"; // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nexport default function orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}","import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport getComputedStyle from \"./dom-utils/getComputedStyle.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport validateModifiers from \"./utils/validateModifiers.js\";\nimport uniqueBy from \"./utils/uniqueBy.js\";\nimport getBasePlacement from \"./utils/getBasePlacement.js\";\nimport mergeByName from \"./utils/mergeByName.js\";\nimport detectOverflow from \"./utils/detectOverflow.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nimport { auto } from \"./enums.js\";\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (process.env.NODE_ENV !== \"production\") {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = getComputedStyle(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (process.env.NODE_ENV !== \"production\") {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexport { detectOverflow };","export default function debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}","export default function mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), {}, {\n      options: Object.assign(Object.assign({}, existing.options), current.options),\n      data: Object.assign(Object.assign({}, existing.data), current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}","import getWindow from \"../dom-utils/getWindow.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n};","import { auto } from \"../enums.js\";\nexport default function getBasePlacement(placement) {\n  return placement.split('-')[0];\n}","export default function getVariation(placement) {\n  return placement.split('-')[1];\n}","export default function getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}","import getBasePlacement from \"./getBasePlacement.js\";\nimport getVariation from \"./getVariation.js\";\nimport getMainAxisFromPlacement from \"./getMainAxisFromPlacement.js\";\nimport { top, right, bottom, left, start, end } from \"../enums.js\";\nexport default function computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}","import computeOffsets from \"../utils/computeOffsets.js\";\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n};","import { top, left, right, bottom } from \"../enums.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport getWindow from \"../dom-utils/getWindow.js\";\nimport getDocumentElement from \"../dom-utils/getDocumentElement.js\";\nimport getComputedStyle from \"../dom-utils/getComputedStyle.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar round = Math.round;\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(round(x * dpr) / dpr) || 0,\n    y: round(round(y * dpr) / dpr) || 0\n  };\n}\n\nexport function mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets;\n\n  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,\n      _ref3$x = _ref3.x,\n      x = _ref3$x === void 0 ? 0 : _ref3$x,\n      _ref3$y = _ref3.y,\n      y = _ref3$y === void 0 ? 0 : _ref3$y;\n\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n    /*:: offsetParent = (offsetParent: Element); */\n\n\n    if (placement === top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref4) {\n  var state = _ref4.state,\n      options = _ref4.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';\n\n    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {\n      return transitionProperty.indexOf(property) >= 0;\n    })) {\n      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', '\\n\\n', 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\\n\\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));\n    }\n  }\n\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};","import { popperGenerator, detectOverflow } from \"./createPopper.js\";\nimport eventListeners from \"./modifiers/eventListeners.js\";\nimport popperOffsets from \"./modifiers/popperOffsets.js\";\nimport computeStyles from \"./modifiers/computeStyles.js\";\nimport applyStyles from \"./modifiers/applyStyles.js\";\nvar defaultModifiers = [eventListeners, popperOffsets, computeStyles, applyStyles];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper, popperGenerator, defaultModifiers, detectOverflow };","import getNodeName from \"../dom-utils/getNodeName.js\";\nimport { isHTMLElement } from \"../dom-utils/instanceOf.js\"; // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n};","var hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nexport default function getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}","var hash = {\n  start: 'end',\n  end: 'start'\n};\nexport default function getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}","import { isShadowRoot } from \"./instanceOf.js\";\nexport default function contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}","export default function rectToClientRect(rect) {\n  return Object.assign(Object.assign({}, rect), {}, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}","import { viewport } from \"../enums.js\";\nimport getViewportRect from \"./getViewportRect.js\";\nimport getDocumentRect from \"./getDocumentRect.js\";\nimport listScrollParents from \"./listScrollParents.js\";\nimport getOffsetParent from \"./getOffsetParent.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport { isElement, isHTMLElement } from \"./instanceOf.js\";\nimport getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport contains from \"./contains.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport rectToClientRect from \"../utils/rectToClientRect.js\";\n\nfunction getInnerBoundingClientRect(element) {\n  var rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nexport default function getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}","import getWindow from \"./getWindow.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nexport default function getViewportRect(element) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n  // can be obscured underneath it.\n  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n  // if it isn't open, so if this isn't available, the popper will be detected\n  // to overflow the bottom of the screen too early.\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n    // Feature detection fails in mobile emulation mode in Chrome.\n    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n    // 0.001\n    // Fallback here: \"Not Safari\" userAgent\n\n    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}","import getDocumentElement from \"./getDocumentElement.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport getWindowScroll from \"./getWindowScroll.js\"; // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nexport default function getDocumentRect(element) {\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = element.ownerDocument.body;\n  var width = Math.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = Math.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += Math.max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}","import getBoundingClientRect from \"../dom-utils/getBoundingClientRect.js\";\nimport getClippingRect from \"../dom-utils/getClippingRect.js\";\nimport getDocumentElement from \"../dom-utils/getDocumentElement.js\";\nimport computeOffsets from \"./computeOffsets.js\";\nimport rectToClientRect from \"./rectToClientRect.js\";\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from \"../enums.js\";\nimport { isElement } from \"../dom-utils/instanceOf.js\";\nimport mergePaddingObject from \"./mergePaddingObject.js\";\nimport expandToHashMap from \"./expandToHashMap.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport default function detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(referenceElement);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}","export default function expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}","import getFreshSideObject from \"./getFreshSideObject.js\";\nexport default function mergePaddingObject(paddingObject) {\n  return Object.assign(Object.assign({}, getFreshSideObject()), paddingObject);\n}","export default function getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}","import getOppositePlacement from \"../utils/getOppositePlacement.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getOppositeVariationPlacement from \"../utils/getOppositeVariationPlacement.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport computeAutoPlacement from \"../utils/computeAutoPlacement.js\";\nimport { bottom, top, start, right, left, auto } from \"../enums.js\";\nimport getVariation from \"../utils/getVariation.js\"; // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases  research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};","import getVariation from \"./getVariation.js\";\nimport { variationPlacements, basePlacements, placements as allPlacements } from \"../enums.js\";\nimport detectOverflow from \"./detectOverflow.js\";\nimport getBasePlacement from \"./getBasePlacement.js\";\n\n/*:: type OverflowsMap = { [ComputedPlacement]: number }; */\n\n/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\nexport default function computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? allPlacements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(' '));\n    }\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}","export default function within(min, value, max) {\n  return Math.max(min, Math.min(value, max));\n}","import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport within from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {}, {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var _preventedOffset = within(_min, _offset, _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","export default function getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}","import 'alpinejs'\nimport 'focus-visible'\nimport {createPopper} from '@popperjs/core/lib/popper-lite.js'\nimport flip from '@popperjs/core/lib/modifiers/flip.js'\nimport preventOverflow from '@popperjs/core/lib/modifiers/preventOverflow.js'\n\nwindow.createPopper = createPopper\nwindow.flip = flip\nwindow.preventOverflow = preventOverflow\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (factory());\n}(this, (function () { 'use strict';\n\n  /**\n   * Applies the :focus-visible polyfill at the given scope.\n   * A scope in this case is either the top-level Document or a Shadow Root.\n   *\n   * @param {(Document|ShadowRoot)} scope\n   * @see https://github.com/WICG/focus-visible\n   */\n  function applyFocusVisiblePolyfill(scope) {\n    var hadKeyboardEvent = true;\n    var hadFocusVisibleRecently = false;\n    var hadFocusVisibleRecentlyTimeout = null;\n\n    var inputTypesAllowlist = {\n      text: true,\n      search: true,\n      url: true,\n      tel: true,\n      email: true,\n      password: true,\n      number: true,\n      date: true,\n      month: true,\n      week: true,\n      time: true,\n      datetime: true,\n      'datetime-local': true\n    };\n\n    /**\n     * Helper function for legacy browsers and iframes which sometimes focus\n     * elements like document, body, and non-interactive SVG.\n     * @param {Element} el\n     */\n    function isValidFocusTarget(el) {\n      if (\n        el &&\n        el !== document &&\n        el.nodeName !== 'HTML' &&\n        el.nodeName !== 'BODY' &&\n        'classList' in el &&\n        'contains' in el.classList\n      ) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Computes whether the given element should automatically trigger the\n     * `focus-visible` class being added, i.e. whether it should always match\n     * `:focus-visible` when focused.\n     * @param {Element} el\n     * @return {boolean}\n     */\n    function focusTriggersKeyboardModality(el) {\n      var type = el.type;\n      var tagName = el.tagName;\n\n      if (tagName === 'INPUT' && inputTypesAllowlist[type] && !el.readOnly) {\n        return true;\n      }\n\n      if (tagName === 'TEXTAREA' && !el.readOnly) {\n        return true;\n      }\n\n      if (el.isContentEditable) {\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * Add the `focus-visible` class to the given element if it was not added by\n     * the author.\n     * @param {Element} el\n     */\n    function addFocusVisibleClass(el) {\n      if (el.classList.contains('focus-visible')) {\n        return;\n      }\n      el.classList.add('focus-visible');\n      el.setAttribute('data-focus-visible-added', '');\n    }\n\n    /**\n     * Remove the `focus-visible` class from the given element if it was not\n     * originally added by the author.\n     * @param {Element} el\n     */\n    function removeFocusVisibleClass(el) {\n      if (!el.hasAttribute('data-focus-visible-added')) {\n        return;\n      }\n      el.classList.remove('focus-visible');\n      el.removeAttribute('data-focus-visible-added');\n    }\n\n    /**\n     * If the most recent user interaction was via the keyboard;\n     * and the key press did not include a meta, alt/option, or control key;\n     * then the modality is keyboard. Otherwise, the modality is not keyboard.\n     * Apply `focus-visible` to any current active element and keep track\n     * of our keyboard modality state with `hadKeyboardEvent`.\n     * @param {KeyboardEvent} e\n     */\n    function onKeyDown(e) {\n      if (e.metaKey || e.altKey || e.ctrlKey) {\n        return;\n      }\n\n      if (isValidFocusTarget(scope.activeElement)) {\n        addFocusVisibleClass(scope.activeElement);\n      }\n\n      hadKeyboardEvent = true;\n    }\n\n    /**\n     * If at any point a user clicks with a pointing device, ensure that we change\n     * the modality away from keyboard.\n     * This avoids the situation where a user presses a key on an already focused\n     * element, and then clicks on a different element, focusing it with a\n     * pointing device, while we still think we're in keyboard modality.\n     * @param {Event} e\n     */\n    function onPointerDown(e) {\n      hadKeyboardEvent = false;\n    }\n\n    /**\n     * On `focus`, add the `focus-visible` class to the target if:\n     * - the target received focus as a result of keyboard navigation, or\n     * - the event target is an element that will likely require interaction\n     *   via the keyboard (e.g. a text box)\n     * @param {Event} e\n     */\n    function onFocus(e) {\n      // Prevent IE from focusing the document or HTML element.\n      if (!isValidFocusTarget(e.target)) {\n        return;\n      }\n\n      if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {\n        addFocusVisibleClass(e.target);\n      }\n    }\n\n    /**\n     * On `blur`, remove the `focus-visible` class from the target.\n     * @param {Event} e\n     */\n    function onBlur(e) {\n      if (!isValidFocusTarget(e.target)) {\n        return;\n      }\n\n      if (\n        e.target.classList.contains('focus-visible') ||\n        e.target.hasAttribute('data-focus-visible-added')\n      ) {\n        // To detect a tab/window switch, we look for a blur event followed\n        // rapidly by a visibility change.\n        // If we don't see a visibility change within 100ms, it's probably a\n        // regular focus change.\n        hadFocusVisibleRecently = true;\n        window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n        hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {\n          hadFocusVisibleRecently = false;\n        }, 100);\n        removeFocusVisibleClass(e.target);\n      }\n    }\n\n    /**\n     * If the user changes tabs, keep track of whether or not the previously\n     * focused element had .focus-visible.\n     * @param {Event} e\n     */\n    function onVisibilityChange(e) {\n      if (document.visibilityState === 'hidden') {\n        // If the tab becomes active again, the browser will handle calling focus\n        // on the element (Safari actually calls it twice).\n        // If this tab change caused a blur on an element with focus-visible,\n        // re-apply the class when the user switches back to the tab.\n        if (hadFocusVisibleRecently) {\n          hadKeyboardEvent = true;\n        }\n        addInitialPointerMoveListeners();\n      }\n    }\n\n    /**\n     * Add a group of listeners to detect usage of any pointing devices.\n     * These listeners will be added when the polyfill first loads, and anytime\n     * the window is blurred, so that they are active when the window regains\n     * focus.\n     */\n    function addInitialPointerMoveListeners() {\n      document.addEventListener('mousemove', onInitialPointerMove);\n      document.addEventListener('mousedown', onInitialPointerMove);\n      document.addEventListener('mouseup', onInitialPointerMove);\n      document.addEventListener('pointermove', onInitialPointerMove);\n      document.addEventListener('pointerdown', onInitialPointerMove);\n      document.addEventListener('pointerup', onInitialPointerMove);\n      document.addEventListener('touchmove', onInitialPointerMove);\n      document.addEventListener('touchstart', onInitialPointerMove);\n      document.addEventListener('touchend', onInitialPointerMove);\n    }\n\n    function removeInitialPointerMoveListeners() {\n      document.removeEventListener('mousemove', onInitialPointerMove);\n      document.removeEventListener('mousedown', onInitialPointerMove);\n      document.removeEventListener('mouseup', onInitialPointerMove);\n      document.removeEventListener('pointermove', onInitialPointerMove);\n      document.removeEventListener('pointerdown', onInitialPointerMove);\n      document.removeEventListener('pointerup', onInitialPointerMove);\n      document.removeEventListener('touchmove', onInitialPointerMove);\n      document.removeEventListener('touchstart', onInitialPointerMove);\n      document.removeEventListener('touchend', onInitialPointerMove);\n    }\n\n    /**\n     * When the polfyill first loads, assume the user is in keyboard modality.\n     * If any event is received from a pointing device (e.g. mouse, pointer,\n     * touch), turn off keyboard modality.\n     * This accounts for situations where focus enters the page from the URL bar.\n     * @param {Event} e\n     */\n    function onInitialPointerMove(e) {\n      // Work around a Safari quirk that fires a mousemove on <html> whenever the\n      // window blurs, even if you're tabbing out of the page. \\_()_/\n      if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {\n        return;\n      }\n\n      hadKeyboardEvent = false;\n      removeInitialPointerMoveListeners();\n    }\n\n    // For some kinds of state, we are interested in changes at the global scope\n    // only. For example, global pointer input, global key presses and global\n    // visibility change should affect the state at every scope:\n    document.addEventListener('keydown', onKeyDown, true);\n    document.addEventListener('mousedown', onPointerDown, true);\n    document.addEventListener('pointerdown', onPointerDown, true);\n    document.addEventListener('touchstart', onPointerDown, true);\n    document.addEventListener('visibilitychange', onVisibilityChange, true);\n\n    addInitialPointerMoveListeners();\n\n    // For focus and blur, we specifically care about state changes in the local\n    // scope. This is because focus / blur events that originate from within a\n    // shadow root are not re-dispatched from the host element if it was already\n    // the active element in its own scope:\n    scope.addEventListener('focus', onFocus, true);\n    scope.addEventListener('blur', onBlur, true);\n\n    // We detect that a node is a ShadowRoot by ensuring that it is a\n    // DocumentFragment and also has a host property. This check covers native\n    // implementation and polyfill implementation transparently. If we only cared\n    // about the native implementation, we could just check if the scope was\n    // an instance of a ShadowRoot.\n    if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {\n      // Since a ShadowRoot is a special kind of DocumentFragment, it does not\n      // have a root element to add a class to. So, we add this attribute to the\n      // host element instead:\n      scope.host.setAttribute('data-js-focus-visible', '');\n    } else if (scope.nodeType === Node.DOCUMENT_NODE) {\n      document.documentElement.classList.add('js-focus-visible');\n      document.documentElement.setAttribute('data-js-focus-visible', '');\n    }\n  }\n\n  // It is important to wrap all references to global window and document in\n  // these checks to support server-side rendering use cases\n  // @see https://github.com/WICG/focus-visible/issues/199\n  if (typeof window !== 'undefined' && typeof document !== 'undefined') {\n    // Make the polyfill helper globally available. This can be used as a signal\n    // to interested libraries that wish to coordinate with the polyfill for e.g.,\n    // applying the polyfill to a shadow root:\n    window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;\n\n    // Notify interested libraries of the polyfill's presence, in case the\n    // polyfill was loaded lazily:\n    var event;\n\n    try {\n      event = new CustomEvent('focus-visible-polyfill-ready');\n    } catch (error) {\n      // IE11 does not support using CustomEvent as a constructor directly:\n      event = document.createEvent('CustomEvent');\n      event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});\n    }\n\n    window.dispatchEvent(event);\n  }\n\n  if (typeof document !== 'undefined') {\n    // Apply the polyfill to the global document, so that no JavaScript\n    // coordination is required to use the polyfill in the top-level document:\n    applyFocusVisiblePolyfill(document);\n  }\n\n})));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n// It's empty as some runtime module handles the default behavior\n__webpack_require__.x = x => {};\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// Promise = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t731: 0\n};\n\nvar deferredModules = [\n\t[789],\n\t[849]\n];\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\nvar checkDeferredModules = x => {};\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime, executeModules] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0, resolves = [];\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tresolves.push(installedChunks[chunkId][0]);\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\tfor(moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\twhile(resolves.length) {\n\t\tresolves.shift()();\n\t}\n\n\t// add entry modules from loaded chunk to deferred list\n\tif(executeModules) deferredModules.push.apply(deferredModules, executeModules);\n\n\t// run deferred modules when all chunks ready\n\treturn checkDeferredModules();\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));\n\nfunction checkDeferredModulesImpl() {\n\tvar result;\n\tfor(var i = 0; i < deferredModules.length; i++) {\n\t\tvar deferredModule = deferredModules[i];\n\t\tvar fulfilled = true;\n\t\tfor(var j = 1; j < deferredModule.length; j++) {\n\t\t\tvar depId = deferredModule[j];\n\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferredModules.splice(i--, 1);\n\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n\t\t}\n\t}\n\tif(deferredModules.length === 0) {\n\t\t__webpack_require__.x();\n\t\t__webpack_require__.x = x => {};\n\t}\n\treturn result;\n}\nvar startup = __webpack_require__.x;\n__webpack_require__.x = () => {\n\t// reset startup function so it can be called again when more startup code is added\n\t__webpack_require__.x = startup || (x => {});\n\treturn (checkDeferredModules = checkDeferredModulesImpl)();\n};","// run startup\n__webpack_require__.x();\n"],"sourceRoot":""}